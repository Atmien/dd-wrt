Index: athrf1_phy.c
===================================================================
--- athrf1_phy.c	(revision 13405)
+++ athrf1_phy.c	(working copy)
@@ -28,9 +28,7 @@
 #else
 #include <linux/kernel.h>
 #include <asm/delay.h>
-//#ifdef CONFIG_CUS109_F1E_PHY
 #define mdelay(_x)         udelay((_x)*1000)
-//#endif
 #endif
 #endif
 
@@ -59,20 +57,28 @@
   unsigned int     phy_addr;
 }athr_phy_t;
 
-athr_phy_t phy_info[] = {
-    {is_enet_port: 1,
-     mac_unit    : 0,
-//#ifdef CONFIG_CUS109_F1E_PHY
-     phy_addr    : 0x00},
+  athr_phy_t phy_info[] = {
+#ifdef CONFIG_CUS109_F1E_PHY
+      {is_enet_port: 1,
+       mac_unit    : 0,
+       phy_addr    : 0x00},
+  
+      {is_enet_port: 1,
+       mac_unit    : 1,
+       phy_addr    : 0x01}
+#elif CONFIG_MACH_AR7100_PB47
+     {is_enet_port: 1,
+      mac_unit    : 1,
+      phy_addr    : 0x00}
+#else
+     {is_enet_port: 1,
+      mac_unit    : 0,
+       phy_addr    : 0x00}
+#endif
+  };
 
-    {is_enet_port: 1,
-     mac_unit    : 1,
-     phy_addr    : 0x01}
-//#else		   
-//     phy_addr    : 0x00}
-//#endif
-};
 
+
 static athr_phy_t *
 athr_phy_find(int unit)
 {
@@ -89,6 +95,14 @@
     return NULL;
 }
 
+/* N.B.: On AR7100, MDC/MDIO is only on MAC0. So, trying to access PHY
+ * registers using MAC1 is futile. Reads will give incorrect values and
+ * writes do not take effect. So, always use as shown below:
+ *
+ *    phy_reg_read(0, ...) phy_reg_write(0, ...) OR
+ */
+
+
 int
 athr_phy_setup(int unit)
 {
@@ -107,60 +121,52 @@
      * it can respond properly.
      */
 
-    phy_reg_write(unit, phy->phy_addr, ATHR_AUTONEG_ADVERT,
-                  ATHR_ADVERTISE_ALL);
-
-    phy_reg_write(unit, phy->phy_addr, ATHR_1000BASET_CONTROL,
-                  ATHR_ADVERTISE_1000FULL);
-
-//#ifdef CONFIG_CUS109_F1E_PHY
-    /* delay rx_clk */
-    phy_reg_write(unit, phy->phy_addr, 0x1D, 0x0);
-    phy_reg_write(unit, phy->phy_addr, 0x1E, 0x34E);
-//#endif
-
-    /* delay tx_clk */
-    phy_reg_write(unit, phy->phy_addr, 0x1D, 0x5);
-//#ifdef CONFIG_CUS109_F1E_PHY
-    phy_reg_write(unit, phy->phy_addr, 0x1E, 0x3C47);
-//#else
-//    phy_reg_write(unit, phy->phy_addr, 0x1E, 0x100);
-//#endif
-
-    /* Reset PHYs*/
-    phy_reg_write(unit, phy->phy_addr, ATHR_PHY_CONTROL,
-                  ATHR_CTRL_AUTONEGOTIATION_ENABLE 
-                  | ATHR_CTRL_SOFTWARE_RESET);
-
-    mdelay(500);
-
+     phy_reg_write(0, phy->phy_addr, ATHR_AUTONEG_ADVERT,
+                    ATHR_ADVERTISE_ALL);
+  
+     phy_reg_write(0, phy->phy_addr, ATHR_1000BASET_CONTROL,
+                   ATHR_ADVERTISE_1000FULL|ATHR_ADVERTISE_1000HALF);
+  
+      /* delay rx_clk */
+     phy_reg_write(0, phy->phy_addr, 0x1D, 0x0);
+     phy_reg_write(0, phy->phy_addr, 0x1E, 0x34E);
+  
+      /* delay tx_clk */
+     phy_reg_write(0, phy->phy_addr, 0x1D, 0x5);
+#ifdef CONFIG_CUS109_F1E_PHY
+     phy_reg_write(0, phy->phy_addr, 0x1E, 0x3C47);
+#else
+     phy_reg_write(0, phy->phy_addr, 0x1E, 0x3D47);
+#endif
+  
+      /* Reset PHYs*/
+     phy_reg_write(0, phy->phy_addr, ATHR_PHY_CONTROL,
+                    ATHR_CTRL_AUTONEGOTIATION_ENABLE 
+                    | ATHR_CTRL_SOFTWARE_RESET);
+  
+     mdelay(50);
     /*
      * Wait up to 3 seconds for ALL associated PHYs to finish
      * autonegotiation.  The only way we get out of here sooner is
      * if ALL PHYs are connected AND finish autonegotiation.
      */
-    timeout=20;
-    for (;;) {
-        phyHwStatus = phy_reg_read(unit, phy->phy_addr, ATHR_PHY_CONTROL);
-
-        if (ATHR_RESET_DONE(phyHwStatus)) {
-	    printk(MODULE_NAME": Port %d, Neg Success\n", unit);
-            break;
-        }
-        if (timeout == 0) {
-	    printk(MODULE_NAME": Port %d, Negogiation timeout\n", unit);
-            break;
-        }
-        if (--timeout == 0) {
-	    printk(MODULE_NAME": Port %d, Negogiation timeout\n", unit);
-            break;
-        }
-
-        mdelay(150);
-    }
-
-    printk(MODULE_NAME": unit %d phy addr %x ", unit, phy->phy_addr);
-    printk(MODULE_NAME": reg0 %x\n", ag7100_mii_read(0, phy->phy_addr, 0));
+     for (timeout=20; timeout; mdelay(150), timeout--) {
+         phyHwStatus = phy_reg_read(0, phy->phy_addr, ATHR_PHY_CONTROL);
+  
+         if (!ATHR_RESET_DONE(phyHwStatus))
+             continue;
+ 
+         phyHwStatus = phy_reg_read(0, phy->phy_addr, ATHR_PHY_STATUS);
+         if (ATHR_AUTONEG_DONE(phyHwStatus)) {
+                 printk(MODULE_NAME": Port %d, Auto-Negotiation Success\n", unit);
+                 break;
+         }
+      }
+     if (timeout == 0)
+         printk(MODULE_NAME": Port %d, Auto-Negotiation timeout\n", unit);
+  
+      printk(MODULE_NAME": unit %d phy addr %x ", unit, phy->phy_addr);
+     printk(MODULE_NAME": reg0 %x\n", phy_reg_read(0, phy->phy_addr, 0));
 }
 
 int
@@ -172,11 +178,10 @@
     if (!phy) 
         return 0;
 
-    status = ag7100_mii_read(0, phy->phy_addr, ATHR_PHY_SPEC_STATUS);
+    status = ag7100_mii_read(phy->mac_unit, phy->phy_addr, ATHR_PHY_SPEC_STATUS);
 
-    if (status & ATHR_STATUS_LINK_PASS)
+    if (status & ATHR_STATUS_LINK_UP)
         return 1;
-
     return 0;
 }
 
@@ -191,10 +196,11 @@
         return 0;
 
     do {
-    status = ag7100_mii_read(0, phy->phy_addr, ATHR_PHY_SPEC_STATUS);
-	    mdelay(10);
-    } while((!(status & ATHR_STATUS_RESOVLED)) && --ii);
-    status = !(!(status & ATHER_STATUS_FULL_DEPLEX));
+        status = phy_reg_read(0, phy->phy_addr, ATHR_PHY_SPEC_STATUS);
+        if (status & ATHR_STATUS_RESOLVED) break;
+        mdelay(10);
+    }while(--ii);
+    status = !(!(status & ATHR_STATUS_FULL_DUPLEX));
 
     return (status);
 }
@@ -210,11 +216,12 @@
         return 0;
 
     do {
-        status = ag7100_mii_read(0, phy->phy_addr, ATHR_PHY_SPEC_STATUS);
-	    mdelay(10);
-    }while((!(status & ATHR_STATUS_RESOVLED)) && --ii);
+        status = phy_reg_read(0, phy->phy_addr, ATHR_PHY_SPEC_STATUS);
+        if (status & ATHR_STATUS_RESOLVED) break;
+        mdelay(10);
+    }while(--ii);
 
-    status = ((status & ATHER_STATUS_LINK_MASK) >> ATHER_STATUS_LINK_SHIFT);
+    status = ((status & ATHR_STATUS_SPEED_MASK) >> ATHR_STATUS_SPEED_SHIFT);
 
     switch(status) {
     case 0:
@@ -224,8 +231,41 @@
     case 2:
         return AG7100_PHY_SPEED_1000T;
     default:
-        printk(MODULE_NAME": Unkown speed read!\n");
+        printk(MODULE_NAME": Unkown speed read (phy_addr %d unit %d)!\n", phy->phy_addr, phy->mac_unit);
     }
     return -1;
 }
 
+int
+athr_phy_status(int unit, int *link, int *fdx, int *speed)
+{
+    athr_phy_t *phy = athr_phy_find(unit);
+    int status;
+    int ii = 100;
+
+    if (!phy) {
+	*link = 0;
+        return 0;
+    }
+
+    do {
+        status = phy_reg_read(phy->mac_unit, phy->phy_addr, ATHR_PHY_SPEC_STATUS);
+        /* delay only if status is not yet resolved */
+        if (status & ATHR_STATUS_RESOLVED) break;
+        mdelay(10);
+    }while(--ii);
+
+    if (ii == 0) {
+        *link = 0;
+    }
+    else {
+        *link = !(!(status & ATHR_STATUS_LINK_UP));
+        *fdx = !(!(status & ATHR_STATUS_FULL_DUPLEX));
+        *speed = (status & ATHR_STATUS_SPEED_MASK) >> ATHR_STATUS_SPEED_SHIFT;
+        if (status & ATHR_STATUS_SMARTSPEED_DOWN)
+            printk(MODULE_NAME": SmartSpeed Downgrade! (unit %d)\n", phy->mac_unit);
+    }
+
+    return 0;
+}
+
Index: athrs16_phy.c
===================================================================
--- athrs16_phy.c	(revision 13405)
+++ athrs16_phy.c	(working copy)
@@ -12,7 +12,7 @@
  * All definitions in this file are operating system independent!
  */
 
-#include <linux/autoconf.h>
+#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -20,6 +20,16 @@
 #include "ag7100_phy.h"
 #include "ag7100.h"
 
+#ifdef FULL_FEATURE
+extern void* ssdk_mdio_set;
+extern void* ssdk_mdio_get;
+#endif
+
+#ifdef FULL_FEATURE
+extern void* ssdk_mdio_set;
+extern void* ssdk_mdio_get;
+#endif
+
 /* PHY selections and access functions */
 typedef enum {
     PHY_SRCPORT_INFO, 
@@ -81,9 +91,9 @@
 static athrPhyInfo_t athrPhyInfo[] = {
     {TRUE,   /* phy port 0 -- LAN port 0 */
      FALSE,
-     ENET_UNIT_WAN,
+     ENET_UNIT_LAN,
      0,
-     ATHR_PHY4_ADDR,
+     ATHR_PHY0_ADDR,
      ATHR_LAN_PORT_VLAN
     },
 
@@ -91,7 +101,7 @@
      FALSE,
      ENET_UNIT_LAN,
      0,
-     ATHR_PHY0_ADDR,
+     ATHR_PHY1_ADDR,
      ATHR_LAN_PORT_VLAN
     },
 
@@ -99,7 +109,7 @@
      FALSE,
      ENET_UNIT_LAN,
      0,
-     ATHR_PHY1_ADDR, 
+     ATHR_PHY2_ADDR, 
      ATHR_LAN_PORT_VLAN
     },
 
@@ -107,15 +117,15 @@
      FALSE,
      ENET_UNIT_LAN,
      0,
-     ATHR_PHY2_ADDR, 
+     ATHR_PHY3_ADDR, 
      ATHR_LAN_PORT_VLAN
     },
 
     {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
      FALSE,
-     ENET_UNIT_LAN,
+     ENET_UNIT_WAN,
      0,
-     ATHR_PHY3_ADDR, 
+     ATHR_PHY4_ADDR, 
      ATHR_LAN_PORT_VLAN   /* Send to all ports */
     },
     
@@ -128,7 +138,7 @@
     },
 };
 
-static uint8_t athr16_init_flag = 1;
+static uint8_t athr16_init_flag = 0;
 
 //#define ATHR_PHY_MAX (sizeof(ipPhyInfo) / sizeof(ipPhyInfo[0]))
 #define ATHR_PHY_MAX 5
@@ -159,10 +169,8 @@
 
 void phy_mode_setup(void) 
 {
-//#define show_phy(a,ofs) printk(KERN_INFO "phy reg 0x%08X ofs %d = 0x08X\n",phy_reg_read(ATHR_PHYBASE(a), ATHR_PHYADDR(a), ofs));
     printk("phy_mode_setup\n");
-//    show_phy(ATHR_IND_PHY,29);
-   return;
+
     /*work around for phy4 rgmii mode*/
     phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);     
     phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);    
@@ -177,46 +185,88 @@
 
 }
 
+static BOOL
+athrs16_bist_test(void)
+{
+    uint32_t times = 2, regc = 0xa0, regr = 0xa4, data = 0, i;
+
+    while (--times) {
+        athrs16_reg_write(regc, 0x80700000);
+
+        i = 0x1000;
+        while(i--) {
+            if(!(athrs16_reg_read(regc)&0x80000000))
+                break;
+            udelay(5);
+        }
+
+        if (0 == i)
+            return FALSE;
+
+        data = athrs16_reg_read(regc);
+
+        if(!(data & 0xe000))
+            break;
+        
+        if (!times || !(data & 0x40000000))
+            return FALSE;
+        
+        athrs16_reg_write(regr, (data & 0x1fff) | 0x80000000);
+
+    }
+
+    /* test pass then reset switch */
+    printk(MODULE_NAME ": resetting...\n");
+    athrs16_reg_write(0x0, athrs16_reg_read(0x0)|0x80000000);
+
+    i = 20;
+    while(i--) {
+        mdelay(100);
+        if(!(athrs16_reg_read(0x0)&0x80000000))
+            break;
+    }
+
+    if (i)
+        printk(MODULE_NAME ": reset done.\n");
+    else
+        printk(MODULE_NAME ": reset fail.\n"); 
+
+    return TRUE;
+}
+
 void athrs16_reg_init()
 {
     /* if using header for register configuration, we have to     */
     /* configure s16 register after frame transmission is enabled */
-//   if (athr16_init_flag)
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x208,athrs16_reg_read(0x208));
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x108,athrs16_reg_read(0x108));
-
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x8,athrs16_reg_read(0x8));
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x100,athrs16_reg_read(0x100));
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x200,athrs16_reg_read(0x200));
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x300,athrs16_reg_read(0x300));
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x400,athrs16_reg_read(0x400));
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x500,athrs16_reg_read(0x500));
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x600,athrs16_reg_read(0x600));
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x2c,athrs16_reg_read(0x2c));
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x104,athrs16_reg_read(0x104));
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x204,athrs16_reg_read(0x204));
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x304,athrs16_reg_read(0x304));
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x404,athrs16_reg_read(0x404));
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x504,athrs16_reg_read(0x504));
-    printk(KERN_INFO "reg 0x%04X = 0x%08X\n",0x604,athrs16_reg_read(0x604));
+    if (athr16_init_flag)
         return;
 
+#ifdef FULL_FEATURE
+    ssdk_mdio_set = phy_reg_write;
+    ssdk_mdio_get = phy_reg_read;
+    ssdk_reduced_init(0, 2, 1);
+#else
+    if(FALSE == athrs16_bist_test()) {
+        printk(MODULE_NAME ": bist test fail.\n");
+    }
+#endif
+
     /*Power on strip mode setup*/
-#if CFG_BOARD_PB45
+#if defined  CFG_BOARD_PB45
     athrs16_reg_write(0x208, 0x2fd0001);  /*tx delay*/   
     athrs16_reg_write(0x108, 0x2be0001);  /*mac0 rgmii mode*/ 
-#elif CFG_BOARD_AP96
+#elif defined CFG_BOARD_AP96
     athrs16_reg_write(0x8, 0x012e1bea);
 #endif
     
     athrs16_reg_write(0x100, 0x7e);
-    athrs16_reg_write(0x200, 0x200);
-    athrs16_reg_write(0x300, 0x200);
-    athrs16_reg_write(0x400, 0x200);
-    athrs16_reg_write(0x500, 0x200);
-#if CFG_BOARD_PB45
-    athrs16_reg_write(0x600, 0x200);
-#elif CFG_BOARD_AP96
+    athrs16_reg_write(0x200, 0x1200);
+    athrs16_reg_write(0x300, 0x1200);
+    athrs16_reg_write(0x400, 0x1200);
+    athrs16_reg_write(0x500, 0x1200);
+#if defined CFG_BOARD_PB45
+    athrs16_reg_write(0x600, 0x1200);
+#elif defined CFG_BOARD_AP96
     athrs16_reg_write(0x600, 0x0);
 #endif
 
@@ -242,10 +292,7 @@
 #endif
 #endif
 
-#ifdef FULL_FEATURE
-	hsl_dev_init(0, 2);
-#endif
-    printk("athrs16_reg_init complete.\n");
+    printk(MODULE_NAME ": athrs16_reg_init complete.\n");
 
     athr16_init_flag = 1;
 }
@@ -298,7 +345,7 @@
     uint32_t  phyBase = 0;
     BOOL      foundPhy = FALSE;
     uint32_t  phyAddr = 0;
-    return TRUE;
+    
 
     /* See if there's any configuration data for this enet */
     /* start auto negogiation on each phy */
@@ -397,7 +444,6 @@
                          ATHR_PHYADDR(phyUnit),
                          ATHR_PHY_SPEC_STATUS)));
     }
-    
     phy_mode_setup();    
     return (liveLinks > 0);
 }
@@ -434,10 +480,12 @@
             phyAddr = ATHR_PHYADDR(phyUnit);
 
             do {
-                phyHwStatus = ag7100_mii_read (phyBase, phyAddr, 
+                phyHwStatus = phy_reg_read (phyBase, phyAddr, 
                                                ATHR_PHY_SPEC_STATUS);
+		if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			break;
                 mdelay(10);
-            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+            } while(--ii);
             
             if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
                 return TRUE;
@@ -447,7 +495,6 @@
     return FALSE;
 }
 
-
 /******************************************************************************
 *
 * athrs16_phy_speed - Determines the speed of phy ports associated with the
@@ -466,42 +513,58 @@
     uint32_t  phyBase;
     uint32_t  phyAddr;
     int       ii = 200;
+    ag7100_phy_speed_t phySpeed = AG7100_PHY_SPEED_10T;
 
-    if (ethUnit == ENET_UNIT_LAN)
-        return AG7100_PHY_SPEED_1000T;
-        
     for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
         if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
             continue;
         }
 
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        phySpeed = AG7100_PHY_SPEED_10T;
+
         if (athrs16_phy_is_link_alive(phyUnit)) {
 
-            phyBase = ATHR_PHYBASE(phyUnit);
-            phyAddr = ATHR_PHYADDR(phyUnit);
             do {
-                phyHwStatus = ag7100_mii_read(phyBase, phyAddr, 
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
                                               ATHR_PHY_SPEC_STATUS);
+		        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			        break;
                 mdelay(10);
-            }while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+            }while(--ii);
             
             phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
                            ATHER_STATUS_LINK_SHIFT);
 
             switch(phyHwStatus) {
             case 0:
-                return AG7100_PHY_SPEED_10T;
+                phySpeed = AG7100_PHY_SPEED_10T;
+                break;
             case 1:
-                return AG7100_PHY_SPEED_100TX;
+                phySpeed = AG7100_PHY_SPEED_100TX;
+                break;
             case 2:
-                return AG7100_PHY_SPEED_1000T;
+                phySpeed = AG7100_PHY_SPEED_1000T;
+                break;
             default:
                 printk("Unkown speed read!\n");
             }
+        } 
+
+        phy_reg_write(phyBase, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x18);
+        
+        if(phySpeed == AG7100_PHY_SPEED_100TX) {
+            phy_reg_write(phyBase, phyAddr, ATHR_DEBUG_PORT_DATA, 0xba8);
+        } else {            
+            phy_reg_write(phyBase, phyAddr, ATHR_DEBUG_PORT_DATA, 0x2ea);
         }
     }
 
-    return AG7100_PHY_SPEED_10T;
+    if (ethUnit == ENET_UNIT_LAN)
+         phySpeed = AG7100_PHY_SPEED_1000T;
+
+    return phySpeed;
 }
 
 /*****************************************************************************
@@ -612,7 +675,7 @@
 
     return reg_val;   
 }
-#if 1
+
 static void
 athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val)
 {
@@ -648,7 +711,7 @@
     phy_val = (uint16_t) (reg_val & 0xffff);
     phy_reg_write(0, phy_addr, phy_reg, phy_val); 
 }
-#endif
+
 int
 athr_ioctl(uint32_t *args, int cmd)
 {
Index: athrs16_phy.h
===================================================================
--- athrs16_phy.h	(revision 13405)
+++ athrs16_phy.h	(working copy)
@@ -80,7 +80,7 @@
 #endif
 
 /*add feature define here*/
-//#define FULL_FEATURE
+#define FULL_FEATURE
 
 #ifdef CONFIG_ATHRS16_PHY 
 #undef HEADER_REG_CONF
Index: Makefile
===================================================================
--- Makefile	(revision 13517)
+++ Makefile	(working copy)
@@ -10,10 +10,14 @@
 ifeq ($(CONFIG_AP81_CARRIER_CUS109), 1)
 obj-phy-$(CONFIG_ATHRF1_PHY) 	=	athrf1_phy.o
 else
+ifeq ($(CONFIG_MACH_AR7100_PB47),y)
+obj-phy-$(CONFIG_ATHRF1_PHY) 	=	athrf1_phy.o
+else
 obj-phy-$(CONFIG_ATHR_PHY) 	=	athrf1_phy.o
 endif
+endif
 obj-phy-$(CONFIG_ATHRS26_PHY) 	=	athrs26_phy.o
-obj-phy-$(CONFIG_ATHRS16_PHY) 	=	athrs16_phy.o
+obj-phy-$(CONFIG_ATHRS16_PHY) 	=	athrs16_phy.o ssdk_mod.a
 obj-phy-$(CONFIG_AG7100_GENERIC_PHY)    = generic_phy.o
 obj-phy-$(CONFIG_VITESSE_8601_PHY)      = vsc8601_phy.o
 obj-phy-$(CONFIG_VITESSE_8601_7395_PHY) = vsc8601_phy.o generic_i2c.o generic_spi.o vsc73xx.o
Index: ag7100.c
===================================================================
--- ag7100.c	(revision 13523)
+++ ag7100.c	(working copy)
@@ -323,6 +323,12 @@
 {
     ag7100_ring_t *tx = &mac->mac_txring, *rx = &mac->mac_rxring;
     ag7100_desc_t *r0, *t0;
+    ar7100_reg_rmw_set(AR7100_RESET, ag7100_reset_mask(mac->mac_unit));
+    mdelay(100);
+    ar7100_reg_rmw_clear(AR7100_RESET, ag7100_reset_mask(mac->mac_unit));
+    mdelay(100);
+    /* clear the rx fifo state if any */
+    ag7100_reg_wr(mac, AG7100_DMA_RX_STATUS, ag7100_reg_rd(mac, AG7100_DMA_RX_STATUS));
 #ifdef CONFIG_AR9100 
 #ifndef CONFIG_PORT0_AS_SWITCH
     if(mac->mac_unit) {
@@ -400,10 +406,13 @@
     /*
     * put everything into reset.
     */
-#ifdef CONFIG_DUAL_F1E_PHY
-	if(mac->mac_unit == 1)
-#endif
+    /* On AR7100, there is only one MDC/MDIO bus and it is present on MAC0. 
+     * Setting MAC0's soft reset will stop MDC/MDIO bus. So, we don't allow 
+     * MAC0 to be reset unless MAC1 isn't connected. 
+     */
+    if ((mac->mac_unit == 1) || (AG7100_NMACS == 1)) {
     	ag7100_reg_rmw_set(mac, AG7100_MAC_CFG1, AG7100_MAC_CFG1_SOFT_RST);
+    }
 }
 
 /*
@@ -2094,7 +2103,16 @@
         ag7100_reg_rmw_set(mac, AG7100_MAC_CFG1, AG7100_MAC_CFG1_SOFT_RST 
 				| AG7100_MAC_CFG1_RX_RST | AG7100_MAC_CFG1_TX_RST);
 #else
-        ag7100_reg_rmw_set(mac, AG7100_MAC_CFG1, AG7100_MAC_CFG1_SOFT_RST);
+	/* On AR7100, the MDC/MDIO to the PHY is off MAC0 and not MAC1. So,
+	 * we need to bring MAC0 out of soft reset to let the driver talk
+	 * to the PHY. This applies to AR9100 too above.
+	 */
+        ag7100_reg_wr(mac, AG7100_MAC_CFG1, AG7100_MAC_CFG1_SOFT_RST);
+        if (i == 0)  {
+            mdelay(10); /* what's the minimum delay needed? */
+            ag7100_reg_wr(mac, AG7100_MAC_CFG1, 
+                 AG7100_MAC_CFG1_RX_RST | AG7100_MAC_CFG1_TX_RST);
+        }
 #endif
         udelay(20);
         mask = ag7100_reset_mask(mac->mac_unit);
Index: athr_phy.h
===================================================================
--- athr_phy.h	(revision 13405)
+++ athr_phy.h	(working copy)
@@ -18,6 +18,8 @@
 #define ATHR_1000BASET_STATUS            10
 #define ATHR_PHY_SPEC_CONTROL            16
 #define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_INTR_STATUS                 19
+#define ATHR_EXT_PHY_SPEC_CONTROL        20
 
 /* ATHR_PHY_CONTROL fields */
 #define ATHR_CTRL_SOFTWARE_RESET                    0x8000
@@ -32,6 +34,7 @@
     
 /* Phy status fields */
 #define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+#define ATHR_STATUS_LINK_STATUS                     0x0004
 
 #define ATHR_AUTONEG_DONE(ip_phy_status)                   \
     (((ip_phy_status) &                                  \
@@ -58,13 +61,15 @@
                        
 /* 1000BASET_CONTROL */
 #define ATHR_ADVERTISE_1000FULL               0x0200
+#define ATHR_ADVERTISE_1000HALF               0x0100
 
 /* Phy Specific status fields */
-#define ATHER_STATUS_LINK_MASK                0xC000
-#define ATHER_STATUS_LINK_SHIFT               14
-#define ATHER_STATUS_FULL_DEPLEX              0x2000
-#define ATHR_STATUS_LINK_PASS                 0x0400 
-#define ATHR_STATUS_RESOVLED                  0x0800
+#define ATHR_STATUS_SPEED_MASK                0xC000
+#define ATHR_STATUS_SPEED_SHIFT               14
+#define ATHR_STATUS_FULL_DUPLEX               0x2000
+#define ATHR_STATUS_RESOLVED                  0x0800
+#define ATHR_STATUS_LINK_UP                   0x0400 
+#define ATHR_STATUS_SMARTSPEED_DOWN           0x0020
 
 int athr_phy_is_up(int unit);
 int athr_phy_is_fdx(int unit);
Index: ag7100_phy.h
===================================================================
--- ag7100_phy.h	(revision 13517)
+++ ag7100_phy.h	(working copy)
@@ -392,6 +392,12 @@
 static inline unsigned int 
 ag7100_get_link_status(int unit, int *link, int *fdx, ag7100_phy_speed_t *speed)
 {
+#if defined(CONFIG_MACH_AR7100_PB47)
+  /* determining link status is faster calling this function rather than ... */
+  athr_phy_status(unit, link, fdx, speed);
+  return 0;
+#else
+  /* ... these functions. we really just need to read the PHY register once. */
   *link=ag7100_phy_is_up(unit);
   if (*link == 0)
     return 0;
@@ -399,6 +405,7 @@
   *fdx=ag7100_phy_is_fdx(unit);
   *speed=ag7100_phy_speed(unit);
   return 0;
+#endif
 }
 
 static inline int
