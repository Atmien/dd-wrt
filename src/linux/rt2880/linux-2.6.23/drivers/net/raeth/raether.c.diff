diff -urN SDK_3_1_0_0/RT288x_SDK/source/linux-2.6.21.x/drivers/net/raeth/raether.c SDK_3_2_0_0/RT288x_SDK/source/linux-2.6.21.x//drivers/net/raeth/raether.c
--- SDK_3_1_0_0/RT288x_SDK/source/linux-2.6.21.x/drivers/net/raeth/raether.c	2008-08-06 05:27:47.000000000 +0200
+++ SDK_3_2_0_0/RT288x_SDK/source/linux-2.6.21.x//drivers/net/raeth/raether.c	2008-10-24 08:20:14.000000000 +0200
@@ -20,6 +20,7 @@
 #include <asm/io.h>
 #include <asm/dma.h>
 #include <asm/atomic.h>
+#include <asm/uaccess.h>
 #include <asm/rt2880/surfboardint.h>
 
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
@@ -96,7 +97,7 @@
 #ifdef CONFIG_RAETH_JUMBOFRAME
 #define	MAX_RX_LENGTH	4096
 #else
-#define	MAX_RX_LENGTH	1600
+#define	MAX_RX_LENGTH	1500
 #endif
 
 #define RX_DESC_SIZE	(sizeof(struct PDMA_rxdesc))
@@ -111,13 +112,16 @@
 static struct PDMA_rxdesc *rx_ring;
 static unsigned int phy_rx_ring;
 
+#if defined (CONFIG_ETHTOOL) && ( defined (CONFIG_RAETH_ROUTER) || defined (CONFIG_RT_3052_ESW) )
 extern struct ethtool_ops ra_ethtool_ops;
+#endif
+
 #ifdef CONFIG_RALINK_VISTA_BASIC
 int is_switch_175c = 1;
 #endif
 END_DEVICE *ra_ei_local;
 //bruce debug
-#if 1
+#if 0
 void skb_dump(struct sk_buff* sk) {
         unsigned int i;
 
@@ -139,6 +143,28 @@
 }
 #endif
 
+#if defined (CONFIG_GIGAPHY) || defined (CONFIG_P5_MAC_TO_PHY_MODE)
+int isMarvellGigaPHY(void)
+{
+        u32 phy_id0,phy_id1;
+
+        if( ! mii_mgr_read(31, 2,&phy_id0)){
+                printk("\n Read PhyID 0 is Fail!!\n");
+                phy_id0 =0;
+        }
+
+        if( ! mii_mgr_read(31, 3,&phy_id1)){
+                printk("\n Read PhyID 1 is Fail!!\n");
+                phy_id1 = 0;
+        }
+
+        if((phy_id0 == EV_MARVELL_PHY_ID0) && (phy_id1 == EV_MARVELL_PHY_ID1))
+                return 1;
+
+        return 0;
+}
+#endif	
+
 /*
  * Set the hardware MAC address.
  */
@@ -179,7 +205,8 @@
         int fe_glo_cfg=0;
         int pdma_glo_cfg=0;
 
-	pdma_glo_cfg = (RT2880_TX_WB_DDONE | RT2880_RX_DMA_EN | RT2880_TX_DMA_EN);
+	pdma_glo_cfg = sysRegRead(PDMA_GLO_CFG);
+	pdma_glo_cfg |= (RT2880_TX_WB_DDONE | RT2880_RX_DMA_EN | RT2880_TX_DMA_EN | PDMA_BT_SIZE_4DWORDS);
 	sysRegWrite(PDMA_GLO_CFG, pdma_glo_cfg);
 
 	//set 1us timer count in unit of clock cycle
@@ -248,9 +275,9 @@
  *	Bit 0: PSE Rest
  *	Reset PSE after re-programming PSE_FQ_CFG.
  */
-	regVal = sysRegRead(FE_RST_GL);
-	regVal |= 0x1;
+	regVal = 0x1;
 	sysRegWrite(FE_RST_GL, regVal);
+	sysRegWrite(FE_RST_GL, 0);	// update for RSTCTL issue
 
 	regVal = sysRegRead(GDMA1_FWD_CFG);
 	printk("GDMA1_FWD_CFG = %0X\n",regVal);
@@ -286,7 +313,6 @@
 		break;
 	}
 
-	phySetup();
 
 #if defined (CONFIG_RAETH_QOS)
 	int j=0;
@@ -915,12 +941,28 @@
 	return ei_start_xmit(skb, dev, 1);
 }
 
-#if defined(CONFIG_RT_3052_ESW)
-#define _ESW_REG(x)	(*((volatile u32 *)(RALINK_ETH_SW_BASE + x)))
+
 int ei_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
+#if defined(CONFIG_RT_3052_ESW)
 	esw_reg reg;
+#endif
+	ra_mii_ioctl_data mii;
 	switch (cmd) {
+		case RAETH_MII_READ:
+			copy_from_user(&mii, ifr->ifr_data, sizeof(mii));
+			mii_mgr_read(mii.phy_id, mii.reg_num, &mii.val_out);
+			//printk("phy %d, reg %d, val 0x%x\n", mii.phy_id, mii.reg_num, mii.val_out);
+			copy_to_user(ifr->ifr_data, &mii, sizeof(mii));
+			break;
+
+		case RAETH_MII_WRITE:
+			copy_from_user(&mii, ifr->ifr_data, sizeof(mii));
+			//printk("phy %d, reg %d, val 0x%x\n", mii.phy_id, mii.reg_num, mii.val_in);
+			mii_mgr_write(mii.phy_id, mii.reg_num, mii.val_in);
+			break;
+#if defined(CONFIG_RT_3052_ESW)
+#define _ESW_REG(x)	(*((volatile u32 *)(RALINK_ETH_SW_BASE + x)))
 		case RAETH_ESW_REG_READ:
 			copy_from_user(&reg, ifr->ifr_data, sizeof(reg));
 			if (reg.off > REG_ESW_MAX)
@@ -936,10 +978,10 @@
 			_ESW_REG(reg.off) = reg.val;
 			//printk("write reg off:%x val:%x\n", reg.off, reg.val);
 			break;
+#endif // CONFIG_RT_3052_ESW
 	}
 	return 0;
 }
-#endif	// CONFIG_RT_3052_ESW
 
 /*
  * Set new MTU size
@@ -1002,12 +1044,10 @@
 #endif
 #endif
 
-#if defined (CONFIG_RAETH_ROUTER) || defined (CONFIG_RT_3052_ESW)
+#if defined (CONFIG_ETHTOOL) && ( defined (CONFIG_RAETH_ROUTER) || defined (CONFIG_RT_3052_ESW) )
 	dev->ethtool_ops	= &ra_ethtool_ops;
 #endif
-#if defined(CONFIG_RT_3052_ESW)
 	dev->do_ioctl		= ei_ioctl;
-#endif
 }
 
 
@@ -1070,7 +1110,7 @@
 int __init rather_probe(struct net_device *dev)
 {
 	int i;
-        unsigned int regValue = sysRegRead(FE_RESET);
+        unsigned int regValue = 0;
         END_DEVICE *ei_local = netdev_priv(dev);
 	struct sockaddr addr;
 	unsigned char *mac_addr;
@@ -1080,8 +1120,9 @@
 	ra_ei_local = ei_local;
 
 	dev->base_addr = RA2882ETH_BASE;
-        regValue |= FE_RESET_BIT;;
+        regValue |= FE_RESET_BIT;
         sysRegWrite(FE_RESET, regValue);
+        sysRegWrite(FE_RESET, 0);
 
         /* receiving packet buffer allocation - NUM_RX_DESC x MAX_RX_LENGTH */
         for ( i = 0; i < NUM_RX_DESC; i++)
@@ -1179,6 +1220,7 @@
 #endif //CONFIG_RAETH_NAPI//
 }
 
+#if 0 //moved to scripts
 #ifdef CONFIG_WAN_AT_P4
 void config_ICPLUS_175C_eva(void)
 {
@@ -1237,6 +1279,7 @@
 	printk("ICPLUS 175C config LAN_WAN finished (demo board)\n");
 }
 #endif
+#endif
 
 #ifdef CONFIG_PSEUDO_SUPPORT
 int VirtualIF_ioctl(struct net_device * net_dev,
@@ -1374,6 +1417,7 @@
 {
 	int i;
 	unsigned long flags;
+	END_DEVICE *ei_local;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	if (!try_module_get(THIS_MODULE))
 	{
@@ -1384,7 +1428,7 @@
 	MOD_INC_USE_COUNT;
 #endif
 
-  	END_DEVICE *ei_local = netdev_priv(dev); // get device pointer from System
+  	ei_local = netdev_priv(dev); // get device pointer from System
 	// unsigned int flags;
 
 	if (ei_local == NULL)
@@ -1517,6 +1561,65 @@
 	return 0;
 }
 
+#if defined (CONFIG_RALINK_RT3052) 
+void rt305x_esw_init(void)
+{
+	int i=0;
+
+        *(unsigned long *)(0xb01100E4) = 0x00000000;
+        *(unsigned long *)(0xb0110014) = 0x00405555;
+        *(unsigned long *)(0xb0110050) = 0x00002001;
+        *(unsigned long *)(0xb0110090) = 0x00007f7f;
+        *(unsigned long *)(0xb0110098) = 0x00007f3f; //disable VLAN
+        *(unsigned long *)(0xb01100CC) = 0x00d6500c;
+        *(unsigned long *)(0xb011009C) = 0x0008a301; //hashing algorithm=XOR48, aging interval=300sec
+        *(unsigned long *)(0xb011008C) = 0x02404040;
+#if defined (CONFIG_RT3052_ASIC)
+        *(unsigned long *)(0xb01100C8) = 0x3f502b28; //Change polling Ext PHY Addr=0x0
+        *(unsigned long *)(0xb0110084) = 0x00000000;
+#elif defined (CONFIG_RT3052_FPGA)
+        *(unsigned long *)(0xb01100C8) = 0x3ff02b28; //Change polling Ext PHY Addr=0x0
+        *(unsigned long *)(0xb0110084) = 0xffdf1f00;
+#endif // RT3052_ASIC_BOARD
+  /* to lower down PHY 10Mbps mode power */
+        mii_mgr_write(0, 31, 0x8000);   //---> select local register
+        for(i=0;i<5;i++){
+                mii_mgr_write(i, 26, 0x1601);   //TX10 waveform coefficient
+                mii_mgr_write(i, 29, 0x7058);   //TX100/TX10 AD/DA current bias
+                mii_mgr_write(i, 30, 0x0018);   //TX100 slew rate control
+        }
+        /* PHY IOT */
+        mii_mgr_write(0, 31, 0x0);      //select global register
+        mii_mgr_write(0, 22, 0x052f);   //tune TP_IDL tail and head waveform
+        mii_mgr_write(0, 17, 0x0fe0);   //set TX10 signal amplitude threshold to minimum
+        mii_mgr_write(0, 18, 0x40ba);   //set squelch amplitude to higher threshold
+        mii_mgr_write(0, 14, 0x65);     //longer TP_IDL tail length
+        mii_mgr_write(0, 31, 0x8000);   //select local register
+
+#if defined (CONFIG_P5_RGMII_TO_MAC_MODE)
+        *(unsigned long *)(0xb01100C8) &= ~(1<<29); //disable port 5 auto-polling
+        *(unsigned long *)(0xb01100C8) |= 0x3fff; //force 1000M full duplex
+#elif defined (CONFIG_P5_MII_TO_MAC_MODE)
+        *(unsigned long *)(0xb01100C8) &= ~(1<<29); //disable port 5 auto-polling
+        *(unsigned long *)(0xb01100C8) |= 0x3ffd; //force 100M full duplex
+#elif defined (CONFIG_P5_MAC_TO_PHY_MODE)
+	enable_auto_negotiate();
+        if (isMarvellGigaPHY()) {
+                printk("\n MARVELL Phy\n");
+                mii_mgr_write(31,20,0x0ce0);
+                mii_mgr_write(31,0,0x9140);
+        }
+
+#elif defined (CONFIG_P5_RMII_TO_MAC_MODE)
+	/* reserved */
+#else // Port 5 Disabled //
+        *(unsigned long *)(0xb0000060) |= (1 << 9); //set RGMII to GPIO mode (GPIO41-GPIO50)
+        *(unsigned long *)(0xb0000674) = 0xFFF; //GPIO41-GPIO50 output mode
+        *(unsigned long *)(0xb0000670) = 0x0; //GPIO41-GPIO50 output low
+#endif // CONFIG_P5_RGMII_TO_MAC_MODE //
+
+}
+#endif
 
 /**
  * ra2882eth_init - Module Init code
@@ -1538,7 +1641,7 @@
 	dev->base_addr = RA2882_ENET0;	
 
 	dev->init =  rather_probe;
-	dev->mtu  = MAX_RX_LENGTH;
+	//dev->mtu  = MAX_RX_LENGTH; --> use default MTU
 
 	/* net_device structure Init */
 	hard_init(dev);
@@ -1557,43 +1660,53 @@
 	csr_netlink_init();
 #endif
 	ret = debug_proc_init();
+
+// RT2880 + GigaPhy
+#if defined (CONFIG_GIGAPHY) 
+        unsigned int regValue = 0;
+        enable_auto_negotiate();
+        if (isMarvellGigaPHY()) {
+                printk("\n Reset MARVELL phy\n");
+                mii_mgr_read(31,20, &regValue);
+                regValue |= 1<<7; //Add delay to RX_CLK for RXD Outputs
+                mii_mgr_write(31,20, regValue);
+
+                mii_mgr_read(31,0, &regValue);
+                regValue |= 1<<15; //PHY Software Reset
+                mii_mgr_write(31,0, regValue);
+        }
+
+// RT3052 + EmbeddedSW
+#elif defined (CONFIG_RT_3052_ESW) 
+	rt305x_esw_init();
+// RT2880 + GigaSW
+#elif defined (CONFIG_MAC_TO_MAC_MODE)
+        // force cpu port is 1000F
+	sysRegWrite(MDIO_CFG, 0x1F01DC01);
+
+// RT2880 + 100PHY
+#elif defined (CONFIG_RAETH_ROUTER) || defined (CONFIG_ICPLUS_PHY)
+
+	sysRegWrite(MDIO_CFG, INIT_VALUE_OF_ICPLUS_PHY_INIT_VALUE);
+
 #if defined (CONFIG_RAETH_ROUTER)
-	*(unsigned long *)MDIO_CFG = 0x1001BC01;
-	//force cpu port is 100F
-	mii_mgr_write(29, 22, 0x8420);
 #ifdef CONFIG_RALINK_VISTA_BASIC
 	int sw_id=0;
 	mii_mgr_read(29, 31, &sw_id);
-	if (sw_id == 0x175c)
-		is_switch_175c = 1;
-	else
-		is_switch_175c = 0;
-#endif
-#elif defined(CONFIG_RT_3052_ESW)
-	*(unsigned long *)MDIO_CFG = 0x1001BC01;
-
- 	*(unsigned long *)(0xb01100e4) = 0x00000000;
-#if defined (CONFIG_RT3052_FPGA)
-        *(unsigned long *)(0xb0110084) = 0xffdf1f00;
-        *(unsigned long *)(0xb01100C8) = 0x3ff02b28; //Change polling Ext PHY Addr=0x0
-#endif
-#if defined (CONFIG_RT3052_ASIC)
-        *(unsigned long *)(0xb0110084) = 0x00000000;
-        *(unsigned long *)(0xb01100C8) = 0x3f502b28; //Change polling Ext PHY Addr=0x0
-#endif
-#if defined (CONFIG_P5_RGMII_TO_MAC_MODE)
-        *(unsigned long *)(0xb01100C8) |= 0x3fff;
-#endif
-        *(unsigned long *)(0xb0110014) = 0xffff5555;
-        *(unsigned long *)(0xb0110090) = 0x00007f7f;
-        *(unsigned long *)(0xb0110098) = 0x00007fff; //disable VLAN
-        *(unsigned long *)(0xb01100CC) = 0x00d6500c; 
-        *(unsigned long *)(0xb011009C) = 0x0008a100; // bit[3:0]=0001=300 sec, 0000=Disable aging
-        *(unsigned long *)(0xb011008C) = 0x7F404040; // bit[3:0]=0001=300 sec, 0000=Disable aging
-#else
-	/* reserved */
-#endif	// CONFIG_RT_3052_ESW
-
+	if (sw_id == 0x175c) {
+	    is_switch_175c = 1;
+	} else {
+	    is_switch_175c = 0;
+	}
+#endif // CONFIG_RALINK_VISTA_BASIC
+
+        // due to the flaws of RT2880 GMAC implementation (or IC+ SW ?) we use the
+        // fixed capability instead of auto-polling.
+        // force cpu port is 100F
+        mii_mgr_write(29, 22, 0x8420);
+#endif // CONFIG_RAETH_ROUTER //
+#endif // CONFIG_GIGAPHY //  
+	
 	dev_raether = dev;
 	return ret;
 }
@@ -1608,10 +1721,11 @@
 {
 	int i;
 	struct net_device *dev = dev_raether;
+	END_DEVICE *ei_local;
 
 	if (dev->priv != NULL)
 	{
-		END_DEVICE *ei_local = netdev_priv(dev);
+		ei_local = netdev_priv(dev);
 		if ( ei_local->MACInfo != NULL )
 		{
 			RAETH_PRINT("Free MACInfo...\n");
@@ -1647,9 +1761,3 @@
 module_init(ra2882eth_init);
 module_exit(ra2882eth_cleanup_module);
 MODULE_LICENSE("GPL");
-
-/*
- * Local variables:
- * compile-command: "gcc -DMODULE -DMODVERSIONS -D__KERNEL__ -Wall -Wstrict-prototypes -O2 -g -fomit-frame-pointer -c raether.c"
- * End:
- */
