diff -urN SDK_3_1_0_0/RT288x_SDK/source/linux-2.6.21.x/drivers/net/raeth/ra_mac.c SDK_3_2_0_0/RT288x_SDK/source/linux-2.6.21.x//drivers/net/raeth/ra_mac.c
--- SDK_3_1_0_0/RT288x_SDK/source/linux-2.6.21.x/drivers/net/raeth/ra_mac.c	2008-08-06 05:27:47.000000000 +0200
+++ SDK_3_2_0_0/RT288x_SDK/source/linux-2.6.21.x//drivers/net/raeth/ra_mac.c	2008-10-24 08:20:14.000000000 +0200
@@ -1,10 +1,6 @@
-#ifndef RA_MAC
-#define RA_MAC
-
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/version.h>
-
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/types.h>
@@ -47,226 +43,33 @@
 
 extern END_DEVICE *ra_ei_local;
 
-int phyregread(unsigned int phy_register, unsigned int* value)
-{
-	unsigned long mdio_reg = sysRegRead(MDIO_ACCESS);
-	unsigned long timer = jiffies;
-
-	for (;;)
-	{
-		if ( !(mdio_reg & RT2880_BIT(31) ) )
-			break;
-		else if ((jiffies - timer) > (5*HZ))
-		{
-			printk(KERN_ERR "rt2880 MDIO read Failed...\n");
-			return -1;
-		}
-	}
-	sysRegWrite(MDIO_ACCESS, 0);
-
-	mdio_reg = (0x1f << 24) | (phy_register << 16);
-	sysRegWrite(MDIO_ACCESS, mdio_reg);
-	mdio_reg |= RT2880_BIT(31);
-	sysRegWrite(MDIO_ACCESS, mdio_reg);
-
-	timer = jiffies;
-
-        for (;;)
-        {
-		mdio_reg = sysRegRead(MDIO_ACCESS);
-
-                if ( !(mdio_reg & RT2880_BIT(31) )) {
-			mdio_reg = sysRegRead(MDIO_ACCESS);
-			*value = (unsigned long)(mdio_reg & 0x0000ffff);
-                        break;
-		} else if ((jiffies - timer) > (5*HZ))
-                {
-                        printk(KERN_ERR "rt2880 MDIO read Failed!\n");
-                        return -2;
-                }
-        }
-
-	return 1;
-}
-
-int phyregwrite(unsigned int phy_register, unsigned int value)
-{
-        unsigned long mdio_reg = sysRegRead(MDIO_ACCESS);
-        unsigned long timer = jiffies;
-
-        for (;;)
-        {
-                if ( !(mdio_reg & RT2880_BIT(31) ) )
-                        break;
-                else if ((jiffies - timer) > (5*HZ))
-                {
-                        printk(KERN_ERR "rt2880 MDIO Write Failed...\n");
-                        return -1;
-                }
-        }
-
-        sysRegWrite(MDIO_ACCESS, 0);
-	mdio_reg = (0x1f << 24) | (phy_register << 16) | RT2880_BIT(30) | value;
-        sysRegWrite(MDIO_ACCESS, mdio_reg);
-
-	mdio_reg |= RT2880_BIT(31);
-	sysRegWrite(MDIO_ACCESS, mdio_reg);
-
-	timer = jiffies;
-
-        mdio_reg = sysRegRead(MDIO_ACCESS);
-        for (;;)
-        {
-                if ( !(mdio_reg & RT2880_BIT(31) )) {
-                        break;
-                } else if ((jiffies - timer) > (5*HZ))
-                {
-                        printk(KERN_ERR "rt2880 MDIO Write Failed!\n");
-                        return -2;
-                }
-        	mdio_reg = sysRegRead(MDIO_ACCESS);
-        }
-	return 1;
-
-}
-
-void rt2880_mdio_cfg(unsigned int addr, unsigned int offset, unsigned int value)
-{
-	unsigned int phy_register;
-	int ret;
-	if (offset > 32) {
-		printk("offset input failed");
-		return;
-	}
-
-	ret = phyregread(addr, &phy_register);
-	if (ret < 0) {
-		printk("PHY config read failed!");
-		return;
-	} else
-		printk("mdio.wb addr[%08X] value[0x%08X]\n", addr, phy_register);
-
-	if(phy_register)
-	{
-		phy_register |= RT2880_BIT(offset);
-	} else {
-		phy_register &= ~(RT2880_BIT(offset));
-	}
-
-	ret = phyregwrite(addr, phy_register);
 
-	if ( ret < 0)
-		printk("PHY config write failed!");
-	else
-		printk("mdio.wb addr[0x%X] value[0x%X]\n", addr, phy_register);
-}
-
-#ifdef CONFIG_GIGAPHY
-inline void enable_auto_negotiate(void)
+#if defined (CONFIG_GIGAPHY) || defined (CONFIG_P5_MAC_TO_PHY_MODE)
+void enable_auto_negotiate(void)
 {
-
+#if defined (CONFIG_RALINK_RT3052)
+        u32 regValue = sysRegRead(0xb01100C8);
+#else
 	u32 regValue = sysRegRead(MDIO_CFG);
-	u32 addr = CONFIG_MAC_TO_GIGAPHY_MODE_ADDR;	// define in linux/autoconf.h
-
-	regValue &= 0xe0ff7fff;			// clear auto polling related field:
- 						// (MD_PHY1ADDR & GP1_FRC_EN).
-	regValue |= 0x20000000;			// force to enable MDC/MDIO auto polling.
-	regValue |= (addr << 24);		// setup PHY address for auto polling.
-
-	sysRegWrite(MDIO_CFG, regValue);
-	return;
-}
-
-#define LINKUP_RETRY_MAX 10
-inline void wait_linkup(void)
-{
-	u32 regValue;
-	int retry=0;
-	while(retry < LINKUP_RETRY_MAX){
-		regValue = sysRegRead(MDIO_CFG);
-		if(! (regValue & RT2880_GP1_LNK_DWN)){
-			printk("raeth: link up.\n");
-            return;
-		}
-		msleep(50);
-		retry++;
-	}
-	printk("raeth: give up to wait for linkup\n");
-	return;
-}
-
-#define AN_RETRY_MAX 30
-inline void wait_an_completed(void)
-{
-	u32 regValue;
-	int retry=0;
-	while(retry < AN_RETRY_MAX){
-		regValue = sysRegRead(MDIO_CFG);
-		if((regValue & RT2880_GP1_AN_FAIL)){
-			printk("raeth: AN completed.\n");
-			break;
-		}
-		msleep(100);
-		retry++;
-	}
-	printk("raeth: timeout for AN\n");
-	return;
-}
-#endif
-
-
-void phySetup()
-{
-#ifdef CONFIG_MAC_TO_MAC_MODE
-	*(unsigned long *)MDIO_CFG = 0x1F01DC01;
-	printk("MDIO_CFG = %x\n", *(unsigned long *)MDIO_CFG);
-	return;
 #endif
 
-#ifdef CONFIG_GIGAPHY
-	unsigned long phy_id0, phy_id1;
-	unsigned long regValue = sysRegRead(MDIO_CFG);
-	int ret = 0;
+        u32 addr = CONFIG_MAC_TO_GIGAPHY_MODE_ADDR;     // define in linux/autoconf.h
 
-	regValue &= ~(0x1F << 24);
-	regValue |= (0x1F << 24);
+        regValue &= 0xe0ff7fff;                 // clear auto polling related field:
+                                                // (MD_PHY1ADDR & GP1_FRC_EN).
+        regValue |= 0x20000000;                 // force to enable MDC/MDIO auto polling.
+        regValue |= (addr << 24);               // setup PHY address for auto polling.
+
+#if defined (CONFIG_RALINK_RT3052)
+	sysRegWrite(0xb01100C8, regValue);
+#else
 	sysRegWrite(MDIO_CFG, regValue);
-
-	ret =  phyregread(2, &phy_id0);
-	if (!ret) {
-		printk("PhyID 0 read failed!\n");
-		phy_id0 = 0;
-	}
-	
-	ret = phyregread(3, &phy_id1);
-	if (!ret) {
-		printk("PhyID 1 read failed!\n");
-		phy_id1 = 0;
-	}
-
-	if ( (phy_id0 == EV_MARVELL_PHY_ID0) && (phy_id1 == EV_MARVELL_PHY_ID1) ) {
-		printk("MARVELL PHY Init ok...\n");
-                rt2880_mdio_cfg(20, 7, 1);
-                rt2880_mdio_cfg(0, 15, 1);
-		regValue = sysRegRead(FE_GLO_CFG); 
-		regValue |= 0x0000ff00;
-		sysRegWrite(FE_GLO_CFG, regValue);
-	} else {
-		enable_auto_negotiate();
-		wait_linkup();
-		wait_an_completed();
-	}
-	return;
 #endif
 
-#if defined (CONFIG_RAETH_ROUTER ) || defined (CONFIG_ICPLUS_PHY)
-	printk("IC-Plus PHY Init...");
-	sysRegWrite(MDIO_CFG, INIT_VALUE_OF_ICPLUS_PHY_INIT_VALUE);
-	printk("ok\n");
-#endif
 
 }
 
+#endif
 void ra2880stop(END_DEVICE *ei_local)
 {
 	unsigned int regValue;
@@ -287,10 +90,11 @@
 
 void rt2880_gmac_hard_reset(void)
 {
-	unsigned int regValue = sysRegRead(FE_RESET);
+	unsigned int regValue = 0;
 
 	regValue |= FE_RESET_BIT;
 	sysRegWrite(FE_RESET, regValue);
+	sysRegWrite(FE_RESET, 0);	// update for RSTCTL issue
 }
 
 void ra2880EnableInterrupt()
@@ -350,6 +154,7 @@
         return;
 }
 
+#if defined (CONFIG_ETHTOOL) && ( defined (CONFIG_RAETH_ROUTER) || defined (CONFIG_RT_3052_ESW) )
 /*
  *	mii_mgr_read wrapper for mii.o ethtool
  */
@@ -372,6 +177,7 @@
 	mii_mgr_write( (unsigned int) ei_local->mii_info.phy_id, (unsigned int)location, (unsigned int)value);
 	return;
 }
+#endif
 
 /**
  * hard_init - Called by raeth_probe to inititialize network device
@@ -399,6 +205,7 @@
 	else
 		printk("HWnetInit() failed!!!\n");
 
+#if defined (CONFIG_ETHTOOL) && ( defined (CONFIG_RAETH_ROUTER) || defined (CONFIG_RT_3052_ESW) )
 	// init mii structure
 	ei_local->mii_info.dev = dev;
 	ei_local->mii_info.mdio_read = mdio_read;
@@ -407,7 +214,7 @@
 	ei_local->mii_info.reg_num_mask = 0x1f;
 	// TODO:   phy_id: 0~4
 	ei_local->mii_info.phy_id = 1;
-
+#endif
 	return;
 }
 
@@ -608,7 +415,7 @@
 	printk("GDMA_RX_LERCNT0(0x%08x)     : 0x%08x\n", GDMA_RX_LERCNT0, sysRegRead(GDMA_RX_LERCNT0));
 	printk("GDMA_RX_CERCNT0(0x%08x)     : 0x%08x\n\n", GDMA_RX_CERCNT0, sysRegRead(GDMA_RX_CERCNT0));	
 
-#ifdef CONFIG_RAETH_ROUTER
+#if defined (CONFIG_ETHTOOL) && ( defined (CONFIG_RAETH_ROUTER) || defined (CONFIG_RT_3052_ESW) )
 	// just for debug
 	printk("The current PHY address selected by ethtool is %d\n", get_current_phy_address());
 #endif
@@ -675,6 +482,7 @@
 }
 #endif
 
+#if defined (CONFIG_ETHTOOL) && ( defined (CONFIG_RAETH_ROUTER) || defined (CONFIG_RT_3052_ESW) )
 /*
  * proc write procedure
  */
@@ -700,6 +508,7 @@
 	ei_local->mii_info.phy_id = (unsigned char)(simple_strtol(buf, 0, 10));
 	return count;
 }
+#endif
 
 int debug_proc_init(void)
 {
@@ -707,7 +516,9 @@
 	
     if ((procGmac = create_proc_entry(PROCREG_GMAC, 0, procRegDir))){
 	 procGmac->read_proc = (read_proc_t*)&RegReadMain;
+#if defined (CONFIG_ETHTOOL) && ( defined (CONFIG_RAETH_ROUTER) || defined (CONFIG_RT_3052_ESW) )
 	 procGmac->write_proc = (write_proc_t*)&change_phyid;
+#endif
 	}
 
     if ((procSysCP0 = create_proc_entry(PROCREG_CP0, 0, procRegDir)))
@@ -743,4 +554,3 @@
     printk(KERN_ALERT "proc exit\n");
 }
 
-#endif
