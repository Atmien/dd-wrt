diff -urN SDK_3_1_0_0/RT288x_SDK/source/linux-2.6.21.x/drivers/net/raeth/mcast.c SDK_3_2_0_0/RT288x_SDK/source/linux-2.6.21.x//drivers/net/raeth/mcast.c
--- SDK_3_1_0_0/RT288x_SDK/source/linux-2.6.21.x/drivers/net/raeth/mcast.c	2008-08-06 05:27:47.000000000 +0200
+++ SDK_3_2_0_0/RT288x_SDK/source/linux-2.6.21.x//drivers/net/raeth/mcast.c	2008-10-24 08:20:14.000000000 +0200
@@ -6,17 +6,17 @@
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/netdevice.h>
+#include <asm/semaphore.h>
 
 
 #if defined(CONFIG_RALINK_RT3052_MP) || defined(CONFIG_RALINK_RT3052_MP2)
 
-#define MAX_MCAST_ENTRY	    32
-#define AGEING_TIME	    10  //Unit: Sec
+#define MAX_MCAST_ENTRY	    16
+#define AGEING_TIME	    5  //Unit: Sec
 #define MAC_ARG(x) ((u8*)(x))[0],((u8*)(x))[1],((u8*)(x))[2], \
     ((u8*)(x))[3],((u8*)(x))[4],((u8*)(x))[5]
 
 //#define MCAST_DEBUG
-
 #ifdef MCAST_DEBUG
 #define MCAST_PRINT(fmt, args...) printk(KERN_INFO fmt, ## args)
 #else
@@ -32,11 +32,12 @@
 } mcast_entry;
 
 mcast_entry mcast_tbl[MAX_MCAST_ENTRY];
-uint8_t mcast_entry_num=0;
+atomic_t mcast_entry_num=ATOMIC_INIT(0);
+DECLARE_MUTEX(mtbl_lock);
 
 uint32_t inline is_multicast_pkt(uint8_t *mac)
 {
-    if(mac[0]==0x01 && mac[1]==0x00 && mac[2]==0x5e) {
+    if(mac[0]==0x01) {
 	return 1;
     }else{
 	return 0;
@@ -67,7 +68,7 @@
 		time_after(jiffies, mcast_tbl[i].ageout)) {
 
 	    if(mcast_tbl[i].valid==0) {
-		mcast_entry_num++;
+		atomic_inc(&mcast_entry_num);
 	    }
 
 	    memcpy(mcast_tbl[i].src_mac, src_mac, 6);
@@ -86,19 +87,23 @@
 
 int inline mcast_entry_ins(uint8_t *src_mac, uint8_t *dst_mac) 
 {
-    int entry_num=0;
+    int entry_num=0, ret=0;
 
+    down(&mtbl_lock);
     if((entry_num = mcast_entry_get(src_mac, dst_mac)) >=0) {
 	mcast_tbl[entry_num].use_count++;
 	mcast_tbl[entry_num].ageout=jiffies + AGEING_TIME * HZ;
 	MCAST_PRINT("%s: Update %0X:%0X:%0X:%0X:%0X:%0X's use_count=%d\n" \
 		,__FUNCTION__, MAC_ARG(dst_mac), mcast_tbl[entry_num].use_count);
-	return 1;
+	ret = 1;
     }else { //if entry not found, create new entry.
 	MCAST_PRINT("%s: Create new entry %0X:%0X:%0X:%0X:%0X:%0X\n", \
 		__FUNCTION__, MAC_ARG(dst_mac));
-	return __add_mcast_entry(src_mac,dst_mac);
+	ret = __add_mcast_entry(src_mac,dst_mac);
     }
+    
+    up(&mtbl_lock);
+    return ret;
 
 }
 
@@ -112,16 +117,19 @@
 {
     int entry_num;
 
+    down(&mtbl_lock);
     if((entry_num = mcast_entry_get(src_mac, dst_mac)) >=0) {
 	if((--mcast_tbl[entry_num].use_count)==0) {
 	    MCAST_PRINT("%s: %0X:%0X:%0X:%0X:%0X:%0X (entry_num=%d)\n", \
 		    __FUNCTION__, MAC_ARG(dst_mac), entry_num);
 	    mcast_tbl[entry_num].valid=0;
-	    mcast_entry_num--;
+	    atomic_dec(&mcast_entry_num);
 	}
+	up(&mtbl_lock);
 	return 0;
     }else { 
 	/* this multicast packet was not sent by meself, just ignore it */
+	up(&mtbl_lock);
 	return 1;
     }
 }
@@ -138,8 +146,7 @@
     /* if we do not send multicast packet before, 
      * we don't need to check re-inject multicast packet.
      */
-
-    if (mcast_entry_num==0) {
+    if (atomic_read(&mcast_entry_num)==0) {
 	return 1;
     }
 
