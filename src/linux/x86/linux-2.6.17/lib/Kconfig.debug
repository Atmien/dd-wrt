
config PRINTK_TIME
	bool "Show timing information on printks"
	help
	  Selecting this option causes timing information to be
	  included in printk output.  This allows you to measure
	  the interval between kernel operations, including bootup
	  operations.  This is useful for identifying long delays
	  in kernel startup.


config MAGIC_SYSRQ
	bool "Magic SysRq key"
	depends on !UML
	help
	  If you say Y here, you will have some control over the system even
	  if the system crashes for example during kernel debugging (e.g., you
	  will be able to flush the buffer cache to disk, reboot the system
	  immediately or dump some status information). This is accomplished
	  by pressing various keys while holding SysRq (Alt+PrintScreen). It
	  also works on a serial console (on PC hardware at least), if you
	  send a BREAK and then within 5 seconds a command keypress. The
	  keys are documented in <file:Documentation/sysrq.txt>. Don't say Y
	  unless you really know what this hack does.

config DEBUG_KERNEL
	bool "Kernel debugging"
	help
	  Say Y here if you are developing drivers or trying to debug and
	  identify kernel problems.

config LOG_BUF_SHIFT
	int "Kernel log buffer size (16 => 64KB, 17 => 128KB)" if DEBUG_KERNEL
	range 12 21
	default 17 if S390
	default 16 if X86_NUMAQ || IA64
	default 15 if SMP
	default 14
	help
	  Select kernel log buffer size as a power of 2.
	  Defaults and Examples:
	  	     17 => 128 KB for S/390
		     16 => 64 KB for x86 NUMAQ or IA-64
	             15 => 32 KB for SMP
	             14 => 16 KB for uniprocessor
		     13 =>  8 KB
		     12 =>  4 KB

config DETECT_SOFTLOCKUP
	bool "Detect Soft Lockups"
	depends on DEBUG_KERNEL
	default y
	help
	  Say Y here to enable the kernel to detect "soft lockups",
	  which are bugs that cause the kernel to loop in kernel
	  mode for more than 10 seconds, without giving other tasks a
	  chance to run.

	  When a soft-lockup is detected, the kernel will print the
	  current stack trace (which you should report), but the
	  system will stay locked up. This feature has negligible
	  overhead.

	  (Note that "hard lockups" are separate type of bugs that
	   can be detected via the NMI-watchdog, on platforms that
	   support it.)

config SCHEDSTATS
	bool "Collect scheduler statistics"
	depends on DEBUG_KERNEL && PROC_FS
	help
	  If you say Y here, additional code will be inserted into the
	  scheduler and related routines to collect statistics about
	  scheduler behavior and provide them in /proc/schedstat.  These
	  stats may be useful for both tuning and debugging the scheduler
	  If you aren't debugging the scheduler or trying to tune a specific
	  application, you can say N to avoid the very slight overhead
	  this adds.

config DEBUG_SLAB
	bool "Debug slab memory allocations"
	depends on DEBUG_KERNEL && SLAB
	help
	  Say Y here to have the kernel do limited verification on memory
	  allocation as well as poisoning memory on free to catch use of freed
	  memory. This can make kmalloc/kfree-intensive workloads much slower.

config DEBUG_SLAB_LEAK
	bool "Memory leak debugging"
	depends on DEBUG_SLAB

menuconfig DEBUG_MEMLEAK
	bool "Kernel memory leak detector"
	default n
	depends on EXPERIMENTAL && DEBUG_SLAB
	depends on !NUMA
	select DEBUG_FS
	help
	  Say Y here if you want to enable the memory leak
	  detector. The memory allocation/freeing is traced in a way
	  similar to the Boehm's conservative garbage collector, the
	  difference being that the orphan pointers are not freed but
	  only shown in /sys/kernel/debug/memleak. Enabling this
	  feature will introduce an overhead to memory allocations.

	  In order to access the memleak file, debugfs needs to be
	  mounted (usually at /sys/kernel/debug).

config DEBUG_MEMLEAK_TRACE_LENGTH
	int "KMemLeak stack trace length"
	default 4
	depends on DEBUG_MEMLEAK && FRAME_POINTER
	help
	  This option sets the length of the stack trace for the
	  allocated pointers tracked by kmemleak.

config DEBUG_MEMLEAK_PREINIT_POINTERS
	int "KMemLeak pre-init actions buffer size"
	default 512
	depends on DEBUG_MEMLEAK
	help
	  This is the buffer for storing the memory allocation/freeing
	  calls before kmemleak is fully initialized. Each element in
	  the buffer takes 20 bytes on a 32 bit architecture. This
	  buffer will be freed once the system initialization is
	  completed.

config DEBUG_MEMLEAK_SECONDARY_ALIASES
	bool "Create secondary level pointer aliases"
	default y
	depends on DEBUG_MEMLEAK
	help
	  This option creates aliases for container_of(container_of(member))
	  access to pointers. Disabling this option reduces the chances of
	  false negatives but it can slightly increase the number of false
	  positives.

config DEBUG_MEMLEAK_TASK_STACKS
	bool "Scan task kernel stacks"
	default n
	depends on DEBUG_MEMLEAK
	help
	  This option enables the scanning of the task kernel
	  stacks. Note that this option can introduce a lot of false
	  negatives because of the randomness of stacks content.

config DEBUG_MEMLEAK_ORPHAN_FREEING
	bool "Notify when freeing orphan pointers"
	default n
	depends on DEBUG_MEMLEAK
	help
	  This option enables the notification when pointers
	  considered leaks are freed. The stack dump and the pointer
	  information displayed allow an easier identification of
	  false positives.

config DEBUG_KEEP_INIT
	bool "Do not free the __init functions"
	default n
	depends on DEBUG_MEMLEAK
	help
	  This option moves the __init functions out of the .init.text
	  section and therefore they are no longer freed after the
	  kernel initialization. It is useful for identifying memory
	  leaks happening during the kernel or modules initialization.

config DEBUG_MEMLEAK_TEST
	tristate "Test the kernel memory leak detector"
	default n
	depends on DEBUG_MEMLEAK
	help
	  Say Y here to build the test harness for the kernel memory
	  leak detector. At the moment, this option enables a module
	  that explicitly leaks memory.

config DEBUG_PREEMPT
	bool "Debug preemptible kernel"
	depends on DEBUG_KERNEL && PREEMPT
	default y
	help
	  If you say Y here then the kernel will use a debug variant of the
	  commonly used smp_processor_id() function and will print warnings
	  if kernel code uses it in a preemption-unsafe way. Also, the kernel
	  will detect preemption count underflows.

config DEBUG_MUTEXES
	bool "Mutex debugging, deadlock detection"
	default n
	depends on DEBUG_KERNEL
	help
	 This allows mutex semantics violations and mutex related deadlocks
	 (lockups) to be detected and reported automatically.

config DEBUG_SPINLOCK
	bool "Spinlock debugging"
	depends on DEBUG_KERNEL
	help
	  Say Y here and build SMP to catch missing spinlock initialization
	  and certain other kinds of spinlock errors commonly made.  This is
	  best used in conjunction with the NMI watchdog so that spinlock
	  deadlocks are also debuggable.

config DEBUG_SPINLOCK_SLEEP
	bool "Sleep-inside-spinlock checking"
	depends on DEBUG_KERNEL
	help
	  If you say Y here, various routines which may sleep will become very
	  noisy if they are called with a spinlock held.

config DEBUG_KOBJECT
	bool "kobject debugging"
	depends on DEBUG_KERNEL
	help
	  If you say Y here, some extra kobject debugging messages will be sent
	  to the syslog. 

config DEBUG_HIGHMEM
	bool "Highmem debugging"
	depends on DEBUG_KERNEL && HIGHMEM
	help
	  This options enables addition error checking for high memory systems.
	  Disable for production systems.

config DEBUG_BUGVERBOSE
	bool "Verbose BUG() reporting (adds 70K)" if DEBUG_KERNEL && EMBEDDED
	depends on BUG
	depends on ARM || ARM26 || M32R || M68K || SPARC32 || SPARC64 || X86_32 || FRV
	default !EMBEDDED
	help
	  Say Y here to make BUG() panics output the file name and line number
	  of the BUG call as well as the EIP and oops trace.  This aids
	  debugging but costs about 70-100K of memory.

config DEBUG_INFO
	bool "Compile the kernel with debug info"
	depends on DEBUG_KERNEL
	help
          If you say Y here the resulting kernel image will include
	  debugging info resulting in a larger kernel image.
	  Say Y here only if you plan to debug the kernel.

	  If unsure, say N.

config DEBUG_FS
	bool "Debug Filesystem"
	depends on SYSFS
	help
	  debugfs is a virtual file system that kernel developers use to put
	  debugging files into.  Enable this option to be able to read and
	  write to these files.

	  If unsure, say N.

config DEBUG_VM
	bool "Debug VM"
	depends on DEBUG_KERNEL
	help
	  Enable this to turn on extended checks in the virtual-memory system
          that may impact performance.

	  If unsure, say N.

config FRAME_POINTER
	bool "Compile the kernel with frame pointers"
	depends on DEBUG_KERNEL && (X86 || CRIS || M68K || M68KNOMMU || FRV || UML)
	default y if DEBUG_INFO && UML
	help
	  If you say Y here the resulting kernel image will be slightly larger
	  and slower, but it might give very useful debugging information on
	  some architectures or if you use external debuggers.
	  If you don't debug the kernel, you can say N.

config UNWIND_INFO
	bool "Compile the kernel with frame unwind information"
	depends on !IA64
	depends on !MODULES || !(MIPS || PARISC || PPC || SUPERH || V850)
	help
	  If you say Y here the resulting kernel image will be slightly larger
	  but not slower, and it will give very useful debugging information.
	  If you don't debug the kernel, you can say N, but we may not be able
	  to solve problems without frame unwind information or frame pointers.

config FORCED_INLINING
	bool "Force gcc to inline functions marked 'inline'"
	depends on DEBUG_KERNEL
	default y
	help
	  This option determines if the kernel forces gcc to inline the functions
	  developers have marked 'inline'. Doing so takes away freedom from gcc to
	  do what it thinks is best, which is desirable for the gcc 3.x series of
	  compilers. The gcc 4.x series have a rewritten inlining algorithm and
	  disabling this option will generate a smaller kernel there. Hopefully
	  this algorithm is so good that allowing gcc4 to make the decision can
	  become the default in the future, until then this option is there to
	  test gcc for this.

config RCU_TORTURE_TEST
	tristate "torture tests for RCU"
	depends on DEBUG_KERNEL
	default n
	help
	  This option provides a kernel module that runs torture tests
	  on the RCU infrastructure.  The kernel module may be built
	  after the fact on the running kernel to be tested, if desired.

	  Say Y here if you want RCU torture tests to start automatically
	  at boot time (you probably don't).
	  Say M if you want the RCU torture tests to build as a module.
	  Say N if you are unsure.
