Index: net/bridge/br_private.h
===================================================================
--- net/bridge/br_private.h	(revision 7525)
+++ net/bridge/br_private.h	(working copy)
@@ -31,10 +31,6 @@
 /* Path to usermode spanning tree program */
 #define BR_STP_PROG	"/sbin/bridge-stp"
 
-#define TIMER_CHECK_TIMEOUT 10
-#define QUERY_TIMEOUT 130
-//#define QUERY_TIMEOUT 60
-
 typedef struct bridge_id bridge_id;
 typedef struct mac_addr mac_addr;
 typedef __u16 port_id;
@@ -50,17 +46,6 @@
 	unsigned char	addr[6];
 };
 
-struct net_bridge_mc_fdb_entry
-{
-	struct net_bridge_port		*dst;
-	mac_addr			addr;
-	mac_addr			host;
-	unsigned char			is_local;
-	unsigned char			is_static;
-	unsigned long			tstamp;
-	struct list_head 		list;
-};
-
 struct net_bridge_fdb_entry
 {
 	struct hlist_node		hlist;
@@ -92,7 +77,6 @@
 	bridge_id			designated_bridge;
 	u32				path_cost;
 	u32				designated_cost;
-	int		 		dirty;
 
 	struct timer_list		forward_delay_timer;
 	struct timer_list		hold_timer;
@@ -112,12 +96,6 @@
 	struct list_head		age_list;
 	unsigned long			feature_mask;
 
-	struct list_head		mc_list;
-	struct timer_list 		igmp_timer;
-	int		 		proxy;
-	spinlock_t			mcl_lock;
-	int		 		start_timer;
-
 	/* STP */
 	bridge_id			designated_root;
 	bridge_id			bridge_id;
@@ -216,18 +194,6 @@
 extern struct sk_buff *br_handle_frame(struct net_bridge_port *p,
 				       struct sk_buff *skb);
 
-extern int snooping;
-extern void query_timeout(unsigned long ptr);
-extern int mc_forward(struct net_bridge *br, struct sk_buff *skb, const unsigned char *dest,int forward, int clone);
-extern void dolist(struct net_bridge *br);
-extern int br_mc_fdb_update(struct net_bridge *br, struct net_bridge_port *prt, const unsigned char *dest, unsigned char *host);
-extern struct net_bridge_mc_fdb_entry *br_mc_fdb_get(struct net_bridge *br, struct net_bridge_port *prt, unsigned char *dest, unsigned char *host);
-extern int br_mc_fdb_add(struct net_bridge *br, struct net_bridge_port *prt, const unsigned char *dest, unsigned char *host);
-extern void br_mc_fdb_cleanup(struct net_bridge *br);
-extern void br_mc_fdb_remove_grp(struct net_bridge *br, struct net_bridge_port *prt, unsigned char *dest);
-extern int br_mc_fdb_remove(struct net_bridge *br, struct net_bridge_port *prt, unsigned char *dest, unsigned char *host);
-extern void addr_debug(unsigned char *dest);
-
 /* br_ioctl.c */
 extern int br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 extern int br_ioctl_deviceless_stub(unsigned int cmd, void __user *arg);
Index: net/bridge/br.c
===================================================================
--- net/bridge/br.c	(revision 7525)
+++ net/bridge/br.c	(working copy)
@@ -63,7 +63,7 @@
 err_out3:
 	unregister_netdevice_notifier(&br_device_notifier);
 err_out2:
-//	br_netfilter_fini();
+	br_netfilter_fini();
 err_out1:
 	llc_sap_put(br_stp_sap);
 	return err;
Index: net/bridge/br_stp_if.c
===================================================================
--- net/bridge/br_stp_if.c	(revision 7525)
+++ net/bridge/br_stp_if.c	(working copy)
@@ -52,9 +52,6 @@
 
 	br_config_bpdu_generation(br);
 
-	// brcm
-	br->dev->trans_start = jiffies * 100 / HZ;
-
 	list_for_each_entry(p, &br->port_list, list) {
 		if ((p->dev->flags & IFF_UP) && netif_carrier_ok(p->dev))
 			br_stp_enable_port(p);
@@ -79,9 +76,6 @@
 	br->topology_change_detected = 0;
 	spin_unlock_bh(&br->lock);
 
-	// brcm
-	br->dev->trans_start = jiffies * 100 / HZ;
-
 	del_timer_sync(&br->hello_timer);
 	del_timer_sync(&br->topology_change_timer);
 	del_timer_sync(&br->tcn_timer);
@@ -224,7 +218,7 @@
 
 	list_for_each_entry(p, &br->port_list, list) {
 		if (addr == br_mac_zero ||
-		    memcmp(p->dev->dev_addr, addr, ETH_ALEN) > 0)
+		    memcmp(p->dev->dev_addr, addr, ETH_ALEN) < 0)
 			addr = p->dev->dev_addr;
 
 	}
Index: net/bridge/br_fdb.c
===================================================================
--- net/bridge/br_fdb.c	(revision 7525)
+++ net/bridge/br_fdb.c	(working copy)
@@ -55,11 +55,7 @@
  */
 static inline unsigned long hold_time(const struct net_bridge *br)
 {
-    /* We use forward_delay=0. If code unchanged, every entry in fdb will expire immidately */
-    /* and every packet flood the local network for a period of bridge_max_age afterboot up */
-    /* So we decoulpe this timer from forward_delay. */
-	return br->topology_change ? (15*HZ) : br->ageing_time;
-	//return br->topology_change ? br->forward_delay : br->ageing_time;
+	return br->topology_change ? br->forward_delay : br->ageing_time;
 }
 
 static inline int has_expired(const struct net_bridge *br,
@@ -82,148 +78,6 @@
 	br_fdb_put(f);
 }
 
-
-void dolist(struct net_bridge *br)
-{
-	struct net_bridge_mc_fdb_entry *dst;
-	struct list_head *lh;
-
-	
-	if (!br)
-	    return;
-
-	printk(KERN_EMERG "bridge	device	group			source			timeout\n");
-	list_for_each_rcu(lh, &br->mc_list) {
-	    dst = (struct net_bridge_mc_fdb_entry *) list_entry(lh, struct net_bridge_mc_fdb_entry, list);
-	    printk(KERN_EMERG "%s	%s  	", br->dev->name, dst->dst->dev->name);
-	    addr_debug((unsigned char *) &dst->addr);
-	    printk(KERN_EMERG "	");
-	    addr_debug((unsigned char *) &dst->host);
-	    printk(KERN_EMERG "	%d\n", (int) (dst->tstamp - jiffies)/HZ);
-	}
-}
-
-int br_mc_fdb_update(struct net_bridge *br, struct net_bridge_port *prt, const unsigned char *dest, unsigned char *host)
-{
-	struct net_bridge_mc_fdb_entry *dst;
-	struct list_head *lh;
-	int ret = 0;
-    
-	list_for_each_rcu(lh, &br->mc_list) {
-	    dst = (struct net_bridge_mc_fdb_entry *) list_entry(lh, struct net_bridge_mc_fdb_entry, list);
-	    if (!memcmp(&dst->addr, dest, ETH_ALEN)) {
-		dst->tstamp = jiffies + QUERY_TIMEOUT*HZ;
-		if (!memcmp(&dst->host, host, ETH_ALEN))
-		    ret = 1;
-	    }
-	}
-	
-	return ret;
-}
-
-struct net_bridge_mc_fdb_entry *br_mc_fdb_get(struct net_bridge *br, struct net_bridge_port *prt, unsigned char *dest, unsigned char *host)
-{
-	struct net_bridge_mc_fdb_entry *dst;
-	struct list_head *lh;
-    
-	list_for_each_rcu(lh, &br->mc_list) {
-	    dst = (struct net_bridge_mc_fdb_entry *) list_entry(lh, struct net_bridge_mc_fdb_entry, list);
-	    if ((!memcmp(&dst->addr, dest, ETH_ALEN)) && (!memcmp(&dst->host, host, ETH_ALEN))) {
-		if (dst->dst == prt)
-		    return dst;
-	    }
-	}
-	
-	return NULL;
-}
-
-extern mac_addr upnp_addr;
-
-int br_mc_fdb_add(struct net_bridge *br, struct net_bridge_port *prt, const unsigned char *dest, unsigned char *host)
-{
-	struct net_bridge_mc_fdb_entry *mc_fdb;
-
-	//printk("--- add mc entry ---\n");
-
-	if (!memcmp(dest, &upnp_addr, ETH_ALEN))
-	    return 0;
-	    
-	if (br_mc_fdb_update(br, prt, dest, host))
-	    return 0;
-	    
-	mc_fdb = kmalloc(sizeof(struct net_bridge_mc_fdb_entry), GFP_KERNEL);
-	if (!mc_fdb)
-	    return ENOMEM;
-	memcpy(mc_fdb->addr.addr, dest, ETH_ALEN);
-	memcpy(mc_fdb->host.addr, host, ETH_ALEN);
-	mc_fdb->dst = prt;
-	mc_fdb->tstamp = jiffies + QUERY_TIMEOUT*HZ;;
-	spin_lock_bh(&br->mcl_lock);
-	list_add_tail_rcu(&mc_fdb->list, &br->mc_list);
-	spin_unlock_bh(&br->mcl_lock);
-
-	if (!br->start_timer) {
-    	    init_timer(&br->igmp_timer);
-	    br->igmp_timer.expires = jiffies + TIMER_CHECK_TIMEOUT*HZ;
-	    br->igmp_timer.function = query_timeout;
-	    br->igmp_timer.data = (unsigned long) br;
-	    add_timer(&br->igmp_timer);
-	    br->start_timer = 1;
-	}
-
-	return 1;
-}
-
-void br_mc_fdb_cleanup(struct net_bridge *br)
-{
-	struct net_bridge_mc_fdb_entry *dst;
-	struct list_head *lh;
-	struct list_head *tmp;
-    
-	spin_lock_bh(&br->mcl_lock);
-	list_for_each_safe_rcu(lh, tmp, &br->mc_list) {
-	    dst = (struct net_bridge_mc_fdb_entry *) list_entry(lh, struct net_bridge_mc_fdb_entry, list);
-	    list_del_rcu(&dst->list);
-	    kfree(dst);
-	}
-	spin_unlock_bh(&br->mcl_lock);
-}
-
-void br_mc_fdb_remove_grp(struct net_bridge *br, struct net_bridge_port *prt, unsigned char *dest)
-{
-	struct net_bridge_mc_fdb_entry *dst;
-	struct list_head *lh;
-	struct list_head *tmp;
-
-	spin_lock_bh(&br->mcl_lock);
-	list_for_each_safe_rcu(lh, tmp, &br->mc_list) {
-	    dst = (struct net_bridge_mc_fdb_entry *) list_entry(lh, struct net_bridge_mc_fdb_entry, list);
-	    if ((!memcmp(&dst->addr, dest, ETH_ALEN)) && (dst->dst == prt)) {
-		list_del_rcu(&dst->list);
-		kfree(dst);
-	    }
-	}
-	spin_unlock_bh(&br->mcl_lock);
-}
-
-int br_mc_fdb_remove(struct net_bridge *br, struct net_bridge_port *prt, unsigned char *dest, unsigned char *host)
-{
-	struct net_bridge_mc_fdb_entry *mc_fdb;
-
-	//printk("--- remove mc entry ---\n");
-	
-	if ((mc_fdb = br_mc_fdb_get(br, prt, dest, host))) {
-	    spin_lock_bh(&br->mcl_lock);
-	    list_del_rcu(&mc_fdb->list);
-	    kfree(mc_fdb);
-	    spin_unlock_bh(&br->mcl_lock);
-
-	    return 1;
-	}
-	
-	return 0;
-}
-
 void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr)
 {
 	struct net_bridge *br = p->br;
@@ -534,12 +388,10 @@
 	if (likely(fdb)) {
 		/* attempt to update an entry for a local interface */
 		if (unlikely(fdb->is_local)) {
-		#if 0 
 			if (net_ratelimit())
 				printk(KERN_WARNING "%s: received packet with "
 				       " own address as source address\n",
 				       source->dev->name);
-		#endif
 		} else {
 			/* fastpath: update of existing entry */
 			fdb->dst = source;
Index: net/bridge/br_netfilter.c
===================================================================
--- net/bridge/br_netfilter.c	(revision 7525)
+++ net/bridge/br_netfilter.c	(working copy)
@@ -992,6 +992,6 @@
 	unregister_sysctl_table(brnf_sysctl_header);
 #endif
 }
-EXPORT_NO_SYMBOLS;
 EXPORT_SYMBOL(br_netfilter_init);
 EXPORT_SYMBOL(br_netfilter_fini);
+
Index: net/bridge/br_if.c
===================================================================
--- net/bridge/br_if.c	(revision 7525)
+++ net/bridge/br_if.c	(working copy)
@@ -25,8 +25,6 @@
 
 #include "br_private.h"
 
-int snooping = 0;
-
 /*
  * Determine initial path cost based on speed.
  * using recommendations from 802.1d standard
@@ -177,8 +175,6 @@
 		del_nbp(p);
 	}
 
-	br_mc_fdb_cleanup(br);
-
 	del_timer_sync(&br->gc_timer);
 
 	br_sysfs_delbr(br->dev);
@@ -209,9 +205,6 @@
 	memcpy(br->group_addr, br_group_address, ETH_ALEN);
 
 	br->feature_mask = dev->features;
-  	br->lock = SPIN_LOCK_UNLOCKED;
-  	INIT_LIST_HEAD(&br->mc_list);
-  	br->hash_lock = SPIN_LOCK_UNLOCKED;
 	br->stp_enabled = BR_NO_STP;
 	br->designated_root = br->bridge_id;
 	br->root_path_cost = 0;
Index: net/bridge/br_device.c
===================================================================
--- net/bridge/br_device.c	(revision 7525)
+++ net/bridge/br_device.c	(working copy)
@@ -40,10 +40,9 @@
 	skb_reset_mac_header(skb);
 	skb_pull(skb, ETH_HLEN);
 
- 	if (dest[0] & 1) {
- 		if (!mc_forward(br, skb, dest, 0, 0))		
- 		br_flood_deliver(br, skb, 0);	
- 	}else if ((dst = __br_fdb_get(br, dest)) != NULL)
+	if (dest[0] & 1)
+		br_flood_deliver(br, skb, 0);
+	else if ((dst = __br_fdb_get(br, dest)) != NULL)
 		br_deliver(dst->dst, skb);
 	else
 		br_flood_deliver(br, skb, 0);
Index: net/bridge/br_input.c
===================================================================
--- net/bridge/br_input.c	(revision 7525)
+++ net/bridge/br_input.c	(working copy)
@@ -17,12 +17,8 @@
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/netfilter_bridge.h>
-#include <linux/timer.h>
-#include <linux/igmp.h>
 #include "br_private.h"
 
-#define SNOOPING_BLOCKING_MODE 2
-
 /* Bridge group multicast address 802.1d (pg 51). */
 const u8 br_group_address[ETH_ALEN] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x00 };
 
@@ -39,143 +35,6 @@
 	NF_HOOK(PF_BRIDGE, NF_BR_LOCAL_IN, skb, indev, NULL,
 		netif_receive_skb);
 }
- void query_timeout(unsigned long ptr)
- {
- 	struct net_bridge_mc_fdb_entry *dst;
- 	struct list_head *tmp;
- 	struct list_head *lh;
- 	struct net_bridge *br;
-     
- 	br = (struct net_bridge *) ptr;
- 
- 	spin_lock_bh(&br->mcl_lock);
- 	list_for_each_safe_rcu(lh, tmp, &br->mc_list) {
- 	    dst = (struct net_bridge_mc_fdb_entry *) list_entry(lh, struct net_bridge_mc_fdb_entry, list);
- 	    if (jiffies > dst->tstamp) {
- 		list_del_rcu(&dst->list);
- 		kfree(dst);
- 	    }
- 	}
- 	spin_unlock_bh(&br->mcl_lock);
- 		
- 	mod_timer(&br->igmp_timer, jiffies + TIMER_CHECK_TIMEOUT*HZ);		
- }
- 
- void addr_debug(unsigned char *dest)
- {
- #define NUM2PRINT 50
- 	char buf[NUM2PRINT * 3 + 1];	/* 3 chars per byte */
- 	int i = 0;
- 	for (i = 0; i < 6 && i < NUM2PRINT; i++) {
- 		sprintf(buf + i * 3, "%2.2x ", 0xff & dest[i]);
- 	}
- 	printk("%s ", buf);
- }
- 
- 
- void addr_conv(const unsigned char *in, char * out)
- {
-     sprintf(out, "%02x%02x%02x%02x%02x%02x", in[0], in[1], in[2], in[3], in[4], in[5]);
- }
- 
- mac_addr upnp_addr = {{0x01, 0x00, 0x5e, 0x7f, 0xff, 0xfa}};
- mac_addr sys1_addr = {{0x01, 0x00, 0x5e, 0x00, 0x00, 0x01}};
- mac_addr sys2_addr = {{0x01, 0x00, 0x5e, 0x00, 0x00, 0x02}};
- mac_addr ospf1_addr = {{0x01, 0x00, 0x5e, 0x00, 0x00, 0x05}};
- mac_addr ospf2_addr = {{0x01, 0x00, 0x5e, 0x00, 0x00, 0x06}};
- mac_addr ripv2_addr = {{0x01, 0x00, 0x5e, 0x00, 0x00, 0x09}};
- mac_addr sys_addr = {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff}};
- 
- int control_filter(const unsigned char *dest)
- {
-     if ((!memcmp(dest, &upnp_addr, ETH_ALEN)) ||
- 	(!memcmp(dest, &sys1_addr, ETH_ALEN)) ||
- 	(!memcmp(dest, &sys2_addr, ETH_ALEN)) ||
- 	(!memcmp(dest, &ospf1_addr, ETH_ALEN)) ||
- 	(!memcmp(dest, &ospf2_addr, ETH_ALEN)) ||
- 	(!memcmp(dest, &sys_addr, ETH_ALEN)) ||
- 	(!memcmp(dest, &ripv2_addr, ETH_ALEN)))
- 	    return 0;
-     else
- 	return 1;
- }
- 
- int mc_forward(struct net_bridge *br, struct sk_buff *skb, const unsigned char *dest,int forward, int clone)
- {
- 	struct net_bridge_mc_fdb_entry *dst;
- 	struct list_head *lh;
- 	int status = 0;
- 	struct sk_buff *skb2;
- 	struct net_bridge_port *p;
- 	unsigned char tmp[6];
- 
- 	if (!snooping)
- 		return 0;
- 
- 	if ((snooping == SNOOPING_BLOCKING_MODE) && control_filter(dest))
- 	    status = 1;
- 
- 	if (skb->data[9] == IPPROTO_IGMP) {
- 	    // For proxy; need to add some intelligence here 
- 	    if (!br->proxy) {
- 		if (skb->data[24] == IGMPV2_HOST_MEMBERSHIP_REPORT &&
- 		    skb->protocol == __constant_htons(ETH_P_IP)) {
- 		    br_mc_fdb_add(br, skb->dev->br_port, dest, eth_hdr(skb)->h_source);
-                 }
- 		else if (skb->data[24] == IGMP_HOST_LEAVE_MESSAGE) {
- 		    tmp[0] = 0x01;
- 		    tmp[1] = 0x00;
- 		    tmp[2] = 0x5e;
- 		    tmp[3] = 0x7F & skb->data[29];
- 		    tmp[4] = skb->data[30];
- 		    tmp[5] = skb->data[31];
- 		    br_mc_fdb_remove(br, skb->dev->br_port, tmp, eth_hdr(skb)->h_source);
- 		}
- 		else
- 		    ;
- 	    }
- 	    return 0;
- 	}
- 
- 	/*
- 	if (clone) {
- 		struct sk_buff *skb3;
- 
- 		if ((skb3 = skb_clone(skb, GFP_ATOMIC)) == NULL) {
- 			br->statistics.tx_dropped++;
- 			return;
- 		}
- 
- 		skb = skb3;
- 	}
- 	*/
- 	
- 	list_for_each_rcu(lh, &br->mc_list) {
- 	    dst = (struct net_bridge_mc_fdb_entry *) list_entry(lh, struct net_bridge_mc_fdb_entry, list);
- 	    if (!memcmp(&dst->addr, dest, ETH_ALEN)) {
- 		if (!dst->dst->dirty) {
- 		    skb2 = skb_clone(skb, GFP_ATOMIC);
- 		    if (forward)
- 			br_forward(dst->dst, skb2);
- 		    else
- 			br_deliver(dst->dst, skb2);
- 		}
- 		dst->dst->dirty = 1;
- 		status = 1;
- 	    }
- 	}
- 	if (status) {
- 	    list_for_each_entry_rcu(p, &br->port_list, list) {
- 		p->dirty = 0;
- 	  }
- 	}
- 
- 	if ((!forward) && (status))
- 	kfree_skb(skb);
- 
- 	return status;
- }
- 
 
 /* note: already called with rcu_read_lock (preempt_disabled) */
 int br_handle_frame_finish(struct sk_buff *skb)
@@ -184,9 +43,7 @@
 	struct net_bridge_port *p = rcu_dereference(skb->dev->br_port);
 	struct net_bridge *br;
 	struct net_bridge_fdb_entry *dst;
-	unsigned char *src;
 	int passedup = 0;
-	src = eth_hdr(skb)->h_source;
 
 	if (!p || p->state == BR_STATE_DISABLED)
 		goto drop;
@@ -209,28 +66,6 @@
 	}
 
 	if (is_multicast_ether_addr(dest)) {
-		if (snooping && br->proxy) {
-		  if (skb->data[9] == IPPROTO_IGMP) {
-		    char destS[16];
-		    char srcS[16];
-
-		    if (skb->data[24] == IGMP_HOST_LEAVE_MESSAGE) {
-			unsigned char tmp[6];
-			
-			tmp[0] = 0x01;
-			tmp[1] = 0x00;
-			tmp[2] = 0x5e;
-			tmp[3] = 0x7F & skb->data[29];
-			tmp[4] = skb->data[30];
-			tmp[5] = skb->data[31];
-			addr_conv(tmp, destS);
-		    }
-		    else
-			addr_conv(dest, destS);
-		    addr_conv(src, srcS);
-		  }
-		}
-		if (!mc_forward(br, skb, dest, 1, !passedup))		
 		br->statistics.multicast++;
 		br_flood_forward(br, skb, !passedup);
 		if (!passedup)
Index: net/bridge/br_ioctl.c
===================================================================
--- net/bridge/br_ioctl.c	(revision 7525)
+++ net/bridge/br_ioctl.c	(working copy)
@@ -21,12 +21,6 @@
 #include <asm/uaccess.h>
 #include "br_private.h"
 
-#define BRCTL_SET_PORT_SNOOPING 21
-#define BRCTL_CLEAR_PORT_SNOOPING 22
-#define BRCTL_ENABLE_SNOOPING 23
-#define BRCTL_SHOW_SNOOPING 24
-#define SIOCBRSHOWSNOOPING 24
-
 /* called with RTNL */
 static int get_bridge_ifindices(int *indices, int num)
 {
@@ -54,31 +48,6 @@
 	}
 }
 
-int br_set_port_snooping(struct net_bridge_port *p,  void __user * userbuf)
-{
-    unsigned char tmp[26];
-    
-    if (copy_from_user(tmp, userbuf, sizeof(tmp)))
-		return -EFAULT;
-    br_mc_fdb_add(p->br, p, tmp, tmp+6);
-    return 0;
-}
-
-int br_clear_port_snooping(struct net_bridge_port *p,  void __user * userbuf)
-{
-    unsigned char tmp[26];
-    unsigned char all[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-    
-    if (copy_from_user(tmp, userbuf, sizeof(tmp)))
-		return -EFAULT;
-    p->br->proxy = 1;
-    if (!memcmp(tmp+6, all, 6))
-	br_mc_fdb_remove_grp(p->br, p, tmp);
-    else
-	br_mc_fdb_remove(p->br, p, tmp, tmp+6);
-    return 1;
-}
-
 /*
  * Format up to a page worth of forwarding table entries
  * userbuf -- where to copy result
@@ -317,39 +286,6 @@
 		return ret;
 	}
 
-	case BRCTL_SET_PORT_SNOOPING:
-	{
-		struct net_bridge_port *p;
-		int ret = 0;
-		if (!capable(CAP_NET_ADMIN))
-			return -EPERM;
-
-		spin_lock_bh(&br->lock);
-		if ((p = br_get_port(br, args[1])) == NULL) 
-			ret = -EINVAL;
-		else
-			br_set_port_snooping(p, (void __user *) args[2]);
-		spin_unlock_bh(&br->lock);
-		return ret;
-	}
-
-	case BRCTL_CLEAR_PORT_SNOOPING:
-	{
-		struct net_bridge_port *p;
-		int ret = 0;
-
-		if (!capable(CAP_NET_ADMIN))
-			return -EPERM;
-
-		spin_lock_bh(&br->lock);
-		if ((p = br_get_port(br, args[1])) == NULL) 
-			ret = -EINVAL;
-		else
-			br_clear_port_snooping(p, (void __user *) args[2]);
-		spin_unlock_bh(&br->lock);
-		return ret;
-	}
-
 	case BRCTL_SET_PATH_COST:
 	{
 		struct net_bridge_port *p;
@@ -423,37 +359,8 @@
 
 		return br_del_bridge(buf);
 	}
-
-	case BRCTL_SHOW_SNOOPING:
-	{
-		char buf[IFNAMSIZ];
-		struct net_device *dev;
-		if (!capable(CAP_NET_ADMIN))
-			return -EPERM;
-
-		if (copy_from_user(buf, (void __user *)args[1], IFNAMSIZ))
-			return -EFAULT;
-
-		buf[IFNAMSIZ-1] = 0;
-
-		dev = __dev_get_by_name(buf);
-		if (dev == NULL) 
-		    return  -ENXIO; 	/* Could not find device */
-		dolist(netdev_priv(dev));
-
-		return 0;
 	}
 
-	case BRCTL_ENABLE_SNOOPING:
-	{
-		if (!capable(CAP_NET_ADMIN))
-			return -EPERM;
-
-		snooping = args[1];
-		return 0;
-	}
-	}
-
 	return -EOPNOTSUPP;
 }
 
@@ -481,27 +388,7 @@
 
 		return br_del_bridge(buf);
 	}
-	case SIOCBRSHOWSNOOPING:
-	{
-		char buf[IFNAMSIZ];
-		struct net_device *dev;
-	
-		if (!capable(CAP_NET_ADMIN))
-			return -EPERM;
-	
-		if (copy_from_user(buf, uarg, IFNAMSIZ))
-			return -EFAULT;
-
-		buf[IFNAMSIZ-1] = 0;
-			
-		dev = __dev_get_by_name(buf);
-		if (dev == NULL) 
-		    return -ENXIO; 	/* Could not find device */
-			dolist(netdev_priv(dev));
-		
-		return 0;
 	}
-	}
 	return -EOPNOTSUPP;
 }
 
@@ -522,4 +409,3 @@
 	pr_debug("Bridge does not support ioctl 0x%x\n", cmd);
 	return -EOPNOTSUPP;
 }
-
