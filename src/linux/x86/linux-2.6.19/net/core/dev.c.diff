diff -urN linux-2.6.17/net/core/dev.c linux-2.6.17.14/net/core/dev.c
--- linux-2.6.17/net/core/dev.c	2006-12-22 20:34:34.000000000 +0100
+++ linux-2.6.17.14/net/core/dev.c	2006-10-17 15:35:50.000000000 +0200
@@ -116,57 +116,6 @@
 #include <asm/current.h>
 #include <linux/audit.h>
 
-#if defined (CONFIG_RING) || defined(CONFIG_RING_MODULE)
-
-/* #define RING_DEBUG */
-
-#include <linux/ring.h>
-#include <linux/version.h>
-
-static handle_ring_skb ring_handler = NULL;
-
-handle_ring_skb get_skb_ring_handler() { return(ring_handler); }
-
-void set_skb_ring_handler(handle_ring_skb the_handler) {
-  ring_handler = the_handler;
-}
-
-void do_skb_ring_handler(struct sk_buff *skb,
-			 u_char recv_packet, u_char real_skb) {
-  if(ring_handler)
-    ring_handler(skb, recv_packet, real_skb);
-}
-
-/* ******************* */
-
-static handle_ring_buffer buffer_ring_handler = NULL;
-
-handle_ring_buffer get_buffer_ring_handler() { return(buffer_ring_handler); }
-
-void set_buffer_ring_handler(handle_ring_buffer the_handler) {
-  buffer_ring_handler = the_handler;
-}
-
-int do_buffer_ring_handler(struct net_device *dev, char *data, int len) {
-  if(buffer_ring_handler) {
-    buffer_ring_handler(dev, data, len);
-    return(1);
-  } else 
-    return(0);
-}
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
-EXPORT_SYMBOL(get_skb_ring_handler);
-EXPORT_SYMBOL(set_skb_ring_handler);
-EXPORT_SYMBOL(do_skb_ring_handler);
-
-EXPORT_SYMBOL(get_buffer_ring_handler);
-EXPORT_SYMBOL(set_buffer_ring_handler);
-EXPORT_SYMBOL(do_buffer_ring_handler);
-#endif
-
-#endif
-
 /*
  *	The list of packet types we will receive (as opposed to discard)
  *	and the routines to invoke.
@@ -1319,12 +1268,6 @@
 
 	/* We are no longer a clone, even if we were. */
 	skb->cloned    = 0;
-#if defined(CONFIG_MIPS_BRCM)
-    /* The data buffer of this skb is not pre-allocated any more
-     * even the skb itself is pre-allocated. (songw)
-     */
-    skb->retfreeq_data_prealloc = 0;
-#endif
 
 	skb->tail     += skb->data_len;
 	skb->data_len  = 0;
@@ -1425,10 +1368,6 @@
 	skb->tc_verd = SET_TC_AT(skb->tc_verd,AT_EGRESS);
 #endif
 	if (q->enqueue) {
-#if defined (CONFIG_RING) || defined(CONFIG_RING_MODULE)
-	if(ring_handler) ring_handler(skb, 0, 1);
-#endif /* CONFIG_RING */
-
 		/* Grab device queue */
 		spin_lock(&dev->queue_lock);
 
@@ -1528,12 +1467,6 @@
 {
 	struct softnet_data *queue;
 	unsigned long flags;
-#if defined (CONFIG_RING) || defined(CONFIG_RING_MODULE)
-	if(ring_handler && ring_handler(skb, 1, 1)) {
-	  /* The packet has been copied into a ring */
-	  return(NET_RX_SUCCESS);
-	}
-#endif /* CONFIG_RING */
 
 	/* if netpoll wants it, pretend we never saw it */
 	if (netpoll_rx(skb))
@@ -1550,18 +1483,6 @@
 	queue = &__get_cpu_var(softnet_data);
 
 	__get_cpu_var(netdev_rx_stat).total++;
-#ifdef CONFIG_BRIDGE
-	/* Optimisation for framebursting (allow interleaving of pkts by
-	 * immediately processing the rx pkt instead of Qing the pkt and deferring
-	 * the processing). Only optimise for bridging and guard against non
-	 * TASKLET based netif_rx calls.
-	 */
-	if (!in_irq() && (skb->dev->br_port != NULL) && br_handle_frame_hook != NULL) {
-		local_irq_restore(flags);
-		return netif_receive_skb(skb);
-	}
-#endif		
-
 	if (queue->input_pkt_queue.qlen <= netdev_max_backlog) {
 		if (queue->input_pkt_queue.qlen) {
 enqueue:
@@ -1693,21 +1614,6 @@
 				    struct packet_type **pt_prev, int *ret,
 				    struct net_device *orig_dev)
 {
-
-#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
-#if defined(CONFIG_MIPS_BRCM)
-	if ((*pskb)->dev->br_port && (*pskb)->pkt_type != PACKET_LOOPBACK) {
-            if ((*pskb)->protocol == __constant_htons(ETH_P_PPP_SES)||
-                (*pskb)->protocol == __constant_htons(ETH_P_PPP_DISC)) {
-                    if (!memcmp(eth_hdr(*pskb)->h_dest,(*pskb)->dev->dev_addr,ETH_ALEN))
-                        goto skipbridge;
-            }
-#if defined (CONFIG_BCM_ATM_BONDING_ETH) || defined(CONFIG_BCM_ATM_BONDING_ETH_MODULE)
-				if ((ntohs((*pskb)->protocol) & 0xFFF0) == 0x0830)
-				{
-					goto skipbridge;
-				}
-#endif
 	struct net_bridge_port *port;
 
 	if ((*pskb)->pkt_type == PACKET_LOOPBACK ||
@@ -1720,24 +1626,6 @@
 	} 
 	
 	return br_handle_frame_hook(port, pskb);
-	}
-skipbridge:
-return 0;
-#else
-	struct net_bridge_port *port;
-
-	if ((*pskb)->pkt_type == PACKET_LOOPBACK ||
-	    (port = rcu_dereference((*pskb)->dev->br_port)) == NULL)
-		return 0;
-
-	if (*pt_prev) {
-		*ret = deliver_skb(*pskb, *pt_prev, orig_dev);
-		*pt_prev = NULL;
-	} 
-	
-	return br_handle_frame_hook(port, pskb);
-#endif
-#endif
 }
 #else
 #define handle_bridge(skb, pt_prev, ret, orig_dev)	(0)
@@ -1788,13 +1676,6 @@
 	int ret = NET_RX_DROP;
 	unsigned short type;
 
-#if defined (CONFIG_RING) || defined(CONFIG_RING_MODULE)
-	if(ring_handler && ring_handler(skb, 1, 1)) {
-	  /* The packet has been copied into a ring */
-	  return(NET_RX_SUCCESS);
-	}
-#endif /* CONFIG_RING */
-
 	/* if we've gotten here through NAPI, check netpoll */
 	if (skb->dev->poll && netpoll_rx(skb))
 		return NET_RX_DROP;
@@ -2525,24 +2406,10 @@
 					   (currently unused) */
 			return -EOPNOTSUPP;
 
-#if defined(CONFIG_MIPS_BRCM)
-		case SIOCGIFTRANSSTART:
-		   ifr->ifr_ifru.ifru_ivalue = dev->trans_start;
-		   return 0;
-#endif
-
 		case SIOCGIFMTU:	/* Get the MTU of a device */
 			ifr->ifr_mtu = dev->mtu;
 			return 0;
 
-#if defined(CONFIG_MIPS_BRCM)
-		case SIOCCIFSTATS:	/* Clean up the Stats of a device */
-			{
-			struct net_device_stats * pStats = dev->get_stats(dev);
-			memset(pStats, 0, sizeof(struct net_device_stats));
-			}
-			return 0;
-#endif
 		case SIOCSIFMTU:	/* Set the MTU of a device */
 			return dev_set_mtu(dev, ifr->ifr_mtu);
 
@@ -2718,9 +2585,6 @@
 		case SIOCGIFMAP:
 		case SIOCGIFINDEX:
 		case SIOCGIFTXQLEN:
-#if defined(CONFIG_MIPS_BRCM)
-		case SIOCGIFTRANSSTART:
-#endif
 			dev_load(ifr.ifr_name);
 			read_lock(&dev_base_lock);
 			ret = dev_ifsioc(&ifr, cmd);
@@ -2820,9 +2684,6 @@
 		 */
 		default:
 			if (cmd == SIOCWANDEV ||
-#if defined(CONFIG_MIPS_BRCM)
-               cmd == SIOCCIFSTATS ||
-#endif                
 			    (cmd >= SIOCDEVPRIVATE &&
 			     cmd <= SIOCDEVPRIVATE + 15)) {
 				dev_load(ifr.ifr_name);
@@ -2936,10 +2797,6 @@
 		goto out;
 
 	dev->iflink = -1;
-//#if defined(CONFIG_MIPS_BRCM)
-//	/* Init dev->last_stats in case CONFIG_SYSFS is disabled */
-//	dev->last_stats = dev->get_stats;
-//#endif
 
 	/* Init, if this function is available */
 	if (dev->init) {
@@ -3137,13 +2994,6 @@
 			       "waiting for %s to become free. Usage "
 			       "count = %d\n",
 			       dev->name, atomic_read(&dev->refcnt));
-#if defined(CONFIG_MIPS_BRCM)
-		      /* if eth? device reference counter goes to negative, reset to 0 and get out the while loop */
-			if (atomic_read(&dev->refcnt) < 0 && strstr(dev->name, "eth")) {
-				atomic_set(&dev->refcnt, 0);		
-				printk("Reset to 0, dev->refcnt=%d.\n", atomic_read(&dev->refcnt));
-			}
-#endif
 			warning_time = jiffies;
 		}
 	}
@@ -3254,7 +3104,6 @@
 	dev = (struct net_device *)
 		(((long)p + NETDEV_ALIGN_CONST) & ~NETDEV_ALIGN_CONST);
 	dev->padded = (char *)dev - (char *)p;
-	memleak_padding(p, dev->padded, sizeof(struct net_device));
 
 	if (sizeof_priv)
 		dev->priv = netdev_priv(dev);
@@ -3295,10 +3144,7 @@
 /* Synchronize with packet receive processing. */
 void synchronize_net(void) 
 {
-printk(KERN_INFO "might sleep\n");
-
 	might_sleep();
-printk(KERN_INFO "sychronize rcu\n");
 	synchronize_rcu();
 }
 
