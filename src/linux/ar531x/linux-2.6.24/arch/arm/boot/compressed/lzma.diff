Index: LzmaDecode.c
===================================================================
--- LzmaDecode.c	(revision 8777)
+++ LzmaDecode.c	(working copy)
@@ -1,8 +1,8 @@
 /*
-  LzmaDecode.c
-  LZMA Decoder (optimized for Speed version)
+  LzmaDecodeSize.c
+  LZMA Decoder (optimized for Size version)
   
-  LZMA SDK 4.22 Copyright (c) 1999-2005 Igor Pavlov (2005-06-10)
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
   http://www.7-zip.org/
 
   LZMA SDK is licensed under two licenses:
@@ -12,19 +12,15 @@
   follow rules of that license.
 
   SPECIAL EXCEPTION:
-  Igor Pavlov, as the author of this Code, expressly permits you to 
-  statically or dynamically link your Code (or bind by name) to the 
-  interfaces of this file without subjecting your linked Code to the 
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
   terms of the CPL or GNU LGPL. Any modifications or additions 
   to this file, however, are subject to the LGPL or CPL terms.
 */
 
 #include "LzmaDecode.h"
 
-#ifndef Byte
-#define Byte unsigned char
-#endif
-
 #define kNumTopBits 24
 #define kTopValue ((UInt32)1 << kNumTopBits)
 
@@ -32,45 +28,240 @@
 #define kBitModelTotal (1 << kNumBitModelTotalBits)
 #define kNumMoveBits 5
 
-#define RC_READ_BYTE (*Buffer++)
+typedef struct _CRangeDecoder
+{
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+  #ifdef _LZMA_IN_CB
+  ILzmaInCallback *InCallback;
+  int Result;
+  #endif
+  int ExtraBytes;
+} CRangeDecoder;
 
-#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
-  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+Byte RangeDecoderReadByte(CRangeDecoder *rd)
+{
+  if (rd->Buffer == rd->BufferLim)
+  {
+    #ifdef _LZMA_IN_CB
+    SizeT size;
+    rd->Result = rd->InCallback->Read(rd->InCallback, &rd->Buffer, &size);
+    rd->BufferLim = rd->Buffer + size;
+    if (size == 0)
+    #endif
+    {
+      rd->ExtraBytes = 1;
+      return 0xFF;
+    }
+  }
+  return (*rd->Buffer++);
+}
 
-#ifdef _LZMA_IN_CB
+/* #define ReadByte (*rd->Buffer++) */
+#define ReadByte (RangeDecoderReadByte(rd))
 
-#define RC_TEST { if (Buffer == BufferLim) \
-  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) return result; \
-  BufferLim = Buffer + size; if (size == 0) return LZMA_RESULT_DATA_ERROR; }}
+void RangeDecoderInit(CRangeDecoder *rd
+  #ifndef _LZMA_IN_CB
+    , const Byte *stream, SizeT bufferSize
+  #endif
+    )
+{
+  int i;
+  #ifdef _LZMA_IN_CB
+  rd->Buffer = rd->BufferLim = 0;
+  #else
+  rd->Buffer = stream;
+  rd->BufferLim = stream + bufferSize;
+  #endif
+  rd->ExtraBytes = 0;
+  rd->Code = 0;
+  rd->Range = (0xFFFFFFFF);
+  for(i = 0; i < 5; i++)
+    rd->Code = (rd->Code << 8) | ReadByte;
+}
 
-#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+#define RC_INIT_VAR UInt32 range = rd->Range; UInt32 code = rd->Code;        
+#define RC_FLUSH_VAR rd->Range = range; rd->Code = code;
+#define RC_NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | ReadByte; }
 
-#else
+UInt32 RangeDecoderDecodeDirectBits(CRangeDecoder *rd, int numTotalBits)
+{
+  RC_INIT_VAR
+  UInt32 result = 0;
+  int i;
+  for (i = numTotalBits; i != 0; i--)
+  {
+    /* UInt32 t; */
+    range >>= 1;
 
-#define RC_TEST { if (Buffer == BufferLim) return LZMA_RESULT_DATA_ERROR; }
+    result <<= 1;
+    if (code >= range)
+    {
+      code -= range;
+      result |= 1;
+    }
+    /*
+    t = (code - range) >> 31;
+    t &= 1;
+    code -= range & (t - 1);
+    result = (result + result) | (1 - t);
+    */
+    RC_NORMALIZE
+  }
+  RC_FLUSH_VAR
+  return result;
+}
 
-#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
- 
-#endif
+int RangeDecoderBitDecode(CProb *prob, CRangeDecoder *rd)
+{
+  UInt32 bound = (rd->Range >> kNumBitModelTotalBits) * *prob;
+  if (rd->Code < bound)
+  {
+    rd->Range = bound;
+    *prob += (kBitModelTotal - *prob) >> kNumMoveBits;
+    if (rd->Range < kTopValue)
+    {
+      rd->Code = (rd->Code << 8) | ReadByte;
+      rd->Range <<= 8;
+    }
+    return 0;
+  }
+  else
+  {
+    rd->Range -= bound;
+    rd->Code -= bound;
+    *prob -= (*prob) >> kNumMoveBits;
+    if (rd->Range < kTopValue)
+    {
+      rd->Code = (rd->Code << 8) | ReadByte;
+      rd->Range <<= 8;
+    }
+    return 1;
+  }
+}
 
-#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+#define RC_GET_BIT2(prob, mi, A0, A1) \
+  UInt32 bound = (range >> kNumBitModelTotalBits) * *prob; \
+  if (code < bound) \
+    { A0; range = bound; *prob += (kBitModelTotal - *prob) >> kNumMoveBits; mi <<= 1; } \
+  else \
+    { A1; range -= bound; code -= bound; *prob -= (*prob) >> kNumMoveBits; mi = (mi + mi) + 1; } \
+  RC_NORMALIZE
 
-#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
-#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
-#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+#define RC_GET_BIT(prob, mi) RC_GET_BIT2(prob, mi, ; , ;)               
 
-#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
-  { UpdateBit0(p); mi <<= 1; A0; } else \
-  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
-  
-#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+int RangeDecoderBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
+{
+  int mi = 1;
+  int i;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  for(i = numLevels; i != 0; i--)
+  {
+    #ifdef _LZMA_LOC_OPT
+    CProb *prob = probs + mi;
+    RC_GET_BIT(prob, mi)
+    #else
+    mi = (mi + mi) + RangeDecoderBitDecode(probs + mi, rd);
+    #endif
+  }
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return mi - (1 << numLevels);
+}
 
-#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
-  { int i = numLevels; res = 1; \
-  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
-  res -= (1 << numLevels); }
+int RangeDecoderReverseBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
+{
+  int mi = 1;
+  int i;
+  int symbol = 0;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  for(i = 0; i < numLevels; i++)
+  {
+    #ifdef _LZMA_LOC_OPT
+    CProb *prob = probs + mi;
+    RC_GET_BIT2(prob, mi, ; , symbol |= (1 << i))
+    #else
+    int bit = RangeDecoderBitDecode(probs + mi, rd);
+    mi = mi + mi + bit;
+    symbol |= (bit << i);
+    #endif
+  }
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return symbol;
+}
 
+Byte LzmaLiteralDecode(CProb *probs, CRangeDecoder *rd)
+{ 
+  int symbol = 1;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  do
+  {
+    #ifdef _LZMA_LOC_OPT
+    CProb *prob = probs + symbol;
+    RC_GET_BIT(prob, symbol)
+    #else
+    symbol = (symbol + symbol) | RangeDecoderBitDecode(probs + symbol, rd);
+    #endif
+  }
+  while (symbol < 0x100);
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return symbol;
+}
 
+Byte LzmaLiteralDecodeMatch(CProb *probs, CRangeDecoder *rd, Byte matchByte)
+{ 
+  int symbol = 1;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  do
+  {
+    int bit;
+    int matchBit = (matchByte >> 7) & 1;
+    matchByte <<= 1;
+    #ifdef _LZMA_LOC_OPT
+    {
+      CProb *prob = probs + 0x100 + (matchBit << 8) + symbol;
+      RC_GET_BIT2(prob, symbol, bit = 0, bit = 1)
+    }
+    #else
+    bit = RangeDecoderBitDecode(probs + 0x100 + (matchBit << 8) + symbol, rd);
+    symbol = (symbol << 1) | bit;
+    #endif
+    if (matchBit != bit)
+    {
+      while (symbol < 0x100)
+      {
+        #ifdef _LZMA_LOC_OPT
+        CProb *prob = probs + symbol;
+        RC_GET_BIT(prob, symbol)
+        #else
+        symbol = (symbol + symbol) | RangeDecoderBitDecode(probs + symbol, rd);
+        #endif
+      }
+      break;
+    }
+  }
+  while (symbol < 0x100);
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return symbol;
+}
+
 #define kNumPosBitsMax 4
 #define kNumPosStatesMax (1 << kNumPosBitsMax)
 
@@ -88,6 +279,17 @@
 #define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
 #define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
 
+int LzmaLenDecode(CProb *p, CRangeDecoder *rd, int posState)
+{
+  if(RangeDecoderBitDecode(p + LenChoice, rd) == 0)
+    return RangeDecoderBitTreeDecode(p + LenLow +
+        (posState << kLenNumLowBits), kLenNumLowBits, rd);
+  if(RangeDecoderBitDecode(p + LenChoice2, rd) == 0)
+    return kLenNumLowSymbols + RangeDecoderBitTreeDecode(p + LenMid +
+        (posState << kLenNumMidBits), kLenNumMidBits, rd);
+  return kLenNumLowSymbols + kLenNumMidSymbols + 
+      RangeDecoderBitTreeDecode(p + LenHigh, kLenNumHighBits, rd);
+}
 
 #define kNumStates 12
 #define kNumLitStates 7
@@ -121,7 +323,6 @@
 StopCompilingDueBUG
 #endif
 
-#if 0
 int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
 {
   unsigned char prop0;
@@ -154,7 +355,6 @@
   #endif
   return LZMA_RESULT_OK;
 }
-#endif
 
 #define kLzmaStreamWasFinishedId (-1)
 
@@ -172,18 +372,10 @@
   UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
   UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
   int lc = vs->Properties.lc;
+  CRangeDecoder rd;
 
   #ifdef _LZMA_OUT_READ
   
-  UInt32 Range = vs->Range;
-  UInt32 Code = vs->Code;
-  #ifdef _LZMA_IN_CB
-  const Byte *Buffer = vs->Buffer;
-  const Byte *BufferLim = vs->BufferLim;
-  #else
-  const Byte *Buffer = inStream;
-  const Byte *BufferLim = inStream + inSize;
-  #endif
   int state = vs->State;
   UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
   int len = vs->RemainLen;
@@ -196,6 +388,17 @@
 
   Byte tempDictionary[4];
 
+  rd.Range = vs->Range;
+  rd.Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  rd.InCallback = InCallback;
+  rd.Buffer = vs->Buffer;
+  rd.BufferLim = vs->BufferLim;
+  #else
+  rd.Buffer = inStream;
+  rd.BufferLim = inStream + inSize;
+  #endif
+
   #ifndef _LZMA_IN_CB
   *inSizeProcessed = 0;
   #endif
@@ -223,11 +426,17 @@
       distanceLimit = 0;
       dictionaryPos = 0;
       dictionary[dictionarySize - 1] = 0;
+      RangeDecoderInit(&rd
+          #ifndef _LZMA_IN_CB
+          , inStream, inSize
+          #endif
+          );
       #ifdef _LZMA_IN_CB
-      RC_INIT;
-      #else
-      RC_INIT(inStream, inSize);
+      if (rd.Result != LZMA_RESULT_OK)
+        return rd.Result;
       #endif
+      if (rd.ExtraBytes != 0)
+        return LZMA_RESULT_DATA_ERROR;
     }
     len = 0;
   }
@@ -246,15 +455,16 @@
   else
     previousByte = dictionary[dictionaryPos - 1];
 
+  #ifdef _LZMA_IN_CB
+  rd.Result = LZMA_RESULT_OK;
+  #endif
+  rd.ExtraBytes = 0;
+
   #else /* if !_LZMA_OUT_READ */
 
   int state = 0;
   UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
   int len = 0;
-  const Byte *Buffer;
-  const Byte *BufferLim;
-  UInt32 Range;
-  UInt32 Code;
 
   #ifndef _LZMA_IN_CB
   *inSizeProcessed = 0;
@@ -269,17 +479,26 @@
   }
   
   #ifdef _LZMA_IN_CB
-  RC_INIT;
-  #else
-  RC_INIT(inStream, inSize);
+  rd.InCallback = InCallback;
   #endif
+  RangeDecoderInit(&rd
+      #ifndef _LZMA_IN_CB
+      , inStream, inSize
+      #endif
+      );
 
+  #ifdef _LZMA_IN_CB
+  if (rd.Result != LZMA_RESULT_OK)
+    return rd.Result;
+  #endif
+  if (rd.ExtraBytes != 0)
+    return LZMA_RESULT_DATA_ERROR;
+
   #endif /* _LZMA_OUT_READ */
 
+
   while(nowPos < outSize)
   {
-    CProb *prob;
-    UInt32 bound;
     int posState = (int)(
         (nowPos 
         #ifdef _LZMA_OUT_READ
@@ -287,13 +506,15 @@
         #endif
         )
         & posStateMask);
-
-    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
-    IfBit0(prob)
+    #ifdef _LZMA_IN_CB
+    if (rd.Result != LZMA_RESULT_OK)
+      return rd.Result;
+    #endif
+    if (rd.ExtraBytes != 0)
+      return LZMA_RESULT_DATA_ERROR;
+    if (RangeDecoderBitDecode(p + IsMatch + (state << kNumPosBitsMax) + posState, &rd) == 0)
     {
-      int symbol = 1;
-      UpdateBit0(prob)
-      prob = p + Literal + (LZMA_LIT_SIZE * 
+      CProb *probs = p + Literal + (LZMA_LIT_SIZE * 
         (((
         (nowPos 
         #ifdef _LZMA_OUT_READ
@@ -304,7 +525,7 @@
 
       if (state >= kNumLitStates)
       {
-        int matchByte;
+        Byte matchByte;
         #ifdef _LZMA_OUT_READ
         UInt32 pos = dictionaryPos - rep0;
         if (pos >= dictionarySize)
@@ -313,24 +534,10 @@
         #else
         matchByte = outStream[nowPos - rep0];
         #endif
-        do
-        {
-          int bit;
-          CProb *probLit;
-          matchByte <<= 1;
-          bit = (matchByte & 0x100);
-          probLit = prob + 0x100 + bit + symbol;
-          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
-        }
-        while (symbol < 0x100);
+        previousByte = LzmaLiteralDecodeMatch(probs, &rd, matchByte);
       }
-      while (symbol < 0x100)
-      {
-        CProb *probLit = prob + symbol;
-        RC_GET_BIT(probLit, symbol)
-      }
-      previousByte = (Byte)symbol;
-
+      else
+        previousByte = LzmaLiteralDecode(probs, &rd);
       outStream[nowPos++] = previousByte;
       #ifdef _LZMA_OUT_READ
       if (distanceLimit < dictionarySize)
@@ -346,40 +553,24 @@
     }
     else             
     {
-      UpdateBit1(prob);
-      prob = p + IsRep + state;
-      IfBit0(prob)
+      if (RangeDecoderBitDecode(p + IsRep + state, &rd) == 1)
       {
-        UpdateBit0(prob);
-        rep3 = rep2;
-        rep2 = rep1;
-        rep1 = rep0;
-        state = state < kNumLitStates ? 0 : 3;
-        prob = p + LenCoder;
-      }
-      else
-      {
-        UpdateBit1(prob);
-        prob = p + IsRepG0 + state;
-        IfBit0(prob)
+        if (RangeDecoderBitDecode(p + IsRepG0 + state, &rd) == 0)
         {
-          UpdateBit0(prob);
-          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
-          IfBit0(prob)
+          if (RangeDecoderBitDecode(p + IsRep0Long + (state << kNumPosBitsMax) + posState, &rd) == 0)
           {
             #ifdef _LZMA_OUT_READ
             UInt32 pos;
             #endif
-            UpdateBit0(prob);
-            
+      
             #ifdef _LZMA_OUT_READ
             if (distanceLimit == 0)
             #else
             if (nowPos == 0)
             #endif
               return LZMA_RESULT_DATA_ERROR;
-            
-            state = state < kNumLitStates ? 9 : 11;
+
+            state = state < 7 ? 9 : 11;
             #ifdef _LZMA_OUT_READ
             pos = dictionaryPos - rep0;
             if (pos >= dictionarySize)
@@ -392,40 +583,25 @@
             previousByte = outStream[nowPos - rep0];
             #endif
             outStream[nowPos++] = previousByte;
+
             #ifdef _LZMA_OUT_READ
             if (distanceLimit < dictionarySize)
               distanceLimit++;
             #endif
-
             continue;
           }
-          else
-          {
-            UpdateBit1(prob);
-          }
         }
         else
         {
           UInt32 distance;
-          UpdateBit1(prob);
-          prob = p + IsRepG1 + state;
-          IfBit0(prob)
-          {
-            UpdateBit0(prob);
+          if(RangeDecoderBitDecode(p + IsRepG1 + state, &rd) == 0)
             distance = rep1;
-          }
           else 
           {
-            UpdateBit1(prob);
-            prob = p + IsRepG2 + state;
-            IfBit0(prob)
-            {
-              UpdateBit0(prob);
+            if(RangeDecoderBitDecode(p + IsRepG2 + state, &rd) == 0)
               distance = rep2;
-            }
             else
             {
-              UpdateBit1(prob);
               distance = rep3;
               rep3 = rep2;
             }
@@ -434,89 +610,35 @@
           rep1 = rep0;
           rep0 = distance;
         }
-        state = state < kNumLitStates ? 8 : 11;
-        prob = p + RepLenCoder;
+        len = LzmaLenDecode(p + RepLenCoder, &rd, posState);
+        state = state < 7 ? 8 : 11;
       }
+      else
       {
-        int numBits, offset;
-        CProb *probLen = prob + LenChoice;
-        IfBit0(probLen)
-        {
-          UpdateBit0(probLen);
-          probLen = prob + LenLow + (posState << kLenNumLowBits);
-          offset = 0;
-          numBits = kLenNumLowBits;
-        }
-        else
-        {
-          UpdateBit1(probLen);
-          probLen = prob + LenChoice2;
-          IfBit0(probLen)
-          {
-            UpdateBit0(probLen);
-            probLen = prob + LenMid + (posState << kLenNumMidBits);
-            offset = kLenNumLowSymbols;
-            numBits = kLenNumMidBits;
-          }
-          else
-          {
-            UpdateBit1(probLen);
-            probLen = prob + LenHigh;
-            offset = kLenNumLowSymbols + kLenNumMidSymbols;
-            numBits = kLenNumHighBits;
-          }
-        }
-        RangeDecoderBitTreeDecode(probLen, numBits, len);
-        len += offset;
-      }
-
-      if (state < 4)
-      {
         int posSlot;
-        state += kNumLitStates;
-        prob = p + PosSlot +
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < 7 ? 7 : 10;
+        len = LzmaLenDecode(p + LenCoder, &rd, posState);
+        posSlot = RangeDecoderBitTreeDecode(p + PosSlot +
             ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
-            kNumPosSlotBits);
-        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+            kNumPosSlotBits), kNumPosSlotBits, &rd);
         if (posSlot >= kStartPosModelIndex)
         {
           int numDirectBits = ((posSlot >> 1) - 1);
-          rep0 = (2 | ((UInt32)posSlot & 1));
+          rep0 = ((2 | ((UInt32)posSlot & 1)) << numDirectBits);
           if (posSlot < kEndPosModelIndex)
           {
-            rep0 <<= numDirectBits;
-            prob = p + SpecPos + rep0 - posSlot - 1;
+            rep0 += RangeDecoderReverseBitTreeDecode(
+                p + SpecPos + rep0 - posSlot - 1, numDirectBits, &rd);
           }
           else
           {
-            numDirectBits -= kNumAlignBits;
-            do
-            {
-              RC_NORMALIZE
-              Range >>= 1;
-              rep0 <<= 1;
-              if (Code >= Range)
-              {
-                Code -= Range;
-                rep0 |= 1;
-              }
-            }
-            while (--numDirectBits != 0);
-            prob = p + Align;
-            rep0 <<= kNumAlignBits;
-            numDirectBits = kNumAlignBits;
+            rep0 += RangeDecoderDecodeDirectBits(&rd, 
+                numDirectBits - kNumAlignBits) << kNumAlignBits;
+            rep0 += RangeDecoderReverseBitTreeDecode(p + Align, kNumAlignBits, &rd);
           }
-          {
-            int i = 1;
-            int mi = 1;
-            do
-            {
-              CProb *prob3 = prob + mi;
-              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
-              i <<= 1;
-            }
-            while(--numDirectBits != 0);
-          }
         }
         else
           rep0 = posSlot;
@@ -562,11 +684,11 @@
       while(len != 0 && nowPos < outSize);
     }
   }
-  RC_NORMALIZE;
 
+
   #ifdef _LZMA_OUT_READ
-  vs->Range = Range;
-  vs->Code = Code;
+  vs->Range = rd.Range;
+  vs->Code = rd.Code;
   vs->DictionaryPos = dictionaryPos;
   vs->GlobalPos = globalPos + (UInt32)nowPos;
   vs->DistanceLimit = distanceLimit;
@@ -580,10 +702,10 @@
   #endif
 
   #ifdef _LZMA_IN_CB
-  vs->Buffer = Buffer;
-  vs->BufferLim = BufferLim;
+  vs->Buffer = rd.Buffer;
+  vs->BufferLim = rd.BufferLim;
   #else
-  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  *inSizeProcessed = (SizeT)(rd.Buffer - inStream);
   #endif
   *outSizeProcessed = nowPos;
   return LZMA_RESULT_OK;
Index: LzmaDecode.h
===================================================================
--- LzmaDecode.h	(revision 8777)
+++ LzmaDecode.h	(working copy)
@@ -2,7 +2,7 @@
   LzmaDecode.h
   LZMA Decoder interface
 
-  LZMA SDK 4.21 Copyright (c) 1999-2005 Igor Pavlov (2005-06-08)
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
   http://www.7-zip.org/
 
   LZMA SDK is licensed under two licenses:
@@ -22,6 +22,8 @@
 #ifndef __LZMADECODE_H
 #define __LZMADECODE_H
 
+#include "LzmaTypes.h"
+
 /* #define _LZMA_IN_CB */
 /* Use callback for input data */
 
@@ -35,30 +37,10 @@
 /* #define _LZMA_LOC_OPT */
 /* Enable local speed optimizations inside code */
 
-/* #define _LZMA_SYSTEM_SIZE_T */
-/* Use system's size_t. You can use it to enable 64-bit sizes supporting*/
-
-#ifndef UInt32
-#ifdef _LZMA_UINT32_IS_ULONG
-#define UInt32 unsigned long
-#else
-#define UInt32 unsigned int
-#endif
-#endif
-
-#ifndef SizeT
-#ifdef _LZMA_SYSTEM_SIZE_T
-#include <stddef.h>
-#define SizeT size_t
-#else
-#define SizeT UInt32
-#endif
-#endif
-
 #ifdef _LZMA_PROB32
 #define CProb UInt32
 #else
-#define CProb unsigned short
+#define CProb UInt16
 #endif
 
 #define LZMA_RESULT_OK 0
