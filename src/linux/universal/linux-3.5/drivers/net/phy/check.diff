Index: ar8216.c
===================================================================
--- ar8216.c	(revision 19532)
+++ ar8216.c	(working copy)
@@ -43,6 +43,13 @@
 
 #define AR8XXX_CAP_GIGE		BIT(0)
 
+enum {
+	AR8XXX_VER_AR8216 = 0x01,
+	AR8XXX_VER_AR8236 = 0x03,
+	AR8XXX_VER_AR8316 = 0x10,
+	AR8XXX_VER_AR8327 = 0x12,
+};
+
 struct ar8xxx_chip {
 	unsigned long caps;
 
@@ -65,7 +72,8 @@
 	const struct net_device_ops *ndo_old;
 	struct net_device_ops ndo;
 	struct mutex reg_mutex;
-	int chip_type;
+	u8 chip_ver;
+	u8 chip_rev;
 	const struct ar8xxx_chip *chip;
 	bool initialized;
 	bool port4_phy;
@@ -89,6 +97,26 @@
 	return priv->chip->caps & AR8XXX_CAP_GIGE;
 }
 
+static inline bool chip_is_ar8216(struct ar8216_priv *priv)
+{
+	return priv->chip_ver == AR8XXX_VER_AR8216;
+}
+
+static inline bool chip_is_ar8236(struct ar8216_priv *priv)
+{
+	return priv->chip_ver == AR8XXX_VER_AR8236;
+}
+
+static inline bool chip_is_ar8316(struct ar8216_priv *priv)
+{
+	return priv->chip_ver == AR8XXX_VER_AR8316;
+}
+
+static inline bool chip_is_ar8327(struct ar8216_priv *priv)
+{
+	return priv->chip_ver == AR8XXX_VER_AR8327;
+}
+
 static inline void
 split_addr(u32 regaddr, u16 *r1, u16 *r2, u16 *page)
 {
@@ -163,6 +191,17 @@
 	mutex_unlock(&bus->mdio_lock);
 }
 
+static void
+ar8216_phy_mmd_write(struct ar8216_priv *priv, int phy_addr, u16 addr, u16 data)
+{
+	struct mii_bus *bus = priv->phy->bus;
+
+	mutex_lock(&bus->mdio_lock);
+	bus->write(bus, phy_addr, MII_ATH_MMD_ADDR, addr);
+	bus->write(bus, phy_addr, MII_ATH_MMD_DATA, data);
+	mutex_unlock(&bus->mdio_lock);
+}
+
 static u32
 ar8216_rmw(struct ar8216_priv *priv, int reg, u32 mask, u32 val)
 {
@@ -362,7 +401,7 @@
 {
 	u32 header;
 
-	if (priv->vlan && port == AR8216_PORT_CPU && priv->chip_type == AR8216)
+	if (chip_is_ar8216(priv) && priv->vlan && port == AR8216_PORT_CPU)
 		header = AR8216_PORT_CTRL_HEADER;
 	else
 		header = 0;
@@ -416,8 +455,8 @@
                                 AR8216_PORT_SPEED_1000M : AR8216_PORT_SPEED_100M) |
 			AR8216_PORT_STATUS_TXMAC |
 			AR8216_PORT_STATUS_RXMAC |
-			((priv->chip_type == AR8316) ? AR8216_PORT_STATUS_RXFLOW : 0) |
-			((priv->chip_type == AR8316) ? AR8216_PORT_STATUS_TXFLOW : 0) |
+			(chip_is_ar8316(priv) ? AR8216_PORT_STATUS_RXFLOW : 0) |
+			(chip_is_ar8316(priv) ? AR8216_PORT_STATUS_TXFLOW : 0) |
 			AR8216_PORT_STATUS_DUPLEX);
 	} else {
 		priv->write(priv, AR8216_REG_PORT_STATUS(port),
@@ -664,10 +703,39 @@
 	return t;
 }
 
+static void
+ar8327_phy_fixup(struct ar8216_priv *priv, int phy)
+{
+	switch (priv->chip_rev) {
+	case 1:
+		/* For 100M waveform */
+		ar8216_phy_dbg_write(priv, phy, 0, 0x02ea);
+		/* Turn on Gigabit clock */
+		ar8216_phy_dbg_write(priv, phy, 0x3d, 0x68a0);
+		break;
+
+	case 2:
+		ar8216_phy_mmd_write(priv, phy, 0x7, 0x3c);
+		ar8216_phy_mmd_write(priv, phy, 0x4007, 0x0);
+		/* fallthrough */
+	case 4:
+		ar8216_phy_mmd_write(priv, phy, 0x3, 0x800d);
+		ar8216_phy_mmd_write(priv, phy, 0x4003, 0x803f);
+
+		ar8216_phy_dbg_write(priv, phy, 0x3d, 0x6860);
+		ar8216_phy_dbg_write(priv, phy, 0x5, 0x2c46);
+		ar8216_phy_dbg_write(priv, phy, 0x3c, 0x6000);
+		break;
+	}
+}
+
 static int
 ar8327_hw_init(struct ar8216_priv *priv)
 {
 	struct ar8327_platform_data *pdata;
+	struct ar8327_led_cfg *led_cfg;
+	struct mii_bus *bus;
+	u32 pos, new_pos;
 	u32 t;
 	int i;
 
@@ -682,17 +750,41 @@
 	t = ar8327_get_pad_cfg(pdata->pad6_cfg);
 	priv->write(priv, AR8327_REG_PAD6_MODE, t);
 
-	priv->write(priv, AR8327_REG_POWER_ON_STRIP, 0x40000000);
+	pos = priv->read(priv, AR8327_REG_POWER_ON_STRIP);
+	new_pos = pos;
 
-	/* fixup PHYs */
+	led_cfg = pdata->led_cfg;
+	if (led_cfg) {
+		if (led_cfg->open_drain)
+			new_pos |= AR8327_POWER_ON_STRIP_LED_OPEN_EN;
+		else
+			new_pos &= ~AR8327_POWER_ON_STRIP_LED_OPEN_EN;
+
+		priv->write(priv, AR8327_REG_LED_CTRL0, led_cfg->led_ctrl0);
+		priv->write(priv, AR8327_REG_LED_CTRL1, led_cfg->led_ctrl1);
+		priv->write(priv, AR8327_REG_LED_CTRL2, led_cfg->led_ctrl2);
+		priv->write(priv, AR8327_REG_LED_CTRL3, led_cfg->led_ctrl3);
+	}
+
+	if (new_pos != pos) {
+		new_pos |= AR8327_POWER_ON_STRIP_POWER_ON_SEL;
+		priv->write(priv, AR8327_REG_POWER_ON_STRIP, new_pos);
+	}
+
+	bus = priv->phy->bus;
 	for (i = 0; i < AR8327_NUM_PHYS; i++) {
-		/* For 100M waveform */
-		ar8216_phy_dbg_write(priv, i, 0, 0x02ea);
+		ar8327_phy_fixup(priv, i);
 
-		/* Turn on Gigabit clock */
-		ar8216_phy_dbg_write(priv, i, 0x3d, 0x68a0);
+		/* start aneg on the PHY */
+		mdiobus_write(bus, i, MII_ADVERTISE, ADVERTISE_ALL |
+						     ADVERTISE_PAUSE_CAP |
+						     ADVERTISE_PAUSE_ASYM);
+		mdiobus_write(bus, i, MII_CTRL1000, ADVERTISE_1000FULL);
+		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
 	}
 
+	msleep(1000);
+
 	return 0;
 }
 
@@ -1159,8 +1251,6 @@
 	u16 id;
 	int i;
 
-	priv->chip_type = UNKNOWN;
-
 	val = ar8216_mii_read(priv, AR8216_REG_CTRL);
 	if (val == ~0)
 		return -ENODEV;
@@ -1178,30 +1268,27 @@
 			return -ENODEV;
 	}
 
-	switch (id) {
-	case 0x0101:
-		priv->chip_type = AR8216;
+	priv->chip_ver = (id & AR8216_CTRL_VERSION) >> AR8216_CTRL_VERSION_S;
+	priv->chip_rev = (id & AR8216_CTRL_REVISION);
+
+	switch (priv->chip_ver) {
+	case AR8XXX_VER_AR8216:
 		priv->chip = &ar8216_chip;
 		break;
-	case 0x0301:
-		priv->chip_type = AR8236;
+	case AR8XXX_VER_AR8236:
 		priv->chip = &ar8236_chip;
 		break;
-	case 0x1000:
-	case 0x1001:
-		priv->chip_type = AR8316;
+	case AR8XXX_VER_AR8316:
 		priv->chip = &ar8316_chip;
 		break;
-	case 0x1202:
-		priv->chip_type = AR8327;
+	case AR8XXX_VER_AR8327:
 		priv->mii_lo_first = true;
 		priv->chip = &ar8327_chip;
 		break;
 	default:
 		printk(KERN_DEBUG
 			"ar8216: Unknown Atheros device [ver=%d, rev=%d, phy_id=%04x%04x]\n",
-			(int)(id >> AR8216_CTRL_VERSION_S),
-			(int)(id & AR8216_CTRL_REVISION),
+			priv->chip_ver, priv->chip_rev,
 			mdiobus_read(priv->phy->bus, priv->phy->addr, 2),
 			mdiobus_read(priv->phy->bus, priv->phy->addr, 3));
 
@@ -1237,7 +1324,7 @@
 			pdev->advertising |= ADVERTISED_1000baseT_Full;
 		}
 
-		if (priv->chip_type == AR8316) {
+		if (chip_is_ar8316(priv)) {
 			/* check if we're attaching to the switch twice */
 			pdev = pdev->bus->phy_map[0];
 			if (!pdev) {
@@ -1267,9 +1354,6 @@
 		return 0;
 	}
 
-	printk(KERN_INFO "%s: AR%d switch driver attached.\n",
-		pdev->attached_dev->name, priv->chip_type);
-
 	if (ar8xxx_has_gige(priv))
 		pdev->supported = SUPPORTED_1000baseT_Full;
 	else
@@ -1287,7 +1371,7 @@
 	swdev->ops = &ar8216_sw_ops;
 	swdev->ports = AR8216_NUM_PORTS;
 
-	if (priv->chip_type == AR8316) {
+	if (chip_is_ar8316(priv)) {
 		swdev->name = "Atheros AR8316";
 		swdev->vlans = AR8X16_MAX_VLANS;
 
@@ -1295,11 +1379,11 @@
 			/* port 5 connected to the other mac, therefore unusable */
 			swdev->ports = (AR8216_NUM_PORTS - 1);
 		}
-	} else if (priv->chip_type == AR8236) {
+	} else if (chip_is_ar8236(priv)) {
 		swdev->name = "Atheros AR8236";
 		swdev->vlans = AR8216_NUM_VLANS;
 		swdev->ports = AR8216_NUM_PORTS;
-	} else if (priv->chip_type == AR8327) {
+	} else if (chip_is_ar8327(priv)) {
 		swdev->name = "Atheros AR8327";
 		swdev->vlans = AR8X16_MAX_VLANS;
 		swdev->ports = AR8327_NUM_PORTS;
@@ -1312,6 +1396,9 @@
 	if (ret)
 		goto err_free_priv;
 
+	printk(KERN_INFO "%s: %s switch driver attached.\n",
+		pdev->attached_dev->name, swdev->name);
+
 	priv->init = true;
 
 	ret = priv->chip->hw_init(priv);
@@ -1325,7 +1412,7 @@
 	dev->phy_ptr = priv;
 
 	/* VID fixup only needed on ar8216 */
-	if (pdev->addr == 0 && priv->chip_type == AR8216) {
+	if (chip_is_ar8216(priv) && pdev->addr == 0) {
 		dev->priv_flags |= IFF_NO_IP_ALIGN;
 		dev->eth_mangle_rx = ar8216_mangle_rx;
 		dev->eth_mangle_tx = ar8216_mangle_tx;
Index: ar8216.h
===================================================================
--- ar8216.h	(revision 19532)
+++ ar8216.h	(working copy)
@@ -25,6 +25,8 @@
 #define AR8316_NUM_VLANS	4096
 
 /* Atheros specific MII registers */
+#define MII_ATH_MMD_ADDR		0x0d
+#define MII_ATH_MMD_DATA		0x0e
 #define MII_ATH_DBG_ADDR		0x1d
 #define MII_ATH_DBG_DATA		0x1e
 
@@ -196,6 +198,8 @@
 #define   AR8327_PAD_RGMII_EN			BIT(26)
 
 #define AR8327_REG_POWER_ON_STRIP		0x010
+#define   AR8327_POWER_ON_STRIP_POWER_ON_SEL	BIT(31)
+#define   AR8327_POWER_ON_STRIP_LED_OPEN_EN	BIT(24)
 
 #define AR8327_REG_INT_STATUS0			0x020
 #define   AR8327_INT0_VT_DONE			BIT(20)
@@ -334,13 +338,4 @@
 	AR8216_PORT_STATE_FORWARD = 4
 };
 
-/* device */
-enum {
-  UNKNOWN = 0,
-  AR8216 = 8216,
-  AR8236 = 8236,
-  AR8316 = 8316,
-  AR8327 = 8327,
-};
-
 #endif
Index: check.diff
===================================================================
--- check.diff	(revision 19640)
+++ check.diff	(working copy)
@@ -1,410 +1,327 @@
-Index: mvswitch.c
+Index: ar8216.c
 ===================================================================
---- mvswitch.c	(revision 19311)
-+++ mvswitch.c	(working copy)
-@@ -1,7 +1,6 @@
- /*
-  * Marvell 88E6060 switch driver
-  * Copyright (c) 2008 Felix Fietkau <nbd@openwrt.org>
-- * Copyright (c) 2008 Sebastian Gottschall <s.gottschall@dd-wrt.com> (just 88E6061 support)
-  *
-  * This program is free software; you can redistribute  it and/or modify it
-  * under  the terms of the GNU General Public License v2 as published by the
-@@ -30,7 +29,6 @@
- #include <asm/irq.h>
- #include <asm/uaccess.h>
- #include "mvswitch.h"
--#define MVSWITCH_MAGIC 0x88E6060
+--- ar8216.c	(revision 19532)
++++ ar8216.c	(working copy)
+@@ -43,6 +43,13 @@
  
- /* Undefine this to use trailer mode instead.
-  * I don't know if header mode works with all chips */
-@@ -40,12 +38,11 @@
- MODULE_AUTHOR("Felix Fietkau");
- MODULE_LICENSE("GPL");
+ #define AR8XXX_CAP_GIGE		BIT(0)
  
-+#define MVSWITCH_MAGIC 0x88E6060
++enum {
++	AR8XXX_VER_AR8216 = 0x01,
++	AR8XXX_VER_AR8236 = 0x03,
++	AR8XXX_VER_AR8316 = 0x10,
++	AR8XXX_VER_AR8327 = 0x12,
++};
 +
- struct mvswitch_priv {
--	/* the driver's tx function */
--	const struct net_device_ops *ndo_old;
--	struct net_device_ops ndo;
--//	struct vlan_group *grp;
--	u8 vlans[2];
-+	netdev_features_t orig_features;
-+	u8 vlans[16];
- };
+ struct ar8xxx_chip {
+ 	unsigned long caps;
  
- #define to_mvsw(_phy) ((struct mvswitch_priv *) (_phy)->priv)
-@@ -63,8 +60,8 @@
+@@ -65,7 +72,8 @@
+ 	const struct net_device_ops *ndo_old;
+ 	struct net_device_ops ndo;
+ 	struct mutex reg_mutex;
+-	int chip_type;
++	u8 chip_ver;
++	u8 chip_rev;
+ 	const struct ar8xxx_chip *chip;
+ 	bool initialized;
+ 	bool port4_phy;
+@@ -89,6 +97,26 @@
+ 	return priv->chip->caps & AR8XXX_CAP_GIGE;
  }
  
++static inline bool chip_is_ar8216(struct ar8216_priv *priv)
++{
++	return priv->chip_ver == AR8XXX_VER_AR8216;
++}
++
++static inline bool chip_is_ar8236(struct ar8216_priv *priv)
++{
++	return priv->chip_ver == AR8XXX_VER_AR8236;
++}
++
++static inline bool chip_is_ar8316(struct ar8216_priv *priv)
++{
++	return priv->chip_ver == AR8XXX_VER_AR8316;
++}
++
++static inline bool chip_is_ar8327(struct ar8216_priv *priv)
++{
++	return priv->chip_ver == AR8XXX_VER_AR8327;
++}
++
+ static inline void
+ split_addr(u32 regaddr, u16 *r1, u16 *r2, u16 *page)
+ {
+@@ -163,6 +191,17 @@
+ 	mutex_unlock(&bus->mdio_lock);
+ }
  
--static int
--mvswitch_mangle_tx(struct sk_buff *skb, struct net_device *dev)
-+static struct sk_buff *
-+mvswitch_mangle_tx(struct net_device *dev, struct sk_buff *skb)
++static void
++ar8216_phy_mmd_write(struct ar8216_priv *priv, int phy_addr, u16 addr, u16 data)
++{
++	struct mii_bus *bus = priv->phy->bus;
++
++	mutex_lock(&bus->mdio_lock);
++	bus->write(bus, phy_addr, MII_ATH_MMD_ADDR, addr);
++	bus->write(bus, phy_addr, MII_ATH_MMD_DATA, data);
++	mutex_unlock(&bus->mdio_lock);
++}
++
+ static u32
+ ar8216_rmw(struct ar8216_priv *priv, int reg, u32 mask, u32 val)
  {
- 	struct mvswitch_priv *priv;
- 	char *buf = NULL;
-@@ -130,11 +127,11 @@
- 	/* append the tag */
- 	*((__be32 *) buf) = cpu_to_be32((
- 		(MV_TRAILER_OVERRIDE << MV_TRAILER_FLAGS_S) |
--		((priv->vlans[vid] & MV_TRAILER_PORTS_M) << MV_TRAILER_PORTS_S)//|(0x10<<8)
-+		((priv->vlans[vid] & MV_TRAILER_PORTS_M) << MV_TRAILER_PORTS_S)
- 	));
- #endif
+@@ -362,7 +401,7 @@
+ {
+ 	u32 header;
  
--	return priv->ndo_old->ndo_start_xmit(skb, dev);
-+	return skb;
- 
- error_expand:
- 	if (net_ratelimit())
-@@ -143,89 +140,47 @@
- error:
- 	/* any errors? drop the packet! */
- 	dev_kfree_skb_any(skb);
--	return 0;
-+	return NULL;
+-	if (priv->vlan && port == AR8216_PORT_CPU && priv->chip_type == AR8216)
++	if (chip_is_ar8216(priv) && priv->vlan && port == AR8216_PORT_CPU)
+ 		header = AR8216_PORT_CTRL_HEADER;
+ 	else
+ 		header = 0;
+@@ -416,8 +455,8 @@
+                                 AR8216_PORT_SPEED_1000M : AR8216_PORT_SPEED_100M) |
+ 			AR8216_PORT_STATUS_TXMAC |
+ 			AR8216_PORT_STATUS_RXMAC |
+-			((priv->chip_type == AR8316) ? AR8216_PORT_STATUS_RXFLOW : 0) |
+-			((priv->chip_type == AR8316) ? AR8216_PORT_STATUS_TXFLOW : 0) |
++			(chip_is_ar8316(priv) ? AR8216_PORT_STATUS_RXFLOW : 0) |
++			(chip_is_ar8316(priv) ? AR8216_PORT_STATUS_TXFLOW : 0) |
+ 			AR8216_PORT_STATUS_DUPLEX);
+ 	} else {
+ 		priv->write(priv, AR8216_REG_PORT_STATUS(port),
+@@ -664,10 +703,39 @@
+ 	return t;
  }
  
--static int
--mvswitch_mangle_rx(struct sk_buff *skb, int napi)
 +static void
-+mvswitch_mangle_rx(struct net_device *dev, struct sk_buff *skb)
++ar8327_phy_fixup(struct ar8216_priv *priv, int phy)
++{
++	switch (priv->chip_rev) {
++	case 1:
++		/* For 100M waveform */
++		ar8216_phy_dbg_write(priv, phy, 0, 0x02ea);
++		/* Turn on Gigabit clock */
++		ar8216_phy_dbg_write(priv, phy, 0x3d, 0x68a0);
++		break;
++
++	case 2:
++		ar8216_phy_mmd_write(priv, phy, 0x7, 0x3c);
++		ar8216_phy_mmd_write(priv, phy, 0x4007, 0x0);
++		/* fallthrough */
++	case 4:
++		ar8216_phy_mmd_write(priv, phy, 0x3, 0x800d);
++		ar8216_phy_mmd_write(priv, phy, 0x4003, 0x803f);
++
++		ar8216_phy_dbg_write(priv, phy, 0x3d, 0x6860);
++		ar8216_phy_dbg_write(priv, phy, 0x5, 0x2c46);
++		ar8216_phy_dbg_write(priv, phy, 0x3c, 0x6000);
++		break;
++	}
++}
++
+ static int
+ ar8327_hw_init(struct ar8216_priv *priv)
  {
- 	struct mvswitch_priv *priv;
--	struct net_device *dev;
--	int vlan = -1;
- 	unsigned char *buf;
-+	int vlan = -1;
+ 	struct ar8327_platform_data *pdata;
++	struct ar8327_led_cfg *led_cfg;
++	struct mii_bus *bus;
++	u32 pos, new_pos;
+ 	u32 t;
  	int i;
--	dev = skb->dev;
--	if (!dev)
--		goto error;
  
- 	priv = dev->phy_ptr;
--	if (!priv)
--		goto error;
-+	if (WARN_ON_ONCE(!priv))
-+		return;
+@@ -682,17 +750,41 @@
+ 	t = ar8327_get_pad_cfg(pdata->pad6_cfg);
+ 	priv->write(priv, AR8327_REG_PAD6_MODE, t);
  
--//	if (!priv->grp)
--//		goto error;
--
- #ifdef HEADER_MODE
- 	buf = skb->data;
- 	skb_pull(skb, MV_HEADER_SIZE);
- #else
- 	buf = skb->data + skb->len - MV_TRAILER_SIZE;
- 	if (buf[0] != 0x80)
--		goto error;
-+		return;
- #endif
+-	priv->write(priv, AR8327_REG_POWER_ON_STRIP, 0x40000000);
++	pos = priv->read(priv, AR8327_REG_POWER_ON_STRIP);
++	new_pos = pos;
  
- 	/* look for the vlan matching the incoming port */
- 	for (i = 0; i < ARRAY_SIZE(priv->vlans); i++) {
- 		if ((1 << buf[1]) & priv->vlans[i])
--			{
- 			vlan = i;
--			goto receive;
--			}
--			
+-	/* fixup PHYs */
++	led_cfg = pdata->led_cfg;
++	if (led_cfg) {
++		if (led_cfg->open_drain)
++			new_pos |= AR8327_POWER_ON_STRIP_LED_OPEN_EN;
++		else
++			new_pos &= ~AR8327_POWER_ON_STRIP_LED_OPEN_EN;
++
++		priv->write(priv, AR8327_REG_LED_CTRL0, led_cfg->led_ctrl0);
++		priv->write(priv, AR8327_REG_LED_CTRL1, led_cfg->led_ctrl1);
++		priv->write(priv, AR8327_REG_LED_CTRL2, led_cfg->led_ctrl2);
++		priv->write(priv, AR8327_REG_LED_CTRL3, led_cfg->led_ctrl3);
++	}
++
++	if (new_pos != pos) {
++		new_pos |= AR8327_POWER_ON_STRIP_POWER_ON_SEL;
++		priv->write(priv, AR8327_REG_POWER_ON_STRIP, new_pos);
++	}
++
++	bus = priv->phy->bus;
+ 	for (i = 0; i < AR8327_NUM_PHYS; i++) {
+-		/* For 100M waveform */
+-		ar8216_phy_dbg_write(priv, i, 0, 0x02ea);
++		ar8327_phy_fixup(priv, i);
+ 
+-		/* Turn on Gigabit clock */
+-		ar8216_phy_dbg_write(priv, i, 0x3d, 0x68a0);
++		/* start aneg on the PHY */
++		mdiobus_write(bus, i, MII_ADVERTISE, ADVERTISE_ALL |
++						     ADVERTISE_PAUSE_CAP |
++						     ADVERTISE_PAUSE_ASYM);
++		mdiobus_write(bus, i, MII_CTRL1000, ADVERTISE_1000FULL);
++		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
  	}
  
- 	if (vlan == -1)
--		goto error;
--	receive:;
--	skb->protocol = eth_type_trans(skb, skb->dev);
--	__vlan_hwaccel_put_tag(skb, vlan);
--	if (napi)
--		return netif_receive_skb(skb);
--	else
--		return netif_rx(skb);
-+		return;
- 
--error:
--	/* no vlan? eat the packet! */
--	dev_kfree_skb_any(skb);
--	return 0;
-+	__vlan_hwaccel_put_tag(skb, vlan);
++	msleep(1000);
++
+ 	return 0;
  }
  
- 
- static int
--mvswitch_netif_rx(struct sk_buff *skb)
--{
--	return mvswitch_mangle_rx(skb, 0);
--}
--
--static int
--mvswitch_netif_receive_skb(struct sk_buff *skb)
--{
--	return mvswitch_mangle_rx(skb, 1);
--}
--
--
--/*static void
--mvswitch_vlan_rx_register(struct net_device *dev, struct vlan_group *grp)
--{
--	struct mvswitch_priv *priv = dev->phy_ptr;
--	priv->grp = grp;
--}*/
--
--
--static int
- mvswitch_wait_mask(struct phy_device *pdev, int addr, int reg, u16 mask, u16 val)
- {
--	int i = 1000;
-+	int i = 100;
- 	u16 r;
- 
- 	do {
-@@ -242,9 +197,8 @@
- 	struct mvswitch_priv *priv = to_mvsw(pdev);
- 	struct net_device *dev = pdev->attached_dev;
- 	u8 vlmap = 0;
--	u16 reg;
+@@ -1159,8 +1251,6 @@
+ 	u16 id;
  	int i;
--	u16 emask;
-+
- 	if (!dev)
- 		return -EINVAL;
  
-@@ -252,17 +206,14 @@
- 	pdev->supported = ADVERTISED_100baseT_Full;
- 	pdev->advertising = ADVERTISED_100baseT_Full;
- 	dev->phy_ptr = priv;
--	dev->irq = PHY_POLL;
--	emask = MV_PORTCTRL_ENABLED;
--	reg = r16(pdev, MV_PORTREG(IDENT, 0)) & MV_IDENT_MASK;	
--	if (reg == MV_IDENT_VALUE2)
--	    {
--	    printk("%s: Marvell 88E6061 workaround enabled\n",dev->name);
--	    emask = MV_PORTCTRL_ENABLED | MV_PORTCTRL_EGRESSALL;
--	    }
-+	pdev->irq = PHY_POLL;
-+#ifdef HEADER_MODE
-+	dev->flags |= IFF_PROMISC;
-+#endif
-+
- 	/* initialize default vlans */
- 	for (i = 0; i < MV_PORTS; i++)
--		priv->vlans[(i == MV_WANPORT ? 1 : 0)] |= (1 << i);
-+		priv->vlans[(i == MV_WANPORT ? 2 : 1)] |= (1 << i);
- 
- 	/* before entering reset, disable all ports */
- 	for (i = 0; i < MV_PORTS; i++)
-@@ -278,7 +229,6 @@
- 		printk("%s: Timeout waiting for the switch to reset.\n", dev->name);
- 		return i;
- 	}
--	msleep(10); /* wait for the status change to settle in */
- 
- 	/* set the ATU flags */
- 	w16(pdev, MV_SWITCHREG(ATU_CTRL),
-@@ -295,9 +245,8 @@
- 		MV_PORTCTRL_RXTR |
- 		MV_PORTCTRL_TXTR |
- #endif
--		emask
-+		MV_PORTCTRL_ENABLED
- 	);
+-	priv->chip_type = UNKNOWN;
 -
- 	/* wait for the phy change to settle in */
- 	msleep(2);
- 	for (i = 0; i < MV_PORTS; i++) {
-@@ -330,16 +279,15 @@
- 		);
- 
- 		/* re-enable port */
--		w16(pdev, MV_PORTREG(CONTROL, i),emask);
-+		w16(pdev, MV_PORTREG(CONTROL, i),
-+			MV_PORTCTRL_ENABLED
-+		);
+ 	val = ar8216_mii_read(priv, AR8216_REG_CTRL);
+ 	if (val == ~0)
+ 		return -ENODEV;
+@@ -1178,30 +1268,27 @@
+ 			return -ENODEV;
  	}
--//	w16(pdev, MV_PORTREG(VLANMAP, MV_CPUPORT),
--//			MV_PORTVLAN_PORTS(0x1f) |
--//			MV_PORTVLAN_ID(MV_CPUPORT)
--//		);
  
- 	w16(pdev, MV_PORTREG(VLANMAP, MV_CPUPORT),
- 		MV_PORTVLAN_ID(MV_CPUPORT)
- 	);
+-	switch (id) {
+-	case 0x0101:
+-		priv->chip_type = AR8216;
++	priv->chip_ver = (id & AR8216_CTRL_VERSION) >> AR8216_CTRL_VERSION_S;
++	priv->chip_rev = (id & AR8216_CTRL_REVISION);
 +
- 	/* set the port association vector */
- 	for (i = 0; i <= MV_PORTS; i++) {
- 		w16(pdev, MV_PORTREG(ASSOC, i),
-@@ -353,17 +301,12 @@
- 		MV_SWITCHCTL_DROP
- 	);
++	switch (priv->chip_ver) {
++	case AR8XXX_VER_AR8216:
+ 		priv->chip = &ar8216_chip;
+ 		break;
+-	case 0x0301:
+-		priv->chip_type = AR8236;
++	case AR8XXX_VER_AR8236:
+ 		priv->chip = &ar8236_chip;
+ 		break;
+-	case 0x1000:
+-	case 0x1001:
+-		priv->chip_type = AR8316;
++	case AR8XXX_VER_AR8316:
+ 		priv->chip = &ar8316_chip;
+ 		break;
+-	case 0x1202:
+-		priv->chip_type = AR8327;
++	case AR8XXX_VER_AR8327:
+ 		priv->mii_lo_first = true;
+ 		priv->chip = &ar8327_chip;
+ 		break;
+ 	default:
+ 		printk(KERN_DEBUG
+ 			"ar8216: Unknown Atheros device [ver=%d, rev=%d, phy_id=%04x%04x]\n",
+-			(int)(id >> AR8216_CTRL_VERSION_S),
+-			(int)(id & AR8216_CTRL_REVISION),
++			priv->chip_ver, priv->chip_rev,
+ 			mdiobus_read(priv->phy->bus, priv->phy->addr, 2),
+ 			mdiobus_read(priv->phy->bus, priv->phy->addr, 3));
  
--	/* hook into the tx function */
--	priv->ndo_old = dev->netdev_ops;
--	memcpy(&priv->ndo, priv->ndo_old, sizeof(struct net_device_ops));
--	priv->ndo.ndo_start_xmit = mvswitch_mangle_tx;
--//	priv->ndo.ndo_vlan_rx_register = mvswitch_vlan_rx_register;
--	dev->netdev_ops = &priv->ndo;
-+	dev->eth_mangle_rx = mvswitch_mangle_rx;
-+	dev->eth_mangle_tx = mvswitch_mangle_tx;
-+	priv->orig_features = dev->features;
+@@ -1237,7 +1324,7 @@
+ 			pdev->advertising |= ADVERTISED_1000baseT_Full;
+ 		}
  
--	pdev->pkt_align = 2;
--	pdev->netif_receive_skb = mvswitch_netif_receive_skb;
--	pdev->netif_rx = mvswitch_netif_rx;
- #ifdef HEADER_MODE
-+	dev->priv_flags |= IFF_NO_IP_ALIGN;
- 	dev->features |= NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_TX;
- #else
- 	dev->features |= NETIF_F_HW_VLAN_RX;
-@@ -372,54 +315,29 @@
- 	return 0;
- }
+-		if (priv->chip_type == AR8316) {
++		if (chip_is_ar8316(priv)) {
+ 			/* check if we're attaching to the switch twice */
+ 			pdev = pdev->bus->phy_map[0];
+ 			if (!pdev) {
+@@ -1267,9 +1354,6 @@
+ 		return 0;
+ 	}
  
--#define MV_AUTONEG_DONE(mv_phy_specific_status)                   \
--    (((mv_phy_specific_status) &                                  \
--        (MV_STATUS_RESOLVED | MV_STATUS_REAL_TIME_LINK_UP)) ==    \
--        (MV_STATUS_RESOLVED | MV_STATUS_REAL_TIME_LINK_UP))
+-	printk(KERN_INFO "%s: AR%d switch driver attached.\n",
+-		pdev->attached_dev->name, priv->chip_type);
 -
- static int
- mvswitch_read_status(struct phy_device *pdev)
- {
- 	pdev->speed = SPEED_100;
- 	pdev->duplex = DUPLEX_FULL;
--	pdev->state = PHY_UP;
--	static int linkstatus[5]={0,0,0,0,0};
-+	pdev->link = 1;
+ 	if (ar8xxx_has_gige(priv))
+ 		pdev->supported = SUPPORTED_1000baseT_Full;
+ 	else
+@@ -1287,7 +1371,7 @@
+ 	swdev->ops = &ar8216_sw_ops;
+ 	swdev->ports = AR8216_NUM_PORTS;
  
--	int i;
--	for (i=0;i<MV_PORTS;i++)
--	    {
--	    int status = r16(pdev,MV_PHYPORT(i),MV_PHY_STATUS1);
--	    if (linkstatus[i])
--	    {
--	    if (!(status & MV_STATUS_REAL_TIME_LINK_UP))
--		{
--		printk(KERN_INFO "port %d, link down\n",i);
--		/* XXX ugly workaround: we can't force the switch
--		* to gracefully handle hosts moving from one port to another,
--		* so we have to regularly clear the ATU database */
-+	/* XXX ugly workaround: we can't force the switch
-+	 * to gracefully handle hosts moving from one port to another,
-+	 * so we have to regularly clear the ATU database */
+-	if (priv->chip_type == AR8316) {
++	if (chip_is_ar8316(priv)) {
+ 		swdev->name = "Atheros AR8316";
+ 		swdev->vlans = AR8X16_MAX_VLANS;
  
--		/* wait for the ATU to become available */
--		mvswitch_wait_mask(pdev, MV_SWITCHREG(ATU_OP), MV_ATUOP_INPROGRESS, 0);
-+	/* wait for the ATU to become available */
-+	mvswitch_wait_mask(pdev, MV_SWITCHREG(ATU_OP), MV_ATUOP_INPROGRESS, 0);
+@@ -1295,11 +1379,11 @@
+ 			/* port 5 connected to the other mac, therefore unusable */
+ 			swdev->ports = (AR8216_NUM_PORTS - 1);
+ 		}
+-	} else if (priv->chip_type == AR8236) {
++	} else if (chip_is_ar8236(priv)) {
+ 		swdev->name = "Atheros AR8236";
+ 		swdev->vlans = AR8216_NUM_VLANS;
+ 		swdev->ports = AR8216_NUM_PORTS;
+-	} else if (priv->chip_type == AR8327) {
++	} else if (chip_is_ar8327(priv)) {
+ 		swdev->name = "Atheros AR8327";
+ 		swdev->vlans = AR8X16_MAX_VLANS;
+ 		swdev->ports = AR8327_NUM_PORTS;
+@@ -1312,6 +1396,9 @@
+ 	if (ret)
+ 		goto err_free_priv;
  
--		/* flush the ATU */
--		w16(pdev, MV_SWITCHREG(ATU_OP),
--			MV_ATUOP_INPROGRESS |
--			MV_ATUOP_FLUSH_ALL
--		);
-+	/* flush the ATU */
-+	w16(pdev, MV_SWITCHREG(ATU_OP),
-+		MV_ATUOP_INPROGRESS |
-+		MV_ATUOP_FLUSH_ALL
-+	);
- 
--		/* wait for operation to complete */
--		mvswitch_wait_mask(pdev, MV_SWITCHREG(ATU_OP), MV_ATUOP_INPROGRESS, 0);
--		linkstatus[i]=0;
--		}
--	    }else
--	    {
--		if (MV_AUTONEG_DONE(status))
--		    {
--		    printk(KERN_INFO "port %d, link up\n",i);
--		    linkstatus[i]=1;
--		    }
--	    }
--	}    
-+	/* wait for operation to complete */
-+	mvswitch_wait_mask(pdev, MV_SWITCHREG(ATU_OP), MV_ATUOP_INPROGRESS, 0);
++	printk(KERN_INFO "%s: %s switch driver attached.\n",
++		pdev->attached_dev->name, swdev->name);
 +
- 	return 0;
- }
+ 	priv->init = true;
  
-@@ -435,43 +353,14 @@
- 	struct mvswitch_priv *priv = to_mvsw(pdev);
- 	struct net_device *dev = pdev->attached_dev;
+ 	ret = priv->chip->hw_init(priv);
+@@ -1325,7 +1412,7 @@
+ 	dev->phy_ptr = priv;
  
--	/* restore old xmit handler */
--	if (priv->ndo_old && dev)
--		dev->netdev_ops = priv->ndo_old;
- 	dev->phy_ptr = NULL;
--	dev->features &= ~NETIF_F_HW_VLAN_RX;
-+	dev->eth_mangle_rx = NULL;
-+	dev->eth_mangle_tx = NULL;
-+	dev->features = priv->orig_features;
-+	dev->priv_flags &= ~IFF_NO_IP_ALIGN;
- 	kfree(priv);
- }
+ 	/* VID fixup only needed on ar8216 */
+-	if (pdev->addr == 0 && priv->chip_type == AR8216) {
++	if (chip_is_ar8216(priv) && pdev->addr == 0) {
+ 		dev->priv_flags |= IFF_NO_IP_ALIGN;
+ 		dev->eth_mangle_rx = ar8216_mangle_rx;
+ 		dev->eth_mangle_tx = ar8216_mangle_tx;
+Index: ar8216.h
+===================================================================
+--- ar8216.h	(revision 19532)
++++ ar8216.h	(working copy)
+@@ -25,6 +25,8 @@
+ #define AR8316_NUM_VLANS	4096
  
--static bool
--mvswitch_detect(struct mii_bus *bus, int addr)
--{
--	u16 reg;
--	int i;
--	/* we attach to phy id 31 to make sure that the late probe works */
--	if (addr != 0)
--		return false;
--	/* look for the switch on the bus */
--	reg = bus->read(bus, MV_PORTREG(IDENT, 0)) & MV_IDENT_MASK;
--	if (reg != MV_IDENT_VALUE && reg != MV_IDENT_VALUE2)
--		return false;
--
--	/* 
--	 * Now that we've established that the switch actually exists, let's 
--	 * get rid of the competition :)
--	 */
--/*	for (i = 0; i < 31; i++) {
--		if (!bus->phy_map[i])
--			continue;
--
--		device_unregister(&bus->phy_map[i]->dev);
--		kfree(bus->phy_map[i]);
--		bus->phy_map[i] = NULL;
--	}*/
--
--	return true;
--}
--
- static int
- mvswitch_probe(struct phy_device *pdev)
- {
-@@ -485,16 +374,17 @@
+ /* Atheros specific MII registers */
++#define MII_ATH_MMD_ADDR		0x0d
++#define MII_ATH_MMD_DATA		0x0e
+ #define MII_ATH_DBG_ADDR		0x1d
+ #define MII_ATH_DBG_DATA		0x1e
  
- 	return 0;
- }
-+
- static int
- mvswitch_fixup(struct phy_device *dev)
- {
- 	u16 reg;
--//	printk(KERN_EMERG "fixup %d\n",dev->addr);
--	if (dev->addr != 0)
-+
-+	if (dev->addr != 0x10)
- 		return 0;
+@@ -196,6 +198,8 @@
+ #define   AR8327_PAD_RGMII_EN			BIT(26)
  
- 	reg = dev->bus->read(dev->bus, MV_PORTREG(IDENT, 0)) & MV_IDENT_MASK;
--	if (reg != MV_IDENT_VALUE && reg != MV_IDENT_VALUE2)
-+	if (reg != MV_IDENT_VALUE)
- 		return 0;
+ #define AR8327_REG_POWER_ON_STRIP		0x010
++#define   AR8327_POWER_ON_STRIP_POWER_ON_SEL	BIT(31)
++#define   AR8327_POWER_ON_STRIP_LED_OPEN_EN	BIT(24)
  
- 	dev->phy_id = MVSWITCH_MAGIC;
-@@ -503,10 +393,10 @@
+ #define AR8327_REG_INT_STATUS0			0x020
+ #define   AR8327_INT0_VT_DONE			BIT(20)
+@@ -334,13 +338,4 @@
+ 	AR8216_PORT_STATE_FORWARD = 4
+ };
  
- 
- static struct phy_driver mvswitch_driver = {
--	.name		= "Marvell 88E6060/88E6061",
--	.features	= PHY_BASIC_FEATURES,
-+	.name		= "Marvell 88E6060",
- 	.phy_id		= MVSWITCH_MAGIC,
- 	.phy_id_mask	= 0xffffffff,
-+	.features	= PHY_BASIC_FEATURES,
- 	.probe		= &mvswitch_probe,
- 	.remove		= &mvswitch_remove,
- 	.config_init	= &mvswitch_config_init,
+-/* device */
+-enum {
+-  UNKNOWN = 0,
+-  AR8216 = 8216,
+-  AR8236 = 8236,
+-  AR8316 = 8316,
+-  AR8327 = 8327,
+-};
+-
+ #endif
