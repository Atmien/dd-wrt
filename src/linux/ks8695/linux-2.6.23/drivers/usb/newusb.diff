diff -urN host/.built-in.o.cmd host.new/.built-in.o.cmd
--- host/.built-in.o.cmd	2009-04-09 20:24:04.947963208 +0200
+++ host.new/.built-in.o.cmd	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-cmd_drivers/usb/host/built-in.o :=  arm-linux-uclibc-ld -EL   -r -o drivers/usb/host/built-in.o drivers/usb/host/pci-quirks.o drivers/usb/host/ehci-hcd.o
diff -urN host/.ehci-hcd.o.cmd host.new/.ehci-hcd.o.cmd
--- host/.ehci-hcd.o.cmd	2009-04-09 20:24:04.935962818 +0200
+++ host.new/.ehci-hcd.o.cmd	1970-01-01 01:00:00.000000000 +0100
@@ -1,460 +0,0 @@
-cmd_drivers/usb/host/ehci-hcd.o := arm-linux-uclibc-gcc -Wp,-MD,drivers/usb/host/.ehci-hcd.o.d  -nostdinc -isystem /home/xfs/toolchains/toolchain-arm_gcc4.2.3/bin/../lib/gcc/arm-linux-uclibc/4.2.3/include -D__KERNEL__ -Iinclude  -include include/linux/autoconf.h -mlittle-endian -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -O2 -marm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -mabi=apcs-gnu -mno-thumb-interwork -D__LINUX_ARM_ARCH__=4 -march=armv4   -msoft-float -Uarm -fno-omit-frame-pointer -fno-optimize-sibling-calls  -fno-stack-protector -funit-at-a-time -Wdeclaration-after-statement -Wno-pointer-sign    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(ehci_hcd)"  -D"KBUILD_MODNAME=KBUILD_STR(ehci_hcd)" -c -o drivers/usb/host/ehci-hcd.o drivers/usb/host/ehci-hcd.c
-
-deps_drivers/usb/host/ehci-hcd.o := \
-  drivers/usb/host/ehci-hcd.c \
-    $(wildcard include/config/sl2312/usb.h) \
-    $(wildcard include/config/pci.h) \
-    $(wildcard include/config/arch/sl2312.h) \
-    $(wildcard include/config/usb/ehci/fsl.h) \
-    $(wildcard include/config/soc/au1200.h) \
-    $(wildcard include/config/ppc/ps3.h) \
-    $(wildcard include/config/440epx.h) \
-  include/linux/module.h \
-    $(wildcard include/config/modules.h) \
-    $(wildcard include/config/modversions.h) \
-    $(wildcard include/config/unused/symbols.h) \
-    $(wildcard include/config/generic/bug.h) \
-    $(wildcard include/config/module/unload.h) \
-    $(wildcard include/config/kallsyms.h) \
-    $(wildcard include/config/sysfs.h) \
-  include/linux/list.h \
-    $(wildcard include/config/debug/list.h) \
-  include/linux/stddef.h \
-  include/linux/compiler.h \
-    $(wildcard include/config/enable/must/check.h) \
-  include/linux/compiler-gcc4.h \
-    $(wildcard include/config/forced/inlining.h) \
-  include/linux/compiler-gcc.h \
-  include/linux/poison.h \
-  include/linux/prefetch.h \
-  include/linux/types.h \
-    $(wildcard include/config/uid16.h) \
-    $(wildcard include/config/lbd.h) \
-    $(wildcard include/config/lsf.h) \
-    $(wildcard include/config/resources/64bit.h) \
-  include/linux/posix_types.h \
-  include/asm/posix_types.h \
-  include/asm/types.h \
-  include/asm/processor.h \
-    $(wildcard include/config/mmu.h) \
-  include/asm/ptrace.h \
-    $(wildcard include/config/arm/thumb.h) \
-    $(wildcard include/config/smp.h) \
-  include/asm/hwcap.h \
-  include/asm/cache.h \
-  include/asm/system.h \
-    $(wildcard include/config/cpu/cp15.h) \
-    $(wildcard include/config/cpu/xsc3.h) \
-    $(wildcard include/config/cpu/xscale.h) \
-    $(wildcard include/config/cpu/sa1100.h) \
-    $(wildcard include/config/cpu/sa110.h) \
-  include/asm/memory.h \
-    $(wildcard include/config/dram/size.h) \
-    $(wildcard include/config/dram/base.h) \
-    $(wildcard include/config/discontigmem.h) \
-  include/asm/arch/memory.h \
-  include/asm/sizes.h \
-  include/asm-generic/memory_model.h \
-    $(wildcard include/config/flatmem.h) \
-    $(wildcard include/config/sparsemem.h) \
-    $(wildcard include/config/out/of/line/pfn/to/page.h) \
-  include/linux/linkage.h \
-  include/asm/linkage.h \
-  include/linux/irqflags.h \
-    $(wildcard include/config/trace/irqflags.h) \
-    $(wildcard include/config/trace/irqflags/support.h) \
-    $(wildcard include/config/x86.h) \
-  include/asm/irqflags.h \
-  include/linux/stat.h \
-  include/asm/stat.h \
-  include/linux/time.h \
-  include/linux/cache.h \
-  include/linux/kernel.h \
-    $(wildcard include/config/preempt/voluntary.h) \
-    $(wildcard include/config/debug/spinlock/sleep.h) \
-    $(wildcard include/config/printk.h) \
-    $(wildcard include/config/noprintk.h) \
-    $(wildcard include/config/numa.h) \
-  /home/xfs/toolchains/toolchain-arm_gcc4.2.3/bin/../lib/gcc/arm-linux-uclibc/4.2.3/include/stdarg.h \
-  include/linux/bitops.h \
-  include/asm/bitops.h \
-  include/asm-generic/bitops/non-atomic.h \
-  include/asm-generic/bitops/ffz.h \
-  include/asm-generic/bitops/__ffs.h \
-  include/asm-generic/bitops/fls.h \
-  include/asm-generic/bitops/ffs.h \
-  include/asm-generic/bitops/fls64.h \
-  include/asm-generic/bitops/sched.h \
-  include/asm-generic/bitops/hweight.h \
-  include/linux/log2.h \
-    $(wildcard include/config/arch/has/ilog2/u32.h) \
-    $(wildcard include/config/arch/has/ilog2/u64.h) \
-  include/asm/byteorder.h \
-  include/linux/byteorder/little_endian.h \
-  include/linux/byteorder/swab.h \
-  include/linux/byteorder/generic.h \
-  include/asm/bug.h \
-    $(wildcard include/config/bug.h) \
-    $(wildcard include/config/debug/bugverbose.h) \
-  include/asm-generic/bug.h \
-  include/linux/seqlock.h \
-  include/linux/spinlock.h \
-    $(wildcard include/config/debug/spinlock.h) \
-    $(wildcard include/config/preempt.h) \
-    $(wildcard include/config/debug/lock/alloc.h) \
-  include/linux/preempt.h \
-    $(wildcard include/config/debug/preempt.h) \
-    $(wildcard include/config/preempt/notifiers.h) \
-  include/linux/thread_info.h \
-  include/asm/thread_info.h \
-    $(wildcard include/config/debug/stack/usage.h) \
-  include/asm/fpstate.h \
-    $(wildcard include/config/iwmmxt.h) \
-  include/asm/domain.h \
-    $(wildcard include/config/io/36.h) \
-  include/linux/stringify.h \
-  include/linux/bottom_half.h \
-  include/linux/spinlock_types.h \
-  include/linux/spinlock_types_up.h \
-  include/linux/lockdep.h \
-    $(wildcard include/config/lockdep.h) \
-    $(wildcard include/config/lock/stat.h) \
-    $(wildcard include/config/generic/hardirqs.h) \
-    $(wildcard include/config/prove/locking.h) \
-  include/linux/spinlock_up.h \
-  include/linux/spinlock_api_up.h \
-  include/asm/atomic.h \
-  include/asm-generic/atomic.h \
-  include/linux/kmod.h \
-    $(wildcard include/config/kmod.h) \
-  include/linux/errno.h \
-  include/asm/errno.h \
-  include/asm-generic/errno.h \
-  include/asm-generic/errno-base.h \
-  include/linux/elf.h \
-  include/linux/auxvec.h \
-  include/asm/auxvec.h \
-  include/linux/elf-em.h \
-  include/asm/elf.h \
-  include/asm/user.h \
-  include/asm/page.h \
-    $(wildcard include/config/cpu/copy/v3.h) \
-    $(wildcard include/config/cpu/copy/v4wt.h) \
-    $(wildcard include/config/cpu/copy/v4wb.h) \
-    $(wildcard include/config/cpu/copy/fa.h) \
-    $(wildcard include/config/cpu/copy/v6.h) \
-    $(wildcard include/config/aeabi.h) \
-  include/asm/glue.h \
-    $(wildcard include/config/cpu/arm610.h) \
-    $(wildcard include/config/cpu/arm710.h) \
-    $(wildcard include/config/cpu/abrt/lv4t.h) \
-    $(wildcard include/config/cpu/abrt/ev4.h) \
-    $(wildcard include/config/cpu/abrt/ev4t.h) \
-    $(wildcard include/config/cpu/abrt/ev5tj.h) \
-    $(wildcard include/config/cpu/abrt/ev5t.h) \
-    $(wildcard include/config/cpu/abrt/ev6.h) \
-    $(wildcard include/config/cpu/abrt/ev7.h) \
-  include/asm-generic/page.h \
-  include/linux/kobject.h \
-    $(wildcard include/config/hotplug.h) \
-  include/linux/sysfs.h \
-  include/linux/kref.h \
-  include/linux/wait.h \
-  include/asm/current.h \
-  include/linux/moduleparam.h \
-  include/linux/init.h \
-    $(wildcard include/config/hotplug/cpu.h) \
-    $(wildcard include/config/memory/hotplug.h) \
-    $(wildcard include/config/acpi/hotplug/memory.h) \
-  include/asm/local.h \
-  include/asm-generic/local.h \
-  include/linux/percpu.h \
-  include/linux/slab.h \
-    $(wildcard include/config/slab/debug.h) \
-    $(wildcard include/config/slub.h) \
-    $(wildcard include/config/slob.h) \
-    $(wildcard include/config/debug/slab.h) \
-  include/linux/gfp.h \
-    $(wildcard include/config/zone/dma.h) \
-    $(wildcard include/config/zone/dma32.h) \
-    $(wildcard include/config/highmem.h) \
-  include/linux/mmzone.h \
-    $(wildcard include/config/force/max/zoneorder.h) \
-    $(wildcard include/config/arch/populates/node/map.h) \
-    $(wildcard include/config/flat/node/mem/map.h) \
-    $(wildcard include/config/have/memory/present.h) \
-    $(wildcard include/config/need/node/memmap/size.h) \
-    $(wildcard include/config/need/multiple/nodes.h) \
-    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
-    $(wildcard include/config/sparsemem/extreme.h) \
-    $(wildcard include/config/nodes/span/other/nodes.h) \
-    $(wildcard include/config/holes/in/zone.h) \
-  include/linux/threads.h \
-    $(wildcard include/config/nr/cpus.h) \
-    $(wildcard include/config/base/small.h) \
-  include/linux/numa.h \
-    $(wildcard include/config/nodes/shift.h) \
-  include/linux/nodemask.h \
-  include/linux/bitmap.h \
-  include/linux/string.h \
-  include/asm/string.h \
-  include/linux/memory_hotplug.h \
-    $(wildcard include/config/have/arch/nodedata/extension.h) \
-  include/linux/notifier.h \
-  include/linux/mutex.h \
-    $(wildcard include/config/debug/mutexes.h) \
-  include/linux/rwsem.h \
-    $(wildcard include/config/rwsem/generic/spinlock.h) \
-  include/linux/rwsem-spinlock.h \
-  include/linux/srcu.h \
-  include/linux/topology.h \
-    $(wildcard include/config/sched/smt.h) \
-    $(wildcard include/config/sched/mc.h) \
-  include/linux/cpumask.h \
-  include/linux/smp.h \
-  include/asm/topology.h \
-  include/asm-generic/topology.h \
-  include/linux/slab_def.h \
-  include/linux/kmalloc_sizes.h \
-  include/asm/percpu.h \
-  include/asm-generic/percpu.h \
-  include/linux/hardirq.h \
-    $(wildcard include/config/preempt/bkl.h) \
-    $(wildcard include/config/virt/cpu/accounting.h) \
-  include/linux/smp_lock.h \
-    $(wildcard include/config/lock/kernel.h) \
-  include/asm/hardirq.h \
-  include/asm/irq.h \
-  include/asm/arch/irqs.h \
-    $(wildcard include/config/sl3516/asic.h) \
-  include/asm/arch/int_ctrl.h \
-  include/linux/irq_cpustat.h \
-  include/asm/module.h \
-  include/linux/pci.h \
-    $(wildcard include/config/pci/msi.h) \
-    $(wildcard include/config/ht/irq.h) \
-    $(wildcard include/config/pci/domains.h) \
-  include/linux/pci_regs.h \
-  include/linux/mod_devicetable.h \
-  include/linux/ioport.h \
-  include/linux/device.h \
-    $(wildcard include/config/debug/devres.h) \
-  include/linux/klist.h \
-  include/linux/completion.h \
-  include/linux/pm.h \
-    $(wildcard include/config/suspend.h) \
-    $(wildcard include/config/pm/sleep.h) \
-  include/asm/semaphore.h \
-  include/asm/locks.h \
-  include/asm/device.h \
-    $(wildcard include/config/dmabounce.h) \
-  include/linux/pci_ids.h \
-  include/linux/dmapool.h \
-  include/asm/io.h \
-  include/asm/arch/io.h \
-  include/asm/scatterlist.h \
-  include/asm/pci.h \
-  include/asm-generic/pci-dma-compat.h \
-  include/linux/dma-mapping.h \
-    $(wildcard include/config/has/dma.h) \
-  include/linux/err.h \
-  include/asm/dma-mapping.h \
-  include/linux/mm.h \
-    $(wildcard include/config/sysctl.h) \
-    $(wildcard include/config/stack/growsup.h) \
-    $(wildcard include/config/debug/vm.h) \
-    $(wildcard include/config/shmem.h) \
-    $(wildcard include/config/split/ptlock/cpus.h) \
-    $(wildcard include/config/ia64.h) \
-    $(wildcard include/config/proc/fs.h) \
-    $(wildcard include/config/debug/pagealloc.h) \
-  include/linux/rbtree.h \
-  include/linux/prio_tree.h \
-  include/linux/debug_locks.h \
-    $(wildcard include/config/debug/locking/api/selftests.h) \
-  include/linux/backing-dev.h \
-  include/linux/mm_types.h \
-  include/asm/pgtable.h \
-  include/asm-generic/4level-fixup.h \
-  include/asm/proc-fns.h \
-    $(wildcard include/config/cpu/32.h) \
-    $(wildcard include/config/cpu/arm7tdmi.h) \
-    $(wildcard include/config/cpu/arm720t.h) \
-    $(wildcard include/config/cpu/arm740t.h) \
-    $(wildcard include/config/cpu/arm9tdmi.h) \
-    $(wildcard include/config/cpu/arm920t.h) \
-    $(wildcard include/config/cpu/arm922t.h) \
-    $(wildcard include/config/cpu/fa526.h) \
-    $(wildcard include/config/cpu/arm925t.h) \
-    $(wildcard include/config/cpu/arm926t.h) \
-    $(wildcard include/config/cpu/arm940t.h) \
-    $(wildcard include/config/cpu/arm946e.h) \
-    $(wildcard include/config/cpu/arm1020.h) \
-    $(wildcard include/config/cpu/arm1020e.h) \
-    $(wildcard include/config/cpu/arm1022.h) \
-    $(wildcard include/config/cpu/arm1026.h) \
-    $(wildcard include/config/cpu/v6.h) \
-    $(wildcard include/config/cpu/v7.h) \
-  include/asm/cpu-single.h \
-  include/asm/arch/vmalloc.h \
-  include/asm/pgtable-hwdef.h \
-  include/asm-generic/pgtable.h \
-  include/linux/page-flags.h \
-    $(wildcard include/config/s390.h) \
-    $(wildcard include/config/swap.h) \
-  include/linux/vmstat.h \
-    $(wildcard include/config/vm/event/counters.h) \
-  include/asm/hardware.h \
-  include/asm/arch/hardware.h \
-  include/asm/arch/platform.h \
-  include/asm/arch/sl2312.h \
-    $(wildcard include/config/net/sl351x.h) \
-    $(wildcard include/config/gemini/ipi.h) \
-    $(wildcard include/config/sl2312/share/pin.h) \
-  include/linux/delay.h \
-  include/asm/delay.h \
-  include/asm/param.h \
-    $(wildcard include/config/hz.h) \
-  include/linux/sched.h \
-    $(wildcard include/config/sched/debug.h) \
-    $(wildcard include/config/no/hz.h) \
-    $(wildcard include/config/detect/softlockup.h) \
-    $(wildcard include/config/keys.h) \
-    $(wildcard include/config/bsd/process/acct.h) \
-    $(wildcard include/config/taskstats.h) \
-    $(wildcard include/config/audit.h) \
-    $(wildcard include/config/inotify/user.h) \
-    $(wildcard include/config/schedstats.h) \
-    $(wildcard include/config/task/delay/acct.h) \
-    $(wildcard include/config/fair/group/sched.h) \
-    $(wildcard include/config/blk/dev/io/trace.h) \
-    $(wildcard include/config/cc/stackprotector.h) \
-    $(wildcard include/config/sysvipc.h) \
-    $(wildcard include/config/rt/mutexes.h) \
-    $(wildcard include/config/task/xacct.h) \
-    $(wildcard include/config/cpusets.h) \
-    $(wildcard include/config/compat.h) \
-    $(wildcard include/config/fault/injection.h) \
-  include/linux/capability.h \
-  include/linux/timex.h \
-  include/asm/timex.h \
-  include/asm/arch/timex.h \
-  include/asm/arch/sl2312.h \
-  include/linux/jiffies.h \
-  include/linux/calc64.h \
-  include/asm/div64.h \
-  include/asm/mmu.h \
-    $(wildcard include/config/cpu/has/asid.h) \
-  include/asm/cputime.h \
-  include/asm-generic/cputime.h \
-  include/linux/sem.h \
-  include/linux/ipc.h \
-  include/asm/ipcbuf.h \
-  include/asm/sembuf.h \
-  include/linux/signal.h \
-  include/asm/signal.h \
-  include/asm-generic/signal.h \
-  include/asm/sigcontext.h \
-  include/asm/siginfo.h \
-  include/asm-generic/siginfo.h \
-  include/linux/securebits.h \
-  include/linux/fs_struct.h \
-  include/linux/pid.h \
-  include/linux/rcupdate.h \
-  include/linux/seccomp.h \
-    $(wildcard include/config/seccomp.h) \
-  include/linux/futex.h \
-    $(wildcard include/config/futex.h) \
-  include/linux/rtmutex.h \
-    $(wildcard include/config/debug/rt/mutexes.h) \
-  include/linux/plist.h \
-    $(wildcard include/config/debug/pi/list.h) \
-  include/linux/param.h \
-  include/linux/resource.h \
-  include/asm/resource.h \
-  include/asm-generic/resource.h \
-  include/linux/timer.h \
-    $(wildcard include/config/timer/stats.h) \
-  include/linux/ktime.h \
-    $(wildcard include/config/ktime/scalar.h) \
-  include/linux/hrtimer.h \
-    $(wildcard include/config/high/res/timers.h) \
-  include/linux/task_io_accounting.h \
-    $(wildcard include/config/task/io/accounting.h) \
-  include/linux/aio.h \
-  include/linux/workqueue.h \
-  include/linux/aio_abi.h \
-  include/linux/uio.h \
-  include/linux/interrupt.h \
-    $(wildcard include/config/generic/irq/probe.h) \
-  include/linux/irqreturn.h \
-  include/linux/reboot.h \
-  include/asm/emergency-restart.h \
-  include/asm-generic/emergency-restart.h \
-  include/linux/usb.h \
-    $(wildcard include/config/usb/devicefs.h) \
-    $(wildcard include/config/usb/mon.h) \
-    $(wildcard include/config/usb/device/class.h) \
-    $(wildcard include/config/pm.h) \
-    $(wildcard include/config/usb/suspend.h) \
-  include/linux/usb/ch9.h \
-    $(wildcard include/config/size.h) \
-    $(wildcard include/config/att/one.h) \
-    $(wildcard include/config/att/selfpower.h) \
-    $(wildcard include/config/att/wakeup.h) \
-    $(wildcard include/config/att/battery.h) \
-  include/linux/fs.h \
-    $(wildcard include/config/sl2312/tso.h) \
-    $(wildcard include/config/dnotify.h) \
-    $(wildcard include/config/quota.h) \
-    $(wildcard include/config/inotify.h) \
-    $(wildcard include/config/security.h) \
-    $(wildcard include/config/epoll.h) \
-    $(wildcard include/config/auditsyscall.h) \
-    $(wildcard include/config/block.h) \
-    $(wildcard include/config/fs/xip.h) \
-    $(wildcard include/config/migration.h) \
-  include/linux/limits.h \
-  include/linux/ioctl.h \
-  include/asm/ioctl.h \
-  include/asm-generic/ioctl.h \
-  include/linux/kdev_t.h \
-  include/linux/dcache.h \
-    $(wildcard include/config/profiling.h) \
-  include/linux/namei.h \
-  include/linux/radix-tree.h \
-  include/linux/sysctl.h \
-  include/linux/quota.h \
-  include/linux/dqblk_xfs.h \
-  include/linux/dqblk_v1.h \
-  include/linux/dqblk_v2.h \
-  include/linux/nfs_fs_i.h \
-  include/linux/nfs.h \
-  include/linux/sunrpc/msg_prot.h \
-  include/linux/fcntl.h \
-  include/asm/fcntl.h \
-  include/asm-generic/fcntl.h \
-    $(wildcard include/config/64bit.h) \
-  drivers/usb/host/../core/hcd.h \
-  drivers/usb/host/../core/hub.h \
-  include/asm/unaligned.h \
-  drivers/usb/host/ehci.h \
-    $(wildcard include/config/usb/ehci/big/endian/desc.h) \
-    $(wildcard include/config/usb/ehci/root/hub/tt.h) \
-    $(wildcard include/config/ppc/83xx.h) \
-    $(wildcard include/config/usb/ehci/big/endian/mmio.h) \
-    $(wildcard include/config/ppc.h) \
-  drivers/usb/host/ehci-dbg.c \
-  drivers/usb/host/ehci-hub.c \
-    $(wildcard include/config/usb/persist.h) \
-  drivers/usb/host/ehci-mem.c \
-  drivers/usb/host/ehci-q.c \
-  drivers/usb/host/ehci-sched.c \
-    $(wildcard include/config/usb/ehci/tt/newsched.h) \
-    $(wildcard include/config/usb/ehci/split/iso.h) \
-  drivers/usb/host/ehci-fotg2xx.c \
-  include/linux/platform_device.h \
-
-drivers/usb/host/ehci-hcd.o: $(deps_drivers/usb/host/ehci-hcd.o)
-
-$(deps_drivers/usb/host/ehci-hcd.o):
diff -urN host/.ohci-hcd.o.cmd host.new/.ohci-hcd.o.cmd
--- host/.ohci-hcd.o.cmd	2009-04-08 18:13:59.605424830 +0200
+++ host.new/.ohci-hcd.o.cmd	1970-01-01 01:00:00.000000000 +0100
@@ -1,480 +0,0 @@
-cmd_drivers/usb/host/ohci-hcd.o := arm-linux-uclibc-gcc -Wp,-MD,drivers/usb/host/.ohci-hcd.o.d  -nostdinc -isystem /home/xfs/toolchains/toolchain-arm_gcc4.2.3/bin/../lib/gcc/arm-linux-uclibc/4.2.3/include -D__KERNEL__ -Iinclude  -include include/linux/autoconf.h -mlittle-endian -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -O2 -marm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -mabi=apcs-gnu -mno-thumb-interwork -D__LINUX_ARM_ARCH__=4 -march=armv4   -msoft-float -Uarm -fno-omit-frame-pointer -fno-optimize-sibling-calls  -fno-stack-protector -funit-at-a-time -Wdeclaration-after-statement -Wno-pointer-sign    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(ohci_hcd)"  -D"KBUILD_MODNAME=KBUILD_STR(ohci_hcd)" -c -o drivers/usb/host/ohci-hcd.o drivers/usb/host/ohci-hcd.c
-
-deps_drivers/usb/host/ohci-hcd.o := \
-  drivers/usb/host/ohci-hcd.c \
-    $(wildcard include/config/arch/omap.h) \
-    $(wildcard include/config/sa1111.h) \
-    $(wildcard include/config/pci.h) \
-    $(wildcard include/config/arch/s3c2410.h) \
-    $(wildcard include/config/arch/lh7a404.h) \
-    $(wildcard include/config/pxa27x.h) \
-    $(wildcard include/config/arch/ep93xx.h) \
-    $(wildcard include/config/soc/au1x00.h) \
-    $(wildcard include/config/pnx8550.h) \
-    $(wildcard include/config/usb/ohci/hcd/ppc/soc.h) \
-    $(wildcard include/config/arch/at91.h) \
-    $(wildcard include/config/arch/pnx4008.h) \
-    $(wildcard include/config/usb/ohci/hcd/ppc/of.h) \
-    $(wildcard include/config/ppc/ps3.h) \
-  include/linux/module.h \
-    $(wildcard include/config/modules.h) \
-    $(wildcard include/config/modversions.h) \
-    $(wildcard include/config/unused/symbols.h) \
-    $(wildcard include/config/generic/bug.h) \
-    $(wildcard include/config/module/unload.h) \
-    $(wildcard include/config/kallsyms.h) \
-    $(wildcard include/config/sysfs.h) \
-  include/linux/list.h \
-    $(wildcard include/config/debug/list.h) \
-  include/linux/stddef.h \
-  include/linux/compiler.h \
-    $(wildcard include/config/enable/must/check.h) \
-  include/linux/compiler-gcc4.h \
-    $(wildcard include/config/forced/inlining.h) \
-  include/linux/compiler-gcc.h \
-  include/linux/poison.h \
-  include/linux/prefetch.h \
-  include/linux/types.h \
-    $(wildcard include/config/uid16.h) \
-    $(wildcard include/config/lbd.h) \
-    $(wildcard include/config/lsf.h) \
-    $(wildcard include/config/resources/64bit.h) \
-  include/linux/posix_types.h \
-  include/asm/posix_types.h \
-  include/asm/types.h \
-  include/asm/processor.h \
-    $(wildcard include/config/mmu.h) \
-  include/asm/ptrace.h \
-    $(wildcard include/config/arm/thumb.h) \
-    $(wildcard include/config/smp.h) \
-  include/asm/hwcap.h \
-  include/asm/cache.h \
-  include/asm/system.h \
-    $(wildcard include/config/cpu/cp15.h) \
-    $(wildcard include/config/cpu/xsc3.h) \
-    $(wildcard include/config/cpu/xscale.h) \
-    $(wildcard include/config/cpu/sa1100.h) \
-    $(wildcard include/config/cpu/sa110.h) \
-  include/asm/memory.h \
-    $(wildcard include/config/dram/size.h) \
-    $(wildcard include/config/dram/base.h) \
-    $(wildcard include/config/discontigmem.h) \
-  include/asm/arch/memory.h \
-  include/asm/sizes.h \
-  include/asm-generic/memory_model.h \
-    $(wildcard include/config/flatmem.h) \
-    $(wildcard include/config/sparsemem.h) \
-    $(wildcard include/config/out/of/line/pfn/to/page.h) \
-  include/linux/linkage.h \
-  include/asm/linkage.h \
-  include/linux/irqflags.h \
-    $(wildcard include/config/trace/irqflags.h) \
-    $(wildcard include/config/trace/irqflags/support.h) \
-    $(wildcard include/config/x86.h) \
-  include/asm/irqflags.h \
-  include/linux/stat.h \
-  include/asm/stat.h \
-  include/linux/time.h \
-  include/linux/cache.h \
-  include/linux/kernel.h \
-    $(wildcard include/config/preempt/voluntary.h) \
-    $(wildcard include/config/debug/spinlock/sleep.h) \
-    $(wildcard include/config/printk.h) \
-    $(wildcard include/config/noprintk.h) \
-    $(wildcard include/config/numa.h) \
-  /home/xfs/toolchains/toolchain-arm_gcc4.2.3/bin/../lib/gcc/arm-linux-uclibc/4.2.3/include/stdarg.h \
-  include/linux/bitops.h \
-  include/asm/bitops.h \
-  include/asm-generic/bitops/non-atomic.h \
-  include/asm-generic/bitops/ffz.h \
-  include/asm-generic/bitops/__ffs.h \
-  include/asm-generic/bitops/fls.h \
-  include/asm-generic/bitops/ffs.h \
-  include/asm-generic/bitops/fls64.h \
-  include/asm-generic/bitops/sched.h \
-  include/asm-generic/bitops/hweight.h \
-  include/linux/log2.h \
-    $(wildcard include/config/arch/has/ilog2/u32.h) \
-    $(wildcard include/config/arch/has/ilog2/u64.h) \
-  include/asm/byteorder.h \
-  include/linux/byteorder/little_endian.h \
-  include/linux/byteorder/swab.h \
-  include/linux/byteorder/generic.h \
-  include/asm/bug.h \
-    $(wildcard include/config/bug.h) \
-    $(wildcard include/config/debug/bugverbose.h) \
-  include/asm-generic/bug.h \
-  include/linux/seqlock.h \
-  include/linux/spinlock.h \
-    $(wildcard include/config/debug/spinlock.h) \
-    $(wildcard include/config/preempt.h) \
-    $(wildcard include/config/debug/lock/alloc.h) \
-  include/linux/preempt.h \
-    $(wildcard include/config/debug/preempt.h) \
-    $(wildcard include/config/preempt/notifiers.h) \
-  include/linux/thread_info.h \
-  include/asm/thread_info.h \
-    $(wildcard include/config/debug/stack/usage.h) \
-  include/asm/fpstate.h \
-    $(wildcard include/config/iwmmxt.h) \
-  include/asm/domain.h \
-    $(wildcard include/config/io/36.h) \
-  include/linux/stringify.h \
-  include/linux/bottom_half.h \
-  include/linux/spinlock_types.h \
-  include/linux/spinlock_types_up.h \
-  include/linux/lockdep.h \
-    $(wildcard include/config/lockdep.h) \
-    $(wildcard include/config/lock/stat.h) \
-    $(wildcard include/config/generic/hardirqs.h) \
-    $(wildcard include/config/prove/locking.h) \
-  include/linux/spinlock_up.h \
-  include/linux/spinlock_api_up.h \
-  include/asm/atomic.h \
-  include/asm-generic/atomic.h \
-  include/linux/kmod.h \
-    $(wildcard include/config/kmod.h) \
-  include/linux/errno.h \
-  include/asm/errno.h \
-  include/asm-generic/errno.h \
-  include/asm-generic/errno-base.h \
-  include/linux/elf.h \
-  include/linux/auxvec.h \
-  include/asm/auxvec.h \
-  include/linux/elf-em.h \
-  include/asm/elf.h \
-  include/asm/user.h \
-  include/asm/page.h \
-    $(wildcard include/config/cpu/copy/v3.h) \
-    $(wildcard include/config/cpu/copy/v4wt.h) \
-    $(wildcard include/config/cpu/copy/v4wb.h) \
-    $(wildcard include/config/cpu/copy/fa.h) \
-    $(wildcard include/config/cpu/copy/v6.h) \
-    $(wildcard include/config/aeabi.h) \
-  include/asm/glue.h \
-    $(wildcard include/config/cpu/arm610.h) \
-    $(wildcard include/config/cpu/arm710.h) \
-    $(wildcard include/config/cpu/abrt/lv4t.h) \
-    $(wildcard include/config/cpu/abrt/ev4.h) \
-    $(wildcard include/config/cpu/abrt/ev4t.h) \
-    $(wildcard include/config/cpu/abrt/ev5tj.h) \
-    $(wildcard include/config/cpu/abrt/ev5t.h) \
-    $(wildcard include/config/cpu/abrt/ev6.h) \
-    $(wildcard include/config/cpu/abrt/ev7.h) \
-  include/asm-generic/page.h \
-  include/linux/kobject.h \
-    $(wildcard include/config/hotplug.h) \
-  include/linux/sysfs.h \
-  include/linux/kref.h \
-  include/linux/wait.h \
-  include/asm/current.h \
-  include/linux/moduleparam.h \
-  include/linux/init.h \
-    $(wildcard include/config/hotplug/cpu.h) \
-    $(wildcard include/config/memory/hotplug.h) \
-    $(wildcard include/config/acpi/hotplug/memory.h) \
-  include/asm/local.h \
-  include/asm-generic/local.h \
-  include/linux/percpu.h \
-  include/linux/slab.h \
-    $(wildcard include/config/slab/debug.h) \
-    $(wildcard include/config/slub.h) \
-    $(wildcard include/config/slob.h) \
-    $(wildcard include/config/debug/slab.h) \
-  include/linux/gfp.h \
-    $(wildcard include/config/zone/dma.h) \
-    $(wildcard include/config/zone/dma32.h) \
-    $(wildcard include/config/highmem.h) \
-  include/linux/mmzone.h \
-    $(wildcard include/config/force/max/zoneorder.h) \
-    $(wildcard include/config/arch/populates/node/map.h) \
-    $(wildcard include/config/flat/node/mem/map.h) \
-    $(wildcard include/config/have/memory/present.h) \
-    $(wildcard include/config/need/node/memmap/size.h) \
-    $(wildcard include/config/need/multiple/nodes.h) \
-    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
-    $(wildcard include/config/sparsemem/extreme.h) \
-    $(wildcard include/config/nodes/span/other/nodes.h) \
-    $(wildcard include/config/holes/in/zone.h) \
-  include/linux/threads.h \
-    $(wildcard include/config/nr/cpus.h) \
-    $(wildcard include/config/base/small.h) \
-  include/linux/numa.h \
-    $(wildcard include/config/nodes/shift.h) \
-  include/linux/nodemask.h \
-  include/linux/bitmap.h \
-  include/linux/string.h \
-  include/asm/string.h \
-  include/linux/memory_hotplug.h \
-    $(wildcard include/config/have/arch/nodedata/extension.h) \
-  include/linux/notifier.h \
-  include/linux/mutex.h \
-    $(wildcard include/config/debug/mutexes.h) \
-  include/linux/rwsem.h \
-    $(wildcard include/config/rwsem/generic/spinlock.h) \
-  include/linux/rwsem-spinlock.h \
-  include/linux/srcu.h \
-  include/linux/topology.h \
-    $(wildcard include/config/sched/smt.h) \
-    $(wildcard include/config/sched/mc.h) \
-  include/linux/cpumask.h \
-  include/linux/smp.h \
-  include/asm/topology.h \
-  include/asm-generic/topology.h \
-  include/linux/slab_def.h \
-  include/linux/kmalloc_sizes.h \
-  include/asm/percpu.h \
-  include/asm-generic/percpu.h \
-  include/linux/hardirq.h \
-    $(wildcard include/config/preempt/bkl.h) \
-    $(wildcard include/config/virt/cpu/accounting.h) \
-  include/linux/smp_lock.h \
-    $(wildcard include/config/lock/kernel.h) \
-  include/asm/hardirq.h \
-  include/asm/irq.h \
-  include/asm/arch/irqs.h \
-    $(wildcard include/config/sl3516/asic.h) \
-  include/asm/arch/int_ctrl.h \
-  include/linux/irq_cpustat.h \
-  include/asm/module.h \
-  include/linux/pci.h \
-    $(wildcard include/config/pci/msi.h) \
-    $(wildcard include/config/ht/irq.h) \
-    $(wildcard include/config/pci/domains.h) \
-  include/linux/pci_regs.h \
-  include/linux/mod_devicetable.h \
-  include/linux/ioport.h \
-  include/linux/device.h \
-    $(wildcard include/config/debug/devres.h) \
-  include/linux/klist.h \
-  include/linux/completion.h \
-  include/linux/pm.h \
-    $(wildcard include/config/suspend.h) \
-    $(wildcard include/config/pm/sleep.h) \
-  include/asm/semaphore.h \
-  include/asm/locks.h \
-  include/asm/device.h \
-    $(wildcard include/config/dmabounce.h) \
-  include/linux/pci_ids.h \
-  include/linux/dmapool.h \
-  include/asm/io.h \
-  include/asm/arch/io.h \
-  include/asm/scatterlist.h \
-  include/asm/pci.h \
-  include/asm-generic/pci-dma-compat.h \
-  include/linux/dma-mapping.h \
-    $(wildcard include/config/has/dma.h) \
-  include/linux/err.h \
-  include/asm/dma-mapping.h \
-  include/linux/mm.h \
-    $(wildcard include/config/sysctl.h) \
-    $(wildcard include/config/stack/growsup.h) \
-    $(wildcard include/config/debug/vm.h) \
-    $(wildcard include/config/shmem.h) \
-    $(wildcard include/config/split/ptlock/cpus.h) \
-    $(wildcard include/config/ia64.h) \
-    $(wildcard include/config/proc/fs.h) \
-    $(wildcard include/config/debug/pagealloc.h) \
-  include/linux/rbtree.h \
-  include/linux/prio_tree.h \
-  include/linux/debug_locks.h \
-    $(wildcard include/config/debug/locking/api/selftests.h) \
-  include/linux/backing-dev.h \
-  include/linux/mm_types.h \
-  include/asm/pgtable.h \
-  include/asm-generic/4level-fixup.h \
-  include/asm/proc-fns.h \
-    $(wildcard include/config/cpu/32.h) \
-    $(wildcard include/config/cpu/arm7tdmi.h) \
-    $(wildcard include/config/cpu/arm720t.h) \
-    $(wildcard include/config/cpu/arm740t.h) \
-    $(wildcard include/config/cpu/arm9tdmi.h) \
-    $(wildcard include/config/cpu/arm920t.h) \
-    $(wildcard include/config/cpu/arm922t.h) \
-    $(wildcard include/config/cpu/fa526.h) \
-    $(wildcard include/config/cpu/arm925t.h) \
-    $(wildcard include/config/cpu/arm926t.h) \
-    $(wildcard include/config/cpu/arm940t.h) \
-    $(wildcard include/config/cpu/arm946e.h) \
-    $(wildcard include/config/cpu/arm1020.h) \
-    $(wildcard include/config/cpu/arm1020e.h) \
-    $(wildcard include/config/cpu/arm1022.h) \
-    $(wildcard include/config/cpu/arm1026.h) \
-    $(wildcard include/config/cpu/v6.h) \
-    $(wildcard include/config/cpu/v7.h) \
-  include/asm/cpu-single.h \
-  include/asm/arch/vmalloc.h \
-  include/asm/pgtable-hwdef.h \
-  include/asm-generic/pgtable.h \
-  include/linux/page-flags.h \
-    $(wildcard include/config/s390.h) \
-    $(wildcard include/config/swap.h) \
-  include/linux/vmstat.h \
-    $(wildcard include/config/vm/event/counters.h) \
-  include/asm/hardware.h \
-  include/asm/arch/hardware.h \
-  include/asm/arch/platform.h \
-  include/asm/arch/sl2312.h \
-    $(wildcard include/config/net/sl351x.h) \
-    $(wildcard include/config/gemini/ipi.h) \
-    $(wildcard include/config/sl2312/share/pin.h) \
-  include/linux/delay.h \
-  include/asm/delay.h \
-  include/asm/param.h \
-    $(wildcard include/config/hz.h) \
-  include/linux/sched.h \
-    $(wildcard include/config/sched/debug.h) \
-    $(wildcard include/config/no/hz.h) \
-    $(wildcard include/config/detect/softlockup.h) \
-    $(wildcard include/config/keys.h) \
-    $(wildcard include/config/bsd/process/acct.h) \
-    $(wildcard include/config/taskstats.h) \
-    $(wildcard include/config/audit.h) \
-    $(wildcard include/config/inotify/user.h) \
-    $(wildcard include/config/schedstats.h) \
-    $(wildcard include/config/task/delay/acct.h) \
-    $(wildcard include/config/fair/group/sched.h) \
-    $(wildcard include/config/blk/dev/io/trace.h) \
-    $(wildcard include/config/cc/stackprotector.h) \
-    $(wildcard include/config/sysvipc.h) \
-    $(wildcard include/config/rt/mutexes.h) \
-    $(wildcard include/config/task/xacct.h) \
-    $(wildcard include/config/cpusets.h) \
-    $(wildcard include/config/compat.h) \
-    $(wildcard include/config/fault/injection.h) \
-  include/linux/capability.h \
-  include/linux/timex.h \
-  include/asm/timex.h \
-  include/asm/arch/timex.h \
-  include/asm/arch/sl2312.h \
-  include/linux/jiffies.h \
-  include/linux/calc64.h \
-  include/asm/div64.h \
-  include/asm/mmu.h \
-    $(wildcard include/config/cpu/has/asid.h) \
-  include/asm/cputime.h \
-  include/asm-generic/cputime.h \
-  include/linux/sem.h \
-  include/linux/ipc.h \
-  include/asm/ipcbuf.h \
-  include/asm/sembuf.h \
-  include/linux/signal.h \
-  include/asm/signal.h \
-  include/asm-generic/signal.h \
-  include/asm/sigcontext.h \
-  include/asm/siginfo.h \
-  include/asm-generic/siginfo.h \
-  include/linux/securebits.h \
-  include/linux/fs_struct.h \
-  include/linux/pid.h \
-  include/linux/rcupdate.h \
-  include/linux/seccomp.h \
-    $(wildcard include/config/seccomp.h) \
-  include/linux/futex.h \
-    $(wildcard include/config/futex.h) \
-  include/linux/rtmutex.h \
-    $(wildcard include/config/debug/rt/mutexes.h) \
-  include/linux/plist.h \
-    $(wildcard include/config/debug/pi/list.h) \
-  include/linux/param.h \
-  include/linux/resource.h \
-  include/asm/resource.h \
-  include/asm-generic/resource.h \
-  include/linux/timer.h \
-    $(wildcard include/config/timer/stats.h) \
-  include/linux/ktime.h \
-    $(wildcard include/config/ktime/scalar.h) \
-  include/linux/hrtimer.h \
-    $(wildcard include/config/high/res/timers.h) \
-  include/linux/task_io_accounting.h \
-    $(wildcard include/config/task/io/accounting.h) \
-  include/linux/aio.h \
-  include/linux/workqueue.h \
-  include/linux/aio_abi.h \
-  include/linux/uio.h \
-  include/linux/usb.h \
-    $(wildcard include/config/usb/devicefs.h) \
-    $(wildcard include/config/usb/mon.h) \
-    $(wildcard include/config/usb/device/class.h) \
-    $(wildcard include/config/pm.h) \
-    $(wildcard include/config/usb/suspend.h) \
-  include/linux/usb/ch9.h \
-    $(wildcard include/config/size.h) \
-    $(wildcard include/config/att/one.h) \
-    $(wildcard include/config/att/selfpower.h) \
-    $(wildcard include/config/att/wakeup.h) \
-    $(wildcard include/config/att/battery.h) \
-  include/linux/interrupt.h \
-    $(wildcard include/config/generic/irq/probe.h) \
-  include/linux/irqreturn.h \
-  include/linux/fs.h \
-    $(wildcard include/config/sl2312/tso.h) \
-    $(wildcard include/config/dnotify.h) \
-    $(wildcard include/config/quota.h) \
-    $(wildcard include/config/inotify.h) \
-    $(wildcard include/config/security.h) \
-    $(wildcard include/config/epoll.h) \
-    $(wildcard include/config/auditsyscall.h) \
-    $(wildcard include/config/block.h) \
-    $(wildcard include/config/fs/xip.h) \
-    $(wildcard include/config/migration.h) \
-  include/linux/limits.h \
-  include/linux/ioctl.h \
-  include/asm/ioctl.h \
-  include/asm-generic/ioctl.h \
-  include/linux/kdev_t.h \
-  include/linux/dcache.h \
-    $(wildcard include/config/profiling.h) \
-  include/linux/namei.h \
-  include/linux/radix-tree.h \
-  include/linux/sysctl.h \
-  include/linux/quota.h \
-  include/linux/dqblk_xfs.h \
-  include/linux/dqblk_v1.h \
-  include/linux/dqblk_v2.h \
-  include/linux/nfs_fs_i.h \
-  include/linux/nfs.h \
-  include/linux/sunrpc/msg_prot.h \
-  include/linux/fcntl.h \
-  include/asm/fcntl.h \
-  include/asm-generic/fcntl.h \
-    $(wildcard include/config/64bit.h) \
-  include/linux/usb/otg.h \
-  include/linux/reboot.h \
-  include/asm/emergency-restart.h \
-  include/asm-generic/emergency-restart.h \
-  include/asm/unaligned.h \
-  drivers/usb/host/../core/hcd.h \
-  drivers/usb/host/../core/hub.h \
-  drivers/usb/host/ohci.h \
-    $(wildcard include/config/usb/ohci/little/endian.h) \
-    $(wildcard include/config/usb/ohci/big/endian/desc.h) \
-    $(wildcard include/config/usb/ohci/big/endian/mmio.h) \
-    $(wildcard include/config/usb/ohci/big/endian/.h) \
-    $(wildcard include/config/ppc.h) \
-    $(wildcard include/config/ppc/merge.h) \
-    $(wildcard include/config/stb03xxx.h) \
-  drivers/usb/host/ohci-hub.c \
-    $(wildcard include/config/usb/otg.h) \
-  drivers/usb/host/ohci-dbg.c \
-  drivers/usb/host/ohci-mem.c \
-  drivers/usb/host/ohci-q.c \
-  include/linux/irq.h \
-    $(wildcard include/config/irq/per/cpu.h) \
-    $(wildcard include/config/irq/release/method.h) \
-    $(wildcard include/config/generic/pending/irq.h) \
-    $(wildcard include/config/irqbalance.h) \
-    $(wildcard include/config/auto/irq/affinity.h) \
-    $(wildcard include/config/generic/hardirqs/no//do/irq.h) \
-  include/asm/irq_regs.h \
-  include/asm-generic/irq_regs.h \
-  include/asm/hw_irq.h \
-    $(wildcard include/config/no/idle/hz.h) \
-  include/asm/mach/irq.h \
-  drivers/usb/host/ohci-pci.c \
-    $(wildcard include/config/usb/persist.h) \
-    $(wildcard include/config/usb/ehci/hcd.h) \
-
-drivers/usb/host/ohci-hcd.o: $(deps_drivers/usb/host/ohci-hcd.o)
-
-$(deps_drivers/usb/host/ohci-hcd.o):
diff -urN host/.pci-quirks.o.cmd host.new/.pci-quirks.o.cmd
--- host/.pci-quirks.o.cmd	2009-04-08 18:08:27.794654945 +0200
+++ host.new/.pci-quirks.o.cmd	1970-01-01 01:00:00.000000000 +0100
@@ -1,323 +0,0 @@
-cmd_drivers/usb/host/pci-quirks.o := arm-linux-uclibc-gcc -Wp,-MD,drivers/usb/host/.pci-quirks.o.d  -nostdinc -isystem /home/xfs/toolchains/toolchain-arm_gcc4.2.3/bin/../lib/gcc/arm-linux-uclibc/4.2.3/include -D__KERNEL__ -Iinclude  -include include/linux/autoconf.h -mlittle-endian -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -O2 -marm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -mabi=apcs-gnu -mno-thumb-interwork -D__LINUX_ARM_ARCH__=4 -march=armv4   -msoft-float -Uarm -fno-omit-frame-pointer -fno-optimize-sibling-calls  -fno-stack-protector -funit-at-a-time -Wdeclaration-after-statement -Wno-pointer-sign    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(pci_quirks)"  -D"KBUILD_MODNAME=KBUILD_STR(pci_quirks)" -c -o drivers/usb/host/pci-quirks.o drivers/usb/host/pci-quirks.c
-
-deps_drivers/usb/host/pci-quirks.o := \
-  drivers/usb/host/pci-quirks.c \
-  include/linux/types.h \
-    $(wildcard include/config/uid16.h) \
-    $(wildcard include/config/lbd.h) \
-    $(wildcard include/config/lsf.h) \
-    $(wildcard include/config/resources/64bit.h) \
-  include/linux/posix_types.h \
-  include/linux/stddef.h \
-  include/linux/compiler.h \
-    $(wildcard include/config/enable/must/check.h) \
-  include/linux/compiler-gcc4.h \
-    $(wildcard include/config/forced/inlining.h) \
-  include/linux/compiler-gcc.h \
-  include/asm/posix_types.h \
-  include/asm/types.h \
-  include/linux/kernel.h \
-    $(wildcard include/config/preempt/voluntary.h) \
-    $(wildcard include/config/debug/spinlock/sleep.h) \
-    $(wildcard include/config/printk.h) \
-    $(wildcard include/config/noprintk.h) \
-    $(wildcard include/config/numa.h) \
-  /home/xfs/toolchains/toolchain-arm_gcc4.2.3/bin/../lib/gcc/arm-linux-uclibc/4.2.3/include/stdarg.h \
-  include/linux/linkage.h \
-  include/asm/linkage.h \
-  include/linux/bitops.h \
-  include/asm/bitops.h \
-    $(wildcard include/config/smp.h) \
-  include/asm/system.h \
-    $(wildcard include/config/cpu/cp15.h) \
-    $(wildcard include/config/cpu/xsc3.h) \
-    $(wildcard include/config/cpu/xscale.h) \
-    $(wildcard include/config/cpu/sa1100.h) \
-    $(wildcard include/config/cpu/sa110.h) \
-  include/asm/memory.h \
-    $(wildcard include/config/mmu.h) \
-    $(wildcard include/config/dram/size.h) \
-    $(wildcard include/config/dram/base.h) \
-    $(wildcard include/config/discontigmem.h) \
-  include/asm/arch/memory.h \
-  include/asm/sizes.h \
-  include/asm-generic/memory_model.h \
-    $(wildcard include/config/flatmem.h) \
-    $(wildcard include/config/sparsemem.h) \
-    $(wildcard include/config/out/of/line/pfn/to/page.h) \
-  include/linux/irqflags.h \
-    $(wildcard include/config/trace/irqflags.h) \
-    $(wildcard include/config/trace/irqflags/support.h) \
-    $(wildcard include/config/x86.h) \
-  include/asm/irqflags.h \
-  include/asm/ptrace.h \
-    $(wildcard include/config/arm/thumb.h) \
-  include/asm/hwcap.h \
-  include/asm-generic/bitops/non-atomic.h \
-  include/asm-generic/bitops/ffz.h \
-  include/asm-generic/bitops/__ffs.h \
-  include/asm-generic/bitops/fls.h \
-  include/asm-generic/bitops/ffs.h \
-  include/asm-generic/bitops/fls64.h \
-  include/asm-generic/bitops/sched.h \
-  include/asm-generic/bitops/hweight.h \
-  include/linux/log2.h \
-    $(wildcard include/config/arch/has/ilog2/u32.h) \
-    $(wildcard include/config/arch/has/ilog2/u64.h) \
-  include/asm/byteorder.h \
-  include/linux/byteorder/little_endian.h \
-  include/linux/byteorder/swab.h \
-  include/linux/byteorder/generic.h \
-  include/asm/bug.h \
-    $(wildcard include/config/bug.h) \
-    $(wildcard include/config/debug/bugverbose.h) \
-  include/asm-generic/bug.h \
-    $(wildcard include/config/generic/bug.h) \
-  include/linux/pci.h \
-    $(wildcard include/config/pci/msi.h) \
-    $(wildcard include/config/pci.h) \
-    $(wildcard include/config/ht/irq.h) \
-    $(wildcard include/config/pci/domains.h) \
-  include/linux/pci_regs.h \
-  include/linux/mod_devicetable.h \
-  include/linux/ioport.h \
-  include/linux/list.h \
-    $(wildcard include/config/debug/list.h) \
-  include/linux/poison.h \
-  include/linux/prefetch.h \
-  include/asm/processor.h \
-  include/asm/cache.h \
-  include/linux/errno.h \
-  include/asm/errno.h \
-  include/asm-generic/errno.h \
-  include/asm-generic/errno-base.h \
-  include/asm/atomic.h \
-  include/asm-generic/atomic.h \
-  include/linux/device.h \
-    $(wildcard include/config/debug/devres.h) \
-  include/linux/kobject.h \
-    $(wildcard include/config/hotplug.h) \
-  include/linux/sysfs.h \
-    $(wildcard include/config/sysfs.h) \
-  include/linux/spinlock.h \
-    $(wildcard include/config/debug/spinlock.h) \
-    $(wildcard include/config/preempt.h) \
-    $(wildcard include/config/debug/lock/alloc.h) \
-  include/linux/preempt.h \
-    $(wildcard include/config/debug/preempt.h) \
-    $(wildcard include/config/preempt/notifiers.h) \
-  include/linux/thread_info.h \
-  include/asm/thread_info.h \
-    $(wildcard include/config/debug/stack/usage.h) \
-  include/asm/fpstate.h \
-    $(wildcard include/config/iwmmxt.h) \
-  include/asm/domain.h \
-    $(wildcard include/config/io/36.h) \
-  include/linux/stringify.h \
-  include/linux/bottom_half.h \
-  include/linux/spinlock_types.h \
-  include/linux/spinlock_types_up.h \
-  include/linux/lockdep.h \
-    $(wildcard include/config/lockdep.h) \
-    $(wildcard include/config/lock/stat.h) \
-    $(wildcard include/config/generic/hardirqs.h) \
-    $(wildcard include/config/prove/locking.h) \
-  include/linux/spinlock_up.h \
-  include/linux/spinlock_api_up.h \
-  include/linux/kref.h \
-  include/linux/wait.h \
-  include/asm/current.h \
-  include/linux/klist.h \
-  include/linux/completion.h \
-  include/linux/module.h \
-    $(wildcard include/config/modules.h) \
-    $(wildcard include/config/modversions.h) \
-    $(wildcard include/config/unused/symbols.h) \
-    $(wildcard include/config/module/unload.h) \
-    $(wildcard include/config/kallsyms.h) \
-  include/linux/stat.h \
-  include/asm/stat.h \
-  include/linux/time.h \
-  include/linux/cache.h \
-  include/linux/seqlock.h \
-  include/linux/kmod.h \
-    $(wildcard include/config/kmod.h) \
-  include/linux/elf.h \
-  include/linux/auxvec.h \
-  include/asm/auxvec.h \
-  include/linux/elf-em.h \
-  include/asm/elf.h \
-  include/asm/user.h \
-  include/asm/page.h \
-    $(wildcard include/config/cpu/copy/v3.h) \
-    $(wildcard include/config/cpu/copy/v4wt.h) \
-    $(wildcard include/config/cpu/copy/v4wb.h) \
-    $(wildcard include/config/cpu/copy/fa.h) \
-    $(wildcard include/config/cpu/copy/v6.h) \
-    $(wildcard include/config/aeabi.h) \
-  include/asm/glue.h \
-    $(wildcard include/config/cpu/arm610.h) \
-    $(wildcard include/config/cpu/arm710.h) \
-    $(wildcard include/config/cpu/abrt/lv4t.h) \
-    $(wildcard include/config/cpu/abrt/ev4.h) \
-    $(wildcard include/config/cpu/abrt/ev4t.h) \
-    $(wildcard include/config/cpu/abrt/ev5tj.h) \
-    $(wildcard include/config/cpu/abrt/ev5t.h) \
-    $(wildcard include/config/cpu/abrt/ev6.h) \
-    $(wildcard include/config/cpu/abrt/ev7.h) \
-  include/asm-generic/page.h \
-  include/linux/moduleparam.h \
-  include/linux/init.h \
-    $(wildcard include/config/hotplug/cpu.h) \
-    $(wildcard include/config/memory/hotplug.h) \
-    $(wildcard include/config/acpi/hotplug/memory.h) \
-  include/asm/local.h \
-  include/asm-generic/local.h \
-  include/linux/percpu.h \
-  include/linux/slab.h \
-    $(wildcard include/config/slab/debug.h) \
-    $(wildcard include/config/slub.h) \
-    $(wildcard include/config/slob.h) \
-    $(wildcard include/config/debug/slab.h) \
-  include/linux/gfp.h \
-    $(wildcard include/config/zone/dma.h) \
-    $(wildcard include/config/zone/dma32.h) \
-    $(wildcard include/config/highmem.h) \
-  include/linux/mmzone.h \
-    $(wildcard include/config/force/max/zoneorder.h) \
-    $(wildcard include/config/arch/populates/node/map.h) \
-    $(wildcard include/config/flat/node/mem/map.h) \
-    $(wildcard include/config/have/memory/present.h) \
-    $(wildcard include/config/need/node/memmap/size.h) \
-    $(wildcard include/config/need/multiple/nodes.h) \
-    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
-    $(wildcard include/config/sparsemem/extreme.h) \
-    $(wildcard include/config/nodes/span/other/nodes.h) \
-    $(wildcard include/config/holes/in/zone.h) \
-  include/linux/threads.h \
-    $(wildcard include/config/nr/cpus.h) \
-    $(wildcard include/config/base/small.h) \
-  include/linux/numa.h \
-    $(wildcard include/config/nodes/shift.h) \
-  include/linux/nodemask.h \
-  include/linux/bitmap.h \
-  include/linux/string.h \
-  include/asm/string.h \
-  include/linux/memory_hotplug.h \
-    $(wildcard include/config/have/arch/nodedata/extension.h) \
-  include/linux/notifier.h \
-  include/linux/mutex.h \
-    $(wildcard include/config/debug/mutexes.h) \
-  include/linux/rwsem.h \
-    $(wildcard include/config/rwsem/generic/spinlock.h) \
-  include/linux/rwsem-spinlock.h \
-  include/linux/srcu.h \
-  include/linux/topology.h \
-    $(wildcard include/config/sched/smt.h) \
-    $(wildcard include/config/sched/mc.h) \
-  include/linux/cpumask.h \
-  include/linux/smp.h \
-  include/asm/topology.h \
-  include/asm-generic/topology.h \
-  include/linux/slab_def.h \
-  include/linux/kmalloc_sizes.h \
-  include/asm/percpu.h \
-  include/asm-generic/percpu.h \
-  include/linux/hardirq.h \
-    $(wildcard include/config/preempt/bkl.h) \
-    $(wildcard include/config/virt/cpu/accounting.h) \
-  include/linux/smp_lock.h \
-    $(wildcard include/config/lock/kernel.h) \
-  include/asm/hardirq.h \
-  include/asm/irq.h \
-  include/asm/arch/irqs.h \
-    $(wildcard include/config/sl3516/asic.h) \
-  include/asm/arch/int_ctrl.h \
-  include/linux/irq_cpustat.h \
-  include/asm/module.h \
-  include/linux/pm.h \
-    $(wildcard include/config/suspend.h) \
-    $(wildcard include/config/pm/sleep.h) \
-  include/asm/semaphore.h \
-  include/asm/locks.h \
-  include/asm/device.h \
-    $(wildcard include/config/dmabounce.h) \
-  include/linux/pci_ids.h \
-  include/linux/dmapool.h \
-  include/asm/io.h \
-  include/asm/arch/io.h \
-  include/asm/scatterlist.h \
-  include/asm/pci.h \
-  include/asm-generic/pci-dma-compat.h \
-  include/linux/dma-mapping.h \
-    $(wildcard include/config/has/dma.h) \
-  include/linux/err.h \
-  include/asm/dma-mapping.h \
-  include/linux/mm.h \
-    $(wildcard include/config/sysctl.h) \
-    $(wildcard include/config/stack/growsup.h) \
-    $(wildcard include/config/debug/vm.h) \
-    $(wildcard include/config/shmem.h) \
-    $(wildcard include/config/split/ptlock/cpus.h) \
-    $(wildcard include/config/ia64.h) \
-    $(wildcard include/config/proc/fs.h) \
-    $(wildcard include/config/debug/pagealloc.h) \
-  include/linux/rbtree.h \
-  include/linux/prio_tree.h \
-  include/linux/debug_locks.h \
-    $(wildcard include/config/debug/locking/api/selftests.h) \
-  include/linux/backing-dev.h \
-  include/linux/mm_types.h \
-  include/asm/pgtable.h \
-  include/asm-generic/4level-fixup.h \
-  include/asm/proc-fns.h \
-    $(wildcard include/config/cpu/32.h) \
-    $(wildcard include/config/cpu/arm7tdmi.h) \
-    $(wildcard include/config/cpu/arm720t.h) \
-    $(wildcard include/config/cpu/arm740t.h) \
-    $(wildcard include/config/cpu/arm9tdmi.h) \
-    $(wildcard include/config/cpu/arm920t.h) \
-    $(wildcard include/config/cpu/arm922t.h) \
-    $(wildcard include/config/cpu/fa526.h) \
-    $(wildcard include/config/cpu/arm925t.h) \
-    $(wildcard include/config/cpu/arm926t.h) \
-    $(wildcard include/config/cpu/arm940t.h) \
-    $(wildcard include/config/cpu/arm946e.h) \
-    $(wildcard include/config/cpu/arm1020.h) \
-    $(wildcard include/config/cpu/arm1020e.h) \
-    $(wildcard include/config/cpu/arm1022.h) \
-    $(wildcard include/config/cpu/arm1026.h) \
-    $(wildcard include/config/cpu/v6.h) \
-    $(wildcard include/config/cpu/v7.h) \
-  include/asm/cpu-single.h \
-  include/asm/arch/vmalloc.h \
-  include/asm/pgtable-hwdef.h \
-  include/asm-generic/pgtable.h \
-  include/linux/page-flags.h \
-    $(wildcard include/config/s390.h) \
-    $(wildcard include/config/swap.h) \
-  include/linux/vmstat.h \
-    $(wildcard include/config/vm/event/counters.h) \
-  include/asm/hardware.h \
-  include/asm/arch/hardware.h \
-  include/asm/arch/platform.h \
-  include/asm/arch/sl2312.h \
-    $(wildcard include/config/net/sl351x.h) \
-    $(wildcard include/config/gemini/ipi.h) \
-    $(wildcard include/config/sl2312/share/pin.h) \
-  include/linux/delay.h \
-  include/asm/delay.h \
-  include/asm/param.h \
-    $(wildcard include/config/hz.h) \
-  include/linux/acpi.h \
-    $(wildcard include/config/acpi.h) \
-    $(wildcard include/config/have/arch/parse/srat.h) \
-    $(wildcard include/config/acpi/hotplug/cpu.h) \
-    $(wildcard include/config/acpi/ec.h) \
-    $(wildcard include/config/dmi.h) \
-    $(wildcard include/config/acpi/numa.h) \
-  drivers/usb/host/pci-quirks.h \
-
-drivers/usb/host/pci-quirks.o: $(deps_drivers/usb/host/pci-quirks.o)
-
-$(deps_drivers/usb/host/pci-quirks.o):
diff -urN host/.svn/entries host.new/.svn/entries
--- host/.svn/entries	2009-04-07 15:18:20.040063908 +0200
+++ host.new/.svn/entries	1970-01-01 01:00:00.000000000 +0100
@@ -1,1728 +0,0 @@
-10
-
-dir
-11695
-svn://svn.dd-wrt.com/DEV/src/linux/sl2312/linux-2.6.23/drivers/usb/host
-svn://svn.dd-wrt.com/DEV
-
-
-
-2009-01-10T20:36:21.085120Z
-11369
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-52c4871e-980c-0410-b1e0-e73912ce01f8
-
-ohci-at91.c
-file
-
-
-
-
-2009-02-24T18:00:15.367972Z
-f0072f99f15f54fa636f8b7e562527d7
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-7657
-
-Kconfig
-file
-
-
-
-
-2009-02-24T18:00:15.251977Z
-5226b568c3b7e031ef870690c87fdf6f
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-8816
-
-ohci-ppc-of.c
-file
-
-
-
-
-2009-02-24T18:00:15.475966Z
-d8ca79b4e1f32d7c81a83e9c6e549091
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-4829
-
-ehci-hcd.c
-file
-
-
-
-
-2009-02-24T18:00:15.663957Z
-2b5a16afd6394acdcde79da1f680b4ae
-2009-01-10T20:36:21.085120Z
-11369
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-30256
-
-sl811-hcd.c
-file
-
-
-
-
-2009-02-24T18:00:15.571961Z
-002aa4a42016c88e1f3cf9c0e16d0d51
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-47434
-
-ohci-pnx8550.c
-file
-
-
-
-
-2009-02-24T18:00:15.471966Z
-3d1387f2ece58cc03f153d13e85e6528
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-5869
-
-isp116x-hcd.c
-file
-
-
-
-
-2009-02-24T18:00:15.339973Z
-0e0a64da93cd31cb2d3f8bf086c7d9af
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-44804
-
-r8a66597-hcd.c
-file
-
-
-
-
-2009-02-24T18:00:15.551962Z
-1ed1714c9fc2ad11b471190345e70334
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-56812
-
-uhci-debug.c
-file
-
-
-
-
-2009-02-24T18:00:15.631958Z
-95360f053abad315f026ae183337c858
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-15146
-
-ohci-hcd.c
-file
-
-
-
-
-2009-02-24T18:00:15.427969Z
-b1ffd650f28765d6098936ecdae70888
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-27292
-
-ohci-s3c2410.c
-file
-
-
-
-
-2009-02-24T18:00:15.523964Z
-f0cb6d17975f7738d1f3d42285abd3a4
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-11106
-
-ehci-pci.c
-file
-
-
-
-
-2009-02-24T18:00:15.283976Z
-1ed5f98a8ff689413073a4d8664135e5
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-10917
-
-ehci-hub.c
-file
-
-
-
-
-2009-02-24T18:00:15.267977Z
-8217c49174cad6a9c85c886d0d518429
-2009-01-10T20:36:21.085120Z
-11369
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-25035
-
-ehci-mem.c
-file
-
-
-
-
-2009-02-24T18:00:15.279976Z
-192bb6d21c3276ab4c2d0ac0952c946c
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-6213
-
-uhci-hcd.c
-file
-
-
-
-
-2009-02-24T18:00:15.635958Z
-1440d12852f7efb467e9ee3f4dd232e6
-2009-01-10T20:36:21.085120Z
-11369
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-26249
-
-pci-quirks.c
-file
-
-
-
-
-2009-02-24T18:00:15.543963Z
-29f7ee22ab8d93ac6f0ff52e17bdf0b6
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-10371
-
-uhci-hcd.h
-file
-
-
-
-
-2009-02-24T18:00:15.639958Z
-94801fb316824b2957d4aefccb73d35b
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-16286
-
-ehci-fsl.c
-file
-
-
-
-
-2009-02-24T18:00:15.263977Z
-469609298b96093cc7bb051ff8ddd5f1
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-9179
-
-ohci-pci.c
-file
-
-
-
-
-2009-02-24T18:00:15.455967Z
-c819d6ce11772802107fe342e0309f5d
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-9851
-
-Makefile
-file
-
-
-
-
-2009-02-24T18:00:15.251977Z
-ab1d404df78ab5c1204b8c7726a5a766
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-491
-
-pci-quirks.h
-file
-
-
-
-
-2009-02-24T18:00:15.543963Z
-3217982f91778445f43acec2d6101f5f
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-242
-
-sl811_cs.c
-file
-
-
-
-
-2009-02-24T18:00:15.579961Z
-4a508f71121878ce39ce71ec092151d4
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-8342
-
-ohci-mem.c
-file
-
-
-
-
-2009-02-24T18:00:15.435968Z
-ab7b2738720951f05e9e7244a508028f
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-3451
-
-ohci-hub.c
-file
-
-
-
-
-2009-02-24T18:00:15.427969Z
-edf0dcbdbbd3a0d75ca6a645036b57da
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-18981
-
-ehci-fsl.h
-file
-
-
-
-
-2009-02-24T18:00:15.263977Z
-f374f9ee2591a07abbc95c3a9086f72c
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-1599
-
-ohci-pnx4008.c
-file
-
-
-
-
-2009-02-24T18:00:15.467966Z
-5ded547905621a8e4af983f70df6e003
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-11907
-
-ehci-dbg.c
-file
-
-
-
-
-2009-02-24T18:00:15.259977Z
-ce86aca2a64f41297df872bd15db0b51
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-22402
-
-ohci-lh7a404.c
-file
-
-
-
-
-2009-02-24T18:00:15.435968Z
-2895ff2ab44641e422cbda4eab93cbae
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-6105
-
-ehci-au1xxx.c
-file
-
-
-
-
-2009-02-24T18:00:15.255977Z
-c24b5b7f6adb7cb620d8298f9cea9f05
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-7513
-
-uhci-hub.c
-file
-
-
-
-
-2009-02-24T18:00:15.647957Z
-a50fefe53181b93e443ca06da9467e91
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-11206
-
-ehci-q.c
-file
-
-
-
-
-2009-02-24T18:00:15.299975Z
-ef3279d4a2c3d1872d7ebfc194f36af7
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-31167
-
-ohci-pxa27x.c
-file
-
-
-
-
-2009-02-24T18:00:15.491965Z
-d902ae2678ad3454437888aefd2d754a
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-8340
-
-ehci-ppc-soc.c
-file
-
-
-
-
-2009-02-24T18:00:15.287976Z
-9641e91a237b8d2ec041a7a7f3c1542e
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-4817
-
-ehci-ps3.c
-file
-
-
-
-
-2009-02-24T18:00:15.287976Z
-702fe09a5c6acea91c1a27436ce2e3e8
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-6261
-
-ohci-omap.c
-file
-
-
-
-
-2009-02-24T18:00:15.455967Z
-42e1101ab16fbaba77ff6ec67a41cbab
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-13544
-
-ohci-dbg.c
-file
-
-
-
-
-2009-02-24T18:00:15.411969Z
-5bb3626766a78a84b654afe451731520
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-18478
-
-ehci.h
-file
-
-
-
-
-2009-02-24T18:00:15.319974Z
-15ee9d935ff4196c3b20a09cdd7a5e36
-2009-01-10T20:36:21.085120Z
-11369
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-27835
-
-sl811.h
-file
-
-
-
-
-2009-02-24T18:00:15.579961Z
-96ddc1f47a5b42e492b2a304aec54c5d
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-6814
-
-ohci-au1xxx.c
-file
-
-
-
-
-2009-02-24T18:00:15.383971Z
-4be2cf32900d6b9128244470d5b07558
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-8870
-
-ohci-ep93xx.c
-file
-
-
-
-
-2009-02-24T18:00:15.411969Z
-1c6b4c93e730c2cb7391097c1f949e12
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-5061
-
-isp116x.h
-file
-
-
-
-
-2009-02-24T18:00:15.355972Z
-f289c5df20267463e10a70d5f8f9f0ea
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-18150
-
-ohci-q.c
-file
-
-
-
-
-2009-02-24T18:00:15.503965Z
-bf2e27deb5ea418fc3a10e73866c70c6
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-31547
-
-r8a66597.h
-file
-
-
-
-
-2009-02-24T18:00:15.559962Z
-615d064e9b06b5e8fce159da81712d68
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-21000
-
-ohci-ppc-soc.c
-file
-
-
-
-
-2009-02-24T18:00:15.475966Z
-9a811590a5b9756e9ce1a029d807af9e
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-4867
-
-ohci-ps3.c
-file
-
-
-
-
-2009-02-24T18:00:15.491965Z
-186ee0fb86fc3f0adc9b62be068bb08c
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-6537
-
-u132-hcd.c
-file
-
-
-
-
-2009-02-24T18:00:15.627958Z
-48533f80f7e2faf8e4cd484e85eeb643
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-133913
-
-uhci-q.c
-file
-
-
-
-
-2009-02-24T18:00:15.659957Z
-91b44e94648b9f556abf4df6b7cc1492
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-46845
-
-ohci-sa1111.c
-file
-
-
-
-
-2009-02-24T18:00:15.523964Z
-d2cbdf3addf20a8f5dc31f237ae9eaba
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-6736
-
-ohci.h
-file
-
-
-
-
-2009-02-24T18:00:15.539963Z
-44c75791f7bda456ad048a035adbefa8
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-22424
-
-ehci-sched.c
-file
-
-
-
-
-2009-02-24T18:00:15.315974Z
-d4679d6c45ec6394a0223a5961a65beb
-2008-07-24T18:28:54.508515Z
-9980
-BrainSlayer
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-58332
-
diff -urN host/.svn/text-base/Kconfig.svn-base host.new/.svn/text-base/Kconfig.svn-base
--- host/.svn/text-base/Kconfig.svn-base	2009-02-24 19:00:15.667956831 +0100
+++ host.new/.svn/text-base/Kconfig.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,250 +0,0 @@
-#
-# USB Host Controller Drivers
-#
-comment "USB Host Controller Drivers"
-	depends on USB
-
-config USB_EHCI_HCD
-	tristate "EHCI HCD (USB 2.0) support"
-	depends on USB && USB_ARCH_HAS_EHCI
-	---help---
-	  The Enhanced Host Controller Interface (EHCI) is standard for USB 2.0
-	  "high speed" (480 Mbit/sec, 60 Mbyte/sec) host controller hardware.
-	  If your USB host controller supports USB 2.0, you will likely want to
-	  configure this Host Controller Driver.  At the time of this writing, 
-	  the primary implementation of EHCI is a chip from NEC, widely available
-	  in add-on PCI cards, but implementations are in the works from other 
-	  vendors including Intel and Philips.  Motherboard support is appearing.
-
-	  EHCI controllers are packaged with "companion" host controllers (OHCI
-	  or UHCI) to handle USB 1.1 devices connected to root hub ports.  Ports
-	  will connect to EHCI if the device is high speed, otherwise they
-	  connect to a companion controller.  If you configure EHCI, you should
-	  probably configure the OHCI (for NEC and some other vendors) USB Host
-	  Controller Driver or UHCI (for Via motherboards) Host Controller
-	  Driver too.
-
-	  You may want to read <file:Documentation/usb/ehci.txt>.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called ehci-hcd.
-
-config USB_EHCI_SPLIT_ISO
-	bool "Full speed ISO transactions (EXPERIMENTAL)"
-	depends on USB_EHCI_HCD && EXPERIMENTAL
-	default n
-	---help---
-	  This code is new and hasn't been used with many different
-	  EHCI or USB 2.0 transaction translator implementations.
-	  It should work for ISO-OUT transfers, like audio.
-
-config USB_EHCI_ROOT_HUB_TT
-	bool "Root Hub Transaction Translators (EXPERIMENTAL)"
-	depends on USB_EHCI_HCD && EXPERIMENTAL
-	---help---
-	  Some EHCI chips have vendor-specific extensions to integrate
-	  transaction translators, so that no OHCI or UHCI companion
-	  controller is needed.  It's safe to say "y" even if your
-	  controller doesn't support this feature.
-
-	  This supports the EHCI implementation that's originally
-	  from ARC, and has since changed hands a few times.
-
-config USB_EHCI_TT_NEWSCHED
-	bool "Improved Transaction Translator scheduling (EXPERIMENTAL)"
-	depends on USB_EHCI_HCD && EXPERIMENTAL
-	---help---
-	  This changes the periodic scheduling code to fill more of the low
-	  and full speed bandwidth available from the Transaction Translator
-	  (TT) in USB 2.0 hubs.  Without this, only one transfer will be
-	  issued in each microframe, significantly reducing the number of
-	  periodic low/fullspeed transfers possible.
-
-	  If you have multiple periodic low/fullspeed devices connected to a
-	  highspeed USB hub which is connected to a highspeed USB Host
-	  Controller, and some of those devices will not work correctly
-	  (possibly due to "ENOSPC" or "-28" errors), say Y.
-
-	  If unsure, say N.
-
-config USB_EHCI_BIG_ENDIAN_MMIO
-	bool
-	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX)
-	default y
-
-config USB_EHCI_BIG_ENDIAN_DESC
-	bool
-	depends on USB_EHCI_HCD && 440EPX
-	default y
-
-config USB_EHCI_FSL
-	bool
-	select USB_EHCI_ROOT_HUB_TT
-	default y if MPC834x || PPC_MPC831x
-	---help---
-	  Variation of ARC USB block used in some Freescale chips.
-
-config USB_ISP116X_HCD
-	tristate "ISP116X HCD support"
-	depends on USB
-	---help---
-	  The ISP1160 and ISP1161 chips are USB host controllers. Enable this
-	  option if your board has this chip. If unsure, say N.
-
-	  This driver does not support isochronous transfers.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called isp116x-hcd.
-
-config USB_OHCI_HCD
-	tristate "OHCI HCD support"
-	depends on USB && USB_ARCH_HAS_OHCI
-	select ISP1301_OMAP if MACH_OMAP_H2 || MACH_OMAP_H3
-	select I2C if ARCH_PNX4008
-	---help---
-	  The Open Host Controller Interface (OHCI) is a standard for accessing
-	  USB 1.1 host controller hardware.  It does more in hardware than Intel's
-	  UHCI specification.  If your USB host controller follows the OHCI spec,
-	  say Y.  On most non-x86 systems, and on x86 hardware that's not using a
-	  USB controller from Intel or VIA, this is appropriate.  If your host
-	  controller doesn't use PCI, this is probably appropriate.  For a PCI
-	  based system where you're not sure, the "lspci -v" entry will list the
-	  right "prog-if" for your USB controller(s):  EHCI, OHCI, or UHCI.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called ohci-hcd.
-
-config USB_OHCI_HCD_PPC_SOC
-	bool "OHCI support for on-chip PPC USB controller"
-	depends on USB_OHCI_HCD && (STB03xxx || PPC_MPC52xx)
-	default y
-	select USB_OHCI_BIG_ENDIAN_DESC
-	select USB_OHCI_BIG_ENDIAN_MMIO
-	---help---
-	  Enables support for the USB controller on the MPC52xx or
-	  STB03xxx processor chip.  If unsure, say Y.
-
-config USB_OHCI_HCD_PPC_OF
-	bool "OHCI support for PPC USB controller on OF platform bus"
-	depends on USB_OHCI_HCD && PPC_OF
-	default y
-	---help---
-	  Enables support for the USB controller PowerPC present on the
-	  OpenFirmware platform bus.
-
-config USB_OHCI_HCD_PPC_OF_BE
-	bool "Support big endian HC"
-	depends on USB_OHCI_HCD_PPC_OF
-	default y
-	select USB_OHCI_BIG_ENDIAN_DESC
-	select USB_OHCI_BIG_ENDIAN_MMIO
-
-config USB_OHCI_HCD_PPC_OF_LE
-	bool "Support little endian HC"
-	depends on USB_OHCI_HCD_PPC_OF
-	default n
-	select USB_OHCI_LITTLE_ENDIAN
-
-config USB_OHCI_HCD_PCI
-	bool "OHCI support for PCI-bus USB controllers"
-	depends on USB_OHCI_HCD && PCI && (STB03xxx || PPC_MPC52xx || USB_OHCI_HCD_PPC_OF)
-	default y
-	select USB_OHCI_LITTLE_ENDIAN
-	---help---
-	  Enables support for PCI-bus plug-in USB controller cards.
-	  If unsure, say Y.
-
-config USB_OHCI_BIG_ENDIAN_DESC
-	bool
-	depends on USB_OHCI_HCD
-	default n
-
-config USB_OHCI_BIG_ENDIAN_MMIO
-	bool
-	depends on USB_OHCI_HCD
-	default n
-
-config USB_OHCI_LITTLE_ENDIAN
-	bool
-	depends on USB_OHCI_HCD
-	default n if STB03xxx || PPC_MPC52xx
-	default y
-
-config USB_UHCI_HCD
-	tristate "UHCI HCD (most Intel and VIA) support"
-	depends on USB && PCI
-	---help---
-	  The Universal Host Controller Interface is a standard by Intel for
-	  accessing the USB hardware in the PC (which is also called the USB
-	  host controller). If your USB host controller conforms to this
-	  standard, you may want to say Y, but see below. All recent boards
-	  with Intel PCI chipsets (like intel 430TX, 440FX, 440LX, 440BX,
-	  i810, i820) conform to this standard. Also all VIA PCI chipsets
-	  (like VIA VP2, VP3, MVP3, Apollo Pro, Apollo Pro II or Apollo Pro
-	  133). If unsure, say Y.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called uhci-hcd.
-
-config USB_U132_HCD
-	tristate "Elan U132 Adapter Host Controller"
-	depends on USB && USB_FTDI_ELAN
-	default M
-	help
-	  The U132 adapter is a USB to CardBus adapter specifically designed
-	  for PC cards that contain an OHCI host controller. Typical PC cards
-	  are the Orange Mobile 3G Option GlobeTrotter Fusion card. The U132
-	  adapter will *NOT* work with PC cards that do not contain an OHCI
-	  controller.
-
-	  For those PC cards that contain multiple OHCI controllers only the
-	  first one is used.
-
-	  The driver consists of two modules, the "ftdi-elan" module is a
-	  USB client driver that interfaces to the FTDI chip within ELAN's
-	  USB-to-PCMCIA adapter, and this "u132-hcd" module is a USB host
-	  controller driver that talks to the OHCI controller within the
-	  CardBus cards that are inserted in the U132 adapter.
-
-	  This driver has been tested with a CardBus OHCI USB adapter, and
-	  worked with a USB PEN Drive inserted into the first USB port of
-	  the PCCARD. A rather pointless thing to do, but useful for testing.
-
-	  It is safe to say M here.
-
-	  See also <http://www.elandigitalsystems.com/support/ufaq/u132linux.php>
-
-config USB_SL811_HCD
-	tristate "SL811HS HCD support"
-	depends on USB
-	help
-	  The SL811HS is a single-port USB controller that supports either
-	  host side or peripheral side roles.  Enable this option if your
-	  board has this chip, and you want to use it as a host controller. 
-	  If unsure, say N.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called sl811-hcd.
-
-config USB_SL811_CS
-	tristate "CF/PCMCIA support for SL811HS HCD"
-	depends on USB_SL811_HCD && PCMCIA
-	help
-	  Wraps a PCMCIA driver around the SL811HS HCD, supporting the RATOC
-	  REX-CFU1U CF card (often used with PDAs).  If unsure, say N.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called "sl811_cs".
-
-config USB_R8A66597_HCD
-	tristate "R8A66597 HCD support"
-	depends on USB
-	help
-	  The R8A66597 is a USB 2.0 host and peripheral controller.
-
-	  Enable this option if your board has this chip, and you want
-	  to use it as a host controller.  If unsure, say N.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called r8a66597-hcd.
-
diff -urN host/.svn/text-base/Makefile.svn-base host.new/.svn/text-base/Makefile.svn-base
--- host/.svn/text-base/Makefile.svn-base	2009-02-24 19:00:15.667956831 +0100
+++ host.new/.svn/text-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
-#
-# Makefile for USB Host Controller Drivers
-#
-
-ifeq ($(CONFIG_USB_DEBUG),y)
-	EXTRA_CFLAGS		+= -DDEBUG
-endif
-
-obj-$(CONFIG_PCI)		+= pci-quirks.o
-
-obj-$(CONFIG_USB_EHCI_HCD)	+= ehci-hcd.o
-obj-$(CONFIG_USB_ISP116X_HCD)	+= isp116x-hcd.o
-obj-$(CONFIG_USB_OHCI_HCD)	+= ohci-hcd.o
-obj-$(CONFIG_USB_UHCI_HCD)	+= uhci-hcd.o
-obj-$(CONFIG_USB_SL811_HCD)	+= sl811-hcd.o
-obj-$(CONFIG_USB_SL811_CS)	+= sl811_cs.o
-obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
-obj-$(CONFIG_USB_R8A66597_HCD)	+= r8a66597-hcd.o
-
diff -urN host/.svn/text-base/ehci-au1xxx.c.svn-base host.new/.svn/text-base/ehci-au1xxx.c.svn-base
--- host/.svn/text-base/ehci-au1xxx.c.svn-base	2009-02-24 19:00:15.667956831 +0100
+++ host.new/.svn/text-base/ehci-au1xxx.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,280 +0,0 @@
-/*
- * EHCI HCD (Host Controller Driver) for USB.
- *
- * Bus Glue for AMD Alchemy Au1xxx
- *
- * Based on "ohci-au1xxx.c" by Matt Porter <mporter@kernel.crashing.org>
- *
- * Modified for AMD Alchemy Au1200 EHC
- *  by K.Boge <karsten.boge@amd.com>
- *
- * This file is licenced under the GPL.
- */
-
-#include <linux/platform_device.h>
-#include <asm/mach-au1x00/au1000.h>
-
-#define USB_HOST_CONFIG   (USB_MSR_BASE + USB_MSR_MCFG)
-#define USB_MCFG_PFEN     (1<<31)
-#define USB_MCFG_RDCOMB   (1<<30)
-#define USB_MCFG_SSDEN    (1<<23)
-#define USB_MCFG_PHYPLLEN (1<<19)
-#define USB_MCFG_EHCCLKEN (1<<17)
-#define USB_MCFG_UCAM     (1<<7)
-#define USB_MCFG_EBMEN    (1<<3)
-#define USB_MCFG_EMEMEN   (1<<2)
-
-#define USBH_ENABLE_CE    (USB_MCFG_PHYPLLEN | USB_MCFG_EHCCLKEN)
-
-#ifdef CONFIG_DMA_COHERENT
-#define USBH_ENABLE_INIT  (USBH_ENABLE_CE \
-                         | USB_MCFG_PFEN | USB_MCFG_RDCOMB \
-                         | USB_MCFG_SSDEN | USB_MCFG_UCAM \
-                         | USB_MCFG_EBMEN | USB_MCFG_EMEMEN)
-#else
-#define USBH_ENABLE_INIT  (USBH_ENABLE_CE \
-                         | USB_MCFG_PFEN | USB_MCFG_RDCOMB \
-                         | USB_MCFG_SSDEN \
-                         | USB_MCFG_EBMEN | USB_MCFG_EMEMEN)
-#endif
-#define USBH_DISABLE      (USB_MCFG_EBMEN | USB_MCFG_EMEMEN)
-
-extern int usb_disabled(void);
-
-/*-------------------------------------------------------------------------*/
-
-static void au1xxx_start_ehc(struct platform_device *dev)
-{
-	pr_debug(__FILE__ ": starting Au1xxx EHCI USB Controller\n");
-
-	/* write HW defaults again in case Yamon cleared them */
-	if (au_readl(USB_HOST_CONFIG) == 0) {
-		au_writel(0x00d02000, USB_HOST_CONFIG);
-		au_readl(USB_HOST_CONFIG);
-		udelay(1000);
-	}
-	/* enable host controller */
-	au_writel(USBH_ENABLE_CE | au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
-	udelay(1000);
-	au_writel(USBH_ENABLE_INIT | au_readl(USB_HOST_CONFIG),
-		  USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
-	udelay(1000);
-
-	pr_debug(__FILE__ ": Clock to USB host has been enabled\n");
-}
-
-static void au1xxx_stop_ehc(struct platform_device *dev)
-{
-	pr_debug(__FILE__ ": stopping Au1xxx EHCI USB Controller\n");
-
-	/* Disable mem */
-	au_writel(~USBH_DISABLE & au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
-	udelay(1000);
-	/* Disable clock */
-	au_writel(~USB_MCFG_EHCCLKEN & au_readl(USB_HOST_CONFIG),
-		  USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* configure so an HC device and id are always provided */
-/* always called with process context; sleeping is OK */
-
-/**
- * usb_ehci_au1xxx_probe - initialize Au1xxx-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- *
- */
-int usb_ehci_au1xxx_probe(const struct hc_driver *driver,
-			  struct usb_hcd **hcd_out, struct platform_device *dev)
-{
-	int retval;
-	struct usb_hcd *hcd;
-	struct ehci_hcd *ehci;
-
-#if defined(CONFIG_SOC_AU1200) && defined(CONFIG_DMA_COHERENT)
-
-	/* Au1200 AB USB does not support coherent memory */
-	if (!(read_c0_prid() & 0xff)) {
-		pr_info("%s: this is chip revision AB!\n", dev->name);
-		pr_info("%s: update your board or re-configure the kernel\n",
-			dev->name);
-		return -ENODEV;
-	}
-#endif
-
-	au1xxx_start_ehc(dev);
-
-	if (dev->resource[1].flags != IORESOURCE_IRQ) {
-		pr_debug("resource[1] is not IORESOURCE_IRQ");
-		retval = -ENOMEM;
-	}
-	hcd = usb_create_hcd(driver, &dev->dev, "Au1xxx");
-	if (!hcd)
-		return -ENOMEM;
-	hcd->rsrc_start = dev->resource[0].start;
-	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		pr_debug("request_mem_region failed");
-		retval = -EBUSY;
-		goto err1;
-	}
-
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-	if (!hcd->regs) {
-		pr_debug("ioremap failed");
-		retval = -ENOMEM;
-		goto err2;
-	}
-
-	ehci = hcd_to_ehci(hcd);
-	ehci->caps = hcd->regs;
-	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
-	/* cache this readonly data; minimize chip reads */
-	ehci->hcs_params = readl(&ehci->caps->hcs_params);
-
-	/* ehci_hcd_init(hcd_to_ehci(hcd)); */
-
-	retval =
-	    usb_add_hcd(hcd, dev->resource[1].start, IRQF_DISABLED | IRQF_SHARED);
-	if (retval == 0)
-		return retval;
-
-	au1xxx_stop_ehc(dev);
-	iounmap(hcd->regs);
-err2:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-err1:
-	usb_put_hcd(hcd);
-	return retval;
-}
-
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_ehci_hcd_au1xxx_remove - shutdown processing for Au1xxx-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_ehci_hcd_au1xxx_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
- */
-void usb_ehci_au1xxx_remove(struct usb_hcd *hcd, struct platform_device *dev)
-{
-	usb_remove_hcd(hcd);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-	au1xxx_stop_ehc(dev);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static const struct hc_driver ehci_au1xxx_hc_driver = {
-	.description = hcd_name,
-	.product_desc = "Au1xxx EHCI",
-	.hcd_priv_size = sizeof(struct ehci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq = ehci_irq,
-	.flags = HCD_MEMORY | HCD_USB2,
-
-	/*
-	 * basic lifecycle operations
-	 *
-	 * FIXME -- ehci_init() doesn't do enough here.
-	 * See ehci-ppc-soc for a complete implementation.
-	 */
-	.reset = ehci_init,
-	.start = ehci_run,
-	.stop = ehci_stop,
-	.shutdown = ehci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue = ehci_urb_enqueue,
-	.urb_dequeue = ehci_urb_dequeue,
-	.endpoint_disable = ehci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number = ehci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data = ehci_hub_status_data,
-	.hub_control = ehci_hub_control,
-#ifdef	CONFIG_PM
-	.hub_suspend = ehci_hub_suspend,
-	.hub_resume = ehci_hub_resume,
-#endif
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int ehci_hcd_au1xxx_drv_probe(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = NULL;
-	int ret;
-
-	pr_debug("In ehci_hcd_au1xxx_drv_probe\n");
-
-	if (usb_disabled())
-		return -ENODEV;
-
-	ret = usb_ehci_au1xxx_probe(&ehci_au1xxx_hc_driver, &hcd, pdev);
-	return ret;
-}
-
-static int ehci_hcd_au1xxx_drv_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	usb_ehci_au1xxx_remove(hcd, pdev);
-	return 0;
-}
-
- /*TBD*/
-/*static int ehci_hcd_au1xxx_drv_suspend(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct usb_hcd *hcd = dev_get_drvdata(dev);
-
-	return 0;
-}
-static int ehci_hcd_au1xxx_drv_resume(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct usb_hcd *hcd = dev_get_drvdata(dev);
-
-	return 0;
-}
-*/
-MODULE_ALIAS("au1xxx-ehci");
-static struct platform_driver ehci_hcd_au1xxx_driver = {
-	.probe = ehci_hcd_au1xxx_drv_probe,
-	.remove = ehci_hcd_au1xxx_drv_remove,
-	.shutdown = usb_hcd_platform_shutdown,
-	/*.suspend      = ehci_hcd_au1xxx_drv_suspend, */
-	/*.resume       = ehci_hcd_au1xxx_drv_resume, */
-	.driver = {
-		.name = "au1xxx-ehci",
-		.bus = &platform_bus_type
-	}
-};
diff -urN host/.svn/text-base/ehci-dbg.c.svn-base host.new/.svn/text-base/ehci-dbg.c.svn-base
--- host/.svn/text-base/ehci-dbg.c.svn-base	2009-02-24 19:00:15.675956425 +0100
+++ host.new/.svn/text-base/ehci-dbg.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,814 +0,0 @@
-/*
- * Copyright (c) 2001-2002 by David Brownell
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/* this file is part of ehci-hcd.c */
-
-#define ehci_dbg(ehci, fmt, args...) \
-	dev_dbg (ehci_to_hcd(ehci)->self.controller , fmt , ## args )
-#define ehci_err(ehci, fmt, args...) \
-	dev_err (ehci_to_hcd(ehci)->self.controller , fmt , ## args )
-#define ehci_info(ehci, fmt, args...) \
-	dev_info (ehci_to_hcd(ehci)->self.controller , fmt , ## args )
-#define ehci_warn(ehci, fmt, args...) \
-	dev_warn (ehci_to_hcd(ehci)->self.controller , fmt , ## args )
-
-#ifdef EHCI_VERBOSE_DEBUG
-#	define vdbg dbg
-#	define ehci_vdbg ehci_dbg
-#else
-#	define vdbg(fmt,args...) do { } while (0)
-#	define ehci_vdbg(ehci, fmt, args...) do { } while (0)
-#endif
-
-#ifdef	DEBUG
-
-/* check the values in the HCSPARAMS register
- * (host controller _Structural_ parameters)
- * see EHCI spec, Table 2-4 for each value
- */
-static void dbg_hcs_params (struct ehci_hcd *ehci, char *label)
-{
-	u32	params = ehci_readl(ehci, &ehci->caps->hcs_params);
-
-	ehci_dbg (ehci,
-		"%s hcs_params 0x%x dbg=%d%s cc=%d pcc=%d%s%s ports=%d\n",
-		label, params,
-		HCS_DEBUG_PORT (params),
-		HCS_INDICATOR (params) ? " ind" : "",
-		HCS_N_CC (params),
-		HCS_N_PCC (params),
-		HCS_PORTROUTED (params) ? "" : " ordered",
-		HCS_PPC (params) ? "" : " !ppc",
-		HCS_N_PORTS (params)
-		);
-	/* Port routing, per EHCI 0.95 Spec, Section 2.2.5 */
-	if (HCS_PORTROUTED (params)) {
-		int i;
-		char buf [46], tmp [7], byte;
-
-		buf[0] = 0;
-		for (i = 0; i < HCS_N_PORTS (params); i++) {
-			// FIXME MIPS won't readb() ...
-			byte = readb (&ehci->caps->portroute[(i>>1)]);
-			sprintf(tmp, "%d ",
-				((i & 0x1) ? ((byte)&0xf) : ((byte>>4)&0xf)));
-			strcat(buf, tmp);
-		}
-		ehci_dbg (ehci, "%s portroute %s\n",
-				label, buf);
-	}
-}
-#else
-
-static inline void dbg_hcs_params (struct ehci_hcd *ehci, char *label) {}
-
-#endif
-
-#ifdef	DEBUG
-
-/* check the values in the HCCPARAMS register
- * (host controller _Capability_ parameters)
- * see EHCI Spec, Table 2-5 for each value
- * */
-static void dbg_hcc_params (struct ehci_hcd *ehci, char *label)
-{
-	u32	params = ehci_readl(ehci, &ehci->caps->hcc_params);
-
-	if (HCC_ISOC_CACHE (params)) {
-		ehci_dbg (ehci,
-			"%s hcc_params %04x caching frame %s%s%s\n",
-			label, params,
-			HCC_PGM_FRAMELISTLEN(params) ? "256/512/1024" : "1024",
-			HCC_CANPARK(params) ? " park" : "",
-			HCC_64BIT_ADDR(params) ? " 64 bit addr" : "");
-	} else {
-		ehci_dbg (ehci,
-			"%s hcc_params %04x thresh %d uframes %s%s%s\n",
-			label,
-			params,
-			HCC_ISOC_THRES(params),
-			HCC_PGM_FRAMELISTLEN(params) ? "256/512/1024" : "1024",
-			HCC_CANPARK(params) ? " park" : "",
-			HCC_64BIT_ADDR(params) ? " 64 bit addr" : "");
-	}
-}
-#else
-
-static inline void dbg_hcc_params (struct ehci_hcd *ehci, char *label) {}
-
-#endif
-
-#ifdef	DEBUG
-
-static void __maybe_unused
-dbg_qtd (const char *label, struct ehci_hcd *ehci, struct ehci_qtd *qtd)
-{
-	ehci_dbg(ehci, "%s td %p n%08x %08x t%08x p0=%08x\n", label, qtd,
-		hc32_to_cpup(ehci, &qtd->hw_next),
-		hc32_to_cpup(ehci, &qtd->hw_alt_next),
-		hc32_to_cpup(ehci, &qtd->hw_token),
-		hc32_to_cpup(ehci, &qtd->hw_buf [0]));
-	if (qtd->hw_buf [1])
-		ehci_dbg(ehci, "  p1=%08x p2=%08x p3=%08x p4=%08x\n",
-			hc32_to_cpup(ehci, &qtd->hw_buf[1]),
-			hc32_to_cpup(ehci, &qtd->hw_buf[2]),
-			hc32_to_cpup(ehci, &qtd->hw_buf[3]),
-			hc32_to_cpup(ehci, &qtd->hw_buf[4]));
-}
-
-static void __maybe_unused
-dbg_qh (const char *label, struct ehci_hcd *ehci, struct ehci_qh *qh)
-{
-	ehci_dbg (ehci, "%s qh %p n%08x info %x %x qtd %x\n", label,
-		qh, qh->hw_next, qh->hw_info1, qh->hw_info2,
-		qh->hw_current);
-	dbg_qtd ("overlay", ehci, (struct ehci_qtd *) &qh->hw_qtd_next);
-}
-
-static void __maybe_unused
-dbg_itd (const char *label, struct ehci_hcd *ehci, struct ehci_itd *itd)
-{
-	ehci_dbg (ehci, "%s [%d] itd %p, next %08x, urb %p\n",
-		label, itd->frame, itd, hc32_to_cpu(ehci, itd->hw_next),
-		itd->urb);
-	ehci_dbg (ehci,
-		"  trans: %08x %08x %08x %08x %08x %08x %08x %08x\n",
-		hc32_to_cpu(ehci, itd->hw_transaction[0]),
-		hc32_to_cpu(ehci, itd->hw_transaction[1]),
-		hc32_to_cpu(ehci, itd->hw_transaction[2]),
-		hc32_to_cpu(ehci, itd->hw_transaction[3]),
-		hc32_to_cpu(ehci, itd->hw_transaction[4]),
-		hc32_to_cpu(ehci, itd->hw_transaction[5]),
-		hc32_to_cpu(ehci, itd->hw_transaction[6]),
-		hc32_to_cpu(ehci, itd->hw_transaction[7]));
-	ehci_dbg (ehci,
-		"  buf:   %08x %08x %08x %08x %08x %08x %08x\n",
-		hc32_to_cpu(ehci, itd->hw_bufp[0]),
-		hc32_to_cpu(ehci, itd->hw_bufp[1]),
-		hc32_to_cpu(ehci, itd->hw_bufp[2]),
-		hc32_to_cpu(ehci, itd->hw_bufp[3]),
-		hc32_to_cpu(ehci, itd->hw_bufp[4]),
-		hc32_to_cpu(ehci, itd->hw_bufp[5]),
-		hc32_to_cpu(ehci, itd->hw_bufp[6]));
-	ehci_dbg (ehci, "  index: %d %d %d %d %d %d %d %d\n",
-		itd->index[0], itd->index[1], itd->index[2],
-		itd->index[3], itd->index[4], itd->index[5],
-		itd->index[6], itd->index[7]);
-}
-
-static void __maybe_unused
-dbg_sitd (const char *label, struct ehci_hcd *ehci, struct ehci_sitd *sitd)
-{
-	ehci_dbg (ehci, "%s [%d] sitd %p, next %08x, urb %p\n",
-		label, sitd->frame, sitd, hc32_to_cpu(ehci, sitd->hw_next),
-		sitd->urb);
-	ehci_dbg (ehci,
-		"  addr %08x sched %04x result %08x buf %08x %08x\n",
-		hc32_to_cpu(ehci, sitd->hw_fullspeed_ep),
-		hc32_to_cpu(ehci, sitd->hw_uframe),
-		hc32_to_cpu(ehci, sitd->hw_results),
-		hc32_to_cpu(ehci, sitd->hw_buf[0]),
-		hc32_to_cpu(ehci, sitd->hw_buf[1]));
-}
-
-static int __maybe_unused
-dbg_status_buf (char *buf, unsigned len, const char *label, u32 status)
-{
-	return scnprintf (buf, len,
-		"%s%sstatus %04x%s%s%s%s%s%s%s%s%s%s",
-		label, label [0] ? " " : "", status,
-		(status & STS_ASS) ? " Async" : "",
-		(status & STS_PSS) ? " Periodic" : "",
-		(status & STS_RECL) ? " Recl" : "",
-		(status & STS_HALT) ? " Halt" : "",
-		(status & STS_IAA) ? " IAA" : "",
-		(status & STS_FATAL) ? " FATAL" : "",
-		(status & STS_FLR) ? " FLR" : "",
-		(status & STS_PCD) ? " PCD" : "",
-		(status & STS_ERR) ? " ERR" : "",
-		(status & STS_INT) ? " INT" : ""
-		);
-}
-
-static int __maybe_unused
-dbg_intr_buf (char *buf, unsigned len, const char *label, u32 enable)
-{
-	return scnprintf (buf, len,
-		"%s%sintrenable %02x%s%s%s%s%s%s",
-		label, label [0] ? " " : "", enable,
-		(enable & STS_IAA) ? " IAA" : "",
-		(enable & STS_FATAL) ? " FATAL" : "",
-		(enable & STS_FLR) ? " FLR" : "",
-		(enable & STS_PCD) ? " PCD" : "",
-		(enable & STS_ERR) ? " ERR" : "",
-		(enable & STS_INT) ? " INT" : ""
-		);
-}
-
-static const char *const fls_strings [] =
-    { "1024", "512", "256", "??" };
-
-static int
-dbg_command_buf (char *buf, unsigned len, const char *label, u32 command)
-{
-	return scnprintf (buf, len,
-		"%s%scommand %06x %s=%d ithresh=%d%s%s%s%s period=%s%s %s",
-		label, label [0] ? " " : "", command,
-		(command & CMD_PARK) ? "park" : "(park)",
-		CMD_PARK_CNT (command),
-		(command >> 16) & 0x3f,
-		(command & CMD_LRESET) ? " LReset" : "",
-		(command & CMD_IAAD) ? " IAAD" : "",
-		(command & CMD_ASE) ? " Async" : "",
-		(command & CMD_PSE) ? " Periodic" : "",
-		fls_strings [(command >> 2) & 0x3],
-		(command & CMD_RESET) ? " Reset" : "",
-		(command & CMD_RUN) ? "RUN" : "HALT"
-		);
-}
-
-static int
-dbg_port_buf (char *buf, unsigned len, const char *label, int port, u32 status)
-{
-	char	*sig;
-
-	/* signaling state */
-	switch (status & (3 << 10)) {
-	case 0 << 10: sig = "se0"; break;
-	case 1 << 10: sig = "k"; break;		/* low speed */
-	case 2 << 10: sig = "j"; break;
-	default: sig = "?"; break;
-	}
-
-	return scnprintf (buf, len,
-		"%s%sport %d status %06x%s%s sig=%s%s%s%s%s%s%s%s%s%s",
-		label, label [0] ? " " : "", port, status,
-		(status & PORT_POWER) ? " POWER" : "",
-		(status & PORT_OWNER) ? " OWNER" : "",
-		sig,
-		(status & PORT_RESET) ? " RESET" : "",
-		(status & PORT_SUSPEND) ? " SUSPEND" : "",
-		(status & PORT_RESUME) ? " RESUME" : "",
-		(status & PORT_OCC) ? " OCC" : "",
-		(status & PORT_OC) ? " OC" : "",
-		(status & PORT_PEC) ? " PEC" : "",
-		(status & PORT_PE) ? " PE" : "",
-		(status & PORT_CSC) ? " CSC" : "",
-		(status & PORT_CONNECT) ? " CONNECT" : "");
-}
-
-#else
-static inline void __maybe_unused
-dbg_qh (char *label, struct ehci_hcd *ehci, struct ehci_qh *qh)
-{}
-
-static inline int __maybe_unused
-dbg_status_buf (char *buf, unsigned len, const char *label, u32 status)
-{ return 0; }
-
-static inline int __maybe_unused
-dbg_command_buf (char *buf, unsigned len, const char *label, u32 command)
-{ return 0; }
-
-static inline int __maybe_unused
-dbg_intr_buf (char *buf, unsigned len, const char *label, u32 enable)
-{ return 0; }
-
-static inline int __maybe_unused
-dbg_port_buf (char *buf, unsigned len, const char *label, int port, u32 status)
-{ return 0; }
-
-#endif	/* DEBUG */
-
-/* functions have the "wrong" filename when they're output... */
-#define dbg_status(ehci, label, status) { \
-	char _buf [80]; \
-	dbg_status_buf (_buf, sizeof _buf, label, status); \
-	ehci_dbg (ehci, "%s\n", _buf); \
-}
-
-#define dbg_cmd(ehci, label, command) { \
-	char _buf [80]; \
-	dbg_command_buf (_buf, sizeof _buf, label, command); \
-	ehci_dbg (ehci, "%s\n", _buf); \
-}
-
-#define dbg_port(ehci, label, port, status) { \
-	char _buf [80]; \
-	dbg_port_buf (_buf, sizeof _buf, label, port, status); \
-	ehci_dbg (ehci, "%s\n", _buf); \
-}
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef STUB_DEBUG_FILES
-
-static inline void create_debug_files (struct ehci_hcd *bus) { }
-static inline void remove_debug_files (struct ehci_hcd *bus) { }
-
-#else
-
-/* troubleshooting help: expose state in sysfs */
-
-#define speed_char(info1) ({ char tmp; \
-		switch (info1 & (3 << 12)) { \
-		case 0 << 12: tmp = 'f'; break; \
-		case 1 << 12: tmp = 'l'; break; \
-		case 2 << 12: tmp = 'h'; break; \
-		default: tmp = '?'; break; \
-		}; tmp; })
-
-static inline char token_mark(struct ehci_hcd *ehci, __hc32 token)
-{
-	__u32 v = hc32_to_cpu(ehci, token);
-
-	if (v & QTD_STS_ACTIVE)
-		return '*';
-	if (v & QTD_STS_HALT)
-		return '-';
-	if (!IS_SHORT_READ (v))
-		return ' ';
-	/* tries to advance through hw_alt_next */
-	return '/';
-}
-
-static void qh_lines (
-	struct ehci_hcd *ehci,
-	struct ehci_qh *qh,
-	char **nextp,
-	unsigned *sizep
-)
-{
-	u32			scratch;
-	u32			hw_curr;
-	struct list_head	*entry;
-	struct ehci_qtd		*td;
-	unsigned		temp;
-	unsigned		size = *sizep;
-	char			*next = *nextp;
-	char			mark;
-	u32			list_end = EHCI_LIST_END(ehci);
-
-	if (qh->hw_qtd_next == list_end)	/* NEC does this */
-		mark = '@';
-	else
-		mark = token_mark(ehci, qh->hw_token);
-	if (mark == '/') {	/* qh_alt_next controls qh advance? */
-		if ((qh->hw_alt_next & QTD_MASK(ehci))
-				== ehci->async->hw_alt_next)
-			mark = '#';	/* blocked */
-		else if (qh->hw_alt_next == list_end)
-			mark = '.';	/* use hw_qtd_next */
-		/* else alt_next points to some other qtd */
-	}
-	scratch = hc32_to_cpup(ehci, &qh->hw_info1);
-	hw_curr = (mark == '*') ? hc32_to_cpup(ehci, &qh->hw_current) : 0;
-	temp = scnprintf (next, size,
-			"qh/%p dev%d %cs ep%d %08x %08x (%08x%c %s nak%d)",
-			qh, scratch & 0x007f,
-			speed_char (scratch),
-			(scratch >> 8) & 0x000f,
-			scratch, hc32_to_cpup(ehci, &qh->hw_info2),
-			hc32_to_cpup(ehci, &qh->hw_token), mark,
-			(cpu_to_hc32(ehci, QTD_TOGGLE) & qh->hw_token)
-				? "data1" : "data0",
-			(hc32_to_cpup(ehci, &qh->hw_alt_next) >> 1) & 0x0f);
-	size -= temp;
-	next += temp;
-
-	/* hc may be modifying the list as we read it ... */
-	list_for_each (entry, &qh->qtd_list) {
-		td = list_entry (entry, struct ehci_qtd, qtd_list);
-		scratch = hc32_to_cpup(ehci, &td->hw_token);
-		mark = ' ';
-		if (hw_curr == td->qtd_dma)
-			mark = '*';
-		else if (qh->hw_qtd_next == cpu_to_hc32(ehci, td->qtd_dma))
-			mark = '+';
-		else if (QTD_LENGTH (scratch)) {
-			if (td->hw_alt_next == ehci->async->hw_alt_next)
-				mark = '#';
-			else if (td->hw_alt_next != list_end)
-				mark = '/';
-		}
-		temp = snprintf (next, size,
-				"\n\t%p%c%s len=%d %08x urb %p",
-				td, mark, ({ char *tmp;
-				 switch ((scratch>>8)&0x03) {
-				 case 0: tmp = "out"; break;
-				 case 1: tmp = "in"; break;
-				 case 2: tmp = "setup"; break;
-				 default: tmp = "?"; break;
-				 } tmp;}),
-				(scratch >> 16) & 0x7fff,
-				scratch,
-				td->urb);
-		if (temp < 0)
-			temp = 0;
-		else if (size < temp)
-			temp = size;
-		size -= temp;
-		next += temp;
-		if (temp == size)
-			goto done;
-	}
-
-	temp = snprintf (next, size, "\n");
-	if (temp < 0)
-		temp = 0;
-	else if (size < temp)
-		temp = size;
-	size -= temp;
-	next += temp;
-
-done:
-	*sizep = size;
-	*nextp = next;
-}
-
-static ssize_t
-show_async (struct class_device *class_dev, char *buf)
-{
-	struct usb_bus		*bus;
-	struct usb_hcd		*hcd;
-	struct ehci_hcd		*ehci;
-	unsigned long		flags;
-	unsigned		temp, size;
-	char			*next;
-	struct ehci_qh		*qh;
-
-	*buf = 0;
-
-	bus = class_get_devdata(class_dev);
-	hcd = bus_to_hcd(bus);
-	ehci = hcd_to_ehci (hcd);
-	next = buf;
-	size = PAGE_SIZE;
-
-	/* dumps a snapshot of the async schedule.
-	 * usually empty except for long-term bulk reads, or head.
-	 * one QH per line, and TDs we know about
-	 */
-	spin_lock_irqsave (&ehci->lock, flags);
-	for (qh = ehci->async->qh_next.qh; size > 0 && qh; qh = qh->qh_next.qh)
-		qh_lines (ehci, qh, &next, &size);
-	if (ehci->reclaim && size > 0) {
-		temp = scnprintf (next, size, "\nreclaim =\n");
-		size -= temp;
-		next += temp;
-
-		for (qh = ehci->reclaim; size > 0 && qh; qh = qh->reclaim)
-			qh_lines (ehci, qh, &next, &size);
-	}
-	spin_unlock_irqrestore (&ehci->lock, flags);
-
-	return strlen (buf);
-}
-static CLASS_DEVICE_ATTR (async, S_IRUGO, show_async, NULL);
-
-#define DBG_SCHED_LIMIT 64
-
-static ssize_t
-show_periodic (struct class_device *class_dev, char *buf)
-{
-	struct usb_bus		*bus;
-	struct usb_hcd		*hcd;
-	struct ehci_hcd		*ehci;
-	unsigned long		flags;
-	union ehci_shadow	p, *seen;
-	unsigned		temp, size, seen_count;
-	char			*next;
-	unsigned		i;
-	__hc32			tag;
-
-	if (!(seen = kmalloc (DBG_SCHED_LIMIT * sizeof *seen, GFP_ATOMIC)))
-		return 0;
-	seen_count = 0;
-
-	bus = class_get_devdata(class_dev);
-	hcd = bus_to_hcd(bus);
-	ehci = hcd_to_ehci (hcd);
-	next = buf;
-	size = PAGE_SIZE;
-
-	temp = scnprintf (next, size, "size = %d\n", ehci->periodic_size);
-	size -= temp;
-	next += temp;
-
-	/* dump a snapshot of the periodic schedule.
-	 * iso changes, interrupt usually doesn't.
-	 */
-	spin_lock_irqsave (&ehci->lock, flags);
-	for (i = 0; i < ehci->periodic_size; i++) {
-		p = ehci->pshadow [i];
-		if (likely (!p.ptr))
-			continue;
-		tag = Q_NEXT_TYPE(ehci, ehci->periodic [i]);
-
-		temp = scnprintf (next, size, "%4d: ", i);
-		size -= temp;
-		next += temp;
-
-		do {
-			switch (hc32_to_cpu(ehci, tag)) {
-			case Q_TYPE_QH:
-				temp = scnprintf (next, size, " qh%d-%04x/%p",
-						p.qh->period,
-						hc32_to_cpup(ehci,
-								&p.qh->hw_info2)
-							/* uframe masks */
-							& (QH_CMASK | QH_SMASK),
-						p.qh);
-				size -= temp;
-				next += temp;
-				/* don't repeat what follows this qh */
-				for (temp = 0; temp < seen_count; temp++) {
-					if (seen [temp].ptr != p.ptr)
-						continue;
-					if (p.qh->qh_next.ptr)
-						temp = scnprintf (next, size,
-							" ...");
-					p.ptr = NULL;
-					break;
-				}
-				/* show more info the first time around */
-				if (temp == seen_count && p.ptr) {
-					u32	scratch = hc32_to_cpup(ehci,
-							&p.qh->hw_info1);
-					struct ehci_qtd	*qtd;
-					char		*type = "";
-
-					/* count tds, get ep direction */
-					temp = 0;
-					list_for_each_entry (qtd,
-							&p.qh->qtd_list,
-							qtd_list) {
-						temp++;
-						switch (0x03 & (hc32_to_cpu(
-							ehci,
-							qtd->hw_token) >> 8)) {
-						case 0: type = "out"; continue;
-						case 1: type = "in"; continue;
-						}
-					}
-
-					temp = scnprintf (next, size,
-						" (%c%d ep%d%s "
-						"[%d/%d] q%d p%d)",
-						speed_char (scratch),
-						scratch & 0x007f,
-						(scratch >> 8) & 0x000f, type,
-						p.qh->usecs, p.qh->c_usecs,
-						temp,
-						0x7ff & (scratch >> 16));
-
-					if (seen_count < DBG_SCHED_LIMIT)
-						seen [seen_count++].qh = p.qh;
-				} else
-					temp = 0;
-				if (p.qh) {
-					tag = Q_NEXT_TYPE(ehci, p.qh->hw_next);
-					p = p.qh->qh_next;
-				}
-				break;
-			case Q_TYPE_FSTN:
-				temp = scnprintf (next, size,
-					" fstn-%8x/%p", p.fstn->hw_prev,
-					p.fstn);
-				tag = Q_NEXT_TYPE(ehci, p.fstn->hw_next);
-				p = p.fstn->fstn_next;
-				break;
-			case Q_TYPE_ITD:
-				temp = scnprintf (next, size,
-					" itd/%p", p.itd);
-				tag = Q_NEXT_TYPE(ehci, p.itd->hw_next);
-				p = p.itd->itd_next;
-				break;
-			case Q_TYPE_SITD:
-				temp = scnprintf (next, size,
-					" sitd%d-%04x/%p",
-					p.sitd->stream->interval,
-					hc32_to_cpup(ehci, &p.sitd->hw_uframe)
-						& 0x0000ffff,
-					p.sitd);
-				tag = Q_NEXT_TYPE(ehci, p.sitd->hw_next);
-				p = p.sitd->sitd_next;
-				break;
-			}
-			size -= temp;
-			next += temp;
-		} while (p.ptr);
-
-		temp = scnprintf (next, size, "\n");
-		size -= temp;
-		next += temp;
-	}
-	spin_unlock_irqrestore (&ehci->lock, flags);
-	kfree (seen);
-
-	return PAGE_SIZE - size;
-}
-static CLASS_DEVICE_ATTR (periodic, S_IRUGO, show_periodic, NULL);
-
-#undef DBG_SCHED_LIMIT
-
-static ssize_t
-show_registers (struct class_device *class_dev, char *buf)
-{
-	struct usb_bus		*bus;
-	struct usb_hcd		*hcd;
-	struct ehci_hcd		*ehci;
-	unsigned long		flags;
-	unsigned		temp, size, i;
-	char			*next, scratch [80];
-	static char		fmt [] = "%*s\n";
-	static char		label [] = "";
-
-	bus = class_get_devdata(class_dev);
-	hcd = bus_to_hcd(bus);
-	ehci = hcd_to_ehci (hcd);
-	next = buf;
-	size = PAGE_SIZE;
-
-	spin_lock_irqsave (&ehci->lock, flags);
-
-	if (bus->controller->power.power_state.event) {
-		size = scnprintf (next, size,
-			"bus %s, device %s (driver " DRIVER_VERSION ")\n"
-			"%s\n"
-			"SUSPENDED (no register access)\n",
-			hcd->self.controller->bus->name,
-			hcd->self.controller->bus_id,
-			hcd->product_desc);
-		goto done;
-	}
-
-	/* Capability Registers */
-	i = HC_VERSION(ehci_readl(ehci, &ehci->caps->hc_capbase));
-	temp = scnprintf (next, size,
-		"bus %s, device %s (driver " DRIVER_VERSION ")\n"
-		"%s\n"
-		"EHCI %x.%02x, hcd state %d\n",
-		hcd->self.controller->bus->name,
-		hcd->self.controller->bus_id,
-		hcd->product_desc,
-		i >> 8, i & 0x0ff, hcd->state);
-	size -= temp;
-	next += temp;
-
-#ifdef	CONFIG_PCI
-	/* EHCI 0.96 and later may have "extended capabilities" */
-	if (hcd->self.controller->bus == &pci_bus_type) {
-		struct pci_dev	*pdev;
-		u32		offset, cap, cap2;
-		unsigned	count = 256/4;
-
-		pdev = to_pci_dev(ehci_to_hcd(ehci)->self.controller);
-		offset = HCC_EXT_CAPS(ehci_readl(ehci,
-				&ehci->caps->hcc_params));
-		while (offset && count--) {
-			pci_read_config_dword (pdev, offset, &cap);
-			switch (cap & 0xff) {
-			case 1:
-				temp = scnprintf (next, size,
-					"ownership %08x%s%s\n", cap,
-					(cap & (1 << 24)) ? " linux" : "",
-					(cap & (1 << 16)) ? " firmware" : "");
-				size -= temp;
-				next += temp;
-
-				offset += 4;
-				pci_read_config_dword (pdev, offset, &cap2);
-				temp = scnprintf (next, size,
-					"SMI sts/enable 0x%08x\n", cap2);
-				size -= temp;
-				next += temp;
-				break;
-			case 0:		/* illegal reserved capability */
-				cap = 0;
-				/* FALLTHROUGH */
-			default:		/* unknown */
-				break;
-			}
-			temp = (cap >> 8) & 0xff;
-		}
-	}
-#endif
-
-	// FIXME interpret both types of params
-	i = ehci_readl(ehci, &ehci->caps->hcs_params);
-	temp = scnprintf (next, size, "structural params 0x%08x\n", i);
-	size -= temp;
-	next += temp;
-
-	i = ehci_readl(ehci, &ehci->caps->hcc_params);
-	temp = scnprintf (next, size, "capability params 0x%08x\n", i);
-	size -= temp;
-	next += temp;
-
-	/* Operational Registers */
-	temp = dbg_status_buf (scratch, sizeof scratch, label,
-			ehci_readl(ehci, &ehci->regs->status));
-	temp = scnprintf (next, size, fmt, temp, scratch);
-	size -= temp;
-	next += temp;
-
-	temp = dbg_command_buf (scratch, sizeof scratch, label,
-			ehci_readl(ehci, &ehci->regs->command));
-	temp = scnprintf (next, size, fmt, temp, scratch);
-	size -= temp;
-	next += temp;
-
-	temp = dbg_intr_buf (scratch, sizeof scratch, label,
-			ehci_readl(ehci, &ehci->regs->intr_enable));
-	temp = scnprintf (next, size, fmt, temp, scratch);
-	size -= temp;
-	next += temp;
-
-	temp = scnprintf (next, size, "uframe %04x\n",
-			ehci_readl(ehci, &ehci->regs->frame_index));
-	size -= temp;
-	next += temp;
-
-	for (i = 1; i <= HCS_N_PORTS (ehci->hcs_params); i++) {
-		temp = dbg_port_buf (scratch, sizeof scratch, label, i,
-				ehci_readl(ehci,
-					&ehci->regs->port_status[i - 1]));
-		temp = scnprintf (next, size, fmt, temp, scratch);
-		size -= temp;
-		next += temp;
-		if (i == HCS_DEBUG_PORT(ehci->hcs_params) && ehci->debug) {
-			temp = scnprintf (next, size,
-					"    debug control %08x\n",
-					ehci_readl(ehci,
-						&ehci->debug->control));
-			size -= temp;
-			next += temp;
-		}
-	}
-
-	if (ehci->reclaim) {
-		temp = scnprintf (next, size, "reclaim qh %p%s\n",
-				ehci->reclaim,
-				ehci->reclaim_ready ? " ready" : "");
-		size -= temp;
-		next += temp;
-	}
-
-#ifdef EHCI_STATS
-	temp = scnprintf (next, size,
-		"irq normal %ld err %ld reclaim %ld (lost %ld)\n",
-		ehci->stats.normal, ehci->stats.error, ehci->stats.reclaim,
-		ehci->stats.lost_iaa);
-	size -= temp;
-	next += temp;
-
-	temp = scnprintf (next, size, "complete %ld unlink %ld\n",
-		ehci->stats.complete, ehci->stats.unlink);
-	size -= temp;
-	next += temp;
-#endif
-
-done:
-	spin_unlock_irqrestore (&ehci->lock, flags);
-
-	return PAGE_SIZE - size;
-}
-static CLASS_DEVICE_ATTR (registers, S_IRUGO, show_registers, NULL);
-
-static inline void create_debug_files (struct ehci_hcd *ehci)
-{
-	struct class_device *cldev = ehci_to_hcd(ehci)->self.class_dev;
-	int retval;
-
-	retval = class_device_create_file(cldev, &class_device_attr_async);
-	retval = class_device_create_file(cldev, &class_device_attr_periodic);
-	retval = class_device_create_file(cldev, &class_device_attr_registers);
-}
-
-static inline void remove_debug_files (struct ehci_hcd *ehci)
-{
-	struct class_device *cldev = ehci_to_hcd(ehci)->self.class_dev;
-
-	class_device_remove_file(cldev, &class_device_attr_async);
-	class_device_remove_file(cldev, &class_device_attr_periodic);
-	class_device_remove_file(cldev, &class_device_attr_registers);
-}
-
-#endif /* STUB_DEBUG_FILES */
-
diff -urN host/.svn/text-base/ehci-fsl.c.svn-base host.new/.svn/text-base/ehci-fsl.c.svn-base
--- host/.svn/text-base/ehci-fsl.c.svn-base	2009-02-24 19:00:15.679956221 +0100
+++ host.new/.svn/text-base/ehci-fsl.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,354 +0,0 @@
-/*
- * (C) Copyright David Brownell 2000-2002
- * Copyright (c) 2005 MontaVista Software
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- * Ported to 834x by Randy Vinson <rvinson@mvista.com> using code provided
- * by Hunter Wu.
- */
-
-#include <linux/platform_device.h>
-#include <linux/fsl_devices.h>
-
-#include "ehci-fsl.h"
-
-/* FIXME: Power Managment is un-ported so temporarily disable it */
-#undef CONFIG_PM
-
-/* PCI-based HCs are common, but plenty of non-PCI HCs are used too */
-
-/* configure so an HC device and id are always provided */
-/* always called with process context; sleeping is OK */
-
-/**
- * usb_hcd_fsl_probe - initialize FSL-based HCDs
- * @drvier: Driver to be used for this HCD
- * @pdev: USB Host Controller being probed
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller.
- *
- */
-int usb_hcd_fsl_probe(const struct hc_driver *driver,
-		      struct platform_device *pdev)
-{
-	struct fsl_usb2_platform_data *pdata;
-	struct usb_hcd *hcd;
-	struct resource *res;
-	int irq;
-	int retval;
-	unsigned int temp;
-
-	pr_debug("initializing FSL-SOC USB Controller\n");
-
-	/* Need platform data for setup */
-	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
-	if (!pdata) {
-		dev_err(&pdev->dev,
-			"No platform data for %s.\n", pdev->dev.bus_id);
-		return -ENODEV;
-	}
-
-	/*
-	 * This is a host mode driver, verify that we're supposed to be
-	 * in host mode.
-	 */
-	if (!((pdata->operating_mode == FSL_USB2_DR_HOST) ||
-	      (pdata->operating_mode == FSL_USB2_MPH_HOST) ||
-	      (pdata->operating_mode == FSL_USB2_DR_OTG))) {
-		dev_err(&pdev->dev,
-			"Non Host Mode configured for %s. Wrong driver linked.\n",
-			pdev->dev.bus_id);
-		return -ENODEV;
-	}
-
-	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (!res) {
-		dev_err(&pdev->dev,
-			"Found HC with no IRQ. Check %s setup!\n",
-			pdev->dev.bus_id);
-		return -ENODEV;
-	}
-	irq = res->start;
-
-	hcd = usb_create_hcd(driver, &pdev->dev, pdev->dev.bus_id);
-	if (!hcd) {
-		retval = -ENOMEM;
-		goto err1;
-	}
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev,
-			"Found HC with no register addr. Check %s setup!\n",
-			pdev->dev.bus_id);
-		retval = -ENODEV;
-		goto err2;
-	}
-	hcd->rsrc_start = res->start;
-	hcd->rsrc_len = res->end - res->start + 1;
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
-				driver->description)) {
-		dev_dbg(&pdev->dev, "controller already in use\n");
-		retval = -EBUSY;
-		goto err2;
-	}
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-
-	if (hcd->regs == NULL) {
-		dev_dbg(&pdev->dev, "error mapping memory\n");
-		retval = -EFAULT;
-		goto err3;
-	}
-
-	/* Enable USB controller */
-	temp = in_be32(hcd->regs + 0x500);
-	out_be32(hcd->regs + 0x500, temp | 0x4);
-
-	/* Set to Host mode */
-	temp = in_le32(hcd->regs + 0x1a8);
-	out_le32(hcd->regs + 0x1a8, temp | 0x3);
-
-	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
-	if (retval != 0)
-		goto err4;
-	return retval;
-
-      err4:
-	iounmap(hcd->regs);
-      err3:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-      err2:
-	usb_put_hcd(hcd);
-      err1:
-	dev_err(&pdev->dev, "init %s fail, %d\n", pdev->dev.bus_id, retval);
-	return retval;
-}
-
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_hcd_fsl_remove - shutdown processing for FSL-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_hcd_fsl_probe().
- *
- */
-void usb_hcd_fsl_remove(struct usb_hcd *hcd, struct platform_device *pdev)
-{
-	usb_remove_hcd(hcd);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-}
-
-static void mpc83xx_setup_phy(struct ehci_hcd *ehci,
-			      enum fsl_usb2_phy_modes phy_mode,
-			      unsigned int port_offset)
-{
-	u32 portsc = 0;
-	switch (phy_mode) {
-	case FSL_USB2_PHY_ULPI:
-		portsc |= PORT_PTS_ULPI;
-		break;
-	case FSL_USB2_PHY_SERIAL:
-		portsc |= PORT_PTS_SERIAL;
-		break;
-	case FSL_USB2_PHY_UTMI_WIDE:
-		portsc |= PORT_PTS_PTW;
-		/* fall through */
-	case FSL_USB2_PHY_UTMI:
-		portsc |= PORT_PTS_UTMI;
-		break;
-	case FSL_USB2_PHY_NONE:
-		break;
-	}
-	ehci_writel(ehci, portsc, &ehci->regs->port_status[port_offset]);
-}
-
-static void mpc83xx_usb_setup(struct usb_hcd *hcd)
-{
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	struct fsl_usb2_platform_data *pdata;
-	void __iomem *non_ehci = hcd->regs;
-	u32 temp;
-
-	pdata =
-	    (struct fsl_usb2_platform_data *)hcd->self.controller->
-	    platform_data;
-	/* Enable PHY interface in the control reg. */
-	temp = in_be32(non_ehci + FSL_SOC_USB_CTRL);
-	out_be32(non_ehci + FSL_SOC_USB_CTRL, temp | 0x00000004);
-	out_be32(non_ehci + FSL_SOC_USB_SNOOP1, 0x0000001b);
-
-#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
-	/*
-	 * Turn on cache snooping hardware, since some PowerPC platforms
-	 * wholly rely on hardware to deal with cache coherent
-	 */
-
-	/* Setup Snooping for all the 4GB space */
-	/* SNOOP1 starts from 0x0, size 2G */
-	out_be32(non_ehci + FSL_SOC_USB_SNOOP1, 0x0 | SNOOP_SIZE_2GB);
-	/* SNOOP2 starts from 0x80000000, size 2G */
-	out_be32(non_ehci + FSL_SOC_USB_SNOOP2, 0x80000000 | SNOOP_SIZE_2GB);
-#endif
-
-	if ((pdata->operating_mode == FSL_USB2_DR_HOST) ||
-			(pdata->operating_mode == FSL_USB2_DR_OTG))
-		mpc83xx_setup_phy(ehci, pdata->phy_mode, 0);
-
-	if (pdata->operating_mode == FSL_USB2_MPH_HOST) {
-		unsigned int chip, rev, svr;
-
-		svr = mfspr(SPRN_SVR);
-		chip = svr >> 16;
-		rev = (svr >> 4) & 0xf;
-
-		/* Deal with USB Erratum #14 on MPC834x Rev 1.0 & 1.1 chips */
-		if ((rev == 1) && (chip >= 0x8050) && (chip <= 0x8055))
-			ehci->has_fsl_port_bug = 1;
-
-		if (pdata->port_enables & FSL_USB2_PORT0_ENABLED)
-			mpc83xx_setup_phy(ehci, pdata->phy_mode, 0);
-		if (pdata->port_enables & FSL_USB2_PORT1_ENABLED)
-			mpc83xx_setup_phy(ehci, pdata->phy_mode, 1);
-	}
-
-	/* put controller in host mode. */
-	ehci_writel(ehci, 0x00000003, non_ehci + FSL_SOC_USB_USBMODE);
-	out_be32(non_ehci + FSL_SOC_USB_PRICTRL, 0x0000000c);
-	out_be32(non_ehci + FSL_SOC_USB_AGECNTTHRSH, 0x00000040);
-	out_be32(non_ehci + FSL_SOC_USB_SICTRL, 0x00000001);
-}
-
-/* called after powerup, by probe or system-pm "wakeup" */
-static int ehci_fsl_reinit(struct ehci_hcd *ehci)
-{
-	mpc83xx_usb_setup(ehci_to_hcd(ehci));
-	ehci_port_power(ehci, 0);
-
-	return 0;
-}
-
-/* called during probe() after chip reset completes */
-static int ehci_fsl_setup(struct usb_hcd *hcd)
-{
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	int retval;
-
-	/* EHCI registers start at offset 0x100 */
-	ehci->caps = hcd->regs + 0x100;
-	ehci->regs = hcd->regs + 0x100 +
-	    HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-	/* cache this readonly data; minimize chip reads */
-	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
-
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
-
-	/* data structure init */
-	retval = ehci_init(hcd);
-	if (retval)
-		return retval;
-
-	ehci->is_tdi_rh_tt = 1;
-
-	ehci->sbrn = 0x20;
-
-	ehci_reset(ehci);
-
-	retval = ehci_fsl_reinit(ehci);
-	return retval;
-}
-
-static const struct hc_driver ehci_fsl_hc_driver = {
-	.description = hcd_name,
-	.product_desc = "Freescale On-Chip EHCI Host Controller",
-	.hcd_priv_size = sizeof(struct ehci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq = ehci_irq,
-	.flags = HCD_USB2,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset = ehci_fsl_setup,
-	.start = ehci_run,
-#ifdef	CONFIG_PM
-	.suspend = ehci_bus_suspend,
-	.resume = ehci_bus_resume,
-#endif
-	.stop = ehci_stop,
-	.shutdown = ehci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue = ehci_urb_enqueue,
-	.urb_dequeue = ehci_urb_dequeue,
-	.endpoint_disable = ehci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number = ehci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data = ehci_hub_status_data,
-	.hub_control = ehci_hub_control,
-	.bus_suspend = ehci_bus_suspend,
-	.bus_resume = ehci_bus_resume,
-};
-
-static int ehci_fsl_drv_probe(struct platform_device *pdev)
-{
-	if (usb_disabled())
-		return -ENODEV;
-
-	return usb_hcd_fsl_probe(&ehci_fsl_hc_driver, pdev);
-}
-
-static int ehci_fsl_drv_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	usb_hcd_fsl_remove(hcd, pdev);
-
-	return 0;
-}
-
-MODULE_ALIAS("fsl-ehci");
-
-static struct platform_driver ehci_fsl_driver = {
-	.probe = ehci_fsl_drv_probe,
-	.remove = ehci_fsl_drv_remove,
-	.shutdown = usb_hcd_platform_shutdown,
-	.driver = {
-		   .name = "fsl-ehci",
-		   },
-};
diff -urN host/.svn/text-base/ehci-fsl.h.svn-base host.new/.svn/text-base/ehci-fsl.h.svn-base
--- host/.svn/text-base/ehci-fsl.h.svn-base	2009-02-24 19:00:15.679956221 +0100
+++ host.new/.svn/text-base/ehci-fsl.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,38 +0,0 @@
-/* Copyright (c) 2005 freescale semiconductor
- * Copyright (c) 2005 MontaVista Software
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the  GNU General Public License along
- * with this program; if not, write  to the Free Software Foundation, Inc.,
- * 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-#ifndef _EHCI_FSL_H
-#define _EHCI_FSL_H
-
-/* offsets for the non-ehci registers in the FSL SOC USB controller */
-#define FSL_SOC_USB_ULPIVP	0x170
-#define FSL_SOC_USB_PORTSC1	0x184
-#define PORT_PTS_MSK		(3<<30)
-#define PORT_PTS_UTMI		(0<<30)
-#define PORT_PTS_ULPI		(2<<30)
-#define	PORT_PTS_SERIAL		(3<<30)
-#define PORT_PTS_PTW		(1<<28)
-#define FSL_SOC_USB_PORTSC2	0x188
-#define FSL_SOC_USB_USBMODE	0x1a8
-#define FSL_SOC_USB_SNOOP1	0x400	/* NOTE: big-endian */
-#define FSL_SOC_USB_SNOOP2	0x404	/* NOTE: big-endian */
-#define FSL_SOC_USB_AGECNTTHRSH	0x408	/* NOTE: big-endian */
-#define FSL_SOC_USB_PRICTRL	0x40c	/* NOTE: big-endian */
-#define FSL_SOC_USB_SICTRL	0x410	/* NOTE: big-endian */
-#define FSL_SOC_USB_CTRL	0x500	/* NOTE: big-endian */
-#define SNOOP_SIZE_2GB		0x1e
-#endif				/* _EHCI_FSL_H */
diff -urN host/.svn/text-base/ehci-hcd.c.svn-base host.new/.svn/text-base/ehci-hcd.c.svn-base
--- host/.svn/text-base/ehci-hcd.c.svn-base	2009-02-24 19:00:15.695955408 +0100
+++ host.new/.svn/text-base/ehci-hcd.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,1058 +0,0 @@
-/*
- * Copyright (c) 2000-2004 by David Brownell
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include <linux/module.h>
-#include <linux/pci.h>
-#include <linux/dmapool.h>
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/ioport.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/timer.h>
-#include <linux/list.h>
-#include <linux/interrupt.h>
-#include <linux/reboot.h>
-#include <linux/usb.h>
-#include <linux/moduleparam.h>
-#include <linux/dma-mapping.h>
-
-#include "../core/hcd.h"
-
-#include <asm/byteorder.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/system.h>
-#include <asm/unaligned.h>
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * EHCI hc_driver implementation ... experimental, incomplete.
- * Based on the final 1.0 register interface specification.
- *
- * USB 2.0 shows up in upcoming www.pcmcia.org technology.
- * First was PCMCIA, like ISA; then CardBus, which is PCI.
- * Next comes "CardBay", using USB 2.0 signals.
- *
- * Contains additional contributions by Brad Hards, Rory Bolt, and others.
- * Special thanks to Intel and VIA for providing host controllers to
- * test this driver on, and Cypress (including In-System Design) for
- * providing early devices for those host controllers to talk to!
- *
- * HISTORY:
- *
- * 2004-05-10 Root hub and PCI suspend/resume support; remote wakeup. (db)
- * 2004-02-24 Replace pci_* with generic dma_* API calls (dsaxena@plexity.net)
- * 2003-12-29 Rewritten high speed iso transfer support (by Michal Sojka,
- *	<sojkam@centrum.cz>, updates by DB).
- *
- * 2002-11-29	Correct handling for hw async_next register.
- * 2002-08-06	Handling for bulk and interrupt transfers is mostly shared;
- *	only scheduling is different, no arbitrary limitations.
- * 2002-07-25	Sanity check PCI reads, mostly for better cardbus support,
- *	clean up HC run state handshaking.
- * 2002-05-24	Preliminary FS/LS interrupts, using scheduling shortcuts
- * 2002-05-11	Clear TT errors for FS/LS ctrl/bulk.  Fill in some other
- *	missing pieces:  enabling 64bit dma, handoff from BIOS/SMM.
- * 2002-05-07	Some error path cleanups to report better errors; wmb();
- *	use non-CVS version id; better iso bandwidth claim.
- * 2002-04-19	Control/bulk/interrupt submit no longer uses giveback() on
- *	errors in submit path.  Bugfixes to interrupt scheduling/processing.
- * 2002-03-05	Initial high-speed ISO support; reduce ITD memory; shift
- *	more checking to generic hcd framework (db).  Make it work with
- *	Philips EHCI; reduce PCI traffic; shorten IRQ path (Rory Bolt).
- * 2002-01-14	Minor cleanup; version synch.
- * 2002-01-08	Fix roothub handoff of FS/LS to companion controllers.
- * 2002-01-04	Control/Bulk queuing behaves.
- *
- * 2001-12-12	Initial patch version for Linux 2.5.1 kernel.
- * 2001-June	Works with usb-storage and NEC EHCI on 2.4
- */
-
-#define DRIVER_VERSION "10 Dec 2004"
-#define DRIVER_AUTHOR "David Brownell"
-#define DRIVER_DESC "USB 2.0 'Enhanced' Host Controller (EHCI) Driver"
-
-static const char	hcd_name [] = "ehci_hcd";
-
-
-#undef EHCI_VERBOSE_DEBUG
-#undef EHCI_URB_TRACE
-
-#ifdef DEBUG
-#define EHCI_STATS
-#endif
-
-/* magic numbers that can affect system performance */
-#define	EHCI_TUNE_CERR		3	/* 0-3 qtd retries; 0 == don't stop */
-#define	EHCI_TUNE_RL_HS		4	/* nak throttle; see 4.9 */
-#define	EHCI_TUNE_RL_TT		0
-#define	EHCI_TUNE_MULT_HS	1	/* 1-3 transactions/uframe; 4.10.3 */
-#define	EHCI_TUNE_MULT_TT	1
-#define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
-
-#define EHCI_IAA_JIFFIES	(HZ/100)	/* arbitrary; ~10 msec */
-#define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
-#define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
-#define EHCI_SHRINK_JIFFIES	(HZ/200)	/* async qh unlink delay */
-
-/* Initial IRQ latency:  faster than hw default */
-static int log2_irq_thresh = 0;		// 0 to 6
-module_param (log2_irq_thresh, int, S_IRUGO);
-MODULE_PARM_DESC (log2_irq_thresh, "log2 IRQ latency, 1-64 microframes");
-
-/* initial park setting:  slower than hw default */
-static unsigned park = 0;
-module_param (park, uint, S_IRUGO);
-MODULE_PARM_DESC (park, "park setting; 1-3 back-to-back async packets");
-
-/* for flakey hardware, ignore overcurrent indicators */
-static int ignore_oc = 1;
-module_param (ignore_oc, bool, S_IRUGO);
-MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
-
-#define	INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
-
-/*-------------------------------------------------------------------------*/
-
-#include "ehci.h"
-#include "ehci-dbg.c"
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * handshake - spin reading hc until handshake completes or fails
- * @ptr: address of hc register to be read
- * @mask: bits to look at in result of read
- * @done: value of those bits when handshake succeeds
- * @usec: timeout in microseconds
- *
- * Returns negative errno, or zero on success
- *
- * Success happens when the "mask" bits have the specified value (hardware
- * handshake done).  There are two failure modes:  "usec" have passed (major
- * hardware flakeout), or the register reads as all-ones (hardware removed).
- *
- * That last failure should_only happen in cases like physical cardbus eject
- * before driver shutdown. But it also seems to be caused by bugs in cardbus
- * bridge shutdown:  shutting down the bridge before the devices using it.
- */
-static int handshake (struct ehci_hcd *ehci, void __iomem *ptr,
-		      u32 mask, u32 done, int usec)
-{
-	u32	result;
-
-	do {
-		result = ehci_readl(ehci, ptr);
-		if (result == ~(u32)0)		/* card removed */
-			return -ENODEV;
-		result &= mask;
-		if (result == done)
-			return 0;
-		udelay (1);
-		usec--;
-	} while (usec > 0);
-	return -ETIMEDOUT;
-}
-
-/* force HC to halt state from unknown (EHCI spec section 2.3) */
-static int ehci_halt (struct ehci_hcd *ehci)
-{
-	u32	temp = ehci_readl(ehci, &ehci->regs->status);
-
-	/* disable any irqs left enabled by previous code */
-	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
-
-	if ((temp & STS_HALT) != 0)
-		return 0;
-
-#ifndef CONFIG_SL2312_USB
-	temp = ehci_readl(ehci, &ehci->regs->command);
-	temp &= ~CMD_RUN;
-	ehci_writel(ehci, temp, &ehci->regs->command);
-#endif
-	return handshake (ehci, &ehci->regs->status,
-			  STS_HALT, STS_HALT, 16 * 125);
-}
-
-/* put TDI/ARC silicon into EHCI mode */
-static void tdi_reset (struct ehci_hcd *ehci)
-{
-	u32 __iomem	*reg_ptr;
-	u32		tmp;
-
-	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci->regs) + USBMODE);
-	tmp = ehci_readl(ehci, reg_ptr);
-	tmp |= USBMODE_CM_HC;
-	/* The default byte access to MMR space is LE after
-	 * controller reset. Set the required endian mode
-	 * for transfer buffers to match the host microprocessor
-	 */
-	if (ehci_big_endian_mmio(ehci))
-		tmp |= USBMODE_BE;
-	ehci_writel(ehci, tmp, reg_ptr);
-}
-
-/* reset a non-running (STS_HALT == 1) controller */
-static int ehci_reset (struct ehci_hcd *ehci)
-{
-	int	retval;
-	u32	command = ehci_readl(ehci, &ehci->regs->command);
-
-	command |= CMD_RESET;
-	dbg_cmd (ehci, "reset", command);
-	ehci_writel(ehci, command, &ehci->regs->command);
-	ehci_to_hcd(ehci)->state = HC_STATE_HALT;
-	ehci->next_statechange = jiffies;
-	retval = handshake (ehci, &ehci->regs->command,
-			    CMD_RESET, 0, 250 * 1000);
-
-	if (retval)
-		return retval;
-
-	if (ehci_is_TDI(ehci))
-		tdi_reset (ehci);
-
-	return retval;
-}
-
-/* idle the controller (from running) */
-static void ehci_quiesce (struct ehci_hcd *ehci)
-{
-	u32	temp;
-
-#ifdef DEBUG
-	if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state))
-		BUG ();
-#endif
-
-	/* wait for any schedule enables/disables to take effect */
-	temp = ehci_readl(ehci, &ehci->regs->command) << 10;
-	temp &= STS_ASS | STS_PSS;
-	if (handshake (ehci, &ehci->regs->status, STS_ASS | STS_PSS,
-				temp, 16 * 125) != 0) {
-		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
-		return;
-	}
-
-	/* then disable anything that's still active */
-	temp = ehci_readl(ehci, &ehci->regs->command);
-	temp &= ~(CMD_ASE | CMD_IAAD | CMD_PSE);
-	ehci_writel(ehci, temp, &ehci->regs->command);
-
-	/* hardware can take 16 microframes to turn off ... */
-	if (handshake (ehci, &ehci->regs->status, STS_ASS | STS_PSS,
-				0, 16 * 125) != 0) {
-		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
-		return;
-	}
-}
-
-/*-------------------------------------------------------------------------*/
-
-static void ehci_work(struct ehci_hcd *ehci);
-
-#include "ehci-hub.c"
-#include "ehci-mem.c"
-#include "ehci-q.c"
-#include "ehci-sched.c"
-
-/*-------------------------------------------------------------------------*/
-
-static void ehci_watchdog (unsigned long param)
-{
-	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
-	unsigned long		flags;
-
-	spin_lock_irqsave (&ehci->lock, flags);
-
-	/* lost IAA irqs wedge things badly; seen with a vt8235 */
-	if (ehci->reclaim) {
-		u32		status = ehci_readl(ehci, &ehci->regs->status);
-		if (status & STS_IAA) {
-			ehci_vdbg (ehci, "lost IAA\n");
-			COUNT (ehci->stats.lost_iaa);
-			ehci_writel(ehci, STS_IAA, &ehci->regs->status);
-			ehci->reclaim_ready = 1;
-		}
-	}
-
- 	/* stop async processing after it's idled a bit */
-	if (test_bit (TIMER_ASYNC_OFF, &ehci->actions))
-		start_unlink_async (ehci, ehci->async);
-
-	/* ehci could run by timer, without IRQs ... */
-	ehci_work (ehci);
-
-	spin_unlock_irqrestore (&ehci->lock, flags);
-}
-
-/* On some systems, leaving remote wakeup enabled prevents system shutdown.
- * The firmware seems to think that powering off is a wakeup event!
- * This routine turns off remote wakeup and everything else, on all ports.
- */
-static void ehci_turn_off_all_ports(struct ehci_hcd *ehci)
-{
-	int	port = HCS_N_PORTS(ehci->hcs_params);
-
-	while (port--)
-		ehci_writel(ehci, PORT_RWC_BITS,
-				&ehci->regs->port_status[port]);
-}
-
-/* ehci_shutdown kick in for silicon on any bus (not just pci, etc).
- * This forcibly disables dma and IRQs, helping kexec and other cases
- * where the next system software may expect clean state.
- */
-static void
-ehci_shutdown (struct usb_hcd *hcd)
-{
-	struct ehci_hcd	*ehci;
-
-	ehci = hcd_to_ehci (hcd);
-	(void) ehci_halt (ehci);
-	ehci_turn_off_all_ports(ehci);
-
-#ifndef CONFIG_SL2312_USB
-	/* make BIOS/etc use companion controller during reboot */
-	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
-
-	/* unblock posted writes */
-	ehci_readl(ehci, &ehci->regs->configured_flag);
-#endif
-}
-
-static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
-{
-	unsigned port;
-
-	if (!HCS_PPC (ehci->hcs_params))
-		return;
-
-	ehci_dbg (ehci, "...power%s ports...\n", is_on ? "up" : "down");
-	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; )
-		(void) ehci_hub_control(ehci_to_hcd(ehci),
-				is_on ? SetPortFeature : ClearPortFeature,
-				USB_PORT_FEAT_POWER,
-				port--, NULL, 0);
-	/* Flush those writes */
-	ehci_readl(ehci, &ehci->regs->command);
-	msleep(20);
-}
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * ehci_work is called from some interrupts, timers, and so on.
- * it calls driver completion functions, after dropping ehci->lock.
- */
-static void ehci_work (struct ehci_hcd *ehci)
-{
-	timer_action_done (ehci, TIMER_IO_WATCHDOG);
-	if (ehci->reclaim_ready)
-		end_unlink_async (ehci);
-
-	/* another CPU may drop ehci->lock during a schedule scan while
-	 * it reports urb completions.  this flag guards against bogus
-	 * attempts at re-entrant schedule scanning.
-	 */
-	if (ehci->scanning)
-		return;
-	ehci->scanning = 1;
-	scan_async (ehci);
-	if (ehci->next_uframe != -1)
-		scan_periodic (ehci);
-	ehci->scanning = 0;
-
-	/* the IO watchdog guards against hardware or driver bugs that
-	 * misplace IRQs, and should let us run completely without IRQs.
-	 * such lossage has been observed on both VT6202 and VT8235.
-	 */
-	if (HC_IS_RUNNING (ehci_to_hcd(ehci)->state) &&
-			(ehci->async->qh_next.ptr != NULL ||
-			 ehci->periodic_sched != 0))
-		timer_action (ehci, TIMER_IO_WATCHDOG);
-}
-
-static void ehci_stop (struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-
-	ehci_dbg (ehci, "stop\n");
-
-	/* Turn off port power on all root hub ports. */
-	ehci_port_power (ehci, 0);
-
-	/* no more interrupts ... */
-	del_timer_sync (&ehci->watchdog);
-
-	spin_lock_irq(&ehci->lock);
-	if (HC_IS_RUNNING (hcd->state))
-		ehci_quiesce (ehci);
-
-	ehci_reset (ehci);
-	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
-	spin_unlock_irq(&ehci->lock);
-
-#ifndef CONFIG_SL2312_USB
-	/* let companion controllers work when we aren't */
-	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
-#endif
-
-	remove_companion_file(ehci);
-	remove_debug_files (ehci);
-
-	/* root hub is shut down separately (first, when possible) */
-	spin_lock_irq (&ehci->lock);
-	if (ehci->async)
-		ehci_work (ehci);
-	spin_unlock_irq (&ehci->lock);
-	ehci_mem_cleanup (ehci);
-
-#ifdef	EHCI_STATS
-	ehci_dbg (ehci, "irq normal %ld err %ld reclaim %ld (lost %ld)\n",
-		ehci->stats.normal, ehci->stats.error, ehci->stats.reclaim,
-		ehci->stats.lost_iaa);
-	ehci_dbg (ehci, "complete %ld unlink %ld\n",
-		ehci->stats.complete, ehci->stats.unlink);
-#endif
-
-	dbg_status (ehci, "ehci_stop completed",
-		    ehci_readl(ehci, &ehci->regs->status));
-}
-
-/* one-time init, only for memory state */
-static int ehci_init(struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
-	u32			temp;
-	int			retval;
-	u32			hcc_params;
-
-	spin_lock_init(&ehci->lock);
-
-	init_timer(&ehci->watchdog);
-	ehci->watchdog.function = ehci_watchdog;
-	ehci->watchdog.data = (unsigned long) ehci;
-
-	/*
-	 * hw default: 1K periodic list heads, one per frame.
-	 * periodic_size can shrink by USBCMD update if hcc_params allows.
-	 */
-	ehci->periodic_size = DEFAULT_I_TDPS;
-	if ((retval = ehci_mem_init(ehci, GFP_KERNEL)) < 0)
-		return retval;
-
-	/* controllers may cache some of the periodic schedule ... */
-	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
-	if (HCC_ISOC_CACHE(hcc_params))		// full frame cache
-		ehci->i_thresh = 8;
-	else					// N microframes cached
-		ehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
-
-	ehci->reclaim = NULL;
-	ehci->reclaim_ready = 0;
-	ehci->next_uframe = -1;
-
-	/*
-	 * dedicate a qh for the async ring head, since we couldn't unlink
-	 * a 'real' qh without stopping the async schedule [4.8].  use it
-	 * as the 'reclamation list head' too.
-	 * its dummy is used in hw_alt_next of many tds, to prevent the qh
-	 * from automatically advancing to the next td after short reads.
-	 */
-	ehci->async->qh_next.qh = NULL;
-	ehci->async->hw_next = QH_NEXT(ehci, ehci->async->qh_dma);
-	ehci->async->hw_info1 = cpu_to_hc32(ehci, QH_HEAD);
-	ehci->async->hw_token = cpu_to_hc32(ehci, QTD_STS_HALT);
-	ehci->async->hw_qtd_next = EHCI_LIST_END(ehci);
-	ehci->async->qh_state = QH_STATE_LINKED;
-	ehci->async->hw_alt_next = QTD_NEXT(ehci, ehci->async->dummy->qtd_dma);
-
-	/* clear interrupt enables, set irq latency */
-	if (log2_irq_thresh < 0 || log2_irq_thresh > 6)
-		log2_irq_thresh = 0;
-	temp = 1 << (16 + log2_irq_thresh);
-	if (HCC_CANPARK(hcc_params)) {
-		/* HW default park == 3, on hardware that supports it (like
-		 * NVidia and ALI silicon), maximizes throughput on the async
-		 * schedule by avoiding QH fetches between transfers.
-		 *
-		 * With fast usb storage devices and NForce2, "park" seems to
-		 * make problems:  throughput reduction (!), data errors...
-		 */
-		if (park) {
-			park = min(park, (unsigned) 3);
-			temp |= CMD_PARK;
-			temp |= park << 8;
-		}
-		ehci_dbg(ehci, "park %d\n", park);
-	}
-	if (HCC_PGM_FRAMELISTLEN(hcc_params)) {
-		/* periodic schedule size can be smaller than default */
-		temp &= ~(3 << 2);
-		temp |= (EHCI_TUNE_FLS << 2);
-		switch (EHCI_TUNE_FLS) {
-		case 0: ehci->periodic_size = 1024; break;
-		case 1: ehci->periodic_size = 512; break;
-		case 2: ehci->periodic_size = 256; break;
-		default:	BUG();
-		}
-	}
-	ehci->command = temp;
-
-	return 0;
-}
-
-/* start HC running; it's halted, ehci_init() has been run (once) */
-static int ehci_run (struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	int			retval;
-	u32			temp;
-	u32			hcc_params;
-
-	hcd->uses_new_polling = 1;
-	hcd->poll_rh = 0;
-
-	/* EHCI spec section 4.1 */
-	if ((retval = ehci_reset(ehci)) != 0) {
-		ehci_mem_cleanup(ehci);
-		return retval;
-	}
-	ehci_writel(ehci, ehci->periodic_dma, &ehci->regs->frame_list);
-	ehci_writel(ehci, (u32)ehci->async->qh_dma, &ehci->regs->async_next);
-
-	/*
-	 * hcc_params controls whether ehci->regs->segment must (!!!)
-	 * be used; it constrains QH/ITD/SITD and QTD locations.
-	 * pci_pool consistent memory always uses segment zero.
-	 * streaming mappings for I/O buffers, like pci_map_single(),
-	 * can return segments above 4GB, if the device allows.
-	 *
-	 * NOTE:  the dma mask is visible through dma_supported(), so
-	 * drivers can pass this info along ... like NETIF_F_HIGHDMA,
-	 * Scsi_Host.highmem_io, and so forth.  It's readonly to all
-	 * host side drivers though.
-	 */
-	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
-#ifndef CONFIG_SL2312_USB
-	if (HCC_64BIT_ADDR(hcc_params)) {
-		ehci_writel(ehci, 0, &ehci->regs->segment);
-#if 0
-// this is deeply broken on almost all architectures
-		if (!dma_set_mask(hcd->self.controller, DMA_64BIT_MASK))
-			ehci_info(ehci, "enabled 64bit DMA\n");
-#endif
-	}
-#endif
-
-	// Philips, Intel, and maybe others need CMD_RUN before the
-	// root hub will detect new devices (why?); NEC doesn't
-	ehci->command &= ~(CMD_LRESET|CMD_IAAD|CMD_PSE|CMD_ASE|CMD_RESET);
-#ifndef CONFIG_SL2312_USB
-	ehci->command |= CMD_RUN;
-#endif
-	ehci_writel(ehci, ehci->command, &ehci->regs->command);
-	dbg_cmd (ehci, "init", ehci->command);
-
-	/*
-	 * Start, enabling full USB 2.0 functionality ... usb 1.1 devices
-	 * are explicitly handed to companion controller(s), so no TT is
-	 * involved with the root hub.  (Except where one is integrated,
-	 * and there's no companion controller unless maybe for USB OTG.)
-	 *
-	 * Turning on the CF flag will transfer ownership of all ports
-	 * from the companions to the EHCI controller.  If any of the
-	 * companions are in the middle of a port reset at the time, it
-	 * could cause trouble.  Write-locking ehci_cf_port_reset_rwsem
-	 * guarantees that no resets are in progress.  After we set CF,
-	 * a short delay lets the hardware catch up; new resets shouldn't
-	 * be started before the port switching actions could complete.
-	 */
-	down_write(&ehci_cf_port_reset_rwsem);
-	hcd->state = HC_STATE_RUNNING;
-#ifndef CONFIG_SL2312_USB
-	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
-#endif
-	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
-	msleep(5);
-	up_write(&ehci_cf_port_reset_rwsem);
-
-	temp = HC_VERSION(ehci_readl(ehci, &ehci->caps->hc_capbase));
-	ehci_info (ehci,
-		"USB %x.%x started, EHCI %x.%02x, driver %s%s\n",
-		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
-		temp >> 8, temp & 0xff, DRIVER_VERSION,
-		ignore_oc ? ", overcurrent ignored" : "");
-
-	ehci_writel(ehci, INTR_MASK,
-		    &ehci->regs->intr_enable); /* Turn On Interrupts */
-
-	/* GRR this is run-once init(), being done every time the HC starts.
-	 * So long as they're part of class devices, we can't do it init()
-	 * since the class device isn't created that early.
-	 */
-	create_debug_files(ehci);
-	create_companion_file(ehci);
-
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static irqreturn_t ehci_irq (struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	u32			status, pcd_status = 0;
-	int			bh;
-
-	spin_lock (&ehci->lock);
-
-	status = ehci_readl(ehci, &ehci->regs->status);
-
-	/* e.g. cardbus physical eject */
-	if (status == ~(u32) 0) {
-		ehci_dbg (ehci, "device removed\n");
-		goto dead;
-	}
-
-	status &= INTR_MASK;
-	if (!status) {			/* irq sharing? */
-		spin_unlock(&ehci->lock);
-		return IRQ_NONE;
-	}
-
-	/* clear (just) interrupts */
-	ehci_writel(ehci, status, &ehci->regs->status);
-	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted write */
-	bh = 0;
-
-#ifdef	EHCI_VERBOSE_DEBUG
-	/* unrequested/ignored: Frame List Rollover */
-	dbg_status (ehci, "irq", status);
-#endif
-
-	/* INT, ERR, and IAA interrupt rates can be throttled */
-
-	/* normal [4.15.1.2] or error [4.15.1.1] completion */
-	if (likely ((status & (STS_INT|STS_ERR)) != 0)) {
-		if (likely ((status & STS_ERR) == 0))
-			COUNT (ehci->stats.normal);
-		else
-			COUNT (ehci->stats.error);
-		bh = 1;
-	}
-
-	/* complete the unlinking of some qh [4.15.2.3] */
-	if (status & STS_IAA) {
-		COUNT (ehci->stats.reclaim);
-		ehci->reclaim_ready = 1;
-		bh = 1;
-	}
-
-	/* remote wakeup [4.3.1] */
-	if (status & STS_PCD) {
-		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
-
-		/* resume root hub? */
-		status = ehci_readl (ehci,&ehci->regs->command);
-#ifndef CONFIG_SL2312_USB
-		if (!(status & CMD_RUN))
-			ehci_writel (ehci,status | CMD_RUN, &ehci->regs->command);
-#endif
-		while (i--) {
-			int pstatus = readl (&ehci->regs->port_status [i]);
-
-			if (pstatus & PORT_OWNER)
-				continue;
-			if (!(pstatus & PORT_RESUME)
-					|| ehci->reset_done [i] != 0)
-				continue;
-
-			/* start 20 msec resume signaling from this port,
-			 * and make khubd collect PORT_STAT_C_SUSPEND to
-			 * stop that signaling.
-			 */
-			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
-#ifdef CONFIG_SL2312_USB
-			mod_timer(&hcd->rh_timer, ehci->reset_done[i] + 1);
-#endif
-			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
-			usb_hcd_resume_root_hub(hcd);
-		}
-	}
-
-#ifdef CONFIG_SL2312_USB
-	/* XXX */
-	if (unlikely ((status & STS_FATAL) != 0))
-		status = ehci_readl (ehci, &ehci->regs->status);
-#endif
-
-	/* PCI errors [4.15.2.4] */
-	if (unlikely ((status & STS_FATAL) != 0)) {
-		/* bogus "fatal" IRQs appear on some chips... why?  */
-		status = ehci_readl(ehci, &ehci->regs->status);
-		dbg_cmd (ehci, "fatal", ehci_readl(ehci,
-						   &ehci->regs->command));
-		dbg_status (ehci, "fatal", status);
-		if (status & STS_HALT) {
-			ehci_err (ehci, "fatal error\n");
-dead:
-			ehci_reset (ehci);
-#ifndef CONFIG_SL2312_USB
-			ehci_writel(ehci, 0, &ehci->regs->configured_flag);
-#endif
-			/* generic layer kills/unlinks all urbs, then
-			 * uses ehci_stop to clean up the rest
-			 */
-			bh = 1;
-		}
-	}
-
-	if (bh)
-		ehci_work (ehci);
-	spin_unlock (&ehci->lock);
-	if (pcd_status & STS_PCD)
-		usb_hcd_poll_rh_status(hcd);
-	return IRQ_HANDLED;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * non-error returns are a promise to giveback() the urb later
- * we drop ownership so next owner (or urb unlink) can get it
- *
- * urb + dev is in hcd.self.controller.urb_list
- * we're queueing TDs onto software and hardware lists
- *
- * hcd-specific init for hcpriv hasn't been done yet
- *
- * NOTE:  control, bulk, and interrupt share the same code to append TDs
- * to a (possibly active) QH, and the same QH scanning code.
- */
-static int ehci_urb_enqueue (
-	struct usb_hcd	*hcd,
-	struct usb_host_endpoint *ep,
-	struct urb	*urb,
-	gfp_t		mem_flags
-) {
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	struct list_head	qtd_list;
-
-	INIT_LIST_HEAD (&qtd_list);
-
-	switch (usb_pipetype (urb->pipe)) {
-	// case PIPE_CONTROL:
-	// case PIPE_BULK:
-	default:
-		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
-#ifdef CONFIG_SL2312_USB
-		{
-			printk("urb_transaction: %p\n",
-			       qh_urb_transaction(ehci, urb, &qtd_list, mem_flags));
-			return -ENOMEM;
-		}
-#else
-			return -ENOMEM;
-#endif
-		return submit_async (ehci, ep, urb, &qtd_list, mem_flags);
-
-	case PIPE_INTERRUPT:
-		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
-			return -ENOMEM;
-		return intr_submit (ehci, ep, urb, &qtd_list, mem_flags);
-
-	case PIPE_ISOCHRONOUS:
-		if (urb->dev->speed == USB_SPEED_HIGH)
-			return itd_submit (ehci, urb, mem_flags);
-		else
-			return sitd_submit (ehci, urb, mem_flags);
-	}
-}
-
-static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
-{
-	/* if we need to use IAA and it's busy, defer */
-	if (qh->qh_state == QH_STATE_LINKED
-			&& ehci->reclaim
-			&& HC_IS_RUNNING (ehci_to_hcd(ehci)->state)) {
-		struct ehci_qh		*last;
-
-		for (last = ehci->reclaim;
-				last->reclaim;
-				last = last->reclaim)
-			continue;
-		qh->qh_state = QH_STATE_UNLINK_WAIT;
-		last->reclaim = qh;
-
-	/* bypass IAA if the hc can't care */
-	} else if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state) && ehci->reclaim)
-		end_unlink_async (ehci);
-
-	/* something else might have unlinked the qh by now */
-	if (qh->qh_state == QH_STATE_LINKED)
-		start_unlink_async (ehci, qh);
-}
-
-/* remove from hardware lists
- * completions normally happen asynchronously
- */
-
-static int ehci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	struct ehci_qh		*qh;
-	unsigned long		flags;
-
-	spin_lock_irqsave (&ehci->lock, flags);
-	switch (usb_pipetype (urb->pipe)) {
-	// case PIPE_CONTROL:
-	// case PIPE_BULK:
-	default:
-		qh = (struct ehci_qh *) urb->hcpriv;
-		if (!qh)
-			break;
-		unlink_async (ehci, qh);
-		break;
-
-	case PIPE_INTERRUPT:
-		qh = (struct ehci_qh *) urb->hcpriv;
-		if (!qh)
-			break;
-		switch (qh->qh_state) {
-		case QH_STATE_LINKED:
-			intr_deschedule (ehci, qh);
-			/* FALL THROUGH */
-		case QH_STATE_IDLE:
-			qh_completions (ehci, qh);
-			break;
-		default:
-			ehci_dbg (ehci, "bogus qh %p state %d\n",
-					qh, qh->qh_state);
-			goto done;
-		}
-
-		/* reschedule QH iff another request is queued */
-		if (!list_empty (&qh->qtd_list)
-				&& HC_IS_RUNNING (hcd->state)) {
-			int status;
-
-			status = qh_schedule (ehci, qh);
-			spin_unlock_irqrestore (&ehci->lock, flags);
-
-			if (status != 0) {
-				// shouldn't happen often, but ...
-				// FIXME kill those tds' urbs
-				err ("can't reschedule qh %p, err %d",
-					qh, status);
-			}
-			return status;
-		}
-		break;
-
-	case PIPE_ISOCHRONOUS:
-		// itd or sitd ...
-
-		// wait till next completion, do it then.
-		// completion irqs can wait up to 1024 msec,
-		break;
-	}
-done:
-	spin_unlock_irqrestore (&ehci->lock, flags);
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-// bulk qh holds the data toggle
-
-static void
-ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	unsigned long		flags;
-	struct ehci_qh		*qh, *tmp;
-
-	/* ASSERT:  any requests/urbs are being unlinked */
-	/* ASSERT:  nobody can be submitting urbs for this any more */
-
-rescan:
-	spin_lock_irqsave (&ehci->lock, flags);
-	qh = ep->hcpriv;
-	if (!qh)
-		goto done;
-
-	/* endpoints can be iso streams.  for now, we don't
-	 * accelerate iso completions ... so spin a while.
-	 */
-	if (qh->hw_info1 == 0) {
-		ehci_vdbg (ehci, "iso delay\n");
-		goto idle_timeout;
-	}
-
-	if (!HC_IS_RUNNING (hcd->state))
-		qh->qh_state = QH_STATE_IDLE;
-	switch (qh->qh_state) {
-	case QH_STATE_LINKED:
-		for (tmp = ehci->async->qh_next.qh;
-				tmp && tmp != qh;
-				tmp = tmp->qh_next.qh)
-			continue;
-		/* periodic qh self-unlinks on empty */
-		if (!tmp)
-			goto nogood;
-		unlink_async (ehci, qh);
-		/* FALL THROUGH */
-	case QH_STATE_UNLINK:		/* wait for hw to finish? */
-idle_timeout:
-		spin_unlock_irqrestore (&ehci->lock, flags);
-		schedule_timeout_uninterruptible(1);
-		goto rescan;
-	case QH_STATE_IDLE:		/* fully unlinked */
-		if (list_empty (&qh->qtd_list)) {
-			qh_put (qh);
-			break;
-		}
-		/* else FALL THROUGH */
-	default:
-nogood:
-		/* caller was supposed to have unlinked any requests;
-		 * that's not our job.  just leak this memory.
-		 */
-		ehci_err (ehci, "qh %p (#%02x) state %d%s\n",
-			qh, ep->desc.bEndpointAddress, qh->qh_state,
-			list_empty (&qh->qtd_list) ? "" : "(has tds)");
-		break;
-	}
-	ep->hcpriv = NULL;
-done:
-	spin_unlock_irqrestore (&ehci->lock, flags);
-	return;
-}
-
-static int ehci_get_frame (struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	return (ehci_readl(ehci, &ehci->regs->frame_index) >> 3) %
-		ehci->periodic_size;
-}
-
-/*-------------------------------------------------------------------------*/
-
-#define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
-
-MODULE_DESCRIPTION (DRIVER_INFO);
-MODULE_AUTHOR (DRIVER_AUTHOR);
-MODULE_LICENSE ("GPL");
-
-#ifdef CONFIG_PCI
-#ifdef CONFIG_ARCH_SL2312
-#include "ehci-fotg2xx.c"
-#define	PLATFORM_DRIVER		fotg2xx_ehci_driver
-#else
-#include "ehci-pci.c"
-#define	PCI_DRIVER		ehci_pci_driver
-#endif
-#endif
-
-#ifdef CONFIG_USB_EHCI_FSL
-#include "ehci-fsl.c"
-#define	PLATFORM_DRIVER		ehci_fsl_driver
-#endif
-
-#ifdef CONFIG_SOC_AU1200
-#include "ehci-au1xxx.c"
-#define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
-#endif
-
-#ifdef CONFIG_PPC_PS3
-#include "ehci-ps3.c"
-#define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
-#endif
-
-#ifdef CONFIG_440EPX
-#include "ehci-ppc-soc.c"
-#define	PLATFORM_DRIVER		ehci_ppc_soc_driver
-#endif
-
-#if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
-    !defined(PS3_SYSTEM_BUS_DRIVER)
-#error "missing bus glue for ehci-hcd"
-#endif
-
-static int __init ehci_hcd_init(void)
-{
-	int retval = 0;
-
-	pr_debug("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
-		 hcd_name,
-		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
-		 sizeof(struct ehci_itd), sizeof(struct ehci_sitd));
-
-#ifdef PLATFORM_DRIVER
-	retval = platform_driver_register(&PLATFORM_DRIVER);
-	if (retval < 0)
-		return retval;
-#endif
-
-#ifdef PCI_DRIVER
-	retval = pci_register_driver(&PCI_DRIVER);
-	if (retval < 0) {
-#ifdef PLATFORM_DRIVER
-		platform_driver_unregister(&PLATFORM_DRIVER);
-#endif
-		return retval;
-	}
-#endif
-
-#ifdef PS3_SYSTEM_BUS_DRIVER
-	retval = ps3_ehci_driver_register(&PS3_SYSTEM_BUS_DRIVER);
-	if (retval < 0) {
-#ifdef PLATFORM_DRIVER
-		platform_driver_unregister(&PLATFORM_DRIVER);
-#endif
-#ifdef PCI_DRIVER
-		pci_unregister_driver(&PCI_DRIVER);
-#endif
-		return retval;
-	}
-#endif
-
-	return retval;
-}
-module_init(ehci_hcd_init);
-
-static void __exit ehci_hcd_cleanup(void)
-{
-#ifdef PLATFORM_DRIVER
-	platform_driver_unregister(&PLATFORM_DRIVER);
-#endif
-#ifdef PCI_DRIVER
-	pci_unregister_driver(&PCI_DRIVER);
-#endif
-#ifdef PS3_SYSTEM_BUS_DRIVER
-	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
-#endif
-}
-module_exit(ehci_hcd_cleanup);
-
diff -urN host/.svn/text-base/ehci-hub.c.svn-base host.new/.svn/text-base/ehci-hub.c.svn-base
--- host/.svn/text-base/ehci-hub.c.svn-base	2009-02-24 19:00:15.699955205 +0100
+++ host.new/.svn/text-base/ehci-hub.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,936 +0,0 @@
-/*
- * Copyright (C) 2001-2004 by David Brownell
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/* this file is part of ehci-hcd.c */
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * EHCI Root Hub ... the nonsharable stuff
- *
- * Registers don't need cpu_to_le32, that happens transparently
- */
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef	CONFIG_USB_PERSIST
-
-static int ehci_hub_control(
-	struct usb_hcd	*hcd,
-	u16		typeReq,
-	u16		wValue,
-	u16		wIndex,
-	char		*buf,
-	u16		wLength
-);
-
-/* After a power loss, ports that were owned by the companion must be
- * reset so that the companion can still own them.
- */
-static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
-{
-	u32 __iomem	*reg;
-	u32		status;
-	int		port;
-	__le32		buf;
-	struct usb_hcd	*hcd = ehci_to_hcd(ehci);
-
-	if (!ehci->owned_ports)
-		return;
-
-	/* Give the connections some time to appear */
-	msleep(20);
-
-	port = HCS_N_PORTS(ehci->hcs_params);
-	while (port--) {
-		if (test_bit(port, &ehci->owned_ports)) {
-			reg = &ehci->regs->port_status[port];
-			status = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;
-
-			/* Port already owned by companion? */
-			if (status & PORT_OWNER)
-				clear_bit(port, &ehci->owned_ports);
-			else if (test_bit(port, &ehci->companion_ports))
-				ehci_writel(ehci, status & ~PORT_PE, reg);
-			else
-				ehci_hub_control(hcd, SetPortFeature,
-						USB_PORT_FEAT_RESET, port + 1,
-						NULL, 0);
-		}
-	}
-
-	if (!ehci->owned_ports)
-		return;
-	msleep(90);		/* Wait for resets to complete */
-
-	port = HCS_N_PORTS(ehci->hcs_params);
-	while (port--) {
-		if (test_bit(port, &ehci->owned_ports)) {
-			ehci_hub_control(hcd, GetPortStatus,
-					0, port + 1,
-					(char *) &buf, sizeof(buf));
-
-			/* The companion should now own the port,
-			 * but if something went wrong the port must not
-			 * remain enabled.
-			 */
-			reg = &ehci->regs->port_status[port];
-			status = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;
-			if (status & PORT_OWNER)
-				ehci_writel(ehci, status | PORT_CSC, reg);
-			else {
-				ehci_dbg(ehci, "failed handover port %d: %x\n",
-						port + 1, status);
-				ehci_writel(ehci, status & ~PORT_PE, reg);
-			}
-		}
-	}
-
-	ehci->owned_ports = 0;
-}
-
-#else	/* CONFIG_USB_PERSIST */
-
-static inline void ehci_handover_companion_ports(struct ehci_hcd *ehci)
-{ }
-
-#endif
-
-#ifdef	CONFIG_PM
-
-static int ehci_bus_suspend (struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	int			port;
-	int			mask;
-
-	ehci_dbg(ehci, "suspend root hub\n");
-
-	if (time_before (jiffies, ehci->next_statechange))
-		msleep(5);
-
-	port = HCS_N_PORTS (ehci->hcs_params);
-	spin_lock_irq (&ehci->lock);
-
-	/* stop schedules, clean any completed work */
-	if (HC_IS_RUNNING(hcd->state)) {
-		ehci_quiesce (ehci);
-		hcd->state = HC_STATE_QUIESCING;
-	}
-	ehci->command = ehci_readl(ehci, &ehci->regs->command);
-	if (ehci->reclaim)
-		ehci->reclaim_ready = 1;
-	ehci_work(ehci);
-
-	/* Unlike other USB host controller types, EHCI doesn't have
-	 * any notion of "global" or bus-wide suspend.  The driver has
-	 * to manually suspend all the active unsuspended ports, and
-	 * then manually resume them in the bus_resume() routine.
-	 */
-	ehci->bus_suspended = 0;
-	ehci->owned_ports = 0;
-	while (port--) {
-		u32 __iomem	*reg = &ehci->regs->port_status [port];
-		u32		t1 = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;
-		u32		t2 = t1;
-
-		/* keep track of which ports we suspend */
-		if (t1 & PORT_OWNER)
-			set_bit(port, &ehci->owned_ports);
-		else if ((t1 & PORT_PE) && !(t1 & PORT_SUSPEND)) {
-			t2 |= PORT_SUSPEND;
-			set_bit(port, &ehci->bus_suspended);
-		}
-
-		/* enable remote wakeup on all ports */
-		if (device_may_wakeup(&hcd->self.root_hub->dev))
-			t2 |= PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E;
-		else
-			t2 &= ~(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E);
-
-		if (t1 != t2) {
-			ehci_vdbg (ehci, "port %d, %08x -> %08x\n",
-				port + 1, t1, t2);
-			ehci_writel(ehci, t2, reg);
-		}
-	}
-
-	/* turn off now-idle HC */
-	del_timer_sync (&ehci->watchdog);
-	ehci_halt (ehci);
-	hcd->state = HC_STATE_SUSPENDED;
-
-	/* allow remote wakeup */
-	mask = INTR_MASK;
-	if (!device_may_wakeup(&hcd->self.root_hub->dev))
-		mask &= ~STS_PCD;
-	ehci_writel(ehci, mask, &ehci->regs->intr_enable);
-	ehci_readl(ehci, &ehci->regs->intr_enable);
-
-	ehci->next_statechange = jiffies + msecs_to_jiffies(10);
-	spin_unlock_irq (&ehci->lock);
-	return 0;
-}
-
-
-/* caller has locked the root hub, and should reset/reinit on error */
-static int ehci_bus_resume (struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	u32			temp;
-	u32			power_okay;
-	int			i;
-
-	if (time_before (jiffies, ehci->next_statechange))
-		msleep(5);
-	spin_lock_irq (&ehci->lock);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {
-		spin_unlock_irq(&ehci->lock);
-		return -ESHUTDOWN;
-	}
-
-	/* Ideally and we've got a real resume here, and no port's power
-	 * was lost.  (For PCI, that means Vaux was maintained.)  But we
-	 * could instead be restoring a swsusp snapshot -- so that BIOS was
-	 * the last user of the controller, not reset/pm hardware keeping
-	 * state we gave to it.
-	 */
-	power_okay = ehci_readl(ehci, &ehci->regs->intr_enable);
-	ehci_dbg(ehci, "resume root hub%s\n",
-			power_okay ? "" : " after power loss");
-
-	/* at least some APM implementations will try to deliver
-	 * IRQs right away, so delay them until we're ready.
-	 */
-	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
-
-	/* re-init operational registers */
-	ehci_writel(ehci, 0, &ehci->regs->segment);
-	ehci_writel(ehci, ehci->periodic_dma, &ehci->regs->frame_list);
-	ehci_writel(ehci, (u32) ehci->async->qh_dma, &ehci->regs->async_next);
-
-	/* restore CMD_RUN, framelist size, and irq threshold */
-	ehci_writel(ehci, ehci->command, &ehci->regs->command);
-
-	/* Some controller/firmware combinations need a delay during which
-	 * they set up the port statuses.  See Bugzilla #8190. */
-	mdelay(8);
-
-	/* manually resume the ports we suspended during bus_suspend() */
-	i = HCS_N_PORTS (ehci->hcs_params);
-	while (i--) {
-		temp = ehci_readl(ehci, &ehci->regs->port_status [i]);
-		temp &= ~(PORT_RWC_BITS
-			| PORT_WKOC_E | PORT_WKDISC_E | PORT_WKCONN_E);
-		if (test_bit(i, &ehci->bus_suspended) &&
-				(temp & PORT_SUSPEND)) {
-			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
-			temp |= PORT_RESUME;
-		}
-		ehci_writel(ehci, temp, &ehci->regs->port_status [i]);
-	}
-	i = HCS_N_PORTS (ehci->hcs_params);
-	mdelay (20);
-	while (i--) {
-		temp = ehci_readl(ehci, &ehci->regs->port_status [i]);
-		if (test_bit(i, &ehci->bus_suspended) &&
-				(temp & PORT_SUSPEND)) {
-			temp &= ~(PORT_RWC_BITS | PORT_RESUME);
-			ehci_writel(ehci, temp, &ehci->regs->port_status [i]);
-			ehci_vdbg (ehci, "resumed port %d\n", i + 1);
-		}
-	}
-	(void) ehci_readl(ehci, &ehci->regs->command);
-
-	/* maybe re-activate the schedule(s) */
-	temp = 0;
-	if (ehci->async->qh_next.qh)
-		temp |= CMD_ASE;
-	if (ehci->periodic_sched)
-		temp |= CMD_PSE;
-	if (temp) {
-		ehci->command |= temp;
-		ehci_writel(ehci, ehci->command, &ehci->regs->command);
-	}
-
-	ehci->next_statechange = jiffies + msecs_to_jiffies(5);
-	hcd->state = HC_STATE_RUNNING;
-
-	/* Now we can safely re-enable irqs */
-	ehci_writel(ehci, INTR_MASK, &ehci->regs->intr_enable);
-
-	spin_unlock_irq (&ehci->lock);
-
-	if (!power_okay)
-		ehci_handover_companion_ports(ehci);
-	return 0;
-}
-
-#else
-
-#define ehci_bus_suspend	NULL
-#define ehci_bus_resume		NULL
-
-#endif	/* CONFIG_PM */
-
-/*-------------------------------------------------------------------------*/
-
-/* Display the ports dedicated to the companion controller */
-static ssize_t show_companion(struct class_device *class_dev, char *buf)
-{
-	struct ehci_hcd		*ehci;
-	int			nports, index, n;
-	int			count = PAGE_SIZE;
-	char			*ptr = buf;
-
-	ehci = hcd_to_ehci(bus_to_hcd(class_get_devdata(class_dev)));
-	nports = HCS_N_PORTS(ehci->hcs_params);
-
-	for (index = 0; index < nports; ++index) {
-		if (test_bit(index, &ehci->companion_ports)) {
-			n = scnprintf(ptr, count, "%d\n", index + 1);
-			ptr += n;
-			count -= n;
-		}
-	}
-	return ptr - buf;
-}
-
-/*
- * Dedicate or undedicate a port to the companion controller.
- * Syntax is "[-]portnum", where a leading '-' sign means
- * return control of the port to the EHCI controller.
- */
-static ssize_t store_companion(struct class_device *class_dev,
-		const char *buf, size_t count)
-{
-	struct ehci_hcd		*ehci;
-	int			portnum, new_owner, try;
-	u32 __iomem		*status_reg;
-	u32			port_status;
-
-	ehci = hcd_to_ehci(bus_to_hcd(class_get_devdata(class_dev)));
-	new_owner = PORT_OWNER;		/* Owned by companion */
-	if (sscanf(buf, "%d", &portnum) != 1)
-		return -EINVAL;
-	if (portnum < 0) {
-		portnum = - portnum;
-		new_owner = 0;		/* Owned by EHCI */
-	}
-	if (portnum <= 0 || portnum > HCS_N_PORTS(ehci->hcs_params))
-		return -ENOENT;
-	status_reg = &ehci->regs->port_status[--portnum];
-	if (new_owner)
-		set_bit(portnum, &ehci->companion_ports);
-	else
-		clear_bit(portnum, &ehci->companion_ports);
-
-	/*
-	 * The controller won't set the OWNER bit if the port is
-	 * enabled, so this loop will sometimes require at least two
-	 * iterations: one to disable the port and one to set OWNER.
-	 */
-
-	for (try = 4; try > 0; --try) {
-		spin_lock_irq(&ehci->lock);
-		port_status = ehci_readl(ehci, status_reg);
-		if ((port_status & PORT_OWNER) == new_owner
-				|| (port_status & (PORT_OWNER | PORT_CONNECT))
-					== 0)
-			try = 0;
-		else {
-			port_status ^= PORT_OWNER;
-			port_status &= ~(PORT_PE | PORT_RWC_BITS);
-			ehci_writel(ehci, port_status, status_reg);
-		}
-		spin_unlock_irq(&ehci->lock);
-		if (try > 1)
-			msleep(5);
-	}
-	return count;
-}
-static CLASS_DEVICE_ATTR(companion, 0644, show_companion, store_companion);
-
-static inline void create_companion_file(struct ehci_hcd *ehci)
-{
-	int	i;
-
-	/* with integrated TT there is no companion! */
-	if (!ehci_is_TDI(ehci))
-		i = class_device_create_file(ehci_to_hcd(ehci)->self.class_dev,
-				&class_device_attr_companion);
-}
-
-static inline void remove_companion_file(struct ehci_hcd *ehci)
-{
-	/* with integrated TT there is no companion! */
-	if (!ehci_is_TDI(ehci))
-		class_device_remove_file(ehci_to_hcd(ehci)->self.class_dev,
-				&class_device_attr_companion);
-}
-
-
-/*-------------------------------------------------------------------------*/
-
-static int check_reset_complete (
-	struct ehci_hcd	*ehci,
-	int		index,
-	u32 __iomem	*status_reg,
-	int		port_status
-) {
-	if (!(port_status & PORT_CONNECT)) {
-		ehci->reset_done [index] = 0;
-		return port_status;
-	}
-
-#ifndef CONFIG_SL2312_USB
-	/* if reset finished and it's still not enabled -- handoff */
-	if (!(port_status & PORT_PE)) {
-
-		/* with integrated TT, there's nobody to hand it to! */
-		if (ehci_is_TDI(ehci)) {
-			ehci_dbg (ehci,
-				"Failed to enable port %d on root hub TT\n",
-				index+1);
-			return port_status;
-		}
-
-		ehci_dbg (ehci, "port %d full speed --> companion\n",
-			index + 1);
-
-		// what happens if HCS_N_CC(params) == 0 ?
-		port_status |= PORT_OWNER;
-		port_status &= ~PORT_RWC_BITS;
-		ehci_writel(ehci, port_status, status_reg);
-
-	} else
-		ehci_dbg (ehci, "port %d high speed\n", index + 1);
-#endif
-
-	return port_status;
-}
-
-/*-------------------------------------------------------------------------*/
-
-
-/* build "status change" packet (one or two bytes) from HC registers */
-
-static int
-ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
-{
-	struct ehci_hcd	*ehci = hcd_to_ehci (hcd);
-	u32		temp, status = 0;
-	u32		mask;
-	int		ports, i, retval = 1;
-	unsigned long	flags;
-
-	/* if !USB_SUSPEND, root hub timers won't get shut down ... */
-	if (!HC_IS_RUNNING(hcd->state))
-		return 0;
-
-	/* init status to no-changes */
-	buf [0] = 0;
-	ports = HCS_N_PORTS (ehci->hcs_params);
-	if (ports > 7) {
-		buf [1] = 0;
-		retval++;
-	}
-
-	/* Some boards (mostly VIA?) report bogus overcurrent indications,
-	 * causing massive log spam unless we completely ignore them.  It
-	 * may be relevant that VIA VT8235 controlers, where PORT_POWER is
-	 * always set, seem to clear PORT_OCC and PORT_CSC when writing to
-	 * PORT_POWER; that's surprising, but maybe within-spec.
-	 */
-#ifndef CONFIG_SL2312_USB
-	if (!ignore_oc)
-		mask = PORT_CSC | PORT_PEC | PORT_OCC;
-	else
-#endif
-		mask = PORT_CSC | PORT_PEC;
-	// PORT_RESUME from hardware ~= PORT_STAT_C_SUSPEND
-
-	/* no hub change reports (bit 0) for now (power, ...) */
-
-	/* port N changes (bit N)? */
-	spin_lock_irqsave (&ehci->lock, flags);
-	for (i = 0; i < ports; i++) {
-		temp = ehci_readl(ehci, &ehci->regs->port_status [i]);
-
-		/*
-		 * Return status information even for ports with OWNER set.
-		 * Otherwise khubd wouldn't see the disconnect event when a
-		 * high-speed device is switched over to the companion
-		 * controller by the user.
-		 */
-
-		if (!(temp & PORT_CONNECT))
-			ehci->reset_done [i] = 0;
-		if ((temp & mask) != 0
-				|| ((temp & PORT_RESUME) != 0
-					&& time_after_eq(jiffies,
-						ehci->reset_done[i]))) {
-			if (i < 7)
-			    buf [0] |= 1 << (i + 1);
-			else
-			    buf [1] |= 1 << (i - 7);
-			status = STS_PCD;
-		}
-	}
-	/* FIXME autosuspend idle root hubs */
-	spin_unlock_irqrestore (&ehci->lock, flags);
-	return status ? retval : 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static void
-ehci_hub_descriptor (
-	struct ehci_hcd			*ehci,
-	struct usb_hub_descriptor	*desc
-) {
-	int		ports = HCS_N_PORTS (ehci->hcs_params);
-	u16		temp;
-
-	desc->bDescriptorType = 0x29;
-	desc->bPwrOn2PwrGood = 10;	/* ehci 1.0, 2.3.9 says 20ms max */
-	desc->bHubContrCurrent = 0;
-
-	desc->bNbrPorts = ports;
-	temp = 1 + (ports / 8);
-	desc->bDescLength = 7 + 2 * temp;
-
-	/* two bitmaps:  ports removable, and usb 1.0 legacy PortPwrCtrlMask */
-	memset (&desc->bitmap [0], 0, temp);
-	memset (&desc->bitmap [temp], 0xff, temp);
-
-	temp = 0x0008;			/* per-port overcurrent reporting */
-	if (HCS_PPC (ehci->hcs_params))
-		temp |= 0x0001;		/* per-port power control */
-	else
-		temp |= 0x0002;		/* no power switching */
-#if 0
-// re-enable when we support USB_PORT_FEAT_INDICATOR below.
-	if (HCS_INDICATOR (ehci->hcs_params))
-		temp |= 0x0080;		/* per-port indicators (LEDs) */
-#endif
-	desc->wHubCharacteristics = (__force __u16)cpu_to_le16 (temp);
-}
-
-/*-------------------------------------------------------------------------*/
-
-#define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
-
-static int ehci_hub_control (
-	struct usb_hcd	*hcd,
-	u16		typeReq,
-	u16		wValue,
-	u16		wIndex,
-	char		*buf,
-	u16		wLength
-) {
-	struct ehci_hcd	*ehci = hcd_to_ehci (hcd);
-	int		ports = HCS_N_PORTS (ehci->hcs_params);
-	u32 __iomem	*status_reg = &ehci->regs->port_status[
-				(wIndex & 0xff) - 1];
-	u32		temp, status;
-	unsigned long	flags;
-	int		retval = 0;
-	unsigned	selector;
-
-	/*
-	 * FIXME:  support SetPortFeatures USB_PORT_FEAT_INDICATOR.
-	 * HCS_INDICATOR may say we can change LEDs to off/amber/green.
-	 * (track current state ourselves) ... blink for diagnostics,
-	 * power, "this is the one", etc.  EHCI spec supports this.
-	 */
-
-	spin_lock_irqsave (&ehci->lock, flags);
-	switch (typeReq) {
-	case ClearHubFeature:
-		switch (wValue) {
-		case C_HUB_LOCAL_POWER:
-		case C_HUB_OVER_CURRENT:
-			/* no hub-wide feature/status flags */
-			break;
-		default:
-			goto error;
-		}
-		break;
-	case ClearPortFeature:
-		if (!wIndex || wIndex > ports)
-			goto error;
-		wIndex--;
-		temp = ehci_readl(ehci, status_reg);
-
-		/*
-		 * Even if OWNER is set, so the port is owned by the
-		 * companion controller, khubd needs to be able to clear
-		 * the port-change status bits (especially
-		 * USB_PORT_FEAT_C_CONNECTION).
-		 */
-
-		switch (wValue) {
-		case USB_PORT_FEAT_ENABLE:
-			ehci_writel(ehci, temp & ~PORT_PE, status_reg);
-			break;
-		case USB_PORT_FEAT_C_ENABLE:
-			ehci_writel(ehci, (temp & ~PORT_RWC_BITS) | PORT_PEC,
-					status_reg);
-			break;
-		case USB_PORT_FEAT_SUSPEND:
-			if (temp & PORT_RESET)
-				goto error;
-			if (ehci->no_selective_suspend)
-				break;
-			if (temp & PORT_SUSPEND) {
-				if ((temp & PORT_PE) == 0)
-					goto error;
-				/* resume signaling for 20 msec */
-				temp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
-				ehci_writel(ehci, temp | PORT_RESUME,
-						status_reg);
-				ehci->reset_done [wIndex] = jiffies
-						+ msecs_to_jiffies (20);
-			}
-			break;
-		case USB_PORT_FEAT_C_SUSPEND:
-			/* we auto-clear this feature */
-			break;
-#ifndef CONFIG_SL2312_USB
-		case USB_PORT_FEAT_POWER:
-			if (HCS_PPC (ehci->hcs_params))
-				ehci_writel(ehci,
-					  temp & ~(PORT_RWC_BITS | PORT_POWER),
-					  status_reg);
-			break;
-#endif
-		case USB_PORT_FEAT_C_CONNECTION:
-			ehci_writel(ehci, (temp & ~PORT_RWC_BITS) | PORT_CSC,
-					status_reg);
-			break;
-#ifndef CONFIG_SL2312_USB
-		case USB_PORT_FEAT_C_OVER_CURRENT:
-			ehci_writel(ehci, (temp & ~PORT_RWC_BITS) | PORT_OCC,
-					status_reg);
-			break;
-#endif
-		case USB_PORT_FEAT_C_RESET:
-			/* GetPortStatus clears reset */
-			break;
-		default:
-			goto error;
-		}
-		ehci_readl(ehci, &ehci->regs->command);	/* unblock posted write */
-		break;
-	case GetHubDescriptor:
-		ehci_hub_descriptor (ehci, (struct usb_hub_descriptor *)
-			buf);
-		break;
-	case GetHubStatus:
-		/* no hub-wide feature/status flags */
-		memset (buf, 0, 4);
-		//cpu_to_le32s ((u32 *) buf);
-		break;
-	case GetPortStatus:
-		if (!wIndex || wIndex > ports)
-			goto error;
-		wIndex--;
-		status = 0;
-		temp = ehci_readl(ehci, status_reg);
-
-		// wPortChange bits
-		if (temp & PORT_CSC)
-			status |= 1 << USB_PORT_FEAT_C_CONNECTION;
-		if (temp & PORT_PEC)
-			status |= 1 << USB_PORT_FEAT_C_ENABLE;
-
-#ifndef CONFIG_SL2312_USB
-		if ((temp & PORT_OCC) && !ignore_oc){
-			status |= 1 << USB_PORT_FEAT_C_OVER_CURRENT;
-
-			/*
-			 * Hubs should disable port power on over-current.
-			 * However, not all EHCI implementations do this
-			 * automatically, even if they _do_ support per-port
-			 * power switching; they're allowed to just limit the
-			 * current.  khubd will turn the power back on.
-			 */
-			if (HCS_PPC (ehci->hcs_params)){
-				ehci_writel(ehci,
-					temp & ~(PORT_RWC_BITS | PORT_POWER),
-					status_reg);
-			}
-		}
-#endif
-
-		/* whoever resumes must GetPortStatus to complete it!! */
-		if (temp & PORT_RESUME) {
-
-			/* Remote Wakeup received? */
-			if (!ehci->reset_done[wIndex]) {
-				/* resume signaling for 20 msec */
-				ehci->reset_done[wIndex] = jiffies
-						+ msecs_to_jiffies(20);
-				/* check the port again */
-				mod_timer(&ehci_to_hcd(ehci)->rh_timer,
-						ehci->reset_done[wIndex]);
-			}
-
-			/* resume completed? */
-			else if (time_after_eq(jiffies,
-					ehci->reset_done[wIndex])) {
-				status |= 1 << USB_PORT_FEAT_C_SUSPEND;
-				ehci->reset_done[wIndex] = 0;
-
-				/* stop resume signaling */
-				temp = ehci_readl(ehci, status_reg);
-				ehci_writel(ehci,
-#ifndef CONFIG_SL2312_USB
-					temp & ~(PORT_RWC_BITS | PORT_RESUME),
-#else
-					temp & ~(PORT_RESUME),
-#endif
-					status_reg);
-				retval = handshake(ehci, status_reg,
-					   PORT_RESUME, 0, 2000 /* 2msec */);
-				if (retval != 0) {
-					ehci_err(ehci,
-						"port %d resume error %d\n",
-						wIndex + 1, retval);
-					goto error;
-				}
-				temp &= ~(PORT_SUSPEND|PORT_RESUME|(3<<10));
-			}
-		}
-
-		/* whoever resets must GetPortStatus to complete it!! */
-		if ((temp & PORT_RESET)
-				&& time_after_eq(jiffies,
-					ehci->reset_done[wIndex])) {
-			status |= 1 << USB_PORT_FEAT_C_RESET;
-			ehci->reset_done [wIndex] = 0;
-
-			/* force reset to complete */
-#ifdef CONFIG_SL2312_USB
-			ehci_writel(ehci, temp & ~(PORT_RESET),
-					status_reg);
-			do {
-				temp = ehci_readl(ehci, status_reg);
-				udelay(10);
-			} while (temp & PORT_RESET);
-#else
-			ehci_writel(ehci, temp & ~(PORT_RWC_BITS | PORT_RESET),
-					status_reg);
-			/* REVISIT:  some hardware needs 550+ usec to clear
-			 * this bit; seems too long to spin routinely...
-			 */
-			retval = handshake(ehci, status_reg,
-					PORT_RESET, 0, 750);
-			if (retval != 0) {
-				ehci_err (ehci, "port %d reset error %d\n",
-					wIndex + 1, retval);
-				goto error;
-			}
-#endif
-
-			/* see what we found out */
-			temp = check_reset_complete (ehci, wIndex, status_reg,
-					ehci_readl(ehci, status_reg));
-#ifdef CONFIG_SL2312_USB
-			/* restart schedule */
-			ehci_writel(ehci, ehci_readl(ehci, &ehci->regs->command)|(0x1),&ehci->regs->command);
-
-			hcd->state = HC_STATE_RUNNING;
-
-			switch ((ehci_readl(ehci, hcd->regs + 0x80) >> 22) & 3) {
-				case 0:
-						printk("Full speed\n");
-						break;
-
-				case 1:
-						printk("Low speed\n");
-						break;
-
-				case 2:
-						printk("High speed\n");
-						break;
-				default:
-						printk("Speed detection error\n");
-						break;
-			}
-
-#endif
-		}
-
-		/* transfer dedicated ports to the companion hc */
-		if ((temp & PORT_CONNECT) &&
-				test_bit(wIndex, &ehci->companion_ports)) {
-			temp &= ~PORT_RWC_BITS;
-			temp |= PORT_OWNER;
-			ehci_writel(ehci, temp, status_reg);
-			ehci_dbg(ehci, "port %d --> companion\n", wIndex + 1);
-			temp = ehci_readl(ehci, status_reg);
-		}
-
-		/*
-		 * Even if OWNER is set, there's no harm letting khubd
-		 * see the wPortStatus values (they should all be 0 except
-		 * for PORT_POWER anyway).
-		 */
-
-#ifndef CONFIG_SL2312_USB
-		if (temp & PORT_CONNECT) {
-			status |= 1 << USB_PORT_FEAT_CONNECTION;
-			// status may be from integrated TT
-			status |= ehci_port_speed(ehci, temp);
-		}
-#else
-		if (temp & PORT_CONNECT) {
-			status |= 1 << USB_PORT_FEAT_CONNECTION;
-		if (((ehci_readl(ehci, hcd->regs + 0x80) >> 22) & 3) == 2)
-				status |= 1 << USB_PORT_FEAT_HIGHSPEED;
-		else if (((ehci_readl(ehci, hcd->regs + 0x80) >> 22) & 3) == 1)
-				status |= 1 << USB_PORT_FEAT_LOWSPEED;
-		}
-#endif
-		if (temp & PORT_PE)
-			status |= 1 << USB_PORT_FEAT_ENABLE;
-		if (temp & (PORT_SUSPEND|PORT_RESUME))
-			status |= 1 << USB_PORT_FEAT_SUSPEND;
-#ifndef CONFIG_SL2312_USB
-		if (temp & PORT_OC)
-			status |= 1 << USB_PORT_FEAT_OVER_CURRENT;
-#endif
-		if (temp & PORT_RESET)
-			status |= 1 << USB_PORT_FEAT_RESET;
-#ifndef CONFIG_SL2312_USB
-		if (temp & PORT_POWER)
-			status |= 1 << USB_PORT_FEAT_POWER;
-#endif
-
-#ifndef	EHCI_VERBOSE_DEBUG
-	if (status & ~0xffff)	/* only if wPortChange is interesting */
-#endif
-		dbg_port (ehci, "GetStatus", wIndex + 1, temp);
-		put_unaligned(cpu_to_le32 (status), (__le32 *) buf);
-		break;
-	case SetHubFeature:
-		switch (wValue) {
-		case C_HUB_LOCAL_POWER:
-		case C_HUB_OVER_CURRENT:
-			/* no hub-wide feature/status flags */
-			break;
-		default:
-			goto error;
-		}
-		break;
-	case SetPortFeature:
-		selector = wIndex >> 8;
-		wIndex &= 0xff;
-		if (!wIndex || wIndex > ports)
-			goto error;
-		wIndex--;
-		temp = ehci_readl(ehci, status_reg);
-#ifndef CONFIG_SL2312_USB
-		if (temp & PORT_OWNER)
-			break;
-#endif
-
-		temp &= ~PORT_RWC_BITS;
-		switch (wValue) {
-		case USB_PORT_FEAT_SUSPEND:
-			if (ehci->no_selective_suspend)
-				break;
-			if ((temp & PORT_PE) == 0
-					|| (temp & PORT_RESET) != 0)
-				goto error;
-			if (device_may_wakeup(&hcd->self.root_hub->dev))
-				temp |= PORT_WAKE_BITS;
-			ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
-			break;
-		case USB_PORT_FEAT_POWER:
-#ifndef CONFIG_SL2312_USB
-			if (HCS_PPC (ehci->hcs_params))
-				ehci_writel(ehci, temp | PORT_POWER,
-						status_reg);
-#endif
-			break;
-		case USB_PORT_FEAT_RESET:
-#ifndef CONFIG_SL2312_USB
-			if (temp & PORT_RESUME)
-				goto error;
-			/* line status bits may report this as low speed,
-			 * which can be fine if this root hub has a
-			 * transaction translator built in.
-			 */
-			if ((temp & (PORT_PE|PORT_CONNECT)) == PORT_CONNECT
-					&& !ehci_is_TDI(ehci)
-					&& PORT_USB11 (temp)) {
-				ehci_dbg (ehci,
-					"port %d low speed --> companion\n",
-					wIndex + 1);
-				temp |= PORT_OWNER;
-			} else
-#endif
-			{
-				ehci_vdbg (ehci, "port %d reset\n", wIndex + 1);
-				temp |= PORT_RESET;
-#ifndef CONFIG_SL2312_USB
-				temp &= ~PORT_PE;
-#endif
-
-				/*
-				 * caller must wait, then call GetPortStatus
-				 * usb 2.0 spec says 50 ms resets on root
-				 */
-				ehci->reset_done [wIndex] = jiffies
-						+ msecs_to_jiffies (50);
-			}
-			ehci_writel(ehci, temp, status_reg);
-			break;
-
-		/* For downstream facing ports (these):  one hub port is put
-		 * into test mode according to USB2 11.24.2.13, then the hub
-		 * must be reset (which for root hub now means rmmod+modprobe,
-		 * or else system reboot).  See EHCI 2.3.9 and 4.14 for info
-		 * about the EHCI-specific stuff.
-		 */
-		case USB_PORT_FEAT_TEST:
-			if (!selector || selector > 5)
-				goto error;
-			ehci_quiesce(ehci);
-			ehci_halt(ehci);
-			temp |= selector << 16;
-			ehci_writel(ehci, temp, status_reg);
-			break;
-
-		default:
-			goto error;
-		}
-		ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
-		break;
-
-	default:
-error:
-		/* "stall" on error */
-		retval = -EPIPE;
-	}
-	spin_unlock_irqrestore (&ehci->lock, flags);
-	return retval;
-}
diff -urN host/.svn/text-base/ehci-mem.c.svn-base host.new/.svn/text-base/ehci-mem.c.svn-base
--- host/.svn/text-base/ehci-mem.c.svn-base	2009-02-24 19:00:15.703955002 +0100
+++ host.new/.svn/text-base/ehci-mem.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,233 +0,0 @@
-/*
- * Copyright (c) 2001 by David Brownell
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/* this file is part of ehci-hcd.c */
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * There's basically three types of memory:
- *	- data used only by the HCD ... kmalloc is fine
- *	- async and periodic schedules, shared by HC and HCD ... these
- *	  need to use dma_pool or dma_alloc_coherent
- *	- driver buffers, read/written by HC ... single shot DMA mapped
- *
- * There's also "register" data (e.g. PCI or SOC), which is memory mapped.
- * No memory seen by this driver is pageable.
- */
-
-/*-------------------------------------------------------------------------*/
-
-/* Allocate the key transfer structures from the previously allocated pool */
-
-static inline void ehci_qtd_init(struct ehci_hcd *ehci, struct ehci_qtd *qtd,
-				  dma_addr_t dma)
-{
-	memset (qtd, 0, sizeof *qtd);
-	qtd->qtd_dma = dma;
-	qtd->hw_token = cpu_to_le32 (QTD_STS_HALT);
-	qtd->hw_next = EHCI_LIST_END(ehci);
-	qtd->hw_alt_next = EHCI_LIST_END(ehci);
-	INIT_LIST_HEAD (&qtd->qtd_list);
-}
-
-static struct ehci_qtd *ehci_qtd_alloc (struct ehci_hcd *ehci, gfp_t flags)
-{
-	struct ehci_qtd		*qtd;
-	dma_addr_t		dma;
-
-	qtd = dma_pool_alloc (ehci->qtd_pool, flags, &dma);
-	if (qtd != NULL) {
-		ehci_qtd_init(ehci, qtd, dma);
-	}
-	return qtd;
-}
-
-static inline void ehci_qtd_free (struct ehci_hcd *ehci, struct ehci_qtd *qtd)
-{
-	dma_pool_free (ehci->qtd_pool, qtd, qtd->qtd_dma);
-}
-
-
-static void qh_destroy(struct ehci_qh *qh)
-{
-	struct ehci_hcd *ehci = qh->ehci;
-
-	/* clean qtds first, and know this is not linked */
-	if (!list_empty (&qh->qtd_list) || qh->qh_next.ptr) {
-		ehci_dbg (ehci, "unused qh not empty!\n");
-		BUG ();
-	}
-	if (qh->dummy)
-		ehci_qtd_free (ehci, qh->dummy);
-	dma_pool_free (ehci->qh_pool, qh, qh->qh_dma);
-}
-
-static struct ehci_qh *ehci_qh_alloc (struct ehci_hcd *ehci, gfp_t flags)
-{
-	struct ehci_qh		*qh;
-	dma_addr_t		dma;
-
-	qh = (struct ehci_qh *)
-		dma_pool_alloc (ehci->qh_pool, flags, &dma);
-	if (!qh)
-		return qh;
-
-	memset (qh, 0, sizeof *qh);
-	qh->refcount = 1;
-	qh->ehci = ehci;
-	qh->qh_dma = dma;
-	// INIT_LIST_HEAD (&qh->qh_list);
-	INIT_LIST_HEAD (&qh->qtd_list);
-
-	/* dummy td enables safe urb queuing */
-	qh->dummy = ehci_qtd_alloc (ehci, flags);
-	if (qh->dummy == NULL) {
-		ehci_dbg (ehci, "no dummy td\n");
-		dma_pool_free (ehci->qh_pool, qh, qh->qh_dma);
-		qh = NULL;
-	}
-	return qh;
-}
-
-/* to share a qh (cpu threads, or hc) */
-static inline struct ehci_qh *qh_get (struct ehci_qh *qh)
-{
-	WARN_ON(!qh->refcount);
-	qh->refcount++;
-	return qh;
-}
-
-static inline void qh_put (struct ehci_qh *qh)
-{
-	if (!--qh->refcount)
-		qh_destroy(qh);
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* The queue heads and transfer descriptors are managed from pools tied
- * to each of the "per device" structures.
- * This is the initialisation and cleanup code.
- */
-
-static void ehci_mem_cleanup (struct ehci_hcd *ehci)
-{
-	if (ehci->async)
-		qh_put (ehci->async);
-	ehci->async = NULL;
-
-	/* DMA consistent memory and pools */
-	if (ehci->qtd_pool)
-		dma_pool_destroy (ehci->qtd_pool);
-	ehci->qtd_pool = NULL;
-
-	if (ehci->qh_pool) {
-		dma_pool_destroy (ehci->qh_pool);
-		ehci->qh_pool = NULL;
-	}
-
-	if (ehci->itd_pool)
-		dma_pool_destroy (ehci->itd_pool);
-	ehci->itd_pool = NULL;
-
-	if (ehci->sitd_pool)
-		dma_pool_destroy (ehci->sitd_pool);
-	ehci->sitd_pool = NULL;
-
-	if (ehci->periodic)
-		dma_free_coherent (ehci_to_hcd(ehci)->self.controller,
-			ehci->periodic_size * sizeof (u32),
-			ehci->periodic, ehci->periodic_dma);
-	ehci->periodic = NULL;
-
-	/* shadow periodic table */
-	kfree(ehci->pshadow);
-	ehci->pshadow = NULL;
-}
-
-/* remember to add cleanup code (above) if you add anything here */
-static int ehci_mem_init (struct ehci_hcd *ehci, gfp_t flags)
-{
-	int i;
-
-	/* QTDs for control/bulk/intr transfers */
-	ehci->qtd_pool = dma_pool_create ("ehci_qtd",
-			ehci_to_hcd(ehci)->self.controller,
-			sizeof (struct ehci_qtd),
-			32 /* byte alignment (for hw parts) */,
-			4096 /* can't cross 4K */);
-	if (!ehci->qtd_pool) {
-		goto fail;
-	}
-
-	/* QHs for control/bulk/intr transfers */
-	ehci->qh_pool = dma_pool_create ("ehci_qh",
-			ehci_to_hcd(ehci)->self.controller,
-			sizeof (struct ehci_qh),
-			32 /* byte alignment (for hw parts) */,
-			4096 /* can't cross 4K */);
-	if (!ehci->qh_pool) {
-		goto fail;
-	}
-	ehci->async = ehci_qh_alloc (ehci, flags);
-	if (!ehci->async) {
-		goto fail;
-	}
-
-	/* ITD for high speed ISO transfers */
-	ehci->itd_pool = dma_pool_create ("ehci_itd",
-			ehci_to_hcd(ehci)->self.controller,
-			sizeof (struct ehci_itd),
-			32 /* byte alignment (for hw parts) */,
-			4096 /* can't cross 4K */);
-	if (!ehci->itd_pool) {
-		goto fail;
-	}
-
-	/* SITD for full/low speed split ISO transfers */
-	ehci->sitd_pool = dma_pool_create ("ehci_sitd",
-			ehci_to_hcd(ehci)->self.controller,
-			sizeof (struct ehci_sitd),
-			32 /* byte alignment (for hw parts) */,
-			4096 /* can't cross 4K */);
-	if (!ehci->sitd_pool) {
-		goto fail;
-	}
-
-	/* Hardware periodic table */
-	ehci->periodic = (__le32 *)
-		dma_alloc_coherent (ehci_to_hcd(ehci)->self.controller,
-			ehci->periodic_size * sizeof(__le32),
-			&ehci->periodic_dma, 0);
-	if (ehci->periodic == NULL) {
-		goto fail;
-	}
-	for (i = 0; i < ehci->periodic_size; i++)
-		ehci->periodic [i] = EHCI_LIST_END(ehci);
-
-	/* software shadow of hardware table */
-	ehci->pshadow = kcalloc(ehci->periodic_size, sizeof(void *), flags);
-	if (ehci->pshadow != NULL)
-		return 0;
-
-fail:
-	ehci_dbg (ehci, "couldn't init memory\n");
-	ehci_mem_cleanup (ehci);
-	return -ENOMEM;
-}
diff -urN host/.svn/text-base/ehci-pci.c.svn-base host.new/.svn/text-base/ehci-pci.c.svn-base
--- host/.svn/text-base/ehci-pci.c.svn-base	2009-02-24 19:00:15.711954595 +0100
+++ host.new/.svn/text-base/ehci-pci.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,397 +0,0 @@
-/*
- * EHCI HCD (Host Controller Driver) PCI Bus Glue.
- *
- * Copyright (c) 2000-2004 by David Brownell
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#ifndef CONFIG_PCI
-#error "This file is PCI bus glue.  CONFIG_PCI must be defined."
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-/* called after powerup, by probe or system-pm "wakeup" */
-static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
-{
-	u32			temp;
-	int			retval;
-
-	/* optional debug port, normally in the first BAR */
-	temp = pci_find_capability(pdev, 0x0a);
-	if (temp) {
-		pci_read_config_dword(pdev, temp, &temp);
-		temp >>= 16;
-		if ((temp & (3 << 13)) == (1 << 13)) {
-			temp &= 0x1fff;
-			ehci->debug = ehci_to_hcd(ehci)->regs + temp;
-			temp = ehci_readl(ehci, &ehci->debug->control);
-			ehci_info(ehci, "debug port %d%s\n",
-				HCS_DEBUG_PORT(ehci->hcs_params),
-				(temp & DBGP_ENABLED)
-					? " IN USE"
-					: "");
-			if (!(temp & DBGP_ENABLED))
-				ehci->debug = NULL;
-		}
-	}
-
-	/* we expect static quirk code to handle the "extended capabilities"
-	 * (currently just BIOS handoff) allowed starting with EHCI 0.96
-	 */
-
-	/* PCI Memory-Write-Invalidate cycle support is optional (uncommon) */
-	retval = pci_set_mwi(pdev);
-	if (!retval)
-		ehci_dbg(ehci, "MWI active\n");
-
-	ehci_port_power(ehci, 0);
-
-	return 0;
-}
-
-/* called during probe() after chip reset completes */
-static int ehci_pci_setup(struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
-	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
-	u32			temp;
-	int			retval;
-
-	switch (pdev->vendor) {
-	case PCI_VENDOR_ID_TOSHIBA_2:
-		/* celleb's companion chip */
-		if (pdev->device == 0x01b5) {
-#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
-			ehci->big_endian_mmio = 1;
-#else
-			ehci_warn(ehci,
-				  "unsupported big endian Toshiba quirk\n");
-#endif
-		}
-		break;
-	}
-
-	ehci->caps = hcd->regs;
-	ehci->regs = hcd->regs +
-		HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
-
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-        /* ehci_init() causes memory for DMA transfers to be
-         * allocated.  Thus, any vendor-specific workarounds based on
-         * limiting the type of memory used for DMA transfers must
-         * happen before ehci_init() is called. */
-	switch (pdev->vendor) {
-	case PCI_VENDOR_ID_NVIDIA:
-		/* NVidia reports that certain chips don't handle
-		 * QH, ITD, or SITD addresses above 2GB.  (But TD,
-		 * data buffer, and periodic schedule are normal.)
-		 */
-		switch (pdev->device) {
-		case 0x003c:	/* MCP04 */
-		case 0x005b:	/* CK804 */
-		case 0x00d8:	/* CK8 */
-		case 0x00e8:	/* CK8S */
-			if (pci_set_consistent_dma_mask(pdev,
-						DMA_31BIT_MASK) < 0)
-				ehci_warn(ehci, "can't enable NVidia "
-					"workaround for >2GB RAM\n");
-			break;
-		}
-		break;
-	}
-
-	/* cache this readonly data; minimize chip reads */
-	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
-
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
-
-	/* data structure init */
-	retval = ehci_init(hcd);
-	if (retval)
-		return retval;
-
-	switch (pdev->vendor) {
-	case PCI_VENDOR_ID_TDI:
-		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {
-			ehci->is_tdi_rh_tt = 1;
-			tdi_reset(ehci);
-		}
-		break;
-	case PCI_VENDOR_ID_AMD:
-		/* AMD8111 EHCI doesn't work, according to AMD errata */
-		if (pdev->device == 0x7463) {
-			ehci_info(ehci, "ignoring AMD8111 (errata)\n");
-			retval = -EIO;
-			goto done;
-		}
-		break;
-	case PCI_VENDOR_ID_NVIDIA:
-		switch (pdev->device) {
-		/* Some NForce2 chips have problems with selective suspend;
-		 * fixed in newer silicon.
-		 */
-		case 0x0068:
-			if (pdev->revision < 0xa4)
-				ehci->no_selective_suspend = 1;
-			break;
-		}
-		break;
-	}
-
-	if (ehci_is_TDI(ehci))
-		ehci_reset(ehci);
-
-	/* at least the Genesys GL880S needs fixup here */
-	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
-	temp &= 0x0f;
-	if (temp && HCS_N_PORTS(ehci->hcs_params) > temp) {
-		ehci_dbg(ehci, "bogus port configuration: "
-			"cc=%d x pcc=%d < ports=%d\n",
-			HCS_N_CC(ehci->hcs_params),
-			HCS_N_PCC(ehci->hcs_params),
-			HCS_N_PORTS(ehci->hcs_params));
-
-		switch (pdev->vendor) {
-		case 0x17a0:		/* GENESYS */
-			/* GL880S: should be PORTS=2 */
-			temp |= (ehci->hcs_params & ~0xf);
-			ehci->hcs_params = temp;
-			break;
-		case PCI_VENDOR_ID_NVIDIA:
-			/* NF4: should be PCC=10 */
-			break;
-		}
-	}
-
-	/* Serial Bus Release Number is at PCI 0x60 offset */
-	pci_read_config_byte(pdev, 0x60, &ehci->sbrn);
-
-	/* Workaround current PCI init glitch:  wakeup bits aren't
-	 * being set from PCI PM capability.
-	 */
-	if (!device_can_wakeup(&pdev->dev)) {
-		u16	port_wake;
-
-		pci_read_config_word(pdev, 0x62, &port_wake);
-		if (port_wake & 0x0001)
-			device_init_wakeup(&pdev->dev, 1);
-	}
-
-#ifdef	CONFIG_USB_SUSPEND
-	/* REVISIT: the controller works fine for wakeup iff the root hub
-	 * itself is "globally" suspended, but usbcore currently doesn't
-	 * understand such things.
-	 *
-	 * System suspend currently expects to be able to suspend the entire
-	 * device tree, device-at-a-time.  If we failed selective suspend
-	 * reports, system suspend would fail; so the root hub code must claim
-	 * success.  That's lying to usbcore, and it matters for for runtime
-	 * PM scenarios with selective suspend and remote wakeup...
-	 */
-	if (ehci->no_selective_suspend && device_can_wakeup(&pdev->dev))
-		ehci_warn(ehci, "selective suspend/wakeup unavailable\n");
-#endif
-
-	retval = ehci_pci_reinit(ehci, pdev);
-done:
-	return retval;
-}
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef	CONFIG_PM
-
-/* suspend/resume, section 4.3 */
-
-/* These routines rely on the PCI bus glue
- * to handle powerdown and wakeup, and currently also on
- * transceivers that don't need any software attention to set up
- * the right sort of wakeup.
- * Also they depend on separate root hub suspend/resume.
- */
-
-static int ehci_pci_suspend(struct usb_hcd *hcd, pm_message_t message)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
-	unsigned long		flags;
-	int			rc = 0;
-
-	if (time_before(jiffies, ehci->next_statechange))
-		msleep(10);
-
-	/* Root hub was already suspended. Disable irq emission and
-	 * mark HW unaccessible, bail out if RH has been resumed. Use
-	 * the spinlock to properly synchronize with possible pending
-	 * RH suspend or resume activity.
-	 *
-	 * This is still racy as hcd->state is manipulated outside of
-	 * any locks =P But that will be a different fix.
-	 */
-	spin_lock_irqsave (&ehci->lock, flags);
-	if (hcd->state != HC_STATE_SUSPENDED) {
-		rc = -EINVAL;
-		goto bail;
-	}
-	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
-	(void)ehci_readl(ehci, &ehci->regs->intr_enable);
-
-	/* make sure snapshot being resumed re-enumerates everything */
-	if (message.event == PM_EVENT_PRETHAW) {
-		ehci_halt(ehci);
-		ehci_reset(ehci);
-	}
-
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
- bail:
-	spin_unlock_irqrestore (&ehci->lock, flags);
-
-	// could save FLADJ in case of Vaux power loss
-	// ... we'd only use it to handle clock skew
-
-	return rc;
-}
-
-static int ehci_pci_resume(struct usb_hcd *hcd)
-{
-	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
-	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
-
-	// maybe restore FLADJ
-
-	if (time_before(jiffies, ehci->next_statechange))
-		msleep(100);
-
-	/* Mark hardware accessible again as we are out of D3 state by now */
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-
-	/* If CF is still set, we maintained PCI Vaux power.
-	 * Just undo the effect of ehci_pci_suspend().
-	 */
-	if (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF) {
-		int	mask = INTR_MASK;
-
-		if (!device_may_wakeup(&hcd->self.root_hub->dev))
-			mask &= ~STS_PCD;
-		ehci_writel(ehci, mask, &ehci->regs->intr_enable);
-		ehci_readl(ehci, &ehci->regs->intr_enable);
-		return 0;
-	}
-
-	ehci_dbg(ehci, "lost power, restarting\n");
-	usb_root_hub_lost_power(hcd->self.root_hub);
-
-	/* Else reset, to cope with power loss or flush-to-storage
-	 * style "resume" having let BIOS kick in during reboot.
-	 */
-	(void) ehci_halt(ehci);
-	(void) ehci_reset(ehci);
-	(void) ehci_pci_reinit(ehci, pdev);
-
-	/* emptying the schedule aborts any urbs */
-	spin_lock_irq(&ehci->lock);
-	if (ehci->reclaim)
-		ehci->reclaim_ready = 1;
-	ehci_work(ehci);
-	spin_unlock_irq(&ehci->lock);
-
-	ehci_writel(ehci, ehci->command, &ehci->regs->command);
-	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
-	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
-
-	/* here we "know" root ports should always stay powered */
-	ehci_port_power(ehci, 1);
-	ehci_handover_companion_ports(ehci);
-
-	hcd->state = HC_STATE_SUSPENDED;
-	return 0;
-}
-#endif
-
-static const struct hc_driver ehci_pci_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"EHCI Host Controller",
-	.hcd_priv_size =	sizeof(struct ehci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ehci_irq,
-	.flags =		HCD_MEMORY | HCD_USB2,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset =		ehci_pci_setup,
-	.start =		ehci_run,
-#ifdef	CONFIG_PM
-	.suspend =		ehci_pci_suspend,
-	.resume =		ehci_pci_resume,
-#endif
-	.stop =			ehci_stop,
-	.shutdown =		ehci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ehci_urb_enqueue,
-	.urb_dequeue =		ehci_urb_dequeue,
-	.endpoint_disable =	ehci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ehci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ehci_hub_status_data,
-	.hub_control =		ehci_hub_control,
-	.bus_suspend =		ehci_bus_suspend,
-	.bus_resume =		ehci_bus_resume,
-};
-
-/*-------------------------------------------------------------------------*/
-
-/* PCI driver selection metadata; PCI hotplugging uses this */
-static const struct pci_device_id pci_ids [] = { {
-	/* handle any USB 2.0 EHCI controller */
-	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_EHCI, ~0),
-	.driver_data =	(unsigned long) &ehci_pci_hc_driver,
-	},
-	{ /* end: all zeroes */ }
-};
-MODULE_DEVICE_TABLE(pci, pci_ids);
-
-/* pci driver glue; this is a "new style" PCI driver module */
-static struct pci_driver ehci_pci_driver = {
-	.name =		(char *) hcd_name,
-	.id_table =	pci_ids,
-
-	.probe =	usb_hcd_pci_probe,
-	.remove =	usb_hcd_pci_remove,
-
-#ifdef	CONFIG_PM
-	.suspend =	usb_hcd_pci_suspend,
-	.resume =	usb_hcd_pci_resume,
-#endif
-	.shutdown = 	usb_hcd_pci_shutdown,
-};
diff -urN host/.svn/text-base/ehci-ppc-soc.c.svn-base host.new/.svn/text-base/ehci-ppc-soc.c.svn-base
--- host/.svn/text-base/ehci-ppc-soc.c.svn-base	2009-02-24 19:00:15.719954189 +0100
+++ host.new/.svn/text-base/ehci-ppc-soc.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,200 +0,0 @@
-/*
- * EHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 2006-2007 Stefan Roese <sr@denx.de>, DENX Software Engineering
- *
- * Bus Glue for PPC On-Chip EHCI driver
- * Tested on AMCC 440EPx
- *
- * Based on "ehci-au1xxx.c" by K.Boge <karsten.boge@amd.com>
- *
- * This file is licenced under the GPL.
- */
-
-#include <linux/platform_device.h>
-
-extern int usb_disabled(void);
-
-/* called during probe() after chip reset completes */
-static int ehci_ppc_soc_setup(struct usb_hcd *hcd)
-{
-	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
-	int		retval;
-
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
-
-	retval = ehci_init(hcd);
-	if (retval)
-		return retval;
-
-	ehci->sbrn = 0x20;
-	return ehci_reset(ehci);
-}
-
-/**
- * usb_ehci_ppc_soc_probe - initialize PPC-SoC-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- *
- */
-int usb_ehci_ppc_soc_probe(const struct hc_driver *driver,
-			   struct usb_hcd **hcd_out,
-			   struct platform_device *dev)
-{
-	int retval;
-	struct usb_hcd *hcd;
-	struct ehci_hcd *ehci;
-
-	if (dev->resource[1].flags != IORESOURCE_IRQ) {
-		pr_debug("resource[1] is not IORESOURCE_IRQ");
-		retval = -ENOMEM;
-	}
-	hcd = usb_create_hcd(driver, &dev->dev, "PPC-SOC EHCI");
-	if (!hcd)
-		return -ENOMEM;
-	hcd->rsrc_start = dev->resource[0].start;
-	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		pr_debug("request_mem_region failed");
-		retval = -EBUSY;
-		goto err1;
-	}
-
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-	if (!hcd->regs) {
-		pr_debug("ioremap failed");
-		retval = -ENOMEM;
-		goto err2;
-	}
-
-	ehci = hcd_to_ehci(hcd);
-	ehci->big_endian_mmio = 1;
-	ehci->big_endian_desc = 1;
-	ehci->caps = hcd->regs;
-	ehci->regs = hcd->regs + HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
-
-	/* cache this readonly data; minimize chip reads */
-	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
-
-#if defined(CONFIG_440EPX)
-	/*
-	 * 440EPx Errata USBH_3
-	 * Fix: Enable Break Memory Transfer (BMT) in INSNREG3
-	 */
-	out_be32((void *)((ulong)(&ehci->regs->command) + 0x8c), (1 << 0));
-	ehci_dbg(ehci, "Break Memory Transfer (BMT) has beed enabled!\n");
-#endif
-
-	retval = usb_add_hcd(hcd, dev->resource[1].start, IRQF_DISABLED);
-	if (retval == 0)
-		return retval;
-
-	iounmap(hcd->regs);
-err2:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-err1:
-	usb_put_hcd(hcd);
-	return retval;
-}
-
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_ehci_hcd_ppc_soc_remove - shutdown processing for PPC-SoC-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_ehci_hcd_ppc_soc_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
- */
-void usb_ehci_ppc_soc_remove(struct usb_hcd *hcd, struct platform_device *dev)
-{
-	usb_remove_hcd(hcd);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-}
-
-static const struct hc_driver ehci_ppc_soc_hc_driver = {
-	.description = hcd_name,
-	.product_desc = "PPC-SOC EHCI",
-	.hcd_priv_size = sizeof(struct ehci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq = ehci_irq,
-	.flags = HCD_MEMORY | HCD_USB2,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset = ehci_ppc_soc_setup,
-	.start = ehci_run,
-	.stop = ehci_stop,
-	.shutdown = ehci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue = ehci_urb_enqueue,
-	.urb_dequeue = ehci_urb_dequeue,
-	.endpoint_disable = ehci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number = ehci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data = ehci_hub_status_data,
-	.hub_control = ehci_hub_control,
-#ifdef	CONFIG_PM
-	.hub_suspend = ehci_hub_suspend,
-	.hub_resume = ehci_hub_resume,
-#endif
-};
-
-static int ehci_hcd_ppc_soc_drv_probe(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = NULL;
-	int ret;
-
-	pr_debug("In ehci_hcd_ppc_soc_drv_probe\n");
-
-	if (usb_disabled())
-		return -ENODEV;
-
-	ret = usb_ehci_ppc_soc_probe(&ehci_ppc_soc_hc_driver, &hcd, pdev);
-	return ret;
-}
-
-static int ehci_hcd_ppc_soc_drv_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	usb_ehci_ppc_soc_remove(hcd, pdev);
-	return 0;
-}
-
-MODULE_ALIAS("ppc-soc-ehci");
-static struct platform_driver ehci_ppc_soc_driver = {
-	.probe = ehci_hcd_ppc_soc_drv_probe,
-	.remove = ehci_hcd_ppc_soc_drv_remove,
-	.shutdown = usb_hcd_platform_shutdown,
-	.driver = {
-		.name = "ppc-soc-ehci",
-		.bus = &platform_bus_type
-	}
-};
diff -urN host/.svn/text-base/ehci-ps3.c.svn-base host.new/.svn/text-base/ehci-ps3.c.svn-base
--- host/.svn/text-base/ehci-ps3.c.svn-base	2009-02-24 19:00:15.719954189 +0100
+++ host.new/.svn/text-base/ehci-ps3.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,248 +0,0 @@
-/*
- *  PS3 EHCI Host Controller driver
- *
- *  Copyright (C) 2006 Sony Computer Entertainment Inc.
- *  Copyright 2006 Sony Corp.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <asm/firmware.h>
-#include <asm/ps3.h>
-
-static int ps3_ehci_hc_reset(struct usb_hcd *hcd)
-{
-	int result;
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-
-	ehci->big_endian_mmio = 1;
-
-	ehci->caps = hcd->regs;
-	ehci->regs = hcd->regs + HC_LENGTH(ehci_readl(ehci,
-		&ehci->caps->hc_capbase));
-
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
-
-	result = ehci_halt(ehci);
-
-	if (result)
-		return result;
-
-	result = ehci_init(hcd);
-
-	if (result)
-		return result;
-
-	ehci_port_power(ehci, 0);
-
-	return result;
-}
-
-static const struct hc_driver ps3_ehci_hc_driver = {
-	.description		= hcd_name,
-	.product_desc		= "PS3 EHCI Host Controller",
-	.hcd_priv_size		= sizeof(struct ehci_hcd),
-	.irq			= ehci_irq,
-	.flags			= HCD_MEMORY | HCD_USB2,
-	.reset			= ps3_ehci_hc_reset,
-	.start			= ehci_run,
-	.stop			= ehci_stop,
-	.shutdown		= ehci_shutdown,
-	.urb_enqueue		= ehci_urb_enqueue,
-	.urb_dequeue		= ehci_urb_dequeue,
-	.endpoint_disable	= ehci_endpoint_disable,
-	.get_frame_number	= ehci_get_frame,
-	.hub_status_data	= ehci_hub_status_data,
-	.hub_control		= ehci_hub_control,
-#if defined(CONFIG_PM)
-	.bus_suspend		= ehci_bus_suspend,
-	.bus_resume		= ehci_bus_resume,
-#endif
-};
-
-static int ps3_ehci_probe(struct ps3_system_bus_device *dev)
-{
-	int result;
-	struct usb_hcd *hcd;
-	unsigned int virq;
-	static u64 dummy_mask = DMA_32BIT_MASK;
-
-	if (usb_disabled()) {
-		result = -ENODEV;
-		goto fail_start;
-	}
-
-	result = ps3_open_hv_device(dev);
-
-	if (result) {
-		dev_dbg(&dev->core, "%s:%d: ps3_open_hv_device failed\n",
-			__func__, __LINE__);
-		goto fail_open;
-	}
-
-	result = ps3_dma_region_create(dev->d_region);
-
-	if (result) {
-		dev_dbg(&dev->core, "%s:%d: ps3_dma_region_create failed: "
-			"(%d)\n", __func__, __LINE__, result);
-		BUG_ON("check region type");
-		goto fail_dma_region;
-	}
-
-	result = ps3_mmio_region_create(dev->m_region);
-
-	if (result) {
-		dev_dbg(&dev->core, "%s:%d: ps3_map_mmio_region failed\n",
-			__func__, __LINE__);
-		result = -EPERM;
-		goto fail_mmio_region;
-	}
-
-	dev_dbg(&dev->core, "%s:%d: mmio mapped_addr %lxh\n", __func__,
-		__LINE__, dev->m_region->lpar_addr);
-
-	result = ps3_io_irq_setup(PS3_BINDING_CPU_ANY, dev->interrupt_id, &virq);
-
-	if (result) {
-		dev_dbg(&dev->core, "%s:%d: ps3_construct_io_irq(%d) failed.\n",
-			__func__, __LINE__, virq);
-		result = -EPERM;
-		goto fail_irq;
-	}
-
-	dev->core.power.power_state = PMSG_ON;
-	dev->core.dma_mask = &dummy_mask; /* FIXME: for improper usb code */
-
-	hcd = usb_create_hcd(&ps3_ehci_hc_driver, &dev->core, dev->core.bus_id);
-
-	if (!hcd) {
-		dev_dbg(&dev->core, "%s:%d: usb_create_hcd failed\n", __func__,
-			__LINE__);
-		result = -ENOMEM;
-		goto fail_create_hcd;
-	}
-
-	hcd->rsrc_start = dev->m_region->lpar_addr;
-	hcd->rsrc_len = dev->m_region->len;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name))
-		dev_dbg(&dev->core, "%s:%d: request_mem_region failed\n",
-			__func__, __LINE__);
-
-	hcd->regs = ioremap(dev->m_region->lpar_addr, dev->m_region->len);
-
-	if (!hcd->regs) {
-		dev_dbg(&dev->core, "%s:%d: ioremap failed\n", __func__,
-			__LINE__);
-		result = -EPERM;
-		goto fail_ioremap;
-	}
-
-	dev_dbg(&dev->core, "%s:%d: hcd->rsrc_start %lxh\n", __func__, __LINE__,
-		(unsigned long)hcd->rsrc_start);
-	dev_dbg(&dev->core, "%s:%d: hcd->rsrc_len   %lxh\n", __func__, __LINE__,
-		(unsigned long)hcd->rsrc_len);
-	dev_dbg(&dev->core, "%s:%d: hcd->regs       %lxh\n", __func__, __LINE__,
-		(unsigned long)hcd->regs);
-	dev_dbg(&dev->core, "%s:%d: virq            %lu\n", __func__, __LINE__,
-		(unsigned long)virq);
-
-	ps3_system_bus_set_driver_data(dev, hcd);
-
-	result = usb_add_hcd(hcd, virq, IRQF_DISABLED);
-
-	if (result) {
-		dev_dbg(&dev->core, "%s:%d: usb_add_hcd failed (%d)\n",
-			__func__, __LINE__, result);
-		goto fail_add_hcd;
-	}
-
-	return result;
-
-fail_add_hcd:
-	iounmap(hcd->regs);
-fail_ioremap:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-fail_create_hcd:
-	ps3_io_irq_destroy(virq);
-fail_irq:
-	ps3_free_mmio_region(dev->m_region);
-fail_mmio_region:
-	ps3_dma_region_free(dev->d_region);
-fail_dma_region:
-	ps3_close_hv_device(dev);
-fail_open:
-fail_start:
-	return result;
-}
-
-static int ps3_ehci_remove(struct ps3_system_bus_device *dev)
-{
-	unsigned int tmp;
-	struct usb_hcd *hcd =
-		(struct usb_hcd *)ps3_system_bus_get_driver_data(dev);
-
-	BUG_ON(!hcd);
-
-	dev_dbg(&dev->core, "%s:%d: regs %p\n", __func__, __LINE__, hcd->regs);
-	dev_dbg(&dev->core, "%s:%d: irq %u\n", __func__, __LINE__, hcd->irq);
-
-	tmp = hcd->irq;
-
-	usb_remove_hcd(hcd);
-
-	ps3_system_bus_set_driver_data(dev, NULL);
-
-	BUG_ON(!hcd->regs);
-	iounmap(hcd->regs);
-
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-
-	ps3_io_irq_destroy(tmp);
-	ps3_free_mmio_region(dev->m_region);
-
-	ps3_dma_region_free(dev->d_region);
-	ps3_close_hv_device(dev);
-
-	return 0;
-}
-
-static int ps3_ehci_driver_register(struct ps3_system_bus_driver *drv)
-{
-	return firmware_has_feature(FW_FEATURE_PS3_LV1)
-		? ps3_system_bus_driver_register(drv)
-		: 0;
-}
-
-static void ps3_ehci_driver_unregister(struct ps3_system_bus_driver *drv)
-{
-	if (firmware_has_feature(FW_FEATURE_PS3_LV1))
-		ps3_system_bus_driver_unregister(drv);
-}
-
-MODULE_ALIAS(PS3_MODULE_ALIAS_EHCI);
-
-static struct ps3_system_bus_driver ps3_ehci_driver = {
-	.core.name = "ps3-ehci-driver",
-	.core.owner = THIS_MODULE,
-	.match_id = PS3_MATCH_ID_EHCI,
-	.probe = ps3_ehci_probe,
-	.remove = ps3_ehci_remove,
-	.shutdown = ps3_ehci_remove,
-};
diff -urN host/.svn/text-base/ehci-q.c.svn-base host.new/.svn/text-base/ehci-q.c.svn-base
--- host/.svn/text-base/ehci-q.c.svn-base	2009-02-24 19:00:15.727953782 +0100
+++ host.new/.svn/text-base/ehci-q.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,1118 +0,0 @@
-/*
- * Copyright (C) 2001-2004 by David Brownell
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/* this file is part of ehci-hcd.c */
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * EHCI hardware queue manipulation ... the core.  QH/QTD manipulation.
- *
- * Control, bulk, and interrupt traffic all use "qh" lists.  They list "qtd"
- * entries describing USB transactions, max 16-20kB/entry (with 4kB-aligned
- * buffers needed for the larger number).  We use one QH per endpoint, queue
- * multiple urbs (all three types) per endpoint.  URBs may need several qtds.
- *
- * ISO traffic uses "ISO TD" (itd, and sitd) records, and (along with
- * interrupts) needs careful scheduling.  Performance improvements can be
- * an ongoing challenge.  That's in "ehci-sched.c".
- *
- * USB 1.1 devices are handled (a) by "companion" OHCI or UHCI root hubs,
- * or otherwise through transaction translators (TTs) in USB 2.0 hubs using
- * (b) special fields in qh entries or (c) split iso entries.  TTs will
- * buffer low/full speed data so the host collects it at high speed.
- */
-
-/*-------------------------------------------------------------------------*/
-
-/* fill a qtd, returning how much of the buffer we were able to queue up */
-
-static int
-qtd_fill(struct ehci_hcd *ehci, struct ehci_qtd *qtd, dma_addr_t buf,
-		  size_t len, int token, int maxpacket)
-{
-	int	i, count;
-	u64	addr = buf;
-
-	/* one buffer entry per 4K ... first might be short or unaligned */
-	qtd->hw_buf[0] = cpu_to_hc32(ehci, (u32)addr);
-	qtd->hw_buf_hi[0] = cpu_to_hc32(ehci, (u32)(addr >> 32));
-	count = 0x1000 - (buf & 0x0fff);	/* rest of that page */
-	if (likely (len < count))		/* ... iff needed */
-		count = len;
-	else {
-		buf +=  0x1000;
-		buf &= ~0x0fff;
-
-		/* per-qtd limit: from 16K to 20K (best alignment) */
-		for (i = 1; count < len && i < 5; i++) {
-			addr = buf;
-			qtd->hw_buf[i] = cpu_to_hc32(ehci, (u32)addr);
-			qtd->hw_buf_hi[i] = cpu_to_hc32(ehci,
-					(u32)(addr >> 32));
-			buf += 0x1000;
-			if ((count + 0x1000) < len)
-				count += 0x1000;
-			else
-				count = len;
-		}
-
-		/* short packets may only terminate transfers */
-		if (count != len)
-			count -= (count % maxpacket);
-	}
-	qtd->hw_token = cpu_to_hc32(ehci, (count << 16) | token);
-	qtd->length = count;
-
-	return count;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static inline void
-qh_update (struct ehci_hcd *ehci, struct ehci_qh *qh, struct ehci_qtd *qtd)
-{
-	/* writes to an active overlay are unsafe */
-	BUG_ON(qh->qh_state != QH_STATE_IDLE);
-
-	qh->hw_qtd_next = QTD_NEXT(ehci, qtd->qtd_dma);
-	qh->hw_alt_next = EHCI_LIST_END(ehci);
-
-	/* Except for control endpoints, we make hardware maintain data
-	 * toggle (like OHCI) ... here (re)initialize the toggle in the QH,
-	 * and set the pseudo-toggle in udev. Only usb_clear_halt() will
-	 * ever clear it.
-	 */
-	if (!(qh->hw_info1 & cpu_to_hc32(ehci, 1 << 14))) {
-		unsigned	is_out, epnum;
-
-		is_out = !(qtd->hw_token & cpu_to_hc32(ehci, 1 << 8));
-		epnum = (hc32_to_cpup(ehci, &qh->hw_info1) >> 8) & 0x0f;
-		if (unlikely (!usb_gettoggle (qh->dev, epnum, is_out))) {
-			qh->hw_token &= ~cpu_to_hc32(ehci, QTD_TOGGLE);
-			usb_settoggle (qh->dev, epnum, is_out, 1);
-		}
-	}
-
-	/* HC must see latest qtd and qh data before we clear ACTIVE+HALT */
-	wmb ();
-	qh->hw_token &= cpu_to_hc32(ehci, QTD_TOGGLE | QTD_STS_PING);
-}
-
-/* if it weren't for a common silicon quirk (writing the dummy into the qh
- * overlay, so qh->hw_token wrongly becomes inactive/halted), only fault
- * recovery (including urb dequeue) would need software changes to a QH...
- */
-static void
-qh_refresh (struct ehci_hcd *ehci, struct ehci_qh *qh)
-{
-	struct ehci_qtd *qtd;
-
-	if (list_empty (&qh->qtd_list))
-		qtd = qh->dummy;
-	else {
-		qtd = list_entry (qh->qtd_list.next,
-				struct ehci_qtd, qtd_list);
-		/* first qtd may already be partially processed */
-		if (cpu_to_hc32(ehci, qtd->qtd_dma) == qh->hw_current)
-			qtd = NULL;
-	}
-
-	if (qtd)
-		qh_update (ehci, qh, qtd);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static void qtd_copy_status (
-	struct ehci_hcd *ehci,
-	struct urb *urb,
-	size_t length,
-	u32 token
-)
-{
-	/* count IN/OUT bytes, not SETUP (even short packets) */
-	if (likely (QTD_PID (token) != 2))
-		urb->actual_length += length - QTD_LENGTH (token);
-
-	/* don't modify error codes */
-	if (unlikely (urb->status != -EINPROGRESS))
-		return;
-
-	/* force cleanup after short read; not always an error */
-	if (unlikely (IS_SHORT_READ (token)))
-		urb->status = -EREMOTEIO;
-
-	/* serious "can't proceed" faults reported by the hardware */
-	if (token & QTD_STS_HALT) {
-		if (token & QTD_STS_BABBLE) {
-			/* FIXME "must" disable babbling device's port too */
-			urb->status = -EOVERFLOW;
-		} else if (token & QTD_STS_MMF) {
-			/* fs/ls interrupt xfer missed the complete-split */
-			urb->status = -EPROTO;
-		} else if (token & QTD_STS_DBE) {
-			urb->status = (QTD_PID (token) == 1) /* IN ? */
-				? -ENOSR  /* hc couldn't read data */
-				: -ECOMM; /* hc couldn't write data */
-		} else if (token & QTD_STS_XACT) {
-			/* timeout, bad crc, wrong PID, etc; retried */
-			if (QTD_CERR (token))
-				urb->status = -EPIPE;
-			else {
-				ehci_dbg (ehci, "devpath %s ep%d%s 3strikes\n",
-					urb->dev->devpath,
-					usb_pipeendpoint (urb->pipe),
-					usb_pipein (urb->pipe) ? "in" : "out");
-				urb->status = -EPROTO;
-			}
-		/* CERR nonzero + no errors + halt --> stall */
-		} else if (QTD_CERR (token))
-			urb->status = -EPIPE;
-		else	/* unknown */
-			urb->status = -EPROTO;
-
-		ehci_vdbg (ehci,
-			"dev%d ep%d%s qtd token %08x --> status %d\n",
-			usb_pipedevice (urb->pipe),
-			usb_pipeendpoint (urb->pipe),
-			usb_pipein (urb->pipe) ? "in" : "out",
-			token, urb->status);
-
-		/* if async CSPLIT failed, try cleaning out the TT buffer */
-		if (urb->status != -EPIPE
-				&& urb->dev->tt && !usb_pipeint (urb->pipe)
-				&& ((token & QTD_STS_MMF) != 0
-					|| QTD_CERR(token) == 0)
-				&& (!ehci_is_TDI(ehci)
-			                || urb->dev->tt->hub !=
-					   ehci_to_hcd(ehci)->self.root_hub)) {
-#ifdef DEBUG
-			struct usb_device *tt = urb->dev->tt->hub;
-			dev_dbg (&tt->dev,
-				"clear tt buffer port %d, a%d ep%d t%08x\n",
-				urb->dev->ttport, urb->dev->devnum,
-				usb_pipeendpoint (urb->pipe), token);
-#endif /* DEBUG */
-			usb_hub_tt_clear_buffer (urb->dev, urb->pipe);
-		}
-	}
-}
-
-static void
-ehci_urb_done (struct ehci_hcd *ehci, struct urb *urb)
-__releases(ehci->lock)
-__acquires(ehci->lock)
-{
-	if (likely (urb->hcpriv != NULL)) {
-		struct ehci_qh	*qh = (struct ehci_qh *) urb->hcpriv;
-
-		/* S-mask in a QH means it's an interrupt urb */
-		if ((qh->hw_info2 & cpu_to_hc32(ehci, QH_SMASK)) != 0) {
-
-			/* ... update hc-wide periodic stats (for usbfs) */
-			ehci_to_hcd(ehci)->self.bandwidth_int_reqs--;
-		}
-		qh_put (qh);
-	}
-
-	spin_lock (&urb->lock);
-	urb->hcpriv = NULL;
-	switch (urb->status) {
-	case -EINPROGRESS:		/* success */
-		urb->status = 0;
-	default:			/* fault */
-		COUNT (ehci->stats.complete);
-		break;
-	case -EREMOTEIO:		/* fault or normal */
-		if (!(urb->transfer_flags & URB_SHORT_NOT_OK))
-			urb->status = 0;
-		COUNT (ehci->stats.complete);
-		break;
-	case -ECONNRESET:		/* canceled */
-	case -ENOENT:
-		COUNT (ehci->stats.unlink);
-		break;
-	}
-	spin_unlock (&urb->lock);
-
-#ifdef EHCI_URB_TRACE
-	ehci_dbg (ehci,
-		"%s %s urb %p ep%d%s status %d len %d/%d\n",
-		__FUNCTION__, urb->dev->devpath, urb,
-		usb_pipeendpoint (urb->pipe),
-		usb_pipein (urb->pipe) ? "in" : "out",
-		urb->status,
-		urb->actual_length, urb->transfer_buffer_length);
-#endif
-
-	/* complete() can reenter this HCD */
-	spin_unlock (&ehci->lock);
-	usb_hcd_giveback_urb (ehci_to_hcd(ehci), urb);
-	spin_lock (&ehci->lock);
-}
-
-static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh);
-static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh);
-
-static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh);
-static int qh_schedule (struct ehci_hcd *ehci, struct ehci_qh *qh);
-
-/*
- * Process and free completed qtds for a qh, returning URBs to drivers.
- * Chases up to qh->hw_current.  Returns number of completions called,
- * indicating how much "real" work we did.
- */
-static unsigned
-qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
-{
-	struct ehci_qtd		*last = NULL, *end = qh->dummy;
-	struct list_head	*entry, *tmp;
-	int			stopped;
-	unsigned		count = 0;
-	int			do_status = 0;
-	u8			state;
-	u32			halt = HALT_BIT(ehci);
-
-	if (unlikely (list_empty (&qh->qtd_list)))
-		return count;
-
-	/* completions (or tasks on other cpus) must never clobber HALT
-	 * till we've gone through and cleaned everything up, even when
-	 * they add urbs to this qh's queue or mark them for unlinking.
-	 *
-	 * NOTE:  unlinking expects to be done in queue order.
-	 */
-	state = qh->qh_state;
-	qh->qh_state = QH_STATE_COMPLETING;
-	stopped = (state == QH_STATE_IDLE);
-
-	/* remove de-activated QTDs from front of queue.
-	 * after faults (including short reads), cleanup this urb
-	 * then let the queue advance.
-	 * if queue is stopped, handles unlinks.
-	 */
-	list_for_each_safe (entry, tmp, &qh->qtd_list) {
-		struct ehci_qtd	*qtd;
-		struct urb	*urb;
-		u32		token = 0;
-
-		qtd = list_entry (entry, struct ehci_qtd, qtd_list);
-		urb = qtd->urb;
-
-		/* clean up any state from previous QTD ...*/
-		if (last) {
-			if (likely (last->urb != urb)) {
-				ehci_urb_done (ehci, last->urb);
-				count++;
-			}
-			ehci_qtd_free (ehci, last);
-			last = NULL;
-		}
-
-		/* ignore urbs submitted during completions we reported */
-		if (qtd == end)
-			break;
-
-		/* hardware copies qtd out of qh overlay */
-		rmb ();
-		token = hc32_to_cpu(ehci, qtd->hw_token);
-
-		/* always clean up qtds the hc de-activated */
-		if ((token & QTD_STS_ACTIVE) == 0) {
-
-			if ((token & QTD_STS_HALT) != 0) {
-				stopped = 1;
-
-			/* magic dummy for some short reads; qh won't advance.
-			 * that silicon quirk can kick in with this dummy too.
-			 */
-			} else if (IS_SHORT_READ (token)
-					&& !(qtd->hw_alt_next
-						& EHCI_LIST_END(ehci))) {
-				stopped = 1;
-				goto halt;
-			}
-
-		/* stop scanning when we reach qtds the hc is using */
-		} else if (likely (!stopped
-				&& HC_IS_RUNNING (ehci_to_hcd(ehci)->state))) {
-			break;
-
-		} else {
-			stopped = 1;
-
-			if (unlikely (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state)))
-				urb->status = -ESHUTDOWN;
-
-			/* ignore active urbs unless some previous qtd
-			 * for the urb faulted (including short read) or
-			 * its urb was canceled.  we may patch qh or qtds.
-			 */
-			if (likely (urb->status == -EINPROGRESS))
-				continue;
-
-			/* issue status after short control reads */
-			if (unlikely (do_status != 0)
-					&& QTD_PID (token) == 0 /* OUT */) {
-				do_status = 0;
-				continue;
-			}
-
-			/* token in overlay may be most current */
-			if (state == QH_STATE_IDLE
-					&& cpu_to_hc32(ehci, qtd->qtd_dma)
-						== qh->hw_current)
-				token = hc32_to_cpu(ehci, qh->hw_token);
-
-			/* force halt for unlinked or blocked qh, so we'll
-			 * patch the qh later and so that completions can't
-			 * activate it while we "know" it's stopped.
-			 */
-			if ((halt & qh->hw_token) == 0) {
-halt:
-				qh->hw_token |= halt;
-				wmb ();
-			}
-		}
-
-		/* remove it from the queue */
-		spin_lock (&urb->lock);
-		qtd_copy_status (ehci, urb, qtd->length, token);
-		do_status = (urb->status == -EREMOTEIO)
-				&& usb_pipecontrol (urb->pipe);
-		spin_unlock (&urb->lock);
-
-		if (stopped && qtd->qtd_list.prev != &qh->qtd_list) {
-			last = list_entry (qtd->qtd_list.prev,
-					struct ehci_qtd, qtd_list);
-			last->hw_next = qtd->hw_next;
-		}
-		list_del (&qtd->qtd_list);
-		last = qtd;
-	}
-
-	/* last urb's completion might still need calling */
-	if (likely (last != NULL)) {
-		ehci_urb_done (ehci, last->urb);
-		count++;
-		ehci_qtd_free (ehci, last);
-	}
-
-	/* restore original state; caller must unlink or relink */
-	qh->qh_state = state;
-
-	/* be sure the hardware's done with the qh before refreshing
-	 * it after fault cleanup, or recovering from silicon wrongly
-	 * overlaying the dummy qtd (which reduces DMA chatter).
-	 */
-	if (stopped != 0 || qh->hw_qtd_next == EHCI_LIST_END(ehci)) {
-		switch (state) {
-		case QH_STATE_IDLE:
-			qh_refresh(ehci, qh);
-			break;
-		case QH_STATE_LINKED:
-			/* should be rare for periodic transfers,
-			 * except maybe high bandwidth ...
-			 */
-			if ((cpu_to_hc32(ehci, QH_SMASK)
-					& qh->hw_info2) != 0) {
-				intr_deschedule (ehci, qh);
-				(void) qh_schedule (ehci, qh);
-			} else
-				unlink_async (ehci, qh);
-			break;
-		/* otherwise, unlink already started */
-		}
-	}
-
-	return count;
-}
-
-/*-------------------------------------------------------------------------*/
-
-// high bandwidth multiplier, as encoded in highspeed endpoint descriptors
-#define hb_mult(wMaxPacketSize) (1 + (((wMaxPacketSize) >> 11) & 0x03))
-// ... and packet size, for any kind of endpoint descriptor
-#define max_packet(wMaxPacketSize) ((wMaxPacketSize) & 0x07ff)
-
-/*
- * reverse of qh_urb_transaction:  free a list of TDs.
- * used for cleanup after errors, before HC sees an URB's TDs.
- */
-static void qtd_list_free (
-	struct ehci_hcd		*ehci,
-	struct urb		*urb,
-	struct list_head	*qtd_list
-) {
-	struct list_head	*entry, *temp;
-
-	list_for_each_safe (entry, temp, qtd_list) {
-		struct ehci_qtd	*qtd;
-
-		qtd = list_entry (entry, struct ehci_qtd, qtd_list);
-		list_del (&qtd->qtd_list);
-		ehci_qtd_free (ehci, qtd);
-	}
-}
-
-/*
- * create a list of filled qtds for this URB; won't link into qh.
- */
-static struct list_head *
-qh_urb_transaction (
-	struct ehci_hcd		*ehci,
-	struct urb		*urb,
-	struct list_head	*head,
-	gfp_t			flags
-) {
-	struct ehci_qtd		*qtd, *qtd_prev;
-	dma_addr_t		buf;
-	int			len, maxpacket;
-	int			is_input;
-	u32			token;
-
-	/*
-	 * URBs map to sequences of QTDs:  one logical transaction
-	 */
-	qtd = ehci_qtd_alloc (ehci, flags);
-	if (unlikely (!qtd))
-		return NULL;
-	list_add_tail (&qtd->qtd_list, head);
-	qtd->urb = urb;
-
-	token = QTD_STS_ACTIVE;
-	token |= (EHCI_TUNE_CERR << 10);
-	/* for split transactions, SplitXState initialized to zero */
-
-	len = urb->transfer_buffer_length;
-	is_input = usb_pipein (urb->pipe);
-	if (usb_pipecontrol (urb->pipe)) {
-		/* SETUP pid */
-		qtd_fill(ehci, qtd, urb->setup_dma,
-				sizeof (struct usb_ctrlrequest),
-				token | (2 /* "setup" */ << 8), 8);
-
-		/* ... and always at least one more pid */
-		token ^= QTD_TOGGLE;
-		qtd_prev = qtd;
-		qtd = ehci_qtd_alloc (ehci, flags);
-		if (unlikely (!qtd))
-			goto cleanup;
-		qtd->urb = urb;
-		qtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);
-		list_add_tail (&qtd->qtd_list, head);
-
-		/* for zero length DATA stages, STATUS is always IN */
-		if (len == 0)
-			token |= (1 /* "in" */ << 8);
-	}
-
-	/*
-	 * data transfer stage:  buffer setup
-	 */
-	buf = urb->transfer_dma;
-
-	if (is_input)
-		token |= (1 /* "in" */ << 8);
-	/* else it's already initted to "out" pid (0 << 8) */
-
-	maxpacket = max_packet(usb_maxpacket(urb->dev, urb->pipe, !is_input));
-
-	/*
-	 * buffer gets wrapped in one or more qtds;
-	 * last one may be "short" (including zero len)
-	 * and may serve as a control status ack
-	 */
-	for (;;) {
-		int this_qtd_len;
-
-		this_qtd_len = qtd_fill(ehci, qtd, buf, len, token, maxpacket);
-		len -= this_qtd_len;
-		buf += this_qtd_len;
-		if (is_input)
-			qtd->hw_alt_next = ehci->async->hw_alt_next;
-
-		/* qh makes control packets use qtd toggle; maybe switch it */
-		if ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)
-			token ^= QTD_TOGGLE;
-
-		if (likely (len <= 0))
-			break;
-
-		qtd_prev = qtd;
-		qtd = ehci_qtd_alloc (ehci, flags);
-		if (unlikely (!qtd))
-			goto cleanup;
-		qtd->urb = urb;
-		qtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);
-		list_add_tail (&qtd->qtd_list, head);
-	}
-
-	/* unless the bulk/interrupt caller wants a chance to clean
-	 * up after short reads, hc should advance qh past this urb
-	 */
-	if (likely ((urb->transfer_flags & URB_SHORT_NOT_OK) == 0
-				|| usb_pipecontrol (urb->pipe)))
-		qtd->hw_alt_next = EHCI_LIST_END(ehci);
-
-	/*
-	 * control requests may need a terminating data "status" ack;
-	 * bulk ones may need a terminating short packet (zero length).
-	 */
-	if (likely (urb->transfer_buffer_length != 0)) {
-		int	one_more = 0;
-
-		if (usb_pipecontrol (urb->pipe)) {
-			one_more = 1;
-			token ^= 0x0100;	/* "in" <--> "out"  */
-			token |= QTD_TOGGLE;	/* force DATA1 */
-		} else if (usb_pipebulk (urb->pipe)
-				&& (urb->transfer_flags & URB_ZERO_PACKET)
-				&& !(urb->transfer_buffer_length % maxpacket)) {
-			one_more = 1;
-		}
-		if (one_more) {
-			qtd_prev = qtd;
-			qtd = ehci_qtd_alloc (ehci, flags);
-			if (unlikely (!qtd))
-				goto cleanup;
-			qtd->urb = urb;
-			qtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);
-			list_add_tail (&qtd->qtd_list, head);
-
-			/* never any data in such packets */
-			qtd_fill(ehci, qtd, 0, 0, token, 0);
-		}
-	}
-
-	/* by default, enable interrupt on urb completion */
-	if (likely (!(urb->transfer_flags & URB_NO_INTERRUPT)))
-		qtd->hw_token |= cpu_to_hc32(ehci, QTD_IOC);
-	return head;
-
-cleanup:
-	qtd_list_free (ehci, urb, head);
-	return NULL;
-}
-
-/*-------------------------------------------------------------------------*/
-
-// Would be best to create all qh's from config descriptors,
-// when each interface/altsetting is established.  Unlink
-// any previous qh and cancel its urbs first; endpoints are
-// implicitly reset then (data toggle too).
-// That'd mean updating how usbcore talks to HCDs. (2.7?)
-
-
-/*
- * Each QH holds a qtd list; a QH is used for everything except iso.
- *
- * For interrupt urbs, the scheduler must set the microframe scheduling
- * mask(s) each time the QH gets scheduled.  For highspeed, that's
- * just one microframe in the s-mask.  For split interrupt transactions
- * there are additional complications: c-mask, maybe FSTNs.
- */
-static struct ehci_qh *
-qh_make (
-	struct ehci_hcd		*ehci,
-	struct urb		*urb,
-	gfp_t			flags
-) {
-	struct ehci_qh		*qh = ehci_qh_alloc (ehci, flags);
-	u32			info1 = 0, info2 = 0;
-	int			is_input, type;
-	int			maxp = 0;
-
-	if (!qh)
-		return qh;
-
-	/*
-	 * init endpoint/device data for this QH
-	 */
-	info1 |= usb_pipeendpoint (urb->pipe) << 8;
-	info1 |= usb_pipedevice (urb->pipe) << 0;
-
-	is_input = usb_pipein (urb->pipe);
-	type = usb_pipetype (urb->pipe);
-	maxp = usb_maxpacket (urb->dev, urb->pipe, !is_input);
-
-	/* Compute interrupt scheduling parameters just once, and save.
-	 * - allowing for high bandwidth, how many nsec/uframe are used?
-	 * - split transactions need a second CSPLIT uframe; same question
-	 * - splits also need a schedule gap (for full/low speed I/O)
-	 * - qh has a polling interval
-	 *
-	 * For control/bulk requests, the HC or TT handles these.
-	 */
-	if (type == PIPE_INTERRUPT) {
-		qh->usecs = NS_TO_US (usb_calc_bus_time (USB_SPEED_HIGH, is_input, 0,
-				hb_mult (maxp) * max_packet (maxp)));
-		qh->start = NO_FRAME;
-
-		if (urb->dev->speed == USB_SPEED_HIGH) {
-			qh->c_usecs = 0;
-			qh->gap_uf = 0;
-
-			qh->period = urb->interval >> 3;
-			if (qh->period == 0 && urb->interval != 1) {
-				/* NOTE interval 2 or 4 uframes could work.
-				 * But interval 1 scheduling is simpler, and
-				 * includes high bandwidth.
-				 */
-				dbg ("intr period %d uframes, NYET!",
-						urb->interval);
-				goto done;
-			}
-		} else {
-			struct usb_tt	*tt = urb->dev->tt;
-			int		think_time;
-
-			/* gap is f(FS/LS transfer times) */
-			qh->gap_uf = 1 + usb_calc_bus_time (urb->dev->speed,
-					is_input, 0, maxp) / (125 * 1000);
-
-			/* FIXME this just approximates SPLIT/CSPLIT times */
-			if (is_input) {		// SPLIT, gap, CSPLIT+DATA
-				qh->c_usecs = qh->usecs + HS_USECS (0);
-				qh->usecs = HS_USECS (1);
-			} else {		// SPLIT+DATA, gap, CSPLIT
-				qh->usecs += HS_USECS (1);
-				qh->c_usecs = HS_USECS (0);
-			}
-
-			think_time = tt ? tt->think_time : 0;
-			qh->tt_usecs = NS_TO_US (think_time +
-					usb_calc_bus_time (urb->dev->speed,
-					is_input, 0, max_packet (maxp)));
-			qh->period = urb->interval;
-		}
-	}
-
-	/* support for tt scheduling, and access to toggles */
-	qh->dev = urb->dev;
-
-	/* using TT? */
-	switch (urb->dev->speed) {
-	case USB_SPEED_LOW:
-		info1 |= (1 << 12);	/* EPS "low" */
-		/* FALL THROUGH */
-
-	case USB_SPEED_FULL:
-		/* EPS 0 means "full" */
-		if (type != PIPE_INTERRUPT)
-			info1 |= (EHCI_TUNE_RL_TT << 28);
-		if (type == PIPE_CONTROL) {
-			info1 |= (1 << 27);	/* for TT */
-			info1 |= 1 << 14;	/* toggle from qtd */
-		}
-		info1 |= maxp << 16;
-
-		info2 |= (EHCI_TUNE_MULT_TT << 30);
-
-		/* Some Freescale processors have an erratum in which the
-		 * port number in the queue head was 0..N-1 instead of 1..N.
-		 */
-		if (ehci_has_fsl_portno_bug(ehci))
-			info2 |= (urb->dev->ttport-1) << 23;
-		else
-			info2 |= urb->dev->ttport << 23;
-
-		/* set the address of the TT; for TDI's integrated
-		 * root hub tt, leave it zeroed.
-		 */
-		if (!ehci_is_TDI(ehci)
-				|| urb->dev->tt->hub !=
-					ehci_to_hcd(ehci)->self.root_hub)
-			info2 |= urb->dev->tt->hub->devnum << 16;
-
-		/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets c-mask } */
-
-		break;
-
-	case USB_SPEED_HIGH:		/* no TT involved */
-		info1 |= (2 << 12);	/* EPS "high" */
-		if (type == PIPE_CONTROL) {
-			info1 |= (EHCI_TUNE_RL_HS << 28);
-			info1 |= 64 << 16;	/* usb2 fixed maxpacket */
-			info1 |= 1 << 14;	/* toggle from qtd */
-			info2 |= (EHCI_TUNE_MULT_HS << 30);
-		} else if (type == PIPE_BULK) {
-			info1 |= (EHCI_TUNE_RL_HS << 28);
-			info1 |= 512 << 16;	/* usb2 fixed maxpacket */
-			info2 |= (EHCI_TUNE_MULT_HS << 30);
-		} else {		/* PIPE_INTERRUPT */
-			info1 |= max_packet (maxp) << 16;
-			info2 |= hb_mult (maxp) << 30;
-		}
-		break;
-	default:
-		dbg ("bogus dev %p speed %d", urb->dev, urb->dev->speed);
-done:
-		qh_put (qh);
-		return NULL;
-	}
-
-	/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets s-mask } */
-
-	/* init as live, toggle clear, advance to dummy */
-	qh->qh_state = QH_STATE_IDLE;
-	qh->hw_info1 = cpu_to_hc32(ehci, info1);
-	qh->hw_info2 = cpu_to_hc32(ehci, info2);
-	usb_settoggle (urb->dev, usb_pipeendpoint (urb->pipe), !is_input, 1);
-	qh_refresh (ehci, qh);
-	return qh;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* move qh (and its qtds) onto async queue; maybe enable queue.  */
-
-static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
-{
-	__hc32		dma = QH_NEXT(ehci, qh->qh_dma);
-	struct ehci_qh	*head;
-
-	/* (re)start the async schedule? */
-	head = ehci->async;
-	timer_action_done (ehci, TIMER_ASYNC_OFF);
-	if (!head->qh_next.qh) {
-		u32	cmd = ehci_readl(ehci, &ehci->regs->command);
-
-		if (!(cmd & CMD_ASE)) {
-			/* in case a clear of CMD_ASE didn't take yet */
-			(void)handshake(ehci, &ehci->regs->status,
-					STS_ASS, 0, 150);
-			cmd |= CMD_ASE | CMD_RUN;
-			ehci_writel(ehci, cmd, &ehci->regs->command);
-			ehci_to_hcd(ehci)->state = HC_STATE_RUNNING;
-			/* posted write need not be known to HC yet ... */
-		}
-	}
-
-	/* clear halt and/or toggle; and maybe recover from silicon quirk */
-	if (qh->qh_state == QH_STATE_IDLE)
-		qh_refresh (ehci, qh);
-
-	/* splice right after start */
-	qh->qh_next = head->qh_next;
-	qh->hw_next = head->hw_next;
-	wmb ();
-
-	head->qh_next.qh = qh;
-	head->hw_next = dma;
-
-	qh->qh_state = QH_STATE_LINKED;
-	/* qtd completions reported later by interrupt */
-}
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * For control/bulk/interrupt, return QH with these TDs appended.
- * Allocates and initializes the QH if necessary.
- * Returns null if it can't allocate a QH it needs to.
- * If the QH has TDs (urbs) already, that's great.
- */
-static struct ehci_qh *qh_append_tds (
-	struct ehci_hcd		*ehci,
-	struct urb		*urb,
-	struct list_head	*qtd_list,
-	int			epnum,
-	void			**ptr
-)
-{
-	struct ehci_qh		*qh = NULL;
-	u32			qh_addr_mask = cpu_to_hc32(ehci, 0x7f);
-
-	qh = (struct ehci_qh *) *ptr;
-	if (unlikely (qh == NULL)) {
-		/* can't sleep here, we have ehci->lock... */
-		qh = qh_make (ehci, urb, GFP_ATOMIC);
-		*ptr = qh;
-	}
-	if (likely (qh != NULL)) {
-		struct ehci_qtd	*qtd;
-
-		if (unlikely (list_empty (qtd_list)))
-			qtd = NULL;
-		else
-			qtd = list_entry (qtd_list->next, struct ehci_qtd,
-					qtd_list);
-
-		/* control qh may need patching ... */
-		if (unlikely (epnum == 0)) {
-
-                        /* usb_reset_device() briefly reverts to address 0 */
-                        if (usb_pipedevice (urb->pipe) == 0)
-                                qh->hw_info1 &= ~qh_addr_mask;
-		}
-
-		/* just one way to queue requests: swap with the dummy qtd.
-		 * only hc or qh_refresh() ever modify the overlay.
-		 */
-		if (likely (qtd != NULL)) {
-			struct ehci_qtd		*dummy;
-			dma_addr_t		dma;
-			__hc32			token;
-
-			/* to avoid racing the HC, use the dummy td instead of
-			 * the first td of our list (becomes new dummy).  both
-			 * tds stay deactivated until we're done, when the
-			 * HC is allowed to fetch the old dummy (4.10.2).
-			 */
-			token = qtd->hw_token;
-			qtd->hw_token = HALT_BIT(ehci);
-			wmb ();
-			dummy = qh->dummy;
-
-			dma = dummy->qtd_dma;
-			*dummy = *qtd;
-			dummy->qtd_dma = dma;
-
-			list_del (&qtd->qtd_list);
-			list_add (&dummy->qtd_list, qtd_list);
-			__list_splice (qtd_list, qh->qtd_list.prev);
-
-			ehci_qtd_init(ehci, qtd, qtd->qtd_dma);
-			qh->dummy = qtd;
-
-			/* hc must see the new dummy at list end */
-			dma = qtd->qtd_dma;
-			qtd = list_entry (qh->qtd_list.prev,
-					struct ehci_qtd, qtd_list);
-			qtd->hw_next = QTD_NEXT(ehci, dma);
-
-			/* let the hc process these next qtds */
-			wmb ();
-			dummy->hw_token = token;
-
-			urb->hcpriv = qh_get (qh);
-		}
-	}
-	return qh;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int
-submit_async (
-	struct ehci_hcd		*ehci,
-	struct usb_host_endpoint *ep,
-	struct urb		*urb,
-	struct list_head	*qtd_list,
-	gfp_t			mem_flags
-) {
-	struct ehci_qtd		*qtd;
-	int			epnum;
-	unsigned long		flags;
-	struct ehci_qh		*qh = NULL;
-	int			rc = 0;
-
-	qtd = list_entry (qtd_list->next, struct ehci_qtd, qtd_list);
-	epnum = ep->desc.bEndpointAddress;
-
-#ifdef EHCI_URB_TRACE
-	ehci_dbg (ehci,
-		"%s %s urb %p ep%d%s len %d, qtd %p [qh %p]\n",
-		__FUNCTION__, urb->dev->devpath, urb,
-		epnum & 0x0f, (epnum & USB_DIR_IN) ? "in" : "out",
-		urb->transfer_buffer_length,
-		qtd, ep->hcpriv);
-#endif
-
-	spin_lock_irqsave (&ehci->lock, flags);
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			       &ehci_to_hcd(ehci)->flags))) {
-		rc = -ESHUTDOWN;
-		goto done;
-	}
-
-	qh = qh_append_tds (ehci, urb, qtd_list, epnum, &ep->hcpriv);
-	if (unlikely(qh == NULL)) {
-		rc = -ENOMEM;
-		goto done;
-	}
-
-	/* Control/bulk operations through TTs don't need scheduling,
-	 * the HC and TT handle it when the TT has a buffer ready.
-	 */
-	if (likely (qh->qh_state == QH_STATE_IDLE))
-		qh_link_async (ehci, qh_get (qh));
- done:
-	spin_unlock_irqrestore (&ehci->lock, flags);
-	if (unlikely (qh == NULL))
-		qtd_list_free (ehci, urb, qtd_list);
-	return rc;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* the async qh for the qtds being reclaimed are now unlinked from the HC */
-
-static void end_unlink_async (struct ehci_hcd *ehci)
-{
-	struct ehci_qh		*qh = ehci->reclaim;
-	struct ehci_qh		*next;
-
-	timer_action_done (ehci, TIMER_IAA_WATCHDOG);
-
-	// qh->hw_next = cpu_to_hc32(qh->qh_dma);
-	qh->qh_state = QH_STATE_IDLE;
-	qh->qh_next.qh = NULL;
-	qh_put (qh);			// refcount from reclaim
-
-	/* other unlink(s) may be pending (in QH_STATE_UNLINK_WAIT) */
-	next = qh->reclaim;
-	ehci->reclaim = next;
-	ehci->reclaim_ready = 0;
-	qh->reclaim = NULL;
-
-	qh_completions (ehci, qh);
-
-	if (!list_empty (&qh->qtd_list)
-			&& HC_IS_RUNNING (ehci_to_hcd(ehci)->state))
-		qh_link_async (ehci, qh);
-	else {
-		qh_put (qh);		// refcount from async list
-
-		/* it's not free to turn the async schedule on/off; leave it
-		 * active but idle for a while once it empties.
-		 */
-		if (HC_IS_RUNNING (ehci_to_hcd(ehci)->state)
-				&& ehci->async->qh_next.qh == NULL)
-			timer_action (ehci, TIMER_ASYNC_OFF);
-	}
-
-	if (next) {
-		ehci->reclaim = NULL;
-		start_unlink_async (ehci, next);
-	}
-}
-
-/* makes sure the async qh will become idle */
-/* caller must own ehci->lock */
-
-static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
-{
-	int		cmd = ehci_readl(ehci, &ehci->regs->command);
-	struct ehci_qh	*prev;
-
-#ifdef DEBUG
-	assert_spin_locked(&ehci->lock);
-	if (ehci->reclaim
-			|| (qh->qh_state != QH_STATE_LINKED
-				&& qh->qh_state != QH_STATE_UNLINK_WAIT)
-			)
-		BUG ();
-#endif
-
-	/* stop async schedule right now? */
-	if (unlikely (qh == ehci->async)) {
-		/* can't get here without STS_ASS set */
-		if (ehci_to_hcd(ehci)->state != HC_STATE_HALT
-				&& !ehci->reclaim) {
-			/* ... and CMD_IAAD clear */
-			ehci_writel(ehci, cmd & ~CMD_ASE,
-				    &ehci->regs->command);
-			wmb ();
-			// handshake later, if we need to
-			timer_action_done (ehci, TIMER_ASYNC_OFF);
-		}
-		return;
-	}
-
-	qh->qh_state = QH_STATE_UNLINK;
-	ehci->reclaim = qh = qh_get (qh);
-
-	prev = ehci->async;
-	while (prev->qh_next.qh != qh)
-		prev = prev->qh_next.qh;
-
-	prev->hw_next = qh->hw_next;
-	prev->qh_next = qh->qh_next;
-	wmb ();
-
-	if (unlikely (ehci_to_hcd(ehci)->state == HC_STATE_HALT)) {
-		/* if (unlikely (qh->reclaim != 0))
-		 *	this will recurse, probably not much
-		 */
-		end_unlink_async (ehci);
-		return;
-	}
-
-	ehci->reclaim_ready = 0;
-	cmd |= CMD_IAAD;
-	ehci_writel(ehci, cmd, &ehci->regs->command);
-	(void)ehci_readl(ehci, &ehci->regs->command);
-	timer_action (ehci, TIMER_IAA_WATCHDOG);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static void scan_async (struct ehci_hcd *ehci)
-{
-	struct ehci_qh		*qh;
-	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
-
-	if (!++(ehci->stamp))
-		ehci->stamp++;
-	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
-rescan:
-	qh = ehci->async->qh_next.qh;
-	if (likely (qh != NULL)) {
-		do {
-			/* clean any finished work for this qh */
-			if (!list_empty (&qh->qtd_list)
-					&& qh->stamp != ehci->stamp) {
-				int temp;
-
-				/* unlinks could happen here; completion
-				 * reporting drops the lock.  rescan using
-				 * the latest schedule, but don't rescan
-				 * qhs we already finished (no looping).
-				 */
-				qh = qh_get (qh);
-				qh->stamp = ehci->stamp;
-				temp = qh_completions (ehci, qh);
-				qh_put (qh);
-				if (temp != 0) {
-					goto rescan;
-				}
-			}
-
-			/* unlink idle entries, reducing HC PCI usage as well
-			 * as HCD schedule-scanning costs.  delay for any qh
-			 * we just scanned, there's a not-unusual case that it
-			 * doesn't stay idle for long.
-			 * (plus, avoids some kind of re-activation race.)
-			 */
-			if (list_empty (&qh->qtd_list)) {
-				if (qh->stamp == ehci->stamp)
-					action = TIMER_ASYNC_SHRINK;
-				else if (!ehci->reclaim
-					    && qh->qh_state == QH_STATE_LINKED)
-					start_unlink_async (ehci, qh);
-			}
-
-			qh = qh->qh_next.qh;
-		} while (qh);
-	}
-	if (action == TIMER_ASYNC_SHRINK)
-		timer_action (ehci, TIMER_ASYNC_SHRINK);
-}
diff -urN host/.svn/text-base/ehci-sched.c.svn-base host.new/.svn/text-base/ehci-sched.c.svn-base
--- host/.svn/text-base/ehci-sched.c.svn-base	2009-02-24 19:00:15.735953376 +0100
+++ host.new/.svn/text-base/ehci-sched.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,2241 +0,0 @@
-/*
- * Copyright (c) 2001-2004 by David Brownell
- * Copyright (c) 2003 Michal Sojka, for high-speed iso transfers
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/* this file is part of ehci-hcd.c */
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * EHCI scheduled transaction support:  interrupt, iso, split iso
- * These are called "periodic" transactions in the EHCI spec.
- *
- * Note that for interrupt transfers, the QH/QTD manipulation is shared
- * with the "asynchronous" transaction support (control/bulk transfers).
- * The only real difference is in how interrupt transfers are scheduled.
- *
- * For ISO, we make an "iso_stream" head to serve the same role as a QH.
- * It keeps track of every ITD (or SITD) that's linked, and holds enough
- * pre-calculated schedule data to make appending to the queue be quick.
- */
-
-static int ehci_get_frame (struct usb_hcd *hcd);
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * periodic_next_shadow - return "next" pointer on shadow list
- * @periodic: host pointer to qh/itd/sitd
- * @tag: hardware tag for type of this record
- */
-static union ehci_shadow *
-periodic_next_shadow(struct ehci_hcd *ehci, union ehci_shadow *periodic,
-		__hc32 tag)
-{
-	switch (hc32_to_cpu(ehci, tag)) {
-	case Q_TYPE_QH:
-		return &periodic->qh->qh_next;
-	case Q_TYPE_FSTN:
-		return &periodic->fstn->fstn_next;
-	case Q_TYPE_ITD:
-		return &periodic->itd->itd_next;
-	// case Q_TYPE_SITD:
-	default:
-		return &periodic->sitd->sitd_next;
-	}
-}
-
-/* caller must hold ehci->lock */
-static void periodic_unlink (struct ehci_hcd *ehci, unsigned frame, void *ptr)
-{
-	union ehci_shadow	*prev_p = &ehci->pshadow[frame];
-	__hc32			*hw_p = &ehci->periodic[frame];
-	union ehci_shadow	here = *prev_p;
-
-	/* find predecessor of "ptr"; hw and shadow lists are in sync */
-	while (here.ptr && here.ptr != ptr) {
-		prev_p = periodic_next_shadow(ehci, prev_p,
-				Q_NEXT_TYPE(ehci, *hw_p));
-		hw_p = here.hw_next;
-		here = *prev_p;
-	}
-	/* an interrupt entry (at list end) could have been shared */
-	if (!here.ptr)
-		return;
-
-	/* update shadow and hardware lists ... the old "next" pointers
-	 * from ptr may still be in use, the caller updates them.
-	 */
-	*prev_p = *periodic_next_shadow(ehci, &here,
-			Q_NEXT_TYPE(ehci, *hw_p));
-	*hw_p = *here.hw_next;
-}
-
-/* how many of the uframe's 125 usecs are allocated? */
-static unsigned short
-periodic_usecs (struct ehci_hcd *ehci, unsigned frame, unsigned uframe)
-{
-	__hc32			*hw_p = &ehci->periodic [frame];
-	union ehci_shadow	*q = &ehci->pshadow [frame];
-	unsigned		usecs = 0;
-
-	while (q->ptr) {
-		switch (hc32_to_cpu(ehci, Q_NEXT_TYPE(ehci, *hw_p))) {
-		case Q_TYPE_QH:
-			/* is it in the S-mask? */
-			if (q->qh->hw_info2 & cpu_to_hc32(ehci, 1 << uframe))
-				usecs += q->qh->usecs;
-			/* ... or C-mask? */
-			if (q->qh->hw_info2 & cpu_to_hc32(ehci,
-					1 << (8 + uframe)))
-				usecs += q->qh->c_usecs;
-			hw_p = &q->qh->hw_next;
-			q = &q->qh->qh_next;
-			break;
-		// case Q_TYPE_FSTN:
-		default:
-			/* for "save place" FSTNs, count the relevant INTR
-			 * bandwidth from the previous frame
-			 */
-			if (q->fstn->hw_prev != EHCI_LIST_END(ehci)) {
-				ehci_dbg (ehci, "ignoring FSTN cost ...\n");
-			}
-			hw_p = &q->fstn->hw_next;
-			q = &q->fstn->fstn_next;
-			break;
-		case Q_TYPE_ITD:
-			usecs += q->itd->usecs [uframe];
-			hw_p = &q->itd->hw_next;
-			q = &q->itd->itd_next;
-			break;
-		case Q_TYPE_SITD:
-			/* is it in the S-mask?  (count SPLIT, DATA) */
-			if (q->sitd->hw_uframe & cpu_to_hc32(ehci,
-					1 << uframe)) {
-				if (q->sitd->hw_fullspeed_ep &
-						cpu_to_hc32(ehci, 1<<31))
-					usecs += q->sitd->stream->usecs;
-				else	/* worst case for OUT start-split */
-					usecs += HS_USECS_ISO (188);
-			}
-
-			/* ... C-mask?  (count CSPLIT, DATA) */
-			if (q->sitd->hw_uframe &
-					cpu_to_hc32(ehci, 1 << (8 + uframe))) {
-				/* worst case for IN complete-split */
-				usecs += q->sitd->stream->c_usecs;
-			}
-
-			hw_p = &q->sitd->hw_next;
-			q = &q->sitd->sitd_next;
-			break;
-		}
-	}
-#ifdef	DEBUG
-	if (usecs > 100)
-		ehci_err (ehci, "uframe %d sched overrun: %d usecs\n",
-			frame * 8 + uframe, usecs);
-#endif
-	return usecs;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int same_tt (struct usb_device *dev1, struct usb_device *dev2)
-{
-	if (!dev1->tt || !dev2->tt)
-		return 0;
-	if (dev1->tt != dev2->tt)
-		return 0;
-	if (dev1->tt->multi)
-		return dev1->ttport == dev2->ttport;
-	else
-		return 1;
-}
-
-#ifdef CONFIG_USB_EHCI_TT_NEWSCHED
-
-/* Which uframe does the low/fullspeed transfer start in?
- *
- * The parameter is the mask of ssplits in "H-frame" terms
- * and this returns the transfer start uframe in "B-frame" terms,
- * which allows both to match, e.g. a ssplit in "H-frame" uframe 0
- * will cause a transfer in "B-frame" uframe 0.  "B-frames" lag
- * "H-frames" by 1 uframe.  See the EHCI spec sec 4.5 and figure 4.7.
- */
-static inline unsigned char tt_start_uframe(struct ehci_hcd *ehci, __hc32 mask)
-{
-	unsigned char smask = QH_SMASK & hc32_to_cpu(ehci, mask);
-	if (!smask) {
-		ehci_err(ehci, "invalid empty smask!\n");
-		/* uframe 7 can't have bw so this will indicate failure */
-		return 7;
-	}
-	return ffs(smask) - 1;
-}
-
-static const unsigned char
-max_tt_usecs[] = { 125, 125, 125, 125, 125, 125, 30, 0 };
-
-/* carryover low/fullspeed bandwidth that crosses uframe boundries */
-static inline void carryover_tt_bandwidth(unsigned short tt_usecs[8])
-{
-	int i;
-	for (i=0; i<7; i++) {
-		if (max_tt_usecs[i] < tt_usecs[i]) {
-			tt_usecs[i+1] += tt_usecs[i] - max_tt_usecs[i];
-			tt_usecs[i] = max_tt_usecs[i];
-		}
-	}
-}
-
-/* How many of the tt's periodic downstream 1000 usecs are allocated?
- *
- * While this measures the bandwidth in terms of usecs/uframe,
- * the low/fullspeed bus has no notion of uframes, so any particular
- * low/fullspeed transfer can "carry over" from one uframe to the next,
- * since the TT just performs downstream transfers in sequence.
- *
- * For example two seperate 100 usec transfers can start in the same uframe,
- * and the second one would "carry over" 75 usecs into the next uframe.
- */
-static void
-periodic_tt_usecs (
-	struct ehci_hcd *ehci,
-	struct usb_device *dev,
-	unsigned frame,
-	unsigned short tt_usecs[8]
-)
-{
-	__hc32			*hw_p = &ehci->periodic [frame];
-	union ehci_shadow	*q = &ehci->pshadow [frame];
-	unsigned char		uf;
-
-	memset(tt_usecs, 0, 16);
-
-	while (q->ptr) {
-		switch (hc32_to_cpu(ehci, Q_NEXT_TYPE(ehci, *hw_p))) {
-		case Q_TYPE_ITD:
-			hw_p = &q->itd->hw_next;
-			q = &q->itd->itd_next;
-			continue;
-		case Q_TYPE_QH:
-			if (same_tt(dev, q->qh->dev)) {
-				uf = tt_start_uframe(ehci, q->qh->hw_info2);
-				tt_usecs[uf] += q->qh->tt_usecs;
-			}
-			hw_p = &q->qh->hw_next;
-			q = &q->qh->qh_next;
-			continue;
-		case Q_TYPE_SITD:
-			if (same_tt(dev, q->sitd->urb->dev)) {
-				uf = tt_start_uframe(ehci, q->sitd->hw_uframe);
-				tt_usecs[uf] += q->sitd->stream->tt_usecs;
-			}
-			hw_p = &q->sitd->hw_next;
-			q = &q->sitd->sitd_next;
-			continue;
-		// case Q_TYPE_FSTN:
-		default:
-			ehci_dbg(ehci, "ignoring periodic frame %d FSTN\n",
-					frame);
-			hw_p = &q->fstn->hw_next;
-			q = &q->fstn->fstn_next;
-		}
-	}
-
-	carryover_tt_bandwidth(tt_usecs);
-
-	if (max_tt_usecs[7] < tt_usecs[7])
-		ehci_err(ehci, "frame %d tt sched overrun: %d usecs\n",
-			frame, tt_usecs[7] - max_tt_usecs[7]);
-}
-
-/*
- * Return true if the device's tt's downstream bus is available for a
- * periodic transfer of the specified length (usecs), starting at the
- * specified frame/uframe.  Note that (as summarized in section 11.19
- * of the usb 2.0 spec) TTs can buffer multiple transactions for each
- * uframe.
- *
- * The uframe parameter is when the fullspeed/lowspeed transfer
- * should be executed in "B-frame" terms, which is the same as the
- * highspeed ssplit's uframe (which is in "H-frame" terms).  For example
- * a ssplit in "H-frame" 0 causes a transfer in "B-frame" 0.
- * See the EHCI spec sec 4.5 and fig 4.7.
- *
- * This checks if the full/lowspeed bus, at the specified starting uframe,
- * has the specified bandwidth available, according to rules listed
- * in USB 2.0 spec section 11.18.1 fig 11-60.
- *
- * This does not check if the transfer would exceed the max ssplit
- * limit of 16, specified in USB 2.0 spec section 11.18.4 requirement #4,
- * since proper scheduling limits ssplits to less than 16 per uframe.
- */
-static int tt_available (
-	struct ehci_hcd		*ehci,
-	unsigned		period,
-	struct usb_device	*dev,
-	unsigned		frame,
-	unsigned		uframe,
-	u16			usecs
-)
-{
-	if ((period == 0) || (uframe >= 7))	/* error */
-		return 0;
-
-	for (; frame < ehci->periodic_size; frame += period) {
-		unsigned short tt_usecs[8];
-
-		periodic_tt_usecs (ehci, dev, frame, tt_usecs);
-
-		ehci_vdbg(ehci, "tt frame %d check %d usecs start uframe %d in"
-			" schedule %d/%d/%d/%d/%d/%d/%d/%d\n",
-			frame, usecs, uframe,
-			tt_usecs[0], tt_usecs[1], tt_usecs[2], tt_usecs[3],
-			tt_usecs[4], tt_usecs[5], tt_usecs[6], tt_usecs[7]);
-
-		if (max_tt_usecs[uframe] <= tt_usecs[uframe]) {
-			ehci_vdbg(ehci, "frame %d uframe %d fully scheduled\n",
-				frame, uframe);
-			return 0;
-		}
-
-		/* special case for isoc transfers larger than 125us:
-		 * the first and each subsequent fully used uframe
-		 * must be empty, so as to not illegally delay
-		 * already scheduled transactions
-		 */
-		if (125 < usecs) {
-			int ufs = (usecs / 125) - 1;
-			int i;
-			for (i = uframe; i < (uframe + ufs) && i < 8; i++)
-				if (0 < tt_usecs[i]) {
-					ehci_vdbg(ehci,
-						"multi-uframe xfer can't fit "
-						"in frame %d uframe %d\n",
-						frame, i);
-					return 0;
-				}
-		}
-
-		tt_usecs[uframe] += usecs;
-
-		carryover_tt_bandwidth(tt_usecs);
-
-		/* fail if the carryover pushed bw past the last uframe's limit */
-		if (max_tt_usecs[7] < tt_usecs[7]) {
-			ehci_vdbg(ehci,
-				"tt unavailable usecs %d frame %d uframe %d\n",
-				usecs, frame, uframe);
-			return 0;
-		}
-	}
-
-	return 1;
-}
-
-#else
-
-/* return true iff the device's transaction translator is available
- * for a periodic transfer starting at the specified frame, using
- * all the uframes in the mask.
- */
-static int tt_no_collision (
-	struct ehci_hcd		*ehci,
-	unsigned		period,
-	struct usb_device	*dev,
-	unsigned		frame,
-	u32			uf_mask
-)
-{
-	if (period == 0)	/* error */
-		return 0;
-
-	/* note bandwidth wastage:  split never follows csplit
-	 * (different dev or endpoint) until the next uframe.
-	 * calling convention doesn't make that distinction.
-	 */
-	for (; frame < ehci->periodic_size; frame += period) {
-		union ehci_shadow	here;
-		__hc32			type;
-
-		here = ehci->pshadow [frame];
-		type = Q_NEXT_TYPE(ehci, ehci->periodic [frame]);
-		while (here.ptr) {
-			switch (hc32_to_cpu(ehci, type)) {
-			case Q_TYPE_ITD:
-				type = Q_NEXT_TYPE(ehci, here.itd->hw_next);
-				here = here.itd->itd_next;
-				continue;
-			case Q_TYPE_QH:
-				if (same_tt (dev, here.qh->dev)) {
-					u32		mask;
-
-					mask = hc32_to_cpu(ehci,
-							here.qh->hw_info2);
-					/* "knows" no gap is needed */
-					mask |= mask >> 8;
-					if (mask & uf_mask)
-						break;
-				}
-				type = Q_NEXT_TYPE(ehci, here.qh->hw_next);
-				here = here.qh->qh_next;
-				continue;
-			case Q_TYPE_SITD:
-				if (same_tt (dev, here.sitd->urb->dev)) {
-					u16		mask;
-
-					mask = hc32_to_cpu(ehci, here.sitd
-								->hw_uframe);
-					/* FIXME assumes no gap for IN! */
-					mask |= mask >> 8;
-					if (mask & uf_mask)
-						break;
-				}
-				type = Q_NEXT_TYPE(ehci, here.sitd->hw_next);
-				here = here.sitd->sitd_next;
-				continue;
-			// case Q_TYPE_FSTN:
-			default:
-				ehci_dbg (ehci,
-					"periodic frame %d bogus type %d\n",
-					frame, type);
-			}
-
-			/* collision or error */
-			return 0;
-		}
-	}
-
-	/* no collision */
-	return 1;
-}
-
-#endif /* CONFIG_USB_EHCI_TT_NEWSCHED */
-
-/*-------------------------------------------------------------------------*/
-
-static int enable_periodic (struct ehci_hcd *ehci)
-{
-	u32	cmd;
-	int	status;
-
-	/* did clearing PSE did take effect yet?
-	 * takes effect only at frame boundaries...
-	 */
-	status = handshake(ehci, &ehci->regs->status, STS_PSS, 0, 9 * 125);
-	if (status != 0) {
-		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
-		return status;
-	}
-
-	cmd = ehci_readl(ehci, &ehci->regs->command) | CMD_PSE;
-	ehci_writel(ehci, cmd, &ehci->regs->command);
-	/* posted write ... PSS happens later */
-	ehci_to_hcd(ehci)->state = HC_STATE_RUNNING;
-
-	/* make sure ehci_work scans these */
-	ehci->next_uframe = ehci_readl(ehci, &ehci->regs->frame_index)
-		% (ehci->periodic_size << 3);
-	return 0;
-}
-
-static int disable_periodic (struct ehci_hcd *ehci)
-{
-	u32	cmd;
-	int	status;
-
-	/* did setting PSE not take effect yet?
-	 * takes effect only at frame boundaries...
-	 */
-	status = handshake(ehci, &ehci->regs->status, STS_PSS, STS_PSS, 9 * 125);
-	if (status != 0) {
-		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
-		return status;
-	}
-
-	cmd = ehci_readl(ehci, &ehci->regs->command) & ~CMD_PSE;
-	ehci_writel(ehci, cmd, &ehci->regs->command);
-	/* posted write ... */
-
-	ehci->next_uframe = -1;
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* periodic schedule slots have iso tds (normal or split) first, then a
- * sparse tree for active interrupt transfers.
- *
- * this just links in a qh; caller guarantees uframe masks are set right.
- * no FSTN support (yet; ehci 0.96+)
- */
-static int qh_link_periodic (struct ehci_hcd *ehci, struct ehci_qh *qh)
-{
-	unsigned	i;
-	unsigned	period = qh->period;
-
-	dev_dbg (&qh->dev->dev,
-		"link qh%d-%04x/%p start %d [%d/%d us]\n",
-		period, hc32_to_cpup(ehci, &qh->hw_info2) & (QH_CMASK | QH_SMASK),
-		qh, qh->start, qh->usecs, qh->c_usecs);
-
-	/* high bandwidth, or otherwise every microframe */
-	if (period == 0)
-		period = 1;
-
-	for (i = qh->start; i < ehci->periodic_size; i += period) {
-		union ehci_shadow	*prev = &ehci->pshadow[i];
-		__hc32			*hw_p = &ehci->periodic[i];
-		union ehci_shadow	here = *prev;
-		__hc32			type = 0;
-
-		/* skip the iso nodes at list head */
-		while (here.ptr) {
-			type = Q_NEXT_TYPE(ehci, *hw_p);
-			if (type == cpu_to_hc32(ehci, Q_TYPE_QH))
-				break;
-			prev = periodic_next_shadow(ehci, prev, type);
-			hw_p = &here.qh->hw_next;
-			here = *prev;
-		}
-
-		/* sorting each branch by period (slow-->fast)
-		 * enables sharing interior tree nodes
-		 */
-		while (here.ptr && qh != here.qh) {
-			if (qh->period > here.qh->period)
-				break;
-			prev = &here.qh->qh_next;
-			hw_p = &here.qh->hw_next;
-			here = *prev;
-		}
-		/* link in this qh, unless some earlier pass did that */
-		if (qh != here.qh) {
-			qh->qh_next = here;
-			if (here.qh)
-				qh->hw_next = *hw_p;
-			wmb ();
-			prev->qh = qh;
-			*hw_p = QH_NEXT (ehci, qh->qh_dma);
-		}
-	}
-	qh->qh_state = QH_STATE_LINKED;
-	qh_get (qh);
-
-	/* update per-qh bandwidth for usbfs */
-	ehci_to_hcd(ehci)->self.bandwidth_allocated += qh->period
-		? ((qh->usecs + qh->c_usecs) / qh->period)
-		: (qh->usecs * 8);
-
-	/* maybe enable periodic schedule processing */
-	if (!ehci->periodic_sched++)
-		return enable_periodic (ehci);
-
-	return 0;
-}
-
-static void qh_unlink_periodic (struct ehci_hcd *ehci, struct ehci_qh *qh)
-{
-	unsigned	i;
-	unsigned	period;
-
-	// FIXME:
-	// IF this isn't high speed
-	//   and this qh is active in the current uframe
-	//   (and overlay token SplitXstate is false?)
-	// THEN
-	//   qh->hw_info1 |= __constant_cpu_to_hc32(1 << 7 /* "ignore" */);
-
-	/* high bandwidth, or otherwise part of every microframe */
-	if ((period = qh->period) == 0)
-		period = 1;
-
-	for (i = qh->start; i < ehci->periodic_size; i += period)
-		periodic_unlink (ehci, i, qh);
-
-	/* update per-qh bandwidth for usbfs */
-	ehci_to_hcd(ehci)->self.bandwidth_allocated -= qh->period
-		? ((qh->usecs + qh->c_usecs) / qh->period)
-		: (qh->usecs * 8);
-
-	dev_dbg (&qh->dev->dev,
-		"unlink qh%d-%04x/%p start %d [%d/%d us]\n",
-		qh->period,
-		hc32_to_cpup(ehci, &qh->hw_info2) & (QH_CMASK | QH_SMASK),
-		qh, qh->start, qh->usecs, qh->c_usecs);
-
-	/* qh->qh_next still "live" to HC */
-	qh->qh_state = QH_STATE_UNLINK;
-	qh->qh_next.ptr = NULL;
-	qh_put (qh);
-
-	/* maybe turn off periodic schedule */
-	ehci->periodic_sched--;
-	if (!ehci->periodic_sched)
-		(void) disable_periodic (ehci);
-}
-
-static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
-{
-	unsigned	wait;
-
-	qh_unlink_periodic (ehci, qh);
-
-	/* simple/paranoid:  always delay, expecting the HC needs to read
-	 * qh->hw_next or finish a writeback after SPLIT/CSPLIT ... and
-	 * expect khubd to clean up after any CSPLITs we won't issue.
-	 * active high speed queues may need bigger delays...
-	 */
-	if (list_empty (&qh->qtd_list)
-			|| (cpu_to_hc32(ehci, QH_CMASK)
-					& qh->hw_info2) != 0)
-		wait = 2;
-	else
-		wait = 55;	/* worst case: 3 * 1024 */
-
-	udelay (wait);
-	qh->qh_state = QH_STATE_IDLE;
-	qh->hw_next = EHCI_LIST_END(ehci);
-	wmb ();
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int check_period (
-	struct ehci_hcd *ehci,
-	unsigned	frame,
-	unsigned	uframe,
-	unsigned	period,
-	unsigned	usecs
-) {
-	int		claimed;
-
-	/* complete split running into next frame?
-	 * given FSTN support, we could sometimes check...
-	 */
-	if (uframe >= 8)
-		return 0;
-
-	/*
-	 * 80% periodic == 100 usec/uframe available
-	 * convert "usecs we need" to "max already claimed"
-	 */
-	usecs = 100 - usecs;
-
-	/* we "know" 2 and 4 uframe intervals were rejected; so
-	 * for period 0, check _every_ microframe in the schedule.
-	 */
-	if (unlikely (period == 0)) {
-		do {
-			for (uframe = 0; uframe < 7; uframe++) {
-				claimed = periodic_usecs (ehci, frame, uframe);
-				if (claimed > usecs)
-					return 0;
-			}
-		} while ((frame += 1) < ehci->periodic_size);
-
-	/* just check the specified uframe, at that period */
-	} else {
-		do {
-			claimed = periodic_usecs (ehci, frame, uframe);
-			if (claimed > usecs)
-				return 0;
-		} while ((frame += period) < ehci->periodic_size);
-	}
-
-	// success!
-	return 1;
-}
-
-static int check_intr_schedule (
-	struct ehci_hcd		*ehci,
-	unsigned		frame,
-	unsigned		uframe,
-	const struct ehci_qh	*qh,
-	__hc32			*c_maskp
-)
-{
-	int		retval = -ENOSPC;
-	u8		mask = 0;
-
-	if (qh->c_usecs && uframe >= 6)		/* FSTN territory? */
-		goto done;
-
-	if (!check_period (ehci, frame, uframe, qh->period, qh->usecs))
-		goto done;
-	if (!qh->c_usecs) {
-		retval = 0;
-		*c_maskp = 0;
-		goto done;
-	}
-
-#ifdef CONFIG_USB_EHCI_TT_NEWSCHED
-	if (tt_available (ehci, qh->period, qh->dev, frame, uframe,
-				qh->tt_usecs)) {
-		unsigned i;
-
-		/* TODO : this may need FSTN for SSPLIT in uframe 5. */
-		for (i=uframe+1; i<8 && i<uframe+4; i++)
-			if (!check_period (ehci, frame, i,
-						qh->period, qh->c_usecs))
-				goto done;
-			else
-				mask |= 1 << i;
-
-		retval = 0;
-
-		*c_maskp = cpu_to_hc32(ehci, mask << 8);
-	}
-#else
-	/* Make sure this tt's buffer is also available for CSPLITs.
-	 * We pessimize a bit; probably the typical full speed case
-	 * doesn't need the second CSPLIT.
-	 *
-	 * NOTE:  both SPLIT and CSPLIT could be checked in just
-	 * one smart pass...
-	 */
-	mask = 0x03 << (uframe + qh->gap_uf);
-	*c_maskp = cpu_to_hc32(ehci, mask << 8);
-
-	mask |= 1 << uframe;
-	if (tt_no_collision (ehci, qh->period, qh->dev, frame, mask)) {
-		if (!check_period (ehci, frame, uframe + qh->gap_uf + 1,
-					qh->period, qh->c_usecs))
-			goto done;
-		if (!check_period (ehci, frame, uframe + qh->gap_uf,
-					qh->period, qh->c_usecs))
-			goto done;
-		retval = 0;
-	}
-#endif
-done:
-	return retval;
-}
-
-/* "first fit" scheduling policy used the first time through,
- * or when the previous schedule slot can't be re-used.
- */
-static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
-{
-	int		status;
-	unsigned	uframe;
-	__hc32		c_mask;
-	unsigned	frame;		/* 0..(qh->period - 1), or NO_FRAME */
-
-	qh_refresh(ehci, qh);
-	qh->hw_next = EHCI_LIST_END(ehci);
-	frame = qh->start;
-
-	/* reuse the previous schedule slots, if we can */
-	if (frame < qh->period) {
-		uframe = ffs(hc32_to_cpup(ehci, &qh->hw_info2) & QH_SMASK);
-		status = check_intr_schedule (ehci, frame, --uframe,
-				qh, &c_mask);
-	} else {
-		uframe = 0;
-		c_mask = 0;
-		status = -ENOSPC;
-	}
-
-	/* else scan the schedule to find a group of slots such that all
-	 * uframes have enough periodic bandwidth available.
-	 */
-	if (status) {
-		/* "normal" case, uframing flexible except with splits */
-		if (qh->period) {
-			frame = qh->period - 1;
-			do {
-				for (uframe = 0; uframe < 8; uframe++) {
-					status = check_intr_schedule (ehci,
-							frame, uframe, qh,
-							&c_mask);
-					if (status == 0)
-						break;
-				}
-			} while (status && frame--);
-
-		/* qh->period == 0 means every uframe */
-		} else {
-			frame = 0;
-			status = check_intr_schedule (ehci, 0, 0, qh, &c_mask);
-		}
-		if (status)
-			goto done;
-		qh->start = frame;
-
-		/* reset S-frame and (maybe) C-frame masks */
-		qh->hw_info2 &= cpu_to_hc32(ehci, ~(QH_CMASK | QH_SMASK));
-		qh->hw_info2 |= qh->period
-			? cpu_to_hc32(ehci, 1 << uframe)
-			: cpu_to_hc32(ehci, QH_SMASK);
-		qh->hw_info2 |= c_mask;
-	} else
-		ehci_dbg (ehci, "reused qh %p schedule\n", qh);
-
-	/* stuff into the periodic schedule */
-	status = qh_link_periodic (ehci, qh);
-done:
-	return status;
-}
-
-static int intr_submit (
-	struct ehci_hcd		*ehci,
-	struct usb_host_endpoint *ep,
-	struct urb		*urb,
-	struct list_head	*qtd_list,
-	gfp_t			mem_flags
-) {
-	unsigned		epnum;
-	unsigned long		flags;
-	struct ehci_qh		*qh;
-	int			status = 0;
-	struct list_head	empty;
-
-	/* get endpoint and transfer/schedule data */
-	epnum = ep->desc.bEndpointAddress;
-
-	spin_lock_irqsave (&ehci->lock, flags);
-
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			&ehci_to_hcd(ehci)->flags))) {
-		status = -ESHUTDOWN;
-		goto done;
-	}
-
-	/* get qh and force any scheduling errors */
-	INIT_LIST_HEAD (&empty);
-	qh = qh_append_tds (ehci, urb, &empty, epnum, &ep->hcpriv);
-	if (qh == NULL) {
-		status = -ENOMEM;
-		goto done;
-	}
-	if (qh->qh_state == QH_STATE_IDLE) {
-		if ((status = qh_schedule (ehci, qh)) != 0)
-			goto done;
-	}
-
-	/* then queue the urb's tds to the qh */
-	qh = qh_append_tds (ehci, urb, qtd_list, epnum, &ep->hcpriv);
-	BUG_ON (qh == NULL);
-
-	/* ... update usbfs periodic stats */
-	ehci_to_hcd(ehci)->self.bandwidth_int_reqs++;
-
-done:
-	spin_unlock_irqrestore (&ehci->lock, flags);
-	if (status)
-		qtd_list_free (ehci, urb, qtd_list);
-
-	return status;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* ehci_iso_stream ops work with both ITD and SITD */
-
-static struct ehci_iso_stream *
-iso_stream_alloc (gfp_t mem_flags)
-{
-	struct ehci_iso_stream *stream;
-
-	stream = kzalloc(sizeof *stream, mem_flags);
-	if (likely (stream != NULL)) {
-		INIT_LIST_HEAD(&stream->td_list);
-		INIT_LIST_HEAD(&stream->free_list);
-		stream->next_uframe = -1;
-		stream->refcount = 1;
-	}
-	return stream;
-}
-
-static void
-iso_stream_init (
-	struct ehci_hcd		*ehci,
-	struct ehci_iso_stream	*stream,
-	struct usb_device	*dev,
-	int			pipe,
-	unsigned		interval
-)
-{
-	static const u8 smask_out [] = { 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f };
-
-	u32			buf1;
-	unsigned		epnum, maxp;
-	int			is_input;
-	long			bandwidth;
-
-	/*
-	 * this might be a "high bandwidth" highspeed endpoint,
-	 * as encoded in the ep descriptor's wMaxPacket field
-	 */
-	epnum = usb_pipeendpoint (pipe);
-	is_input = usb_pipein (pipe) ? USB_DIR_IN : 0;
-	maxp = usb_maxpacket(dev, pipe, !is_input);
-	if (is_input) {
-		buf1 = (1 << 11);
-	} else {
-		buf1 = 0;
-	}
-
-	/* knows about ITD vs SITD */
-	if (dev->speed == USB_SPEED_HIGH) {
-		unsigned multi = hb_mult(maxp);
-
-		stream->highspeed = 1;
-
-		maxp = max_packet(maxp);
-		buf1 |= maxp;
-		maxp *= multi;
-
-		stream->buf0 = cpu_to_hc32(ehci, (epnum << 8) | dev->devnum);
-		stream->buf1 = cpu_to_hc32(ehci, buf1);
-		stream->buf2 = cpu_to_hc32(ehci, multi);
-
-		/* usbfs wants to report the average usecs per frame tied up
-		 * when transfers on this endpoint are scheduled ...
-		 */
-		stream->usecs = HS_USECS_ISO (maxp);
-		bandwidth = stream->usecs * 8;
-		bandwidth /= 1 << (interval - 1);
-
-	} else {
-		u32		addr;
-		int		think_time;
-		int		hs_transfers;
-
-		addr = dev->ttport << 24;
-		if (!ehci_is_TDI(ehci)
-				|| (dev->tt->hub !=
-					ehci_to_hcd(ehci)->self.root_hub))
-			addr |= dev->tt->hub->devnum << 16;
-		addr |= epnum << 8;
-		addr |= dev->devnum;
-		stream->usecs = HS_USECS_ISO (maxp);
-		think_time = dev->tt ? dev->tt->think_time : 0;
-		stream->tt_usecs = NS_TO_US (think_time + usb_calc_bus_time (
-				dev->speed, is_input, 1, maxp));
-		hs_transfers = max (1u, (maxp + 187) / 188);
-		if (is_input) {
-			u32	tmp;
-
-			addr |= 1 << 31;
-			stream->c_usecs = stream->usecs;
-			stream->usecs = HS_USECS_ISO (1);
-			stream->raw_mask = 1;
-
-			/* c-mask as specified in USB 2.0 11.18.4 3.c */
-			tmp = (1 << (hs_transfers + 2)) - 1;
-			stream->raw_mask |= tmp << (8 + 2);
-		} else
-			stream->raw_mask = smask_out [hs_transfers - 1];
-		bandwidth = stream->usecs + stream->c_usecs;
-		bandwidth /= 1 << (interval + 2);
-
-		/* stream->splits gets created from raw_mask later */
-		stream->address = cpu_to_hc32(ehci, addr);
-	}
-	stream->bandwidth = bandwidth;
-
-	stream->udev = dev;
-
-	stream->bEndpointAddress = is_input | epnum;
-	stream->interval = interval;
-	stream->maxp = maxp;
-}
-
-static void
-iso_stream_put(struct ehci_hcd *ehci, struct ehci_iso_stream *stream)
-{
-	stream->refcount--;
-
-	/* free whenever just a dev->ep reference remains.
-	 * not like a QH -- no persistent state (toggle, halt)
-	 */
-	if (stream->refcount == 1) {
-		int		is_in;
-
-		// BUG_ON (!list_empty(&stream->td_list));
-
-		while (!list_empty (&stream->free_list)) {
-			struct list_head	*entry;
-
-			entry = stream->free_list.next;
-			list_del (entry);
-
-			/* knows about ITD vs SITD */
-			if (stream->highspeed) {
-				struct ehci_itd		*itd;
-
-				itd = list_entry (entry, struct ehci_itd,
-						itd_list);
-				dma_pool_free (ehci->itd_pool, itd,
-						itd->itd_dma);
-			} else {
-				struct ehci_sitd	*sitd;
-
-				sitd = list_entry (entry, struct ehci_sitd,
-						sitd_list);
-				dma_pool_free (ehci->sitd_pool, sitd,
-						sitd->sitd_dma);
-			}
-		}
-
-		is_in = (stream->bEndpointAddress & USB_DIR_IN) ? 0x10 : 0;
-		stream->bEndpointAddress &= 0x0f;
-		stream->ep->hcpriv = NULL;
-
-		if (stream->rescheduled) {
-			ehci_info (ehci, "ep%d%s-iso rescheduled "
-				"%lu times in %lu seconds\n",
-				stream->bEndpointAddress, is_in ? "in" : "out",
-				stream->rescheduled,
-				((jiffies - stream->start)/HZ)
-				);
-		}
-
-		kfree(stream);
-	}
-}
-
-static inline struct ehci_iso_stream *
-iso_stream_get (struct ehci_iso_stream *stream)
-{
-	if (likely (stream != NULL))
-		stream->refcount++;
-	return stream;
-}
-
-static struct ehci_iso_stream *
-iso_stream_find (struct ehci_hcd *ehci, struct urb *urb)
-{
-	unsigned		epnum;
-	struct ehci_iso_stream	*stream;
-	struct usb_host_endpoint *ep;
-	unsigned long		flags;
-
-	epnum = usb_pipeendpoint (urb->pipe);
-	if (usb_pipein(urb->pipe))
-		ep = urb->dev->ep_in[epnum];
-	else
-		ep = urb->dev->ep_out[epnum];
-
-	spin_lock_irqsave (&ehci->lock, flags);
-	stream = ep->hcpriv;
-
-	if (unlikely (stream == NULL)) {
-		stream = iso_stream_alloc(GFP_ATOMIC);
-		if (likely (stream != NULL)) {
-			/* dev->ep owns the initial refcount */
-			ep->hcpriv = stream;
-			stream->ep = ep;
-			iso_stream_init(ehci, stream, urb->dev, urb->pipe,
-					urb->interval);
-		}
-
-	/* if dev->ep [epnum] is a QH, info1.maxpacket is nonzero */
-	} else if (unlikely (stream->hw_info1 != 0)) {
-		ehci_dbg (ehci, "dev %s ep%d%s, not iso??\n",
-			urb->dev->devpath, epnum,
-			usb_pipein(urb->pipe) ? "in" : "out");
-		stream = NULL;
-	}
-
-	/* caller guarantees an eventual matching iso_stream_put */
-	stream = iso_stream_get (stream);
-
-	spin_unlock_irqrestore (&ehci->lock, flags);
-	return stream;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* ehci_iso_sched ops can be ITD-only or SITD-only */
-
-static struct ehci_iso_sched *
-iso_sched_alloc (unsigned packets, gfp_t mem_flags)
-{
-	struct ehci_iso_sched	*iso_sched;
-	int			size = sizeof *iso_sched;
-
-	size += packets * sizeof (struct ehci_iso_packet);
-	iso_sched = kzalloc(size, mem_flags);
-	if (likely (iso_sched != NULL)) {
-		INIT_LIST_HEAD (&iso_sched->td_list);
-	}
-	return iso_sched;
-}
-
-static inline void
-itd_sched_init(
-	struct ehci_hcd		*ehci,
-	struct ehci_iso_sched	*iso_sched,
-	struct ehci_iso_stream	*stream,
-	struct urb		*urb
-)
-{
-	unsigned	i;
-	dma_addr_t	dma = urb->transfer_dma;
-
-	/* how many uframes are needed for these transfers */
-	iso_sched->span = urb->number_of_packets * stream->interval;
-
-	/* figure out per-uframe itd fields that we'll need later
-	 * when we fit new itds into the schedule.
-	 */
-	for (i = 0; i < urb->number_of_packets; i++) {
-		struct ehci_iso_packet	*uframe = &iso_sched->packet [i];
-		unsigned		length;
-		dma_addr_t		buf;
-		u32			trans;
-
-		length = urb->iso_frame_desc [i].length;
-		buf = dma + urb->iso_frame_desc [i].offset;
-
-		trans = EHCI_ISOC_ACTIVE;
-		trans |= buf & 0x0fff;
-		if (unlikely (((i + 1) == urb->number_of_packets))
-				&& !(urb->transfer_flags & URB_NO_INTERRUPT))
-			trans |= EHCI_ITD_IOC;
-		trans |= length << 16;
-		uframe->transaction = cpu_to_hc32(ehci, trans);
-
-		/* might need to cross a buffer page within a uframe */
-		uframe->bufp = (buf & ~(u64)0x0fff);
-		buf += length;
-		if (unlikely ((uframe->bufp != (buf & ~(u64)0x0fff))))
-			uframe->cross = 1;
-	}
-}
-
-static void
-iso_sched_free (
-	struct ehci_iso_stream	*stream,
-	struct ehci_iso_sched	*iso_sched
-)
-{
-	if (!iso_sched)
-		return;
-	// caller must hold ehci->lock!
-	list_splice (&iso_sched->td_list, &stream->free_list);
-	kfree (iso_sched);
-}
-
-static int
-itd_urb_transaction (
-	struct ehci_iso_stream	*stream,
-	struct ehci_hcd		*ehci,
-	struct urb		*urb,
-	gfp_t			mem_flags
-)
-{
-	struct ehci_itd		*itd;
-	dma_addr_t		itd_dma;
-	int			i;
-	unsigned		num_itds;
-	struct ehci_iso_sched	*sched;
-	unsigned long		flags;
-
-	sched = iso_sched_alloc (urb->number_of_packets, mem_flags);
-	if (unlikely (sched == NULL))
-		return -ENOMEM;
-
-	itd_sched_init(ehci, sched, stream, urb);
-
-	if (urb->interval < 8)
-		num_itds = 1 + (sched->span + 7) / 8;
-	else
-		num_itds = urb->number_of_packets;
-
-	/* allocate/init ITDs */
-	spin_lock_irqsave (&ehci->lock, flags);
-	for (i = 0; i < num_itds; i++) {
-
-		/* free_list.next might be cache-hot ... but maybe
-		 * the HC caches it too. avoid that issue for now.
-		 */
-
-		/* prefer previously-allocated itds */
-		if (likely (!list_empty(&stream->free_list))) {
-			itd = list_entry (stream->free_list.prev,
-					struct ehci_itd, itd_list);
-			list_del (&itd->itd_list);
-			itd_dma = itd->itd_dma;
-		} else
-			itd = NULL;
-
-		if (!itd) {
-			spin_unlock_irqrestore (&ehci->lock, flags);
-			itd = dma_pool_alloc (ehci->itd_pool, mem_flags,
-					&itd_dma);
-			spin_lock_irqsave (&ehci->lock, flags);
-		}
-
-		if (unlikely (NULL == itd)) {
-			iso_sched_free (stream, sched);
-			spin_unlock_irqrestore (&ehci->lock, flags);
-			return -ENOMEM;
-		}
-		memset (itd, 0, sizeof *itd);
-		itd->itd_dma = itd_dma;
-		list_add (&itd->itd_list, &sched->td_list);
-	}
-	spin_unlock_irqrestore (&ehci->lock, flags);
-
-	/* temporarily store schedule info in hcpriv */
-	urb->hcpriv = sched;
-	urb->error_count = 0;
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static inline int
-itd_slot_ok (
-	struct ehci_hcd		*ehci,
-	u32			mod,
-	u32			uframe,
-	u8			usecs,
-	u32			period
-)
-{
-	uframe %= period;
-	do {
-		/* can't commit more than 80% periodic == 100 usec */
-		if (periodic_usecs (ehci, uframe >> 3, uframe & 0x7)
-				> (100 - usecs))
-			return 0;
-
-		/* we know urb->interval is 2^N uframes */
-		uframe += period;
-	} while (uframe < mod);
-	return 1;
-}
-
-static inline int
-sitd_slot_ok (
-	struct ehci_hcd		*ehci,
-	u32			mod,
-	struct ehci_iso_stream	*stream,
-	u32			uframe,
-	struct ehci_iso_sched	*sched,
-	u32			period_uframes
-)
-{
-	u32			mask, tmp;
-	u32			frame, uf;
-
-	mask = stream->raw_mask << (uframe & 7);
-
-	/* for IN, don't wrap CSPLIT into the next frame */
-	if (mask & ~0xffff)
-		return 0;
-
-	/* this multi-pass logic is simple, but performance may
-	 * suffer when the schedule data isn't cached.
-	 */
-
-	/* check bandwidth */
-	uframe %= period_uframes;
-	do {
-		u32		max_used;
-
-		frame = uframe >> 3;
-		uf = uframe & 7;
-
-#ifdef CONFIG_USB_EHCI_TT_NEWSCHED
-		/* The tt's fullspeed bus bandwidth must be available.
-		 * tt_available scheduling guarantees 10+% for control/bulk.
-		 */
-		if (!tt_available (ehci, period_uframes << 3,
-				stream->udev, frame, uf, stream->tt_usecs))
-			return 0;
-#else
-		/* tt must be idle for start(s), any gap, and csplit.
-		 * assume scheduling slop leaves 10+% for control/bulk.
-		 */
-		if (!tt_no_collision (ehci, period_uframes << 3,
-				stream->udev, frame, mask))
-			return 0;
-#endif
-
-		/* check starts (OUT uses more than one) */
-		max_used = 100 - stream->usecs;
-		for (tmp = stream->raw_mask & 0xff; tmp; tmp >>= 1, uf++) {
-			if (periodic_usecs (ehci, frame, uf) > max_used)
-				return 0;
-		}
-
-		/* for IN, check CSPLIT */
-		if (stream->c_usecs) {
-			uf = uframe & 7;
-			max_used = 100 - stream->c_usecs;
-			do {
-				tmp = 1 << uf;
-				tmp <<= 8;
-				if ((stream->raw_mask & tmp) == 0)
-					continue;
-				if (periodic_usecs (ehci, frame, uf)
-						> max_used)
-					return 0;
-			} while (++uf < 8);
-		}
-
-		/* we know urb->interval is 2^N uframes */
-		uframe += period_uframes;
-	} while (uframe < mod);
-
-	stream->splits = cpu_to_hc32(ehci, stream->raw_mask << (uframe & 7));
-	return 1;
-}
-
-/*
- * This scheduler plans almost as far into the future as it has actual
- * periodic schedule slots.  (Affected by TUNE_FLS, which defaults to
- * "as small as possible" to be cache-friendlier.)  That limits the size
- * transfers you can stream reliably; avoid more than 64 msec per urb.
- * Also avoid queue depths of less than ehci's worst irq latency (affected
- * by the per-urb URB_NO_INTERRUPT hint, the log2_irq_thresh module parameter,
- * and other factors); or more than about 230 msec total (for portability,
- * given EHCI_TUNE_FLS and the slop).  Or, write a smarter scheduler!
- */
-
-#define SCHEDULE_SLOP	10	/* frames */
-
-static int
-iso_stream_schedule (
-	struct ehci_hcd		*ehci,
-	struct urb		*urb,
-	struct ehci_iso_stream	*stream
-)
-{
-	u32			now, start, max, period;
-	int			status;
-	unsigned		mod = ehci->periodic_size << 3;
-	struct ehci_iso_sched	*sched = urb->hcpriv;
-
-	if (sched->span > (mod - 8 * SCHEDULE_SLOP)) {
-		ehci_dbg (ehci, "iso request %p too long\n", urb);
-		status = -EFBIG;
-		goto fail;
-	}
-
-	if ((stream->depth + sched->span) > mod) {
-		ehci_dbg (ehci, "request %p would overflow (%d+%d>%d)\n",
-			urb, stream->depth, sched->span, mod);
-		status = -EFBIG;
-		goto fail;
-	}
-
-	now = ehci_readl(ehci, &ehci->regs->frame_index) % mod;
-
-	/* when's the last uframe this urb could start? */
-	max = now + mod;
-
-	/* typical case: reuse current schedule. stream is still active,
-	 * and no gaps from host falling behind (irq delays etc)
-	 */
-	if (likely (!list_empty (&stream->td_list))) {
-		start = stream->next_uframe;
-		if (start < now)
-			start += mod;
-		if (likely ((start + sched->span) < max))
-			goto ready;
-		/* else fell behind; someday, try to reschedule */
-		status = -EL2NSYNC;
-		goto fail;
-	}
-
-	/* need to schedule; when's the next (u)frame we could start?
-	 * this is bigger than ehci->i_thresh allows; scheduling itself
-	 * isn't free, the slop should handle reasonably slow cpus.  it
-	 * can also help high bandwidth if the dma and irq loads don't
-	 * jump until after the queue is primed.
-	 */
-	start = SCHEDULE_SLOP * 8 + (now & ~0x07);
-	start %= mod;
-	stream->next_uframe = start;
-
-	/* NOTE:  assumes URB_ISO_ASAP, to limit complexity/bugs */
-
-	period = urb->interval;
-	if (!stream->highspeed)
-		period <<= 3;
-
-	/* find a uframe slot with enough bandwidth */
-	for (; start < (stream->next_uframe + period); start++) {
-		int		enough_space;
-
-		/* check schedule: enough space? */
-		if (stream->highspeed)
-			enough_space = itd_slot_ok (ehci, mod, start,
-					stream->usecs, period);
-		else {
-			if ((start % 8) >= 6)
-				continue;
-			enough_space = sitd_slot_ok (ehci, mod, stream,
-					start, sched, period);
-		}
-
-		/* schedule it here if there's enough bandwidth */
-		if (enough_space) {
-			stream->next_uframe = start % mod;
-			goto ready;
-		}
-	}
-
-	/* no room in the schedule */
-	ehci_dbg (ehci, "iso %ssched full %p (now %d max %d)\n",
-		list_empty (&stream->td_list) ? "" : "re",
-		urb, now, max);
-	status = -ENOSPC;
-
-fail:
-	iso_sched_free (stream, sched);
-	urb->hcpriv = NULL;
-	return status;
-
-ready:
-	/* report high speed start in uframes; full speed, in frames */
-	urb->start_frame = stream->next_uframe;
-	if (!stream->highspeed)
-		urb->start_frame >>= 3;
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static inline void
-itd_init(struct ehci_hcd *ehci, struct ehci_iso_stream *stream,
-		struct ehci_itd *itd)
-{
-	int i;
-
-	/* it's been recently zeroed */
-	itd->hw_next = EHCI_LIST_END(ehci);
-	itd->hw_bufp [0] = stream->buf0;
-	itd->hw_bufp [1] = stream->buf1;
-	itd->hw_bufp [2] = stream->buf2;
-
-	for (i = 0; i < 8; i++)
-		itd->index[i] = -1;
-
-	/* All other fields are filled when scheduling */
-}
-
-static inline void
-itd_patch(
-	struct ehci_hcd		*ehci,
-	struct ehci_itd		*itd,
-	struct ehci_iso_sched	*iso_sched,
-	unsigned		index,
-	u16			uframe
-)
-{
-	struct ehci_iso_packet	*uf = &iso_sched->packet [index];
-	unsigned		pg = itd->pg;
-
-	// BUG_ON (pg == 6 && uf->cross);
-
-	uframe &= 0x07;
-	itd->index [uframe] = index;
-
-	itd->hw_transaction[uframe] = uf->transaction;
-	itd->hw_transaction[uframe] |= cpu_to_hc32(ehci, pg << 12);
-	itd->hw_bufp[pg] |= cpu_to_hc32(ehci, uf->bufp & ~(u32)0);
-	itd->hw_bufp_hi[pg] |= cpu_to_hc32(ehci, (u32)(uf->bufp >> 32));
-
-	/* iso_frame_desc[].offset must be strictly increasing */
-	if (unlikely (uf->cross)) {
-		u64	bufp = uf->bufp + 4096;
-
-		itd->pg = ++pg;
-		itd->hw_bufp[pg] |= cpu_to_hc32(ehci, bufp & ~(u32)0);
-		itd->hw_bufp_hi[pg] |= cpu_to_hc32(ehci, (u32)(bufp >> 32));
-	}
-}
-
-static inline void
-itd_link (struct ehci_hcd *ehci, unsigned frame, struct ehci_itd *itd)
-{
-	/* always prepend ITD/SITD ... only QH tree is order-sensitive */
-	itd->itd_next = ehci->pshadow [frame];
-	itd->hw_next = ehci->periodic [frame];
-	ehci->pshadow [frame].itd = itd;
-	itd->frame = frame;
-	wmb ();
-	ehci->periodic[frame] = cpu_to_hc32(ehci, itd->itd_dma | Q_TYPE_ITD);
-}
-
-/* fit urb's itds into the selected schedule slot; activate as needed */
-static int
-itd_link_urb (
-	struct ehci_hcd		*ehci,
-	struct urb		*urb,
-	unsigned		mod,
-	struct ehci_iso_stream	*stream
-)
-{
-	int			packet;
-	unsigned		next_uframe, uframe, frame;
-	struct ehci_iso_sched	*iso_sched = urb->hcpriv;
-	struct ehci_itd		*itd;
-
-	next_uframe = stream->next_uframe % mod;
-
-	if (unlikely (list_empty(&stream->td_list))) {
-		ehci_to_hcd(ehci)->self.bandwidth_allocated
-				+= stream->bandwidth;
-		ehci_vdbg (ehci,
-			"schedule devp %s ep%d%s-iso period %d start %d.%d\n",
-			urb->dev->devpath, stream->bEndpointAddress & 0x0f,
-			(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out",
-			urb->interval,
-			next_uframe >> 3, next_uframe & 0x7);
-		stream->start = jiffies;
-	}
-	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs++;
-
-	/* fill iTDs uframe by uframe */
-	for (packet = 0, itd = NULL; packet < urb->number_of_packets; ) {
-		if (itd == NULL) {
-			/* ASSERT:  we have all necessary itds */
-			// BUG_ON (list_empty (&iso_sched->td_list));
-
-			/* ASSERT:  no itds for this endpoint in this uframe */
-
-			itd = list_entry (iso_sched->td_list.next,
-					struct ehci_itd, itd_list);
-			list_move_tail (&itd->itd_list, &stream->td_list);
-			itd->stream = iso_stream_get (stream);
-			itd->urb = usb_get_urb (urb);
-			itd_init (ehci, stream, itd);
-		}
-
-		uframe = next_uframe & 0x07;
-		frame = next_uframe >> 3;
-
-		itd->usecs [uframe] = stream->usecs;
-		itd_patch(ehci, itd, iso_sched, packet, uframe);
-
-		next_uframe += stream->interval;
-		stream->depth += stream->interval;
-		next_uframe %= mod;
-		packet++;
-
-		/* link completed itds into the schedule */
-		if (((next_uframe >> 3) != frame)
-				|| packet == urb->number_of_packets) {
-			itd_link (ehci, frame % ehci->periodic_size, itd);
-			itd = NULL;
-		}
-	}
-	stream->next_uframe = next_uframe;
-
-	/* don't need that schedule data any more */
-	iso_sched_free (stream, iso_sched);
-	urb->hcpriv = NULL;
-
-	timer_action (ehci, TIMER_IO_WATCHDOG);
-	if (unlikely (!ehci->periodic_sched++))
-		return enable_periodic (ehci);
-	return 0;
-}
-
-#define	ISO_ERRS (EHCI_ISOC_BUF_ERR | EHCI_ISOC_BABBLE | EHCI_ISOC_XACTERR)
-
-static unsigned
-itd_complete (
-	struct ehci_hcd	*ehci,
-	struct ehci_itd	*itd
-) {
-	struct urb				*urb = itd->urb;
-	struct usb_iso_packet_descriptor	*desc;
-	u32					t;
-	unsigned				uframe;
-	int					urb_index = -1;
-	struct ehci_iso_stream			*stream = itd->stream;
-	struct usb_device			*dev;
-
-	/* for each uframe with a packet */
-	for (uframe = 0; uframe < 8; uframe++) {
-		if (likely (itd->index[uframe] == -1))
-			continue;
-		urb_index = itd->index[uframe];
-		desc = &urb->iso_frame_desc [urb_index];
-
-		t = hc32_to_cpup(ehci, &itd->hw_transaction [uframe]);
-		itd->hw_transaction [uframe] = 0;
-		stream->depth -= stream->interval;
-
-		/* report transfer status */
-		if (unlikely (t & ISO_ERRS)) {
-			urb->error_count++;
-			if (t & EHCI_ISOC_BUF_ERR)
-				desc->status = usb_pipein (urb->pipe)
-					? -ENOSR  /* hc couldn't read */
-					: -ECOMM; /* hc couldn't write */
-			else if (t & EHCI_ISOC_BABBLE)
-				desc->status = -EOVERFLOW;
-			else /* (t & EHCI_ISOC_XACTERR) */
-				desc->status = -EPROTO;
-
-			/* HC need not update length with this error */
-			if (!(t & EHCI_ISOC_BABBLE))
-				desc->actual_length = EHCI_ITD_LENGTH (t);
-		} else if (likely ((t & EHCI_ISOC_ACTIVE) == 0)) {
-			desc->status = 0;
-			desc->actual_length = EHCI_ITD_LENGTH (t);
-		}
-	}
-
-	usb_put_urb (urb);
-	itd->urb = NULL;
-	itd->stream = NULL;
-	list_move (&itd->itd_list, &stream->free_list);
-	iso_stream_put (ehci, stream);
-
-	/* handle completion now? */
-	if (likely ((urb_index + 1) != urb->number_of_packets))
-		return 0;
-
-	/* ASSERT: it's really the last itd for this urb
-	list_for_each_entry (itd, &stream->td_list, itd_list)
-		BUG_ON (itd->urb == urb);
-	 */
-
-	/* give urb back to the driver ... can be out-of-order */
-	dev = urb->dev;
-	ehci_urb_done (ehci, urb);
-	urb = NULL;
-
-	/* defer stopping schedule; completion can submit */
-	ehci->periodic_sched--;
-	if (unlikely (!ehci->periodic_sched))
-		(void) disable_periodic (ehci);
-	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;
-
-	if (unlikely (list_empty (&stream->td_list))) {
-		ehci_to_hcd(ehci)->self.bandwidth_allocated
-				-= stream->bandwidth;
-		ehci_vdbg (ehci,
-			"deschedule devp %s ep%d%s-iso\n",
-			dev->devpath, stream->bEndpointAddress & 0x0f,
-			(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out");
-	}
-	iso_stream_put (ehci, stream);
-
-	return 1;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int itd_submit (struct ehci_hcd *ehci, struct urb *urb,
-	gfp_t mem_flags)
-{
-	int			status = -EINVAL;
-	unsigned long		flags;
-	struct ehci_iso_stream	*stream;
-
-	/* Get iso_stream head */
-	stream = iso_stream_find (ehci, urb);
-	if (unlikely (stream == NULL)) {
-		ehci_dbg (ehci, "can't get iso stream\n");
-		return -ENOMEM;
-	}
-	if (unlikely (urb->interval != stream->interval)) {
-		ehci_dbg (ehci, "can't change iso interval %d --> %d\n",
-			stream->interval, urb->interval);
-		goto done;
-	}
-
-#ifdef EHCI_URB_TRACE
-	ehci_dbg (ehci,
-		"%s %s urb %p ep%d%s len %d, %d pkts %d uframes [%p]\n",
-		__FUNCTION__, urb->dev->devpath, urb,
-		usb_pipeendpoint (urb->pipe),
-		usb_pipein (urb->pipe) ? "in" : "out",
-		urb->transfer_buffer_length,
-		urb->number_of_packets, urb->interval,
-		stream);
-#endif
-
-	/* allocate ITDs w/o locking anything */
-	status = itd_urb_transaction (stream, ehci, urb, mem_flags);
-	if (unlikely (status < 0)) {
-		ehci_dbg (ehci, "can't init itds\n");
-		goto done;
-	}
-
-	/* schedule ... need to lock */
-	spin_lock_irqsave (&ehci->lock, flags);
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			       &ehci_to_hcd(ehci)->flags)))
-		status = -ESHUTDOWN;
-	else
-		status = iso_stream_schedule (ehci, urb, stream);
-	if (likely (status == 0))
-		itd_link_urb (ehci, urb, ehci->periodic_size << 3, stream);
-	spin_unlock_irqrestore (&ehci->lock, flags);
-
-done:
-	if (unlikely (status < 0))
-		iso_stream_put (ehci, stream);
-	return status;
-}
-
-#ifdef CONFIG_USB_EHCI_SPLIT_ISO
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * "Split ISO TDs" ... used for USB 1.1 devices going through the
- * TTs in USB 2.0 hubs.  These need microframe scheduling.
- */
-
-static inline void
-sitd_sched_init(
-	struct ehci_hcd		*ehci,
-	struct ehci_iso_sched	*iso_sched,
-	struct ehci_iso_stream	*stream,
-	struct urb		*urb
-)
-{
-	unsigned	i;
-	dma_addr_t	dma = urb->transfer_dma;
-
-	/* how many frames are needed for these transfers */
-	iso_sched->span = urb->number_of_packets * stream->interval;
-
-	/* figure out per-frame sitd fields that we'll need later
-	 * when we fit new sitds into the schedule.
-	 */
-	for (i = 0; i < urb->number_of_packets; i++) {
-		struct ehci_iso_packet	*packet = &iso_sched->packet [i];
-		unsigned		length;
-		dma_addr_t		buf;
-		u32			trans;
-
-		length = urb->iso_frame_desc [i].length & 0x03ff;
-		buf = dma + urb->iso_frame_desc [i].offset;
-
-		trans = SITD_STS_ACTIVE;
-		if (((i + 1) == urb->number_of_packets)
-				&& !(urb->transfer_flags & URB_NO_INTERRUPT))
-			trans |= SITD_IOC;
-		trans |= length << 16;
-		packet->transaction = cpu_to_hc32(ehci, trans);
-
-		/* might need to cross a buffer page within a td */
-		packet->bufp = buf;
-		packet->buf1 = (buf + length) & ~0x0fff;
-		if (packet->buf1 != (buf & ~(u64)0x0fff))
-			packet->cross = 1;
-
-		/* OUT uses multiple start-splits */
-		if (stream->bEndpointAddress & USB_DIR_IN)
-			continue;
-		length = (length + 187) / 188;
-		if (length > 1) /* BEGIN vs ALL */
-			length |= 1 << 3;
-		packet->buf1 |= length;
-	}
-}
-
-static int
-sitd_urb_transaction (
-	struct ehci_iso_stream	*stream,
-	struct ehci_hcd		*ehci,
-	struct urb		*urb,
-	gfp_t			mem_flags
-)
-{
-	struct ehci_sitd	*sitd;
-	dma_addr_t		sitd_dma;
-	int			i;
-	struct ehci_iso_sched	*iso_sched;
-	unsigned long		flags;
-
-	iso_sched = iso_sched_alloc (urb->number_of_packets, mem_flags);
-	if (iso_sched == NULL)
-		return -ENOMEM;
-
-	sitd_sched_init(ehci, iso_sched, stream, urb);
-
-	/* allocate/init sITDs */
-	spin_lock_irqsave (&ehci->lock, flags);
-	for (i = 0; i < urb->number_of_packets; i++) {
-
-		/* NOTE:  for now, we don't try to handle wraparound cases
-		 * for IN (using sitd->hw_backpointer, like a FSTN), which
-		 * means we never need two sitds for full speed packets.
-		 */
-
-		/* free_list.next might be cache-hot ... but maybe
-		 * the HC caches it too. avoid that issue for now.
-		 */
-
-		/* prefer previously-allocated sitds */
-		if (!list_empty(&stream->free_list)) {
-			sitd = list_entry (stream->free_list.prev,
-					 struct ehci_sitd, sitd_list);
-			list_del (&sitd->sitd_list);
-			sitd_dma = sitd->sitd_dma;
-		} else
-			sitd = NULL;
-
-		if (!sitd) {
-			spin_unlock_irqrestore (&ehci->lock, flags);
-			sitd = dma_pool_alloc (ehci->sitd_pool, mem_flags,
-					&sitd_dma);
-			spin_lock_irqsave (&ehci->lock, flags);
-		}
-
-		if (!sitd) {
-			iso_sched_free (stream, iso_sched);
-			spin_unlock_irqrestore (&ehci->lock, flags);
-			return -ENOMEM;
-		}
-		memset (sitd, 0, sizeof *sitd);
-		sitd->sitd_dma = sitd_dma;
-		list_add (&sitd->sitd_list, &iso_sched->td_list);
-	}
-
-	/* temporarily store schedule info in hcpriv */
-	urb->hcpriv = iso_sched;
-	urb->error_count = 0;
-
-	spin_unlock_irqrestore (&ehci->lock, flags);
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static inline void
-sitd_patch(
-	struct ehci_hcd		*ehci,
-	struct ehci_iso_stream	*stream,
-	struct ehci_sitd	*sitd,
-	struct ehci_iso_sched	*iso_sched,
-	unsigned		index
-)
-{
-	struct ehci_iso_packet	*uf = &iso_sched->packet [index];
-	u64			bufp = uf->bufp;
-
-	sitd->hw_next = EHCI_LIST_END(ehci);
-	sitd->hw_fullspeed_ep = stream->address;
-	sitd->hw_uframe = stream->splits;
-	sitd->hw_results = uf->transaction;
-	sitd->hw_backpointer = EHCI_LIST_END(ehci);
-
-	bufp = uf->bufp;
-	sitd->hw_buf[0] = cpu_to_hc32(ehci, bufp);
-	sitd->hw_buf_hi[0] = cpu_to_hc32(ehci, bufp >> 32);
-
-	sitd->hw_buf[1] = cpu_to_hc32(ehci, uf->buf1);
-	if (uf->cross)
-		bufp += 4096;
-	sitd->hw_buf_hi[1] = cpu_to_hc32(ehci, bufp >> 32);
-	sitd->index = index;
-}
-
-static inline void
-sitd_link (struct ehci_hcd *ehci, unsigned frame, struct ehci_sitd *sitd)
-{
-	/* note: sitd ordering could matter (CSPLIT then SSPLIT) */
-	sitd->sitd_next = ehci->pshadow [frame];
-	sitd->hw_next = ehci->periodic [frame];
-	ehci->pshadow [frame].sitd = sitd;
-	sitd->frame = frame;
-	wmb ();
-	ehci->periodic[frame] = cpu_to_hc32(ehci, sitd->sitd_dma | Q_TYPE_SITD);
-}
-
-/* fit urb's sitds into the selected schedule slot; activate as needed */
-static int
-sitd_link_urb (
-	struct ehci_hcd		*ehci,
-	struct urb		*urb,
-	unsigned		mod,
-	struct ehci_iso_stream	*stream
-)
-{
-	int			packet;
-	unsigned		next_uframe;
-	struct ehci_iso_sched	*sched = urb->hcpriv;
-	struct ehci_sitd	*sitd;
-
-	next_uframe = stream->next_uframe;
-
-	if (list_empty(&stream->td_list)) {
-		/* usbfs ignores TT bandwidth */
-		ehci_to_hcd(ehci)->self.bandwidth_allocated
-				+= stream->bandwidth;
-		ehci_vdbg (ehci,
-			"sched devp %s ep%d%s-iso [%d] %dms/%04x\n",
-			urb->dev->devpath, stream->bEndpointAddress & 0x0f,
-			(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out",
-			(next_uframe >> 3) % ehci->periodic_size,
-			stream->interval, hc32_to_cpu(ehci, stream->splits));
-		stream->start = jiffies;
-	}
-	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs++;
-
-	/* fill sITDs frame by frame */
-	for (packet = 0, sitd = NULL;
-			packet < urb->number_of_packets;
-			packet++) {
-
-		/* ASSERT:  we have all necessary sitds */
-		BUG_ON (list_empty (&sched->td_list));
-
-		/* ASSERT:  no itds for this endpoint in this frame */
-
-		sitd = list_entry (sched->td_list.next,
-				struct ehci_sitd, sitd_list);
-		list_move_tail (&sitd->sitd_list, &stream->td_list);
-		sitd->stream = iso_stream_get (stream);
-		sitd->urb = usb_get_urb (urb);
-
-		sitd_patch(ehci, stream, sitd, sched, packet);
-		sitd_link (ehci, (next_uframe >> 3) % ehci->periodic_size,
-				sitd);
-
-		next_uframe += stream->interval << 3;
-		stream->depth += stream->interval << 3;
-	}
-	stream->next_uframe = next_uframe % mod;
-
-	/* don't need that schedule data any more */
-	iso_sched_free (stream, sched);
-	urb->hcpriv = NULL;
-
-	timer_action (ehci, TIMER_IO_WATCHDOG);
-	if (!ehci->periodic_sched++)
-		return enable_periodic (ehci);
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-#define	SITD_ERRS (SITD_STS_ERR | SITD_STS_DBE | SITD_STS_BABBLE \
-				| SITD_STS_XACT | SITD_STS_MMF)
-
-static unsigned
-sitd_complete (
-	struct ehci_hcd		*ehci,
-	struct ehci_sitd	*sitd
-) {
-	struct urb				*urb = sitd->urb;
-	struct usb_iso_packet_descriptor	*desc;
-	u32					t;
-	int					urb_index = -1;
-	struct ehci_iso_stream			*stream = sitd->stream;
-	struct usb_device			*dev;
-
-	urb_index = sitd->index;
-	desc = &urb->iso_frame_desc [urb_index];
-	t = hc32_to_cpup(ehci, &sitd->hw_results);
-
-	/* report transfer status */
-	if (t & SITD_ERRS) {
-		urb->error_count++;
-		if (t & SITD_STS_DBE)
-			desc->status = usb_pipein (urb->pipe)
-				? -ENOSR  /* hc couldn't read */
-				: -ECOMM; /* hc couldn't write */
-		else if (t & SITD_STS_BABBLE)
-			desc->status = -EOVERFLOW;
-		else /* XACT, MMF, etc */
-			desc->status = -EPROTO;
-	} else {
-		desc->status = 0;
-		desc->actual_length = desc->length - SITD_LENGTH (t);
-	}
-
-	usb_put_urb (urb);
-	sitd->urb = NULL;
-	sitd->stream = NULL;
-	list_move (&sitd->sitd_list, &stream->free_list);
-	stream->depth -= stream->interval << 3;
-	iso_stream_put (ehci, stream);
-
-	/* handle completion now? */
-	if ((urb_index + 1) != urb->number_of_packets)
-		return 0;
-
-	/* ASSERT: it's really the last sitd for this urb
-	list_for_each_entry (sitd, &stream->td_list, sitd_list)
-		BUG_ON (sitd->urb == urb);
-	 */
-
-	/* give urb back to the driver */
-	dev = urb->dev;
-	ehci_urb_done (ehci, urb);
-	urb = NULL;
-
-	/* defer stopping schedule; completion can submit */
-	ehci->periodic_sched--;
-	if (!ehci->periodic_sched)
-		(void) disable_periodic (ehci);
-	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;
-
-	if (list_empty (&stream->td_list)) {
-		ehci_to_hcd(ehci)->self.bandwidth_allocated
-				-= stream->bandwidth;
-		ehci_vdbg (ehci,
-			"deschedule devp %s ep%d%s-iso\n",
-			dev->devpath, stream->bEndpointAddress & 0x0f,
-			(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out");
-	}
-	iso_stream_put (ehci, stream);
-
-	return 1;
-}
-
-
-static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
-	gfp_t mem_flags)
-{
-	int			status = -EINVAL;
-	unsigned long		flags;
-	struct ehci_iso_stream	*stream;
-
-	/* Get iso_stream head */
-	stream = iso_stream_find (ehci, urb);
-	if (stream == NULL) {
-		ehci_dbg (ehci, "can't get iso stream\n");
-		return -ENOMEM;
-	}
-	if (urb->interval != stream->interval) {
-		ehci_dbg (ehci, "can't change iso interval %d --> %d\n",
-			stream->interval, urb->interval);
-		goto done;
-	}
-
-#ifdef EHCI_URB_TRACE
-	ehci_dbg (ehci,
-		"submit %p dev%s ep%d%s-iso len %d\n",
-		urb, urb->dev->devpath,
-		usb_pipeendpoint (urb->pipe),
-		usb_pipein (urb->pipe) ? "in" : "out",
-		urb->transfer_buffer_length);
-#endif
-
-	/* allocate SITDs */
-	status = sitd_urb_transaction (stream, ehci, urb, mem_flags);
-	if (status < 0) {
-		ehci_dbg (ehci, "can't init sitds\n");
-		goto done;
-	}
-
-	/* schedule ... need to lock */
-	spin_lock_irqsave (&ehci->lock, flags);
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			       &ehci_to_hcd(ehci)->flags)))
-		status = -ESHUTDOWN;
-	else
-		status = iso_stream_schedule (ehci, urb, stream);
-	if (status == 0)
-		sitd_link_urb (ehci, urb, ehci->periodic_size << 3, stream);
-	spin_unlock_irqrestore (&ehci->lock, flags);
-
-done:
-	if (status < 0)
-		iso_stream_put (ehci, stream);
-	return status;
-}
-
-#else
-
-static inline int
-sitd_submit (struct ehci_hcd *ehci, struct urb *urb, gfp_t mem_flags)
-{
-	ehci_dbg (ehci, "split iso support is disabled\n");
-	return -ENOSYS;
-}
-
-static inline unsigned
-sitd_complete (
-	struct ehci_hcd		*ehci,
-	struct ehci_sitd	*sitd
-) {
-	ehci_err (ehci, "sitd_complete %p?\n", sitd);
-	return 0;
-}
-
-#endif /* USB_EHCI_SPLIT_ISO */
-
-/*-------------------------------------------------------------------------*/
-
-static void
-scan_periodic (struct ehci_hcd *ehci)
-{
-	unsigned	frame, clock, now_uframe, mod;
-	unsigned	modified;
-
-	mod = ehci->periodic_size << 3;
-
-	/*
-	 * When running, scan from last scan point up to "now"
-	 * else clean up by scanning everything that's left.
-	 * Touches as few pages as possible:  cache-friendly.
-	 */
-	now_uframe = ehci->next_uframe;
-	if (HC_IS_RUNNING (ehci_to_hcd(ehci)->state))
-		clock = ehci_readl(ehci, &ehci->regs->frame_index);
-	else
-		clock = now_uframe + mod - 1;
-	clock %= mod;
-
-	for (;;) {
-		union ehci_shadow	q, *q_p;
-		__hc32			type, *hw_p;
-		unsigned		uframes;
-
-		/* don't scan past the live uframe */
-		frame = now_uframe >> 3;
-		if (frame == (clock >> 3))
-			uframes = now_uframe & 0x07;
-		else {
-			/* safe to scan the whole frame at once */
-			now_uframe |= 0x07;
-			uframes = 8;
-		}
-
-restart:
-		/* scan each element in frame's queue for completions */
-		q_p = &ehci->pshadow [frame];
-		hw_p = &ehci->periodic [frame];
-		q.ptr = q_p->ptr;
-		type = Q_NEXT_TYPE(ehci, *hw_p);
-		modified = 0;
-
-		while (q.ptr != NULL) {
-			unsigned		uf;
-			union ehci_shadow	temp;
-			int			live;
-
-			live = HC_IS_RUNNING (ehci_to_hcd(ehci)->state);
-			switch (hc32_to_cpu(ehci, type)) {
-			case Q_TYPE_QH:
-				/* handle any completions */
-				temp.qh = qh_get (q.qh);
-				type = Q_NEXT_TYPE(ehci, q.qh->hw_next);
-				q = q.qh->qh_next;
-				modified = qh_completions (ehci, temp.qh);
-				if (unlikely (list_empty (&temp.qh->qtd_list)))
-					intr_deschedule (ehci, temp.qh);
-				qh_put (temp.qh);
-				break;
-			case Q_TYPE_FSTN:
-				/* for "save place" FSTNs, look at QH entries
-				 * in the previous frame for completions.
-				 */
-				if (q.fstn->hw_prev != EHCI_LIST_END(ehci)) {
-					dbg ("ignoring completions from FSTNs");
-				}
-				type = Q_NEXT_TYPE(ehci, q.fstn->hw_next);
-				q = q.fstn->fstn_next;
-				break;
-			case Q_TYPE_ITD:
-				/* skip itds for later in the frame */
-				rmb ();
-				for (uf = live ? uframes : 8; uf < 8; uf++) {
-					if (0 == (q.itd->hw_transaction [uf]
-							& ITD_ACTIVE(ehci)))
-						continue;
-					q_p = &q.itd->itd_next;
-					hw_p = &q.itd->hw_next;
-					type = Q_NEXT_TYPE(ehci,
-							q.itd->hw_next);
-					q = *q_p;
-					break;
-				}
-				if (uf != 8)
-					break;
-
-				/* this one's ready ... HC won't cache the
-				 * pointer for much longer, if at all.
-				 */
-				*q_p = q.itd->itd_next;
-				*hw_p = q.itd->hw_next;
-				type = Q_NEXT_TYPE(ehci, q.itd->hw_next);
-				wmb();
-				modified = itd_complete (ehci, q.itd);
-				q = *q_p;
-				break;
-			case Q_TYPE_SITD:
-				if ((q.sitd->hw_results & SITD_ACTIVE(ehci))
-						&& live) {
-					q_p = &q.sitd->sitd_next;
-					hw_p = &q.sitd->hw_next;
-					type = Q_NEXT_TYPE(ehci,
-							q.sitd->hw_next);
-					q = *q_p;
-					break;
-				}
-				*q_p = q.sitd->sitd_next;
-				*hw_p = q.sitd->hw_next;
-				type = Q_NEXT_TYPE(ehci, q.sitd->hw_next);
-				wmb();
-				modified = sitd_complete (ehci, q.sitd);
-				q = *q_p;
-				break;
-			default:
-				dbg ("corrupt type %d frame %d shadow %p",
-					type, frame, q.ptr);
-				// BUG ();
-				q.ptr = NULL;
-			}
-
-			/* assume completion callbacks modify the queue */
-			if (unlikely (modified))
-				goto restart;
-		}
-
-		/* stop when we catch up to the HC */
-
-		// FIXME:  this assumes we won't get lapped when
-		// latencies climb; that should be rare, but...
-		// detect it, and just go all the way around.
-		// FLR might help detect this case, so long as latencies
-		// don't exceed periodic_size msec (default 1.024 sec).
-
-		// FIXME:  likewise assumes HC doesn't halt mid-scan
-
-		if (now_uframe == clock) {
-			unsigned	now;
-
-			if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state))
-				break;
-			ehci->next_uframe = now_uframe;
-			now = ehci_readl(ehci, &ehci->regs->frame_index) % mod;
-			if (now_uframe == now)
-				break;
-
-			/* rescan the rest of this frame, then ... */
-			clock = now;
-		} else {
-			now_uframe++;
-			now_uframe %= mod;
-		}
-	}
-}
diff -urN host/.svn/text-base/ehci.h.svn-base host.new/.svn/text-base/ehci.h.svn-base
--- host/.svn/text-base/ehci.h.svn-base	2009-02-24 19:00:15.743952969 +0100
+++ host.new/.svn/text-base/ehci.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,870 +0,0 @@
-/*
- * Copyright (c) 2001-2002 by David Brownell
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#ifndef __LINUX_EHCI_HCD_H
-#define __LINUX_EHCI_HCD_H
-
-/* definitions used for the EHCI driver */
-
-/*
- * __hc32 and __hc16 are "Host Controller" types, they may be equivalent to
- * __leXX (normally) or __beXX (given EHCI_BIG_ENDIAN_DESC), depending on
- * the host controller implementation.
- *
- * To facilitate the strongest possible byte-order checking from "sparse"
- * and so on, we use __leXX unless that's not practical.
- */
-#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_DESC
-typedef __u32 __bitwise __hc32;
-typedef __u16 __bitwise __hc16;
-#else
-#define __hc32	__le32
-#define __hc16	__le16
-#endif
-
-/* statistics can be kept for for tuning/monitoring */
-struct ehci_stats {
-	/* irq usage */
-	unsigned long		normal;
-	unsigned long		error;
-	unsigned long		reclaim;
-	unsigned long		lost_iaa;
-
-	/* termination of urbs from core */
-	unsigned long		complete;
-	unsigned long		unlink;
-};
-
-/* ehci_hcd->lock guards shared data against other CPUs:
- *   ehci_hcd:	async, reclaim, periodic (and shadow), ...
- *   usb_host_endpoint: hcpriv
- *   ehci_qh:	qh_next, qtd_list
- *   ehci_qtd:	qtd_list
- *
- * Also, hold this lock when talking to HC registers or
- * when updating hw_* fields in shared qh/qtd/... structures.
- */
-
-#define	EHCI_MAX_ROOT_PORTS	15		/* see HCS_N_PORTS */
-
-struct ehci_hcd {			/* one per controller */
-	/* glue to PCI and HCD framework */
-	struct ehci_caps __iomem *caps;
-	struct ehci_regs __iomem *regs;
-	struct ehci_dbg_port __iomem *debug;
-
-	__u32			hcs_params;	/* cached register copy */
-	spinlock_t		lock;
-
-	/* async schedule support */
-	struct ehci_qh		*async;
-	struct ehci_qh		*reclaim;
-	unsigned		reclaim_ready : 1;
-	unsigned		scanning : 1;
-
-	/* periodic schedule support */
-#define	DEFAULT_I_TDPS		1024		/* some HCs can do less */
-	unsigned		periodic_size;
-	__hc32			*periodic;	/* hw periodic table */
-	dma_addr_t		periodic_dma;
-	unsigned		i_thresh;	/* uframes HC might cache */
-
-	union ehci_shadow	*pshadow;	/* mirror hw periodic table */
-	int			next_uframe;	/* scan periodic, start here */
-	unsigned		periodic_sched;	/* periodic activity count */
-
-	/* per root hub port */
-	unsigned long		reset_done [EHCI_MAX_ROOT_PORTS];
-
-	/* bit vectors (one bit per port) */
-	unsigned long		bus_suspended;		/* which ports were
-			already suspended at the start of a bus suspend */
-	unsigned long		companion_ports;	/* which ports are
-			dedicated to the companion controller */
-	unsigned long		owned_ports;		/* which ports are
-			owned by the companion during a bus suspend */
-
-	/* per-HC memory pools (could be per-bus, but ...) */
-	struct dma_pool		*qh_pool;	/* qh per active urb */
-	struct dma_pool		*qtd_pool;	/* one or more per qh */
-	struct dma_pool		*itd_pool;	/* itd per iso urb */
-	struct dma_pool		*sitd_pool;	/* sitd per split iso urb */
-
-	struct timer_list	watchdog;
-	unsigned long		actions;
-	unsigned		stamp;
-	unsigned long		next_statechange;
-	u32			command;
-
-	/* SILICON QUIRKS */
-	unsigned		is_tdi_rh_tt:1;	/* TDI roothub with TT */
-	unsigned		no_selective_suspend:1;
-	unsigned		has_fsl_port_bug:1; /* FreeScale */
-	unsigned		big_endian_mmio:1;
-	unsigned		big_endian_desc:1;
-
-	u8			sbrn;		/* packed release number */
-
-	/* irq statistics */
-#ifdef EHCI_STATS
-	struct ehci_stats	stats;
-#	define COUNT(x) do { (x)++; } while (0)
-#else
-#	define COUNT(x) do {} while (0)
-#endif
-};
-
-/* convert between an HCD pointer and the corresponding EHCI_HCD */
-static inline struct ehci_hcd *hcd_to_ehci (struct usb_hcd *hcd)
-{
-	return (struct ehci_hcd *) (hcd->hcd_priv);
-}
-static inline struct usb_hcd *ehci_to_hcd (struct ehci_hcd *ehci)
-{
-	return container_of ((void *) ehci, struct usb_hcd, hcd_priv);
-}
-
-
-enum ehci_timer_action {
-	TIMER_IO_WATCHDOG,
-	TIMER_IAA_WATCHDOG,
-	TIMER_ASYNC_SHRINK,
-	TIMER_ASYNC_OFF,
-};
-
-static inline void
-timer_action_done (struct ehci_hcd *ehci, enum ehci_timer_action action)
-{
-	clear_bit (action, &ehci->actions);
-}
-
-static inline void
-timer_action (struct ehci_hcd *ehci, enum ehci_timer_action action)
-{
-	if (!test_and_set_bit (action, &ehci->actions)) {
-		unsigned long t;
-
-		switch (action) {
-		case TIMER_IAA_WATCHDOG:
-			t = EHCI_IAA_JIFFIES;
-			break;
-		case TIMER_IO_WATCHDOG:
-			t = EHCI_IO_JIFFIES;
-			break;
-		case TIMER_ASYNC_OFF:
-			t = EHCI_ASYNC_JIFFIES;
-			break;
-		// case TIMER_ASYNC_SHRINK:
-		default:
-			t = EHCI_SHRINK_JIFFIES;
-			break;
-		}
-		t += jiffies;
-		// all timings except IAA watchdog can be overridden.
-		// async queue SHRINK often precedes IAA.  while it's ready
-		// to go OFF neither can matter, and afterwards the IO
-		// watchdog stops unless there's still periodic traffic.
-		if (action != TIMER_IAA_WATCHDOG
-				&& t > ehci->watchdog.expires
-				&& timer_pending (&ehci->watchdog))
-			return;
-		mod_timer (&ehci->watchdog, t);
-	}
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* EHCI register interface, corresponds to EHCI Revision 0.95 specification */
-
-/* Section 2.2 Host Controller Capability Registers */
-struct ehci_caps {
-	/* these fields are specified as 8 and 16 bit registers,
-	 * but some hosts can't perform 8 or 16 bit PCI accesses.
-	 */
-	u32		hc_capbase;
-#define HC_LENGTH(p)		(((p)>>00)&0x00ff)	/* bits 7:0 */
-#define HC_VERSION(p)		(((p)>>16)&0xffff)	/* bits 31:16 */
-	u32		hcs_params;     /* HCSPARAMS - offset 0x4 */
-#ifndef CONFIG_SL2312_USB
-#define HCS_DEBUG_PORT(p)	(((p)>>20)&0xf)	/* bits 23:20, debug port? */
-#define HCS_INDICATOR(p)	((p)&(1 << 16))	/* true: has port indicators */
-#define HCS_N_CC(p)		(((p)>>12)&0xf)	/* bits 15:12, #companion HCs */
-#else
-#define HCS_DEBUG_PORT(p)	(0)
-#define HCS_INDICATOR(p)	(0)
-#define HCS_N_CC(p)		(0)
-#endif
-
-#define HCS_N_PCC(p)		(((p)>>8)&0xf)	/* bits 11:8, ports per CC */
-#ifndef CONFIG_SL2312_USB
-#define HCS_PORTROUTED(p)	((p)&(1 << 7))	/* true: port routing */
-#define HCS_PPC(p)		((p)&(1 << 4))	/* true: port power control */
-#else
-#define HCS_PORTROUTED(p)	(0)	/* true: port routing */
-#define HCS_PPC(p)		(0)	/* true: port power control */
-#endif
-
-#define HCS_N_PORTS(p)		(((p)>>0)&0xf)	/* bits 3:0, ports on HC */
-
-	u32		hcc_params;      /* HCCPARAMS - offset 0x8 */
-#ifndef CONFIG_SL2312_USB
-#define HCC_EXT_CAPS(p)		(((p)>>8)&0xff)	/* for pci extended caps */
-#else
-#define HCC_EXT_CAPS(p)		(0)	/* for pci extended caps */
-#endif
-
-#define HCC_ISOC_CACHE(p)       ((p)&(1 << 7))  /* true: can cache isoc frame */
-
-#ifndef CONFIG_SL2312_USB
-#define HCC_ISOC_THRES(p)       (((p)>>4)&0x7)  /* bits 6:4, uframes cached */
-#define HCC_CANPARK(p)		((p)&(1 << 2))  /* true: can park on async qh */
-#else
-#define HCC_ISOC_THRES(p)       (0)  /* bits 6:4, uframes cached */
-#define HCC_CANPARK(p)		(0)  /* true: can park on async qh */
-#endif
-
-#define HCC_PGM_FRAMELISTLEN(p) ((p)&(1 << 1))  /* true: periodic_size changes*/
-
-#ifndef CONFIG_SL2312_USB
-#define HCC_64BIT_ADDR(p)       ((p)&(1))       /* true: can use 64-bit addr */
-#else
-#define HCC_64BIT_ADDR(p)       (0)       /* true: can use 64-bit addr */
-#endif
-
-	u8		portroute [8];	 /* nibbles for routing - offset 0xC */
-} __attribute__ ((packed));
-
-
-/* Section 2.3 Host Controller Operational Registers */
-struct ehci_regs {
-
-	/* USBCMD: offset 0x00 */
-	u32		command;
-/* 23:16 is r/w intr rate, in microframes; default "8" == 1/msec */
-#define CMD_PARK	(1<<11)		/* enable "park" on async qh */
-#define CMD_PARK_CNT(c)	(((c)>>8)&3)	/* how many transfers to park for */
-
-#ifndef CONFIG_SL2312_USB
-#define CMD_LRESET	(1<<7)		/* partial reset (no ports, etc) */
-#else
-#define CMD_LRESET	(0)
-#endif
-#define CMD_IAAD	(1<<6)		/* "doorbell" interrupt async advance */
-#define CMD_ASE		(1<<5)		/* async schedule enable */
-#define CMD_PSE		(1<<4)		/* periodic schedule enable */
-/* 3:2 is periodic frame list size */
-#define CMD_RESET	(1<<1)		/* reset HC not bus */
-#define CMD_RUN		(1<<0)		/* start/stop HC */
-
-	/* USBSTS: offset 0x04 */
-	u32		status;
-#define STS_ASS		(1<<15)		/* Async Schedule Status */
-#define STS_PSS		(1<<14)		/* Periodic Schedule Status */
-#define STS_RECL	(1<<13)		/* Reclamation */
-#define STS_HALT	(1<<12)		/* Not running (any reason) */
-/* some bits reserved */
-	/* these STS_* flags are also intr_enable bits (USBINTR) */
-#define STS_IAA		(1<<5)		/* Interrupted on async advance */
-#define STS_FATAL	(1<<4)		/* such as some PCI access errors */
-#define STS_FLR		(1<<3)		/* frame list rolled over */
-#define STS_PCD		(1<<2)		/* port change detect */
-#define STS_ERR		(1<<1)		/* "error" completion (overflow, ...) */
-#define STS_INT		(1<<0)		/* "normal" completion (short, ...) */
-
-	/* USBINTR: offset 0x08 */
-	u32		intr_enable;
-
-	/* FRINDEX: offset 0x0C */
-	u32		frame_index;	/* current microframe number */
-
-#ifdef CONFIG_SL2312_USB
-	u32		reserved1[1];
-#else
-	/* CTRLDSSEGMENT: offset 0x10 */
-	u32		segment;	/* address bits 63:32 if needed */
-#endif
-	/* PERIODICLISTBASE: offset 0x14 */
-	u32		frame_list;	/* points to periodic list */
-	/* ASYNCLISTADDR: offset 0x18 */
-	u32		async_next;	/* address of next async queue head */
-
-#ifdef CONFIG_SL2312_USB
-	u32		reserved2[1];
-#else
-	u32		reserved [9];
-
-	/* CONFIGFLAG: offset 0x40 */
-	u32		configured_flag;
-#define FLAG_CF		(1<<0)		/* true: we'll support "high speed" */
-#endif
-
-	/* PORTSC: offset 0x44 */
-#ifdef CONFIG_SL2312_USB
-	u32		port_status [1];	/* up to N_PORTS */
-#else
-	u32		port_status [0];	/* up to N_PORTS */
-#endif
-/* 31:23 reserved */
-#define PORT_WKOC_E	(1<<22)		/* wake on overcurrent (enable) */
-#define PORT_WKDISC_E	(1<<21)		/* wake on disconnect (enable) */
-#define PORT_WKCONN_E	(1<<20)		/* wake on connect (enable) */
-/* 19:16 for port testing */
-#define PORT_LED_OFF	(0<<14)
-#define PORT_LED_AMBER	(1<<14)
-#define PORT_LED_GREEN	(2<<14)
-#define PORT_LED_MASK	(3<<14)
-#define PORT_OWNER	(1<<13)		/* true: companion hc owns this port */
-#define PORT_POWER	(1<<12)		/* true: has power (see PPC) */
-#define PORT_USB11(x) (((x)&(3<<10))==(1<<10))	/* USB 1.1 device */
-/* 11:10 for detecting lowspeed devices (reset vs release ownership) */
-/* 9 reserved */
-#define PORT_RESET	(1<<8)		/* reset port */
-#define PORT_SUSPEND	(1<<7)		/* suspend port */
-#define PORT_RESUME	(1<<6)		/* resume it */
-#define PORT_OCC	(1<<5)		/* over current change */
-#define PORT_OC		(1<<4)		/* over current active */
-#define PORT_PEC	(1<<3)		/* port enable change */
-#define PORT_PE		(1<<2)		/* port enable */
-#define PORT_CSC	(1<<1)		/* connect status change */
-#define PORT_CONNECT	(1<<0)		/* device connected */
-#define PORT_RWC_BITS   (PORT_CSC | PORT_PEC | PORT_OCC)
-} __attribute__ ((packed));
-
-#define USBMODE		0x68		/* USB Device mode */
-#define USBMODE_SDIS	(1<<3)		/* Stream disable */
-#define USBMODE_BE	(1<<2)		/* BE/LE endianness select */
-#define USBMODE_CM_HC	(3<<0)		/* host controller mode */
-#define USBMODE_CM_IDLE	(0<<0)		/* idle state */
-
-/* Appendix C, Debug port ... intended for use with special "debug devices"
- * that can help if there's no serial console.  (nonstandard enumeration.)
- */
-struct ehci_dbg_port {
-	u32	control;
-#define DBGP_OWNER	(1<<30)
-#define DBGP_ENABLED	(1<<28)
-#define DBGP_DONE	(1<<16)
-#define DBGP_INUSE	(1<<10)
-#define DBGP_ERRCODE(x)	(((x)>>7)&0x07)
-#	define DBGP_ERR_BAD	1
-#	define DBGP_ERR_SIGNAL	2
-#define DBGP_ERROR	(1<<6)
-#define DBGP_GO		(1<<5)
-#define DBGP_OUT	(1<<4)
-#define DBGP_LEN(x)	(((x)>>0)&0x0f)
-	u32	pids;
-#define DBGP_PID_GET(x)		(((x)>>16)&0xff)
-#define DBGP_PID_SET(data,tok)	(((data)<<8)|(tok))
-	u32	data03;
-	u32	data47;
-	u32	address;
-#define DBGP_EPADDR(dev,ep)	(((dev)<<8)|(ep))
-} __attribute__ ((packed));
-
-/*-------------------------------------------------------------------------*/
-
-#define	QTD_NEXT(ehci, dma)	cpu_to_hc32(ehci, (u32)dma)
-
-/*
- * EHCI Specification 0.95 Section 3.5
- * QTD: describe data transfer components (buffer, direction, ...)
- * See Fig 3-6 "Queue Element Transfer Descriptor Block Diagram".
- *
- * These are associated only with "QH" (Queue Head) structures,
- * used with control, bulk, and interrupt transfers.
- */
-struct ehci_qtd {
-	/* first part defined by EHCI spec */
-	__hc32			hw_next;	/* see EHCI 3.5.1 */
-	__hc32			hw_alt_next;    /* see EHCI 3.5.2 */
-	__hc32			hw_token;       /* see EHCI 3.5.3 */
-#define	QTD_TOGGLE	(1 << 31)	/* data toggle */
-#define	QTD_LENGTH(tok)	(((tok)>>16) & 0x7fff)
-#define	QTD_IOC		(1 << 15)	/* interrupt on complete */
-#define	QTD_CERR(tok)	(((tok)>>10) & 0x3)
-#define	QTD_PID(tok)	(((tok)>>8) & 0x3)
-#define	QTD_STS_ACTIVE	(1 << 7)	/* HC may execute this */
-#define	QTD_STS_HALT	(1 << 6)	/* halted on error */
-#define	QTD_STS_DBE	(1 << 5)	/* data buffer error (in HC) */
-#define	QTD_STS_BABBLE	(1 << 4)	/* device was babbling (qtd halted) */
-#define	QTD_STS_XACT	(1 << 3)	/* device gave illegal response */
-#define	QTD_STS_MMF	(1 << 2)	/* incomplete split transaction */
-#define	QTD_STS_STS	(1 << 1)	/* split transaction state */
-#define	QTD_STS_PING	(1 << 0)	/* issue PING? */
-
-#define ACTIVE_BIT(ehci)	cpu_to_hc32(ehci, QTD_STS_ACTIVE)
-#define HALT_BIT(ehci)		cpu_to_hc32(ehci, QTD_STS_HALT)
-#define STATUS_BIT(ehci)	cpu_to_hc32(ehci, QTD_STS_STS)
-
-	__hc32			hw_buf [5];        /* see EHCI 3.5.4 */
-	__hc32			hw_buf_hi [5];        /* Appendix B */
-
-	/* the rest is HCD-private */
-	dma_addr_t		qtd_dma;		/* qtd address */
-	struct list_head	qtd_list;		/* sw qtd list */
-	struct urb		*urb;			/* qtd's urb */
-	size_t			length;			/* length of buffer */
-} __attribute__ ((aligned (32)));
-
-/* mask NakCnt+T in qh->hw_alt_next */
-#define QTD_MASK(ehci)	cpu_to_hc32 (ehci, ~0x1f)
-
-#define IS_SHORT_READ(token) (QTD_LENGTH (token) != 0 && QTD_PID (token) == 1)
-
-/*-------------------------------------------------------------------------*/
-
-/* type tag from {qh,itd,sitd,fstn}->hw_next */
-#define Q_NEXT_TYPE(ehci,dma)	((dma) & cpu_to_hc32(ehci, 3 << 1))
-
-/*
- * Now the following defines are not converted using the
- * __constant_cpu_to_le32() macro anymore, since we have to support
- * "dynamic" switching between be and le support, so that the driver
- * can be used on one system with SoC EHCI controller using big-endian
- * descriptors as well as a normal little-endian PCI EHCI controller.
- */
-/* values for that type tag */
-#define Q_TYPE_ITD	(0 << 1)
-#define Q_TYPE_QH	(1 << 1)
-#define Q_TYPE_SITD	(2 << 1)
-#define Q_TYPE_FSTN	(3 << 1)
-
-/* next async queue entry, or pointer to interrupt/periodic QH */
-#define QH_NEXT(ehci,dma)	(cpu_to_hc32(ehci, (((u32)dma)&~0x01f)|Q_TYPE_QH))
-
-/* for periodic/async schedules and qtd lists, mark end of list */
-#define EHCI_LIST_END(ehci)	cpu_to_hc32(ehci, 1) /* "null pointer" to hw */
-
-/*
- * Entries in periodic shadow table are pointers to one of four kinds
- * of data structure.  That's dictated by the hardware; a type tag is
- * encoded in the low bits of the hardware's periodic schedule.  Use
- * Q_NEXT_TYPE to get the tag.
- *
- * For entries in the async schedule, the type tag always says "qh".
- */
-union ehci_shadow {
-	struct ehci_qh		*qh;		/* Q_TYPE_QH */
-	struct ehci_itd		*itd;		/* Q_TYPE_ITD */
-	struct ehci_sitd	*sitd;		/* Q_TYPE_SITD */
-	struct ehci_fstn	*fstn;		/* Q_TYPE_FSTN */
-	__hc32			*hw_next;	/* (all types) */
-	void			*ptr;
-};
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * EHCI Specification 0.95 Section 3.6
- * QH: describes control/bulk/interrupt endpoints
- * See Fig 3-7 "Queue Head Structure Layout".
- *
- * These appear in both the async and (for interrupt) periodic schedules.
- */
-
-struct ehci_qh {
-	/* first part defined by EHCI spec */
-	__hc32			hw_next;	/* see EHCI 3.6.1 */
-	__hc32			hw_info1;       /* see EHCI 3.6.2 */
-#define	QH_HEAD		0x00008000
-	__hc32			hw_info2;        /* see EHCI 3.6.2 */
-#define	QH_SMASK	0x000000ff
-#define	QH_CMASK	0x0000ff00
-#define	QH_HUBADDR	0x007f0000
-#define	QH_HUBPORT	0x3f800000
-#define	QH_MULT		0xc0000000
-	__hc32			hw_current;	/* qtd list - see EHCI 3.6.4 */
-
-	/* qtd overlay (hardware parts of a struct ehci_qtd) */
-	__hc32			hw_qtd_next;
-	__hc32			hw_alt_next;
-	__hc32			hw_token;
-	__hc32			hw_buf [5];
-	__hc32			hw_buf_hi [5];
-
-	/* the rest is HCD-private */
-	dma_addr_t		qh_dma;		/* address of qh */
-	union ehci_shadow	qh_next;	/* ptr to qh; or periodic */
-	struct list_head	qtd_list;	/* sw qtd list */
-	struct ehci_qtd		*dummy;
-	struct ehci_qh		*reclaim;	/* next to reclaim */
-
-	struct ehci_hcd		*ehci;
-
-	/*
-	 * Do NOT use atomic operations for QH refcounting. On some CPUs
-	 * (PPC7448 for example), atomic operations cannot be performed on
-	 * memory that is cache-inhibited (i.e. being used for DMA).
-	 * Spinlocks are used to protect all QH fields.
-	 */
-	u32			refcount;
-	unsigned		stamp;
-
-	u8			qh_state;
-#define	QH_STATE_LINKED		1		/* HC sees this */
-#define	QH_STATE_UNLINK		2		/* HC may still see this */
-#define	QH_STATE_IDLE		3		/* HC doesn't see this */
-#define	QH_STATE_UNLINK_WAIT	4		/* LINKED and on reclaim q */
-#define	QH_STATE_COMPLETING	5		/* don't touch token.HALT */
-
-	/* periodic schedule info */
-	u8			usecs;		/* intr bandwidth */
-	u8			gap_uf;		/* uframes split/csplit gap */
-	u8			c_usecs;	/* ... split completion bw */
-	u16			tt_usecs;	/* tt downstream bandwidth */
-	unsigned short		period;		/* polling interval */
-	unsigned short		start;		/* where polling starts */
-#define NO_FRAME ((unsigned short)~0)			/* pick new start */
-	struct usb_device	*dev;		/* access to TT */
-} __attribute__ ((aligned (32)));
-
-/*-------------------------------------------------------------------------*/
-
-/* description of one iso transaction (up to 3 KB data if highspeed) */
-struct ehci_iso_packet {
-	/* These will be copied to iTD when scheduling */
-	u64			bufp;		/* itd->hw_bufp{,_hi}[pg] |= */
-	__hc32			transaction;	/* itd->hw_transaction[i] |= */
-	u8			cross;		/* buf crosses pages */
-	/* for full speed OUT splits */
-	u32			buf1;
-};
-
-/* temporary schedule data for packets from iso urbs (both speeds)
- * each packet is one logical usb transaction to the device (not TT),
- * beginning at stream->next_uframe
- */
-struct ehci_iso_sched {
-	struct list_head	td_list;
-	unsigned		span;
-	struct ehci_iso_packet	packet [0];
-};
-
-/*
- * ehci_iso_stream - groups all (s)itds for this endpoint.
- * acts like a qh would, if EHCI had them for ISO.
- */
-struct ehci_iso_stream {
-	/* first two fields match QH, but info1 == 0 */
-	__hc32			hw_next;
-	__hc32			hw_info1;
-
-	u32			refcount;
-	u8			bEndpointAddress;
-	u8			highspeed;
-	u16			depth;		/* depth in uframes */
-	struct list_head	td_list;	/* queued itds/sitds */
-	struct list_head	free_list;	/* list of unused itds/sitds */
-	struct usb_device	*udev;
-	struct usb_host_endpoint *ep;
-
-	/* output of (re)scheduling */
-	unsigned long		start;		/* jiffies */
-	unsigned long		rescheduled;
-	int			next_uframe;
-	__hc32			splits;
-
-	/* the rest is derived from the endpoint descriptor,
-	 * trusting urb->interval == f(epdesc->bInterval) and
-	 * including the extra info for hw_bufp[0..2]
-	 */
-	u8			interval;
-	u8			usecs, c_usecs;
-	u16			tt_usecs;
-	u16			maxp;
-	u16			raw_mask;
-	unsigned		bandwidth;
-
-	/* This is used to initialize iTD's hw_bufp fields */
-	__hc32			buf0;
-	__hc32			buf1;
-	__hc32			buf2;
-
-	/* this is used to initialize sITD's tt info */
-	__hc32			address;
-};
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * EHCI Specification 0.95 Section 3.3
- * Fig 3-4 "Isochronous Transaction Descriptor (iTD)"
- *
- * Schedule records for high speed iso xfers
- */
-struct ehci_itd {
-	/* first part defined by EHCI spec */
-	__hc32			hw_next;           /* see EHCI 3.3.1 */
-	__hc32			hw_transaction [8]; /* see EHCI 3.3.2 */
-#define EHCI_ISOC_ACTIVE        (1<<31)        /* activate transfer this slot */
-#define EHCI_ISOC_BUF_ERR       (1<<30)        /* Data buffer error */
-#define EHCI_ISOC_BABBLE        (1<<29)        /* babble detected */
-#define EHCI_ISOC_XACTERR       (1<<28)        /* XactErr - transaction error */
-#define	EHCI_ITD_LENGTH(tok)	(((tok)>>16) & 0x0fff)
-#define	EHCI_ITD_IOC		(1 << 15)	/* interrupt on complete */
-
-#define ITD_ACTIVE(ehci)	cpu_to_hc32(ehci, EHCI_ISOC_ACTIVE)
-
-	__hc32			hw_bufp [7];	/* see EHCI 3.3.3 */
-	__hc32			hw_bufp_hi [7];	/* Appendix B */
-
-	/* the rest is HCD-private */
-	dma_addr_t		itd_dma;	/* for this itd */
-	union ehci_shadow	itd_next;	/* ptr to periodic q entry */
-
-	struct urb		*urb;
-	struct ehci_iso_stream	*stream;	/* endpoint's queue */
-	struct list_head	itd_list;	/* list of stream's itds */
-
-	/* any/all hw_transactions here may be used by that urb */
-	unsigned		frame;		/* where scheduled */
-	unsigned		pg;
-	unsigned		index[8];	/* in urb->iso_frame_desc */
-	u8			usecs[8];
-} __attribute__ ((aligned (32)));
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * EHCI Specification 0.95 Section 3.4
- * siTD, aka split-transaction isochronous Transfer Descriptor
- *       ... describe full speed iso xfers through TT in hubs
- * see Figure 3-5 "Split-transaction Isochronous Transaction Descriptor (siTD)
- */
-struct ehci_sitd {
-	/* first part defined by EHCI spec */
-	__hc32			hw_next;
-/* uses bit field macros above - see EHCI 0.95 Table 3-8 */
-	__hc32			hw_fullspeed_ep;	/* EHCI table 3-9 */
-	__hc32			hw_uframe;		/* EHCI table 3-10 */
-	__hc32			hw_results;		/* EHCI table 3-11 */
-#define	SITD_IOC	(1 << 31)	/* interrupt on completion */
-#define	SITD_PAGE	(1 << 30)	/* buffer 0/1 */
-#define	SITD_LENGTH(x)	(0x3ff & ((x)>>16))
-#define	SITD_STS_ACTIVE	(1 << 7)	/* HC may execute this */
-#define	SITD_STS_ERR	(1 << 6)	/* error from TT */
-#define	SITD_STS_DBE	(1 << 5)	/* data buffer error (in HC) */
-#define	SITD_STS_BABBLE	(1 << 4)	/* device was babbling */
-#define	SITD_STS_XACT	(1 << 3)	/* illegal IN response */
-#define	SITD_STS_MMF	(1 << 2)	/* incomplete split transaction */
-#define	SITD_STS_STS	(1 << 1)	/* split transaction state */
-
-#define SITD_ACTIVE(ehci)	cpu_to_hc32(ehci, SITD_STS_ACTIVE)
-
-	__hc32			hw_buf [2];		/* EHCI table 3-12 */
-	__hc32			hw_backpointer;		/* EHCI table 3-13 */
-	__hc32			hw_buf_hi [2];		/* Appendix B */
-
-	/* the rest is HCD-private */
-	dma_addr_t		sitd_dma;
-	union ehci_shadow	sitd_next;	/* ptr to periodic q entry */
-
-	struct urb		*urb;
-	struct ehci_iso_stream	*stream;	/* endpoint's queue */
-	struct list_head	sitd_list;	/* list of stream's sitds */
-	unsigned		frame;
-	unsigned		index;
-} __attribute__ ((aligned (32)));
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * EHCI Specification 0.96 Section 3.7
- * Periodic Frame Span Traversal Node (FSTN)
- *
- * Manages split interrupt transactions (using TT) that span frame boundaries
- * into uframes 0/1; see 4.12.2.2.  In those uframes, a "save place" FSTN
- * makes the HC jump (back) to a QH to scan for fs/ls QH completions until
- * it hits a "restore" FSTN; then it returns to finish other uframe 0/1 work.
- */
-struct ehci_fstn {
-	__hc32			hw_next;	/* any periodic q entry */
-	__hc32			hw_prev;	/* qh or EHCI_LIST_END */
-
-	/* the rest is HCD-private */
-	dma_addr_t		fstn_dma;
-	union ehci_shadow	fstn_next;	/* ptr to periodic q entry */
-} __attribute__ ((aligned (32)));
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef CONFIG_USB_EHCI_ROOT_HUB_TT
-
-/*
- * Some EHCI controllers have a Transaction Translator built into the
- * root hub. This is a non-standard feature.  Each controller will need
- * to add code to the following inline functions, and call them as
- * needed (mostly in root hub code).
- */
-
-#define	ehci_is_TDI(e)			((e)->is_tdi_rh_tt)
-
-/* Returns the speed of a device attached to a port on the root hub. */
-static inline unsigned int
-ehci_port_speed(struct ehci_hcd *ehci, unsigned int portsc)
-{
-	if (ehci_is_TDI(ehci)) {
-		switch ((portsc>>26)&3) {
-		case 0:
-			return 0;
-		case 1:
-			return (1<<USB_PORT_FEAT_LOWSPEED);
-		case 2:
-		default:
-			return (1<<USB_PORT_FEAT_HIGHSPEED);
-		}
-	}
-	return (1<<USB_PORT_FEAT_HIGHSPEED);
-}
-
-#else
-
-#define	ehci_is_TDI(e)			(0)
-
-#define	ehci_port_speed(ehci, portsc)	(1<<USB_PORT_FEAT_HIGHSPEED)
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef CONFIG_PPC_83xx
-/* Some Freescale processors have an erratum in which the TT
- * port number in the queue head was 0..N-1 instead of 1..N.
- */
-#define	ehci_has_fsl_portno_bug(e)		((e)->has_fsl_port_bug)
-#else
-#define	ehci_has_fsl_portno_bug(e)		(0)
-#endif
-
-/*
- * While most USB host controllers implement their registers in
- * little-endian format, a minority (celleb companion chip) implement
- * them in big endian format.
- *
- * This attempts to support either format at compile time without a
- * runtime penalty, or both formats with the additional overhead
- * of checking a flag bit.
- */
-
-#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
-#define ehci_big_endian_mmio(e)		((e)->big_endian_mmio)
-#else
-#define ehci_big_endian_mmio(e)		0
-#endif
-
-/*
- * Big-endian read/write functions are arch-specific.
- * Other arches can be added if/when they're needed.
- *
- * REVISIT: arch/powerpc now has readl/writel_be, so the
- * definition below can die once the 4xx support is
- * finally ported over.
- */
-#if defined(CONFIG_PPC)
-#define readl_be(addr)		in_be32((__force unsigned *)addr)
-#define writel_be(val, addr)	out_be32((__force unsigned *)addr, val)
-#endif
-
-static inline unsigned int ehci_readl(const struct ehci_hcd *ehci,
-		__u32 __iomem * regs)
-{
-#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
-	return ehci_big_endian_mmio(ehci) ?
-		readl_be(regs) :
-		readl(regs);
-#else
-	return readl(regs);
-#endif
-}
-
-static inline void ehci_writel(const struct ehci_hcd *ehci,
-		const unsigned int val, __u32 __iomem *regs)
-{
-#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
-	ehci_big_endian_mmio(ehci) ?
-		writel_be(val, regs) :
-		writel(val, regs);
-#else
-	writel(val, regs);
-#endif
-}
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * The AMCC 440EPx not only implements its EHCI registers in big-endian
- * format, but also its DMA data structures (descriptors).
- *
- * EHCI controllers accessed through PCI work normally (little-endian
- * everywhere), so we won't bother supporting a BE-only mode for now.
- */
-#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_DESC
-#define ehci_big_endian_desc(e)		((e)->big_endian_desc)
-
-/* cpu to ehci */
-static inline __hc32 cpu_to_hc32 (const struct ehci_hcd *ehci, const u32 x)
-{
-	return ehci_big_endian_desc(ehci)
-		? (__force __hc32)cpu_to_be32(x)
-		: (__force __hc32)cpu_to_le32(x);
-}
-
-/* ehci to cpu */
-static inline u32 hc32_to_cpu (const struct ehci_hcd *ehci, const __hc32 x)
-{
-	return ehci_big_endian_desc(ehci)
-		? be32_to_cpu((__force __be32)x)
-		: le32_to_cpu((__force __le32)x);
-}
-
-static inline u32 hc32_to_cpup (const struct ehci_hcd *ehci, const __hc32 *x)
-{
-	return ehci_big_endian_desc(ehci)
-		? be32_to_cpup((__force __be32 *)x)
-		: le32_to_cpup((__force __le32 *)x);
-}
-
-#else
-
-/* cpu to ehci */
-static inline __hc32 cpu_to_hc32 (const struct ehci_hcd *ehci, const u32 x)
-{
-	return cpu_to_le32(x);
-}
-
-/* ehci to cpu */
-static inline u32 hc32_to_cpu (const struct ehci_hcd *ehci, const __hc32 x)
-{
-	return le32_to_cpu(x);
-}
-
-static inline u32 hc32_to_cpup (const struct ehci_hcd *ehci, const __hc32 *x)
-{
-	return le32_to_cpup(x);
-}
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-#ifndef DEBUG
-#define STUB_DEBUG_FILES
-#endif	/* DEBUG */
-
-/*-------------------------------------------------------------------------*/
-
-#endif /* __LINUX_EHCI_HCD_H */
diff -urN host/.svn/text-base/isp116x-hcd.c.svn-base host.new/.svn/text-base/isp116x-hcd.c.svn-base
--- host/.svn/text-base/isp116x-hcd.c.svn-base	2009-02-24 19:00:15.787950733 +0100
+++ host.new/.svn/text-base/isp116x-hcd.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,1726 +0,0 @@
-/*
- * ISP116x HCD (Host Controller Driver) for USB.
- *
- * Derived from the SL811 HCD, rewritten for ISP116x.
- * Copyright (C) 2005 Olav Kongas <ok@artecdesign.ee>
- *
- * Portions:
- * Copyright (C) 2004 Psion Teklogix (for NetBook PRO)
- * Copyright (C) 2004 David Brownell
- *
- * Periodic scheduling is based on Roman's OHCI code
- * Copyright (C) 1999 Roman Weissgaerber
- *
- */
-
-/*
- * The driver basically works. A number of people have used it with a range
- * of devices.
- *
- * The driver passes all usbtests 1-14.
- *
- * Suspending/resuming of root hub via sysfs works. Remote wakeup works too.
- * And suspending/resuming of platform device works too. Suspend/resume
- * via HCD operations vector is not implemented.
- *
- * Iso transfer support is not implemented. Adding this would include
- * implementing recovery from the failure to service the processed ITL
- * fifo ram in time, which will involve chip reset.
- *
- * TODO:
- + More testing of suspend/resume.
-*/
-
-/*
-  ISP116x chips require certain delays between accesses to its
-  registers. The following timing options exist.
-
-  1. Configure your memory controller (the best)
-  2. Implement platform-specific delay function possibly
-  combined with configuring the memory controller; see
-  include/linux/usb-isp116x.h for more info. Some broken
-  memory controllers line LH7A400 SMC need this. Also,
-  uncomment for that to work the following
-  USE_PLATFORM_DELAY macro.
-  3. Use ndelay (easiest, poorest). For that, uncomment
-  the following USE_NDELAY macro.
-*/
-#define USE_PLATFORM_DELAY
-//#define USE_NDELAY
-
-//#define DEBUG
-//#define VERBOSE
-/* Transfer descriptors. See dump_ptd() for printout format  */
-//#define PTD_TRACE
-/* enqueuing/finishing log of urbs */
-//#define URB_TRACE
-
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/list.h>
-#include <linux/usb.h>
-#include <linux/usb/isp116x.h>
-#include <linux/platform_device.h>
-
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/system.h>
-#include <asm/byteorder.h>
-
-#include "../core/hcd.h"
-#include "isp116x.h"
-
-#define DRIVER_VERSION	"03 Nov 2005"
-#define DRIVER_DESC	"ISP116x USB Host Controller Driver"
-
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE("GPL");
-
-static const char hcd_name[] = "isp116x-hcd";
-
-/*-----------------------------------------------------------------*/
-
-/*
-  Write len bytes to fifo, pad till 32-bit boundary
- */
-static void write_ptddata_to_fifo(struct isp116x *isp116x, void *buf, int len)
-{
-	u8 *dp = (u8 *) buf;
-	u16 *dp2 = (u16 *) buf;
-	u16 w;
-	int quot = len % 4;
-
-	if ((unsigned long)dp2 & 1) {
-		/* not aligned */
-		for (; len > 1; len -= 2) {
-			w = *dp++;
-			w |= *dp++ << 8;
-			isp116x_raw_write_data16(isp116x, w);
-		}
-		if (len)
-			isp116x_write_data16(isp116x, (u16) * dp);
-	} else {
-		/* aligned */
-		for (; len > 1; len -= 2)
-			isp116x_raw_write_data16(isp116x, *dp2++);
-		if (len)
-			isp116x_write_data16(isp116x, 0xff & *((u8 *) dp2));
-	}
-	if (quot == 1 || quot == 2)
-		isp116x_raw_write_data16(isp116x, 0);
-}
-
-/*
-  Read len bytes from fifo and then read till 32-bit boundary.
- */
-static void read_ptddata_from_fifo(struct isp116x *isp116x, void *buf, int len)
-{
-	u8 *dp = (u8 *) buf;
-	u16 *dp2 = (u16 *) buf;
-	u16 w;
-	int quot = len % 4;
-
-	if ((unsigned long)dp2 & 1) {
-		/* not aligned */
-		for (; len > 1; len -= 2) {
-			w = isp116x_raw_read_data16(isp116x);
-			*dp++ = w & 0xff;
-			*dp++ = (w >> 8) & 0xff;
-		}
-		if (len)
-			*dp = 0xff & isp116x_read_data16(isp116x);
-	} else {
-		/* aligned */
-		for (; len > 1; len -= 2)
-			*dp2++ = isp116x_raw_read_data16(isp116x);
-		if (len)
-			*(u8 *) dp2 = 0xff & isp116x_read_data16(isp116x);
-	}
-	if (quot == 1 || quot == 2)
-		isp116x_raw_read_data16(isp116x);
-}
-
-/*
-  Write ptd's and data for scheduled transfers into
-  the fifo ram. Fifo must be empty and ready.
-*/
-static void pack_fifo(struct isp116x *isp116x)
-{
-	struct isp116x_ep *ep;
-	struct ptd *ptd;
-	int buflen = isp116x->atl_last_dir == PTD_DIR_IN
-	    ? isp116x->atl_bufshrt : isp116x->atl_buflen;
-
-	isp116x_write_reg16(isp116x, HCuPINT, HCuPINT_AIIEOT);
-	isp116x_write_reg16(isp116x, HCXFERCTR, buflen);
-	isp116x_write_addr(isp116x, HCATLPORT | ISP116x_WRITE_OFFSET);
-	for (ep = isp116x->atl_active; ep; ep = ep->active) {
-		ptd = &ep->ptd;
-		dump_ptd(ptd);
-		dump_ptd_out_data(ptd, ep->data);
-		isp116x_write_data16(isp116x, ptd->count);
-		isp116x_write_data16(isp116x, ptd->mps);
-		isp116x_write_data16(isp116x, ptd->len);
-		isp116x_write_data16(isp116x, ptd->faddr);
-		buflen -= sizeof(struct ptd);
-		/* Skip writing data for last IN PTD */
-		if (ep->active || (isp116x->atl_last_dir != PTD_DIR_IN)) {
-			write_ptddata_to_fifo(isp116x, ep->data, ep->length);
-			buflen -= ALIGN(ep->length, 4);
-		}
-	}
-	BUG_ON(buflen);
-}
-
-/*
-  Read the processed ptd's and data from fifo ram back to
-  URBs' buffers. Fifo must be full and done
-*/
-static void unpack_fifo(struct isp116x *isp116x)
-{
-	struct isp116x_ep *ep;
-	struct ptd *ptd;
-	int buflen = isp116x->atl_last_dir == PTD_DIR_IN
-	    ? isp116x->atl_buflen : isp116x->atl_bufshrt;
-
-	isp116x_write_reg16(isp116x, HCuPINT, HCuPINT_AIIEOT);
-	isp116x_write_reg16(isp116x, HCXFERCTR, buflen);
-	isp116x_write_addr(isp116x, HCATLPORT);
-	for (ep = isp116x->atl_active; ep; ep = ep->active) {
-		ptd = &ep->ptd;
-		ptd->count = isp116x_read_data16(isp116x);
-		ptd->mps = isp116x_read_data16(isp116x);
-		ptd->len = isp116x_read_data16(isp116x);
-		ptd->faddr = isp116x_read_data16(isp116x);
-		buflen -= sizeof(struct ptd);
-		/* Skip reading data for last Setup or Out PTD */
-		if (ep->active || (isp116x->atl_last_dir == PTD_DIR_IN)) {
-			read_ptddata_from_fifo(isp116x, ep->data, ep->length);
-			buflen -= ALIGN(ep->length, 4);
-		}
-		dump_ptd(ptd);
-		dump_ptd_in_data(ptd, ep->data);
-	}
-	BUG_ON(buflen);
-}
-
-/*---------------------------------------------------------------*/
-
-/*
-  Set up PTD's.
-*/
-static void preproc_atl_queue(struct isp116x *isp116x)
-{
-	struct isp116x_ep *ep;
-	struct urb *urb;
-	struct ptd *ptd;
-	u16 len;
-
-	for (ep = isp116x->atl_active; ep; ep = ep->active) {
-		u16 toggle = 0, dir = PTD_DIR_SETUP;
-
-		BUG_ON(list_empty(&ep->hep->urb_list));
-		urb = container_of(ep->hep->urb_list.next,
-				   struct urb, urb_list);
-		ptd = &ep->ptd;
-		len = ep->length;
-		ep->data = (unsigned char *)urb->transfer_buffer
-		    + urb->actual_length;
-
-		switch (ep->nextpid) {
-		case USB_PID_IN:
-			toggle = usb_gettoggle(urb->dev, ep->epnum, 0);
-			dir = PTD_DIR_IN;
-			break;
-		case USB_PID_OUT:
-			toggle = usb_gettoggle(urb->dev, ep->epnum, 1);
-			dir = PTD_DIR_OUT;
-			break;
-		case USB_PID_SETUP:
-			len = sizeof(struct usb_ctrlrequest);
-			ep->data = urb->setup_packet;
-			break;
-		case USB_PID_ACK:
-			toggle = 1;
-			len = 0;
-			dir = (urb->transfer_buffer_length
-			       && usb_pipein(urb->pipe))
-			    ? PTD_DIR_OUT : PTD_DIR_IN;
-			break;
-		default:
-			ERR("%s %d: ep->nextpid %d\n", __func__, __LINE__,
-			    ep->nextpid);
-			BUG();
-		}
-
-		ptd->count = PTD_CC_MSK | PTD_ACTIVE_MSK | PTD_TOGGLE(toggle);
-		ptd->mps = PTD_MPS(ep->maxpacket)
-		    | PTD_SPD(urb->dev->speed == USB_SPEED_LOW)
-		    | PTD_EP(ep->epnum);
-		ptd->len = PTD_LEN(len) | PTD_DIR(dir);
-		ptd->faddr = PTD_FA(usb_pipedevice(urb->pipe));
-		if (!ep->active) {
-			ptd->mps |= PTD_LAST_MSK;
-			isp116x->atl_last_dir = dir;
-		}
-		isp116x->atl_bufshrt = sizeof(struct ptd) + isp116x->atl_buflen;
-		isp116x->atl_buflen = isp116x->atl_bufshrt + ALIGN(len, 4);
-	}
-}
-
-/*
-  Take done or failed requests out of schedule. Give back
-  processed urbs.
-*/
-static void finish_request(struct isp116x *isp116x, struct isp116x_ep *ep,
-			   struct urb *urb)
-__releases(isp116x->lock) __acquires(isp116x->lock)
-{
-	unsigned i;
-
-	urb->hcpriv = NULL;
-	ep->error_count = 0;
-
-	if (usb_pipecontrol(urb->pipe))
-		ep->nextpid = USB_PID_SETUP;
-
-	urb_dbg(urb, "Finish");
-
-	spin_unlock(&isp116x->lock);
-	usb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb);
-	spin_lock(&isp116x->lock);
-
-	/* take idle endpoints out of the schedule */
-	if (!list_empty(&ep->hep->urb_list))
-		return;
-
-	/* async deschedule */
-	if (!list_empty(&ep->schedule)) {
-		list_del_init(&ep->schedule);
-		return;
-	}
-
-	/* periodic deschedule */
-	DBG("deschedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);
-	for (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {
-		struct isp116x_ep *temp;
-		struct isp116x_ep **prev = &isp116x->periodic[i];
-
-		while (*prev && ((temp = *prev) != ep))
-			prev = &temp->next;
-		if (*prev)
-			*prev = ep->next;
-		isp116x->load[i] -= ep->load;
-	}
-	ep->branch = PERIODIC_SIZE;
-	isp116x_to_hcd(isp116x)->self.bandwidth_allocated -=
-	    ep->load / ep->period;
-
-	/* switch irq type? */
-	if (!--isp116x->periodic_count) {
-		isp116x->irqenb &= ~HCuPINT_SOF;
-		isp116x->irqenb |= HCuPINT_ATL;
-	}
-}
-
-/*
-  Analyze transfer results, handle partial transfers and errors
-*/
-static void postproc_atl_queue(struct isp116x *isp116x)
-{
-	struct isp116x_ep *ep;
-	struct urb *urb;
-	struct usb_device *udev;
-	struct ptd *ptd;
-	int short_not_ok;
-	int status;
-	u8 cc;
-
-	for (ep = isp116x->atl_active; ep; ep = ep->active) {
-		BUG_ON(list_empty(&ep->hep->urb_list));
-		urb =
-		    container_of(ep->hep->urb_list.next, struct urb, urb_list);
-		udev = urb->dev;
-		ptd = &ep->ptd;
-		cc = PTD_GET_CC(ptd);
-		short_not_ok = 1;
-		status = -EINPROGRESS;
-
-		/* Data underrun is special. For allowed underrun
-		   we clear the error and continue as normal. For
-		   forbidden underrun we finish the DATA stage
-		   immediately while for control transfer,
-		   we do a STATUS stage. */
-		if (cc == TD_DATAUNDERRUN) {
-			if (!(urb->transfer_flags & URB_SHORT_NOT_OK) ||
-					usb_pipecontrol(urb->pipe)) {
-				DBG("Allowed or control data underrun\n");
-				cc = TD_CC_NOERROR;
-				short_not_ok = 0;
-			} else {
-				ep->error_count = 1;
-				usb_settoggle(udev, ep->epnum,
-					      ep->nextpid == USB_PID_OUT,
-					      PTD_GET_TOGGLE(ptd));
-				urb->actual_length += PTD_GET_COUNT(ptd);
-				status = cc_to_error[TD_DATAUNDERRUN];
-				goto done;
-			}
-		}
-
-		if (cc != TD_CC_NOERROR && cc != TD_NOTACCESSED
-		    && (++ep->error_count >= 3 || cc == TD_CC_STALL
-			|| cc == TD_DATAOVERRUN)) {
-			status = cc_to_error[cc];
-			if (ep->nextpid == USB_PID_ACK)
-				ep->nextpid = 0;
-			goto done;
-		}
-		/* According to usb spec, zero-length Int transfer signals
-		   finishing of the urb. Hey, does this apply only
-		   for IN endpoints? */
-		if (usb_pipeint(urb->pipe) && !PTD_GET_LEN(ptd)) {
-			status = 0;
-			goto done;
-		}
-
-		/* Relax after previously failed, but later succeeded
-		   or correctly NAK'ed retransmission attempt */
-		if (ep->error_count
-		    && (cc == TD_CC_NOERROR || cc == TD_NOTACCESSED))
-			ep->error_count = 0;
-
-		/* Take into account idiosyncracies of the isp116x chip
-		   regarding toggle bit for failed transfers */
-		if (ep->nextpid == USB_PID_OUT)
-			usb_settoggle(udev, ep->epnum, 1, PTD_GET_TOGGLE(ptd)
-				      ^ (ep->error_count > 0));
-		else if (ep->nextpid == USB_PID_IN)
-			usb_settoggle(udev, ep->epnum, 0, PTD_GET_TOGGLE(ptd)
-				      ^ (ep->error_count > 0));
-
-		switch (ep->nextpid) {
-		case USB_PID_IN:
-		case USB_PID_OUT:
-			urb->actual_length += PTD_GET_COUNT(ptd);
-			if (PTD_GET_ACTIVE(ptd)
-			    || (cc != TD_CC_NOERROR && cc < 0x0E))
-				break;
-			if (urb->transfer_buffer_length != urb->actual_length) {
-				if (short_not_ok)
-					break;
-			} else {
-				if (urb->transfer_flags & URB_ZERO_PACKET
-				    && ep->nextpid == USB_PID_OUT
-				    && !(PTD_GET_COUNT(ptd) % ep->maxpacket)) {
-					DBG("Zero packet requested\n");
-					break;
-				}
-			}
-			/* All data for this URB is transferred, let's finish */
-			if (usb_pipecontrol(urb->pipe))
-				ep->nextpid = USB_PID_ACK;
-			else
-				status = 0;
-			break;
-		case USB_PID_SETUP:
-			if (PTD_GET_ACTIVE(ptd)
-			    || (cc != TD_CC_NOERROR && cc < 0x0E))
-				break;
-			if (urb->transfer_buffer_length == urb->actual_length)
-				ep->nextpid = USB_PID_ACK;
-			else if (usb_pipeout(urb->pipe)) {
-				usb_settoggle(udev, 0, 1, 1);
-				ep->nextpid = USB_PID_OUT;
-			} else {
-				usb_settoggle(udev, 0, 0, 1);
-				ep->nextpid = USB_PID_IN;
-			}
-			break;
-		case USB_PID_ACK:
-			if (PTD_GET_ACTIVE(ptd)
-			    || (cc != TD_CC_NOERROR && cc < 0x0E))
-				break;
-			if ((urb->transfer_flags & URB_SHORT_NOT_OK) &&
-					urb->actual_length <
-						urb->transfer_buffer_length)
-				status = -EREMOTEIO;
-			else
-				status = 0;
-			ep->nextpid = 0;
-			break;
-		default:
-			BUG();
-		}
-
- done:
-		if (status != -EINPROGRESS) {
-			spin_lock(&urb->lock);
-			if (urb->status == -EINPROGRESS)
-				urb->status = status;
-			spin_unlock(&urb->lock);
-		}
-		if (urb->status != -EINPROGRESS)
-			finish_request(isp116x, ep, urb);
-	}
-}
-
-/*
-  Scan transfer lists, schedule transfers, send data off
-  to chip.
- */
-static void start_atl_transfers(struct isp116x *isp116x)
-{
-	struct isp116x_ep *last_ep = NULL, *ep;
-	struct urb *urb;
-	u16 load = 0;
-	int len, index, speed, byte_time;
-
-	if (atomic_read(&isp116x->atl_finishing))
-		return;
-
-	if (!HC_IS_RUNNING(isp116x_to_hcd(isp116x)->state))
-		return;
-
-	/* FIFO not empty? */
-	if (isp116x_read_reg16(isp116x, HCBUFSTAT) & HCBUFSTAT_ATL_FULL)
-		return;
-
-	isp116x->atl_active = NULL;
-	isp116x->atl_buflen = isp116x->atl_bufshrt = 0;
-
-	/* Schedule int transfers */
-	if (isp116x->periodic_count) {
-		isp116x->fmindex = index =
-		    (isp116x->fmindex + 1) & (PERIODIC_SIZE - 1);
-		if ((load = isp116x->load[index])) {
-			/* Bring all int transfers for this frame
-			   into the active queue */
-			isp116x->atl_active = last_ep =
-			    isp116x->periodic[index];
-			while (last_ep->next)
-				last_ep = (last_ep->active = last_ep->next);
-			last_ep->active = NULL;
-		}
-	}
-
-	/* Schedule control/bulk transfers */
-	list_for_each_entry(ep, &isp116x->async, schedule) {
-		urb = container_of(ep->hep->urb_list.next,
-				   struct urb, urb_list);
-		speed = urb->dev->speed;
-		byte_time = speed == USB_SPEED_LOW
-		    ? BYTE_TIME_LOWSPEED : BYTE_TIME_FULLSPEED;
-
-		if (ep->nextpid == USB_PID_SETUP) {
-			len = sizeof(struct usb_ctrlrequest);
-		} else if (ep->nextpid == USB_PID_ACK) {
-			len = 0;
-		} else {
-			/* Find current free length ... */
-			len = (MAX_LOAD_LIMIT - load) / byte_time;
-
-			/* ... then limit it to configured max size ... */
-			len = min(len, speed == USB_SPEED_LOW ?
-				  MAX_TRANSFER_SIZE_LOWSPEED :
-				  MAX_TRANSFER_SIZE_FULLSPEED);
-
-			/* ... and finally cut to the multiple of MaxPacketSize,
-			   or to the real length if there's enough room. */
-			if (len <
-			    (urb->transfer_buffer_length -
-			     urb->actual_length)) {
-				len -= len % ep->maxpacket;
-				if (!len)
-					continue;
-			} else
-				len = urb->transfer_buffer_length -
-				    urb->actual_length;
-			BUG_ON(len < 0);
-		}
-
-		load += len * byte_time;
-		if (load > MAX_LOAD_LIMIT)
-			break;
-
-		ep->active = NULL;
-		ep->length = len;
-		if (last_ep)
-			last_ep->active = ep;
-		else
-			isp116x->atl_active = ep;
-		last_ep = ep;
-	}
-
-	/* Avoid starving of endpoints */
-	if ((&isp116x->async)->next != (&isp116x->async)->prev)
-		list_move(&isp116x->async, (&isp116x->async)->next);
-
-	if (isp116x->atl_active) {
-		preproc_atl_queue(isp116x);
-		pack_fifo(isp116x);
-	}
-}
-
-/*
-  Finish the processed transfers
-*/
-static void finish_atl_transfers(struct isp116x *isp116x)
-{
-	if (!isp116x->atl_active)
-		return;
-	/* Fifo not ready? */
-	if (!(isp116x_read_reg16(isp116x, HCBUFSTAT) & HCBUFSTAT_ATL_DONE))
-		return;
-
-	atomic_inc(&isp116x->atl_finishing);
-	unpack_fifo(isp116x);
-	postproc_atl_queue(isp116x);
-	atomic_dec(&isp116x->atl_finishing);
-}
-
-static irqreturn_t isp116x_irq(struct usb_hcd *hcd)
-{
-	struct isp116x *isp116x = hcd_to_isp116x(hcd);
-	u16 irqstat;
-	irqreturn_t ret = IRQ_NONE;
-
-	spin_lock(&isp116x->lock);
-	isp116x_write_reg16(isp116x, HCuPINTENB, 0);
-	irqstat = isp116x_read_reg16(isp116x, HCuPINT);
-	isp116x_write_reg16(isp116x, HCuPINT, irqstat);
-
-	if (irqstat & (HCuPINT_ATL | HCuPINT_SOF)) {
-		ret = IRQ_HANDLED;
-		finish_atl_transfers(isp116x);
-	}
-
-	if (irqstat & HCuPINT_OPR) {
-		u32 intstat = isp116x_read_reg32(isp116x, HCINTSTAT);
-		isp116x_write_reg32(isp116x, HCINTSTAT, intstat);
-		if (intstat & HCINT_UE) {
-			ERR("Unrecoverable error, HC is dead!\n");
-			/* IRQ's are off, we do no DMA,
-			   perfectly ready to die ... */
-			hcd->state = HC_STATE_HALT;
-			ret = IRQ_HANDLED;
-			goto done;
-		}
-		if (intstat & HCINT_RHSC)
-			/* When root hub or any of its ports is going
-			   to come out of suspend, it may take more
-			   than 10ms for status bits to stabilize. */
-			mod_timer(&hcd->rh_timer, jiffies
-				  + msecs_to_jiffies(20) + 1);
-		if (intstat & HCINT_RD) {
-			DBG("---- remote wakeup\n");
-			usb_hcd_resume_root_hub(hcd);
-		}
-		irqstat &= ~HCuPINT_OPR;
-		ret = IRQ_HANDLED;
-	}
-
-	if (irqstat & (HCuPINT_ATL | HCuPINT_SOF)) {
-		start_atl_transfers(isp116x);
-	}
-
-	isp116x_write_reg16(isp116x, HCuPINTENB, isp116x->irqenb);
-      done:
-	spin_unlock(&isp116x->lock);
-	return ret;
-}
-
-/*-----------------------------------------------------------------*/
-
-/* usb 1.1 says max 90% of a frame is available for periodic transfers.
- * this driver doesn't promise that much since it's got to handle an
- * IRQ per packet; irq handling latencies also use up that time.
- */
-
-/* out of 1000 us */
-#define	MAX_PERIODIC_LOAD	600
-static int balance(struct isp116x *isp116x, u16 period, u16 load)
-{
-	int i, branch = -ENOSPC;
-
-	/* search for the least loaded schedule branch of that period
-	   which has enough bandwidth left unreserved. */
-	for (i = 0; i < period; i++) {
-		if (branch < 0 || isp116x->load[branch] > isp116x->load[i]) {
-			int j;
-
-			for (j = i; j < PERIODIC_SIZE; j += period) {
-				if ((isp116x->load[j] + load)
-				    > MAX_PERIODIC_LOAD)
-					break;
-			}
-			if (j < PERIODIC_SIZE)
-				continue;
-			branch = i;
-		}
-	}
-	return branch;
-}
-
-/* NB! ALL the code above this point runs with isp116x->lock
-   held, irqs off
-*/
-
-/*-----------------------------------------------------------------*/
-
-static int isp116x_urb_enqueue(struct usb_hcd *hcd,
-			       struct usb_host_endpoint *hep, struct urb *urb,
-			       gfp_t mem_flags)
-{
-	struct isp116x *isp116x = hcd_to_isp116x(hcd);
-	struct usb_device *udev = urb->dev;
-	unsigned int pipe = urb->pipe;
-	int is_out = !usb_pipein(pipe);
-	int type = usb_pipetype(pipe);
-	int epnum = usb_pipeendpoint(pipe);
-	struct isp116x_ep *ep = NULL;
-	unsigned long flags;
-	int i;
-	int ret = 0;
-
-	urb_dbg(urb, "Enqueue");
-
-	if (type == PIPE_ISOCHRONOUS) {
-		ERR("Isochronous transfers not supported\n");
-		urb_dbg(urb, "Refused to enqueue");
-		return -ENXIO;
-	}
-	/* avoid all allocations within spinlocks: request or endpoint */
-	if (!hep->hcpriv) {
-		ep = kzalloc(sizeof *ep, mem_flags);
-		if (!ep)
-			return -ENOMEM;
-	}
-
-	spin_lock_irqsave(&isp116x->lock, flags);
-	if (!HC_IS_RUNNING(hcd->state)) {
-		kfree(ep);
-		ret = -ENODEV;
-		goto fail;
-	}
-
-	if (hep->hcpriv)
-		ep = hep->hcpriv;
-	else {
-		INIT_LIST_HEAD(&ep->schedule);
-		ep->udev = udev;
-		ep->epnum = epnum;
-		ep->maxpacket = usb_maxpacket(udev, urb->pipe, is_out);
-		usb_settoggle(udev, epnum, is_out, 0);
-
-		if (type == PIPE_CONTROL) {
-			ep->nextpid = USB_PID_SETUP;
-		} else if (is_out) {
-			ep->nextpid = USB_PID_OUT;
-		} else {
-			ep->nextpid = USB_PID_IN;
-		}
-
-		if (urb->interval) {
-			/*
-			   With INT URBs submitted, the driver works with SOF
-			   interrupt enabled and ATL interrupt disabled. After
-			   the PTDs are written to fifo ram, the chip starts
-			   fifo processing and usb transfers after the next
-			   SOF and continues until the transfers are finished
-			   (succeeded or failed) or the frame ends. Therefore,
-			   the transfers occur only in every second frame,
-			   while fifo reading/writing and data processing
-			   occur in every other second frame. */
-			if (urb->interval < 2)
-				urb->interval = 2;
-			if (urb->interval > 2 * PERIODIC_SIZE)
-				urb->interval = 2 * PERIODIC_SIZE;
-			ep->period = urb->interval >> 1;
-			ep->branch = PERIODIC_SIZE;
-			ep->load = usb_calc_bus_time(udev->speed,
-						     !is_out,
-						     (type == PIPE_ISOCHRONOUS),
-						     usb_maxpacket(udev, pipe,
-								   is_out)) /
-			    1000;
-		}
-		hep->hcpriv = ep;
-		ep->hep = hep;
-	}
-
-	/* maybe put endpoint into schedule */
-	switch (type) {
-	case PIPE_CONTROL:
-	case PIPE_BULK:
-		if (list_empty(&ep->schedule))
-			list_add_tail(&ep->schedule, &isp116x->async);
-		break;
-	case PIPE_INTERRUPT:
-		urb->interval = ep->period;
-		ep->length = min((int)ep->maxpacket,
-				 urb->transfer_buffer_length);
-
-		/* urb submitted for already existing endpoint */
-		if (ep->branch < PERIODIC_SIZE)
-			break;
-
-		ep->branch = ret = balance(isp116x, ep->period, ep->load);
-		if (ret < 0)
-			goto fail;
-		ret = 0;
-
-		urb->start_frame = (isp116x->fmindex & (PERIODIC_SIZE - 1))
-		    + ep->branch;
-
-		/* sort each schedule branch by period (slow before fast)
-		   to share the faster parts of the tree without needing
-		   dummy/placeholder nodes */
-		DBG("schedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);
-		for (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {
-			struct isp116x_ep **prev = &isp116x->periodic[i];
-			struct isp116x_ep *here = *prev;
-
-			while (here && ep != here) {
-				if (ep->period > here->period)
-					break;
-				prev = &here->next;
-				here = *prev;
-			}
-			if (ep != here) {
-				ep->next = here;
-				*prev = ep;
-			}
-			isp116x->load[i] += ep->load;
-		}
-		hcd->self.bandwidth_allocated += ep->load / ep->period;
-
-		/* switch over to SOFint */
-		if (!isp116x->periodic_count++) {
-			isp116x->irqenb &= ~HCuPINT_ATL;
-			isp116x->irqenb |= HCuPINT_SOF;
-			isp116x_write_reg16(isp116x, HCuPINTENB,
-					    isp116x->irqenb);
-		}
-	}
-
-	/* in case of unlink-during-submit */
-	if (urb->status != -EINPROGRESS) {
-		finish_request(isp116x, ep, urb);
-		ret = 0;
-		goto fail;
-	}
-	urb->hcpriv = hep;
-	start_atl_transfers(isp116x);
-
-      fail:
-	spin_unlock_irqrestore(&isp116x->lock, flags);
-	return ret;
-}
-
-/*
-   Dequeue URBs.
-*/
-static int isp116x_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
-{
-	struct isp116x *isp116x = hcd_to_isp116x(hcd);
-	struct usb_host_endpoint *hep;
-	struct isp116x_ep *ep, *ep_act;
-	unsigned long flags;
-
-	spin_lock_irqsave(&isp116x->lock, flags);
-	hep = urb->hcpriv;
-	/* URB already unlinked (or never linked)? */
-	if (!hep) {
-		spin_unlock_irqrestore(&isp116x->lock, flags);
-		return 0;
-	}
-	ep = hep->hcpriv;
-	WARN_ON(hep != ep->hep);
-
-	/* In front of queue? */
-	if (ep->hep->urb_list.next == &urb->urb_list)
-		/* active? */
-		for (ep_act = isp116x->atl_active; ep_act;
-		     ep_act = ep_act->active)
-			if (ep_act == ep) {
-				VDBG("dequeue, urb %p active; wait for irq\n",
-				     urb);
-				urb = NULL;
-				break;
-			}
-
-	if (urb)
-		finish_request(isp116x, ep, urb);
-
-	spin_unlock_irqrestore(&isp116x->lock, flags);
-	return 0;
-}
-
-static void isp116x_endpoint_disable(struct usb_hcd *hcd,
-				     struct usb_host_endpoint *hep)
-{
-	int i;
-	struct isp116x_ep *ep = hep->hcpriv;
-
-	if (!ep)
-		return;
-
-	/* assume we'd just wait for the irq */
-	for (i = 0; i < 100 && !list_empty(&hep->urb_list); i++)
-		msleep(3);
-	if (!list_empty(&hep->urb_list))
-		WARN("ep %p not empty?\n", ep);
-
-	kfree(ep);
-	hep->hcpriv = NULL;
-}
-
-static int isp116x_get_frame(struct usb_hcd *hcd)
-{
-	struct isp116x *isp116x = hcd_to_isp116x(hcd);
-	u32 fmnum;
-	unsigned long flags;
-
-	spin_lock_irqsave(&isp116x->lock, flags);
-	fmnum = isp116x_read_reg32(isp116x, HCFMNUM);
-	spin_unlock_irqrestore(&isp116x->lock, flags);
-	return (int)fmnum;
-}
-
-/*
-  Adapted from ohci-hub.c. Currently we don't support autosuspend.
-*/
-static int isp116x_hub_status_data(struct usb_hcd *hcd, char *buf)
-{
-	struct isp116x *isp116x = hcd_to_isp116x(hcd);
-	int ports, i, changed = 0;
-	unsigned long flags;
-
-	if (!HC_IS_RUNNING(hcd->state))
-		return -ESHUTDOWN;
-
-	/* Report no status change now, if we are scheduled to be
-	   called later */
-	if (timer_pending(&hcd->rh_timer))
-		return 0;
-
-	ports = isp116x->rhdesca & RH_A_NDP;
-	spin_lock_irqsave(&isp116x->lock, flags);
-	isp116x->rhstatus = isp116x_read_reg32(isp116x, HCRHSTATUS);
-	if (isp116x->rhstatus & (RH_HS_LPSC | RH_HS_OCIC))
-		buf[0] = changed = 1;
-	else
-		buf[0] = 0;
-
-	for (i = 0; i < ports; i++) {
-		u32 status = isp116x->rhport[i] =
-		    isp116x_read_reg32(isp116x, i ? HCRHPORT2 : HCRHPORT1);
-
-		if (status & (RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC
-			      | RH_PS_OCIC | RH_PS_PRSC)) {
-			changed = 1;
-			buf[0] |= 1 << (i + 1);
-			continue;
-		}
-	}
-	spin_unlock_irqrestore(&isp116x->lock, flags);
-	return changed;
-}
-
-static void isp116x_hub_descriptor(struct isp116x *isp116x,
-				   struct usb_hub_descriptor *desc)
-{
-	u32 reg = isp116x->rhdesca;
-
-	desc->bDescriptorType = 0x29;
-	desc->bDescLength = 9;
-	desc->bHubContrCurrent = 0;
-	desc->bNbrPorts = (u8) (reg & 0x3);
-	/* Power switching, device type, overcurrent. */
-	desc->wHubCharacteristics = cpu_to_le16((u16) ((reg >> 8) & 0x1f));
-	desc->bPwrOn2PwrGood = (u8) ((reg >> 24) & 0xff);
-	/* two bitmaps:  ports removable, and legacy PortPwrCtrlMask */
-	desc->bitmap[0] = 0;
-	desc->bitmap[1] = ~0;
-}
-
-/* Perform reset of a given port.
-   It would be great to just start the reset and let the
-   USB core to clear the reset in due time. However,
-   root hub ports should be reset for at least 50 ms, while
-   our chip stays in reset for about 10 ms. I.e., we must
-   repeatedly reset it ourself here.
-*/
-static inline void root_port_reset(struct isp116x *isp116x, unsigned port)
-{
-	u32 tmp;
-	unsigned long flags, t;
-
-	/* Root hub reset should be 50 ms, but some devices
-	   want it even longer. */
-	t = jiffies + msecs_to_jiffies(100);
-
-	while (time_before(jiffies, t)) {
-		spin_lock_irqsave(&isp116x->lock, flags);
-		/* spin until any current reset finishes */
-		for (;;) {
-			tmp = isp116x_read_reg32(isp116x, port ?
-						 HCRHPORT2 : HCRHPORT1);
-			if (!(tmp & RH_PS_PRS))
-				break;
-			udelay(500);
-		}
-		/* Don't reset a disconnected port */
-		if (!(tmp & RH_PS_CCS)) {
-			spin_unlock_irqrestore(&isp116x->lock, flags);
-			break;
-		}
-		/* Reset lasts 10ms (claims datasheet) */
-		isp116x_write_reg32(isp116x, port ? HCRHPORT2 :
-				    HCRHPORT1, (RH_PS_PRS));
-		spin_unlock_irqrestore(&isp116x->lock, flags);
-		msleep(10);
-	}
-}
-
-/* Adapted from ohci-hub.c */
-static int isp116x_hub_control(struct usb_hcd *hcd,
-			       u16 typeReq,
-			       u16 wValue, u16 wIndex, char *buf, u16 wLength)
-{
-	struct isp116x *isp116x = hcd_to_isp116x(hcd);
-	int ret = 0;
-	unsigned long flags;
-	int ports = isp116x->rhdesca & RH_A_NDP;
-	u32 tmp = 0;
-
-	switch (typeReq) {
-	case ClearHubFeature:
-		DBG("ClearHubFeature: ");
-		switch (wValue) {
-		case C_HUB_OVER_CURRENT:
-			DBG("C_HUB_OVER_CURRENT\n");
-			spin_lock_irqsave(&isp116x->lock, flags);
-			isp116x_write_reg32(isp116x, HCRHSTATUS, RH_HS_OCIC);
-			spin_unlock_irqrestore(&isp116x->lock, flags);
-		case C_HUB_LOCAL_POWER:
-			DBG("C_HUB_LOCAL_POWER\n");
-			break;
-		default:
-			goto error;
-		}
-		break;
-	case SetHubFeature:
-		DBG("SetHubFeature: ");
-		switch (wValue) {
-		case C_HUB_OVER_CURRENT:
-		case C_HUB_LOCAL_POWER:
-			DBG("C_HUB_OVER_CURRENT or C_HUB_LOCAL_POWER\n");
-			break;
-		default:
-			goto error;
-		}
-		break;
-	case GetHubDescriptor:
-		DBG("GetHubDescriptor\n");
-		isp116x_hub_descriptor(isp116x,
-				       (struct usb_hub_descriptor *)buf);
-		break;
-	case GetHubStatus:
-		DBG("GetHubStatus\n");
-		*(__le32 *) buf = 0;
-		break;
-	case GetPortStatus:
-		DBG("GetPortStatus\n");
-		if (!wIndex || wIndex > ports)
-			goto error;
-		tmp = isp116x->rhport[--wIndex];
-		*(__le32 *) buf = cpu_to_le32(tmp);
-		DBG("GetPortStatus: port[%d]  %08x\n", wIndex + 1, tmp);
-		break;
-	case ClearPortFeature:
-		DBG("ClearPortFeature: ");
-		if (!wIndex || wIndex > ports)
-			goto error;
-		wIndex--;
-
-		switch (wValue) {
-		case USB_PORT_FEAT_ENABLE:
-			DBG("USB_PORT_FEAT_ENABLE\n");
-			tmp = RH_PS_CCS;
-			break;
-		case USB_PORT_FEAT_C_ENABLE:
-			DBG("USB_PORT_FEAT_C_ENABLE\n");
-			tmp = RH_PS_PESC;
-			break;
-		case USB_PORT_FEAT_SUSPEND:
-			DBG("USB_PORT_FEAT_SUSPEND\n");
-			tmp = RH_PS_POCI;
-			break;
-		case USB_PORT_FEAT_C_SUSPEND:
-			DBG("USB_PORT_FEAT_C_SUSPEND\n");
-			tmp = RH_PS_PSSC;
-			break;
-		case USB_PORT_FEAT_POWER:
-			DBG("USB_PORT_FEAT_POWER\n");
-			tmp = RH_PS_LSDA;
-			break;
-		case USB_PORT_FEAT_C_CONNECTION:
-			DBG("USB_PORT_FEAT_C_CONNECTION\n");
-			tmp = RH_PS_CSC;
-			break;
-		case USB_PORT_FEAT_C_OVER_CURRENT:
-			DBG("USB_PORT_FEAT_C_OVER_CURRENT\n");
-			tmp = RH_PS_OCIC;
-			break;
-		case USB_PORT_FEAT_C_RESET:
-			DBG("USB_PORT_FEAT_C_RESET\n");
-			tmp = RH_PS_PRSC;
-			break;
-		default:
-			goto error;
-		}
-		spin_lock_irqsave(&isp116x->lock, flags);
-		isp116x_write_reg32(isp116x, wIndex
-				    ? HCRHPORT2 : HCRHPORT1, tmp);
-		isp116x->rhport[wIndex] =
-		    isp116x_read_reg32(isp116x, wIndex ? HCRHPORT2 : HCRHPORT1);
-		spin_unlock_irqrestore(&isp116x->lock, flags);
-		break;
-	case SetPortFeature:
-		DBG("SetPortFeature: ");
-		if (!wIndex || wIndex > ports)
-			goto error;
-		wIndex--;
-		switch (wValue) {
-		case USB_PORT_FEAT_SUSPEND:
-			DBG("USB_PORT_FEAT_SUSPEND\n");
-			spin_lock_irqsave(&isp116x->lock, flags);
-			isp116x_write_reg32(isp116x, wIndex
-					    ? HCRHPORT2 : HCRHPORT1, RH_PS_PSS);
-			break;
-		case USB_PORT_FEAT_POWER:
-			DBG("USB_PORT_FEAT_POWER\n");
-			spin_lock_irqsave(&isp116x->lock, flags);
-			isp116x_write_reg32(isp116x, wIndex
-					    ? HCRHPORT2 : HCRHPORT1, RH_PS_PPS);
-			break;
-		case USB_PORT_FEAT_RESET:
-			DBG("USB_PORT_FEAT_RESET\n");
-			root_port_reset(isp116x, wIndex);
-			spin_lock_irqsave(&isp116x->lock, flags);
-			break;
-		default:
-			goto error;
-		}
-		isp116x->rhport[wIndex] =
-		    isp116x_read_reg32(isp116x, wIndex ? HCRHPORT2 : HCRHPORT1);
-		spin_unlock_irqrestore(&isp116x->lock, flags);
-		break;
-
-	default:
-	      error:
-		/* "protocol stall" on error */
-		DBG("PROTOCOL STALL\n");
-		ret = -EPIPE;
-	}
-	return ret;
-}
-
-/*-----------------------------------------------------------------*/
-
-#ifdef CONFIG_DEBUG_FS
-
-static void dump_irq(struct seq_file *s, char *label, u16 mask)
-{
-	seq_printf(s, "%s %04x%s%s%s%s%s%s\n", label, mask,
-		   mask & HCuPINT_CLKRDY ? " clkrdy" : "",
-		   mask & HCuPINT_SUSP ? " susp" : "",
-		   mask & HCuPINT_OPR ? " opr" : "",
-		   mask & HCuPINT_AIIEOT ? " eot" : "",
-		   mask & HCuPINT_ATL ? " atl" : "",
-		   mask & HCuPINT_SOF ? " sof" : "");
-}
-
-static void dump_int(struct seq_file *s, char *label, u32 mask)
-{
-	seq_printf(s, "%s %08x%s%s%s%s%s%s%s\n", label, mask,
-		   mask & HCINT_MIE ? " MIE" : "",
-		   mask & HCINT_RHSC ? " rhsc" : "",
-		   mask & HCINT_FNO ? " fno" : "",
-		   mask & HCINT_UE ? " ue" : "",
-		   mask & HCINT_RD ? " rd" : "",
-		   mask & HCINT_SF ? " sof" : "", mask & HCINT_SO ? " so" : "");
-}
-
-static int isp116x_show_dbg(struct seq_file *s, void *unused)
-{
-	struct isp116x *isp116x = s->private;
-
-	seq_printf(s, "%s\n%s version %s\n",
-		   isp116x_to_hcd(isp116x)->product_desc, hcd_name,
-		   DRIVER_VERSION);
-
-	if (HC_IS_SUSPENDED(isp116x_to_hcd(isp116x)->state)) {
-		seq_printf(s, "HCD is suspended\n");
-		return 0;
-	}
-	if (!HC_IS_RUNNING(isp116x_to_hcd(isp116x)->state)) {
-		seq_printf(s, "HCD not running\n");
-		return 0;
-	}
-
-	spin_lock_irq(&isp116x->lock);
-	dump_irq(s, "hc_irq_enable", isp116x_read_reg16(isp116x, HCuPINTENB));
-	dump_irq(s, "hc_irq_status", isp116x_read_reg16(isp116x, HCuPINT));
-	dump_int(s, "hc_int_enable", isp116x_read_reg32(isp116x, HCINTENB));
-	dump_int(s, "hc_int_status", isp116x_read_reg32(isp116x, HCINTSTAT));
-	isp116x_show_regs_seq(isp116x, s);
-	spin_unlock_irq(&isp116x->lock);
-	seq_printf(s, "\n");
-
-	return 0;
-}
-
-static int isp116x_open_seq(struct inode *inode, struct file *file)
-{
-	return single_open(file, isp116x_show_dbg, inode->i_private);
-}
-
-static const struct file_operations isp116x_debug_fops = {
-	.open = isp116x_open_seq,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static int create_debug_file(struct isp116x *isp116x)
-{
-	isp116x->dentry = debugfs_create_file(hcd_name,
-					      S_IRUGO, NULL, isp116x,
-					      &isp116x_debug_fops);
-	if (!isp116x->dentry)
-		return -ENOMEM;
-	return 0;
-}
-
-static void remove_debug_file(struct isp116x *isp116x)
-{
-	debugfs_remove(isp116x->dentry);
-}
-
-#else
-
-#define	create_debug_file(d)	0
-#define	remove_debug_file(d)	do{}while(0)
-
-#endif				/* CONFIG_DEBUG_FS */
-
-/*-----------------------------------------------------------------*/
-
-/*
-  Software reset - can be called from any contect.
-*/
-static int isp116x_sw_reset(struct isp116x *isp116x)
-{
-	int retries = 15;
-	unsigned long flags;
-	int ret = 0;
-
-	spin_lock_irqsave(&isp116x->lock, flags);
-	isp116x_write_reg16(isp116x, HCSWRES, HCSWRES_MAGIC);
-	isp116x_write_reg32(isp116x, HCCMDSTAT, HCCMDSTAT_HCR);
-	while (--retries) {
-		/* It usually resets within 1 ms */
-		mdelay(1);
-		if (!(isp116x_read_reg32(isp116x, HCCMDSTAT) & HCCMDSTAT_HCR))
-			break;
-	}
-	if (!retries) {
-		ERR("Software reset timeout\n");
-		ret = -ETIME;
-	}
-	spin_unlock_irqrestore(&isp116x->lock, flags);
-	return ret;
-}
-
-static int isp116x_reset(struct usb_hcd *hcd)
-{
-	struct isp116x *isp116x = hcd_to_isp116x(hcd);
-	unsigned long t;
-	u16 clkrdy = 0;
-	int ret, timeout = 15 /* ms */ ;
-
-	ret = isp116x_sw_reset(isp116x);
-	if (ret)
-		return ret;
-
-	t = jiffies + msecs_to_jiffies(timeout);
-	while (time_before_eq(jiffies, t)) {
-		msleep(4);
-		spin_lock_irq(&isp116x->lock);
-		clkrdy = isp116x_read_reg16(isp116x, HCuPINT) & HCuPINT_CLKRDY;
-		spin_unlock_irq(&isp116x->lock);
-		if (clkrdy)
-			break;
-	}
-	if (!clkrdy) {
-		ERR("Clock not ready after %dms\n", timeout);
-		/* After sw_reset the clock won't report to be ready, if
-		   H_WAKEUP pin is high. */
-		ERR("Please make sure that the H_WAKEUP pin is pulled low!\n");
-		ret = -ENODEV;
-	}
-	return ret;
-}
-
-static void isp116x_stop(struct usb_hcd *hcd)
-{
-	struct isp116x *isp116x = hcd_to_isp116x(hcd);
-	unsigned long flags;
-	u32 val;
-
-	spin_lock_irqsave(&isp116x->lock, flags);
-	isp116x_write_reg16(isp116x, HCuPINTENB, 0);
-
-	/* Switch off ports' power, some devices don't come up
-	   after next 'insmod' without this */
-	val = isp116x_read_reg32(isp116x, HCRHDESCA);
-	val &= ~(RH_A_NPS | RH_A_PSM);
-	isp116x_write_reg32(isp116x, HCRHDESCA, val);
-	isp116x_write_reg32(isp116x, HCRHSTATUS, RH_HS_LPS);
-	spin_unlock_irqrestore(&isp116x->lock, flags);
-
-	isp116x_sw_reset(isp116x);
-}
-
-/*
-  Configure the chip. The chip must be successfully reset by now.
-*/
-static int isp116x_start(struct usb_hcd *hcd)
-{
-	struct isp116x *isp116x = hcd_to_isp116x(hcd);
-	struct isp116x_platform_data *board = isp116x->board;
-	u32 val;
-	unsigned long flags;
-
-	spin_lock_irqsave(&isp116x->lock, flags);
-
-	/* clear interrupt status and disable all interrupt sources */
-	isp116x_write_reg16(isp116x, HCuPINT, 0xff);
-	isp116x_write_reg16(isp116x, HCuPINTENB, 0);
-
-	val = isp116x_read_reg16(isp116x, HCCHIPID);
-	if ((val & HCCHIPID_MASK) != HCCHIPID_MAGIC) {
-		ERR("Invalid chip ID %04x\n", val);
-		spin_unlock_irqrestore(&isp116x->lock, flags);
-		return -ENODEV;
-	}
-
-	/* To be removed in future */
-	hcd->uses_new_polling = 1;
-
-	isp116x_write_reg16(isp116x, HCITLBUFLEN, ISP116x_ITL_BUFSIZE);
-	isp116x_write_reg16(isp116x, HCATLBUFLEN, ISP116x_ATL_BUFSIZE);
-
-	/* ----- HW conf */
-	val = HCHWCFG_INT_ENABLE | HCHWCFG_DBWIDTH(1);
-	if (board->sel15Kres)
-		val |= HCHWCFG_15KRSEL;
-	/* Remote wakeup won't work without working clock */
-	if (board->remote_wakeup_enable)
-		val |= HCHWCFG_CLKNOTSTOP;
-	if (board->oc_enable)
-		val |= HCHWCFG_ANALOG_OC;
-	if (board->int_act_high)
-		val |= HCHWCFG_INT_POL;
-	if (board->int_edge_triggered)
-		val |= HCHWCFG_INT_TRIGGER;
-	isp116x_write_reg16(isp116x, HCHWCFG, val);
-
-	/* ----- Root hub conf */
-	val = (25 << 24) & RH_A_POTPGT;
-	/* AN10003_1.pdf recommends RH_A_NPS (no power switching) to
-	   be always set. Yet, instead, we request individual port
-	   power switching. */
-	val |= RH_A_PSM;
-	/* Report overcurrent per port */
-	val |= RH_A_OCPM;
-	isp116x_write_reg32(isp116x, HCRHDESCA, val);
-	isp116x->rhdesca = isp116x_read_reg32(isp116x, HCRHDESCA);
-
-	val = RH_B_PPCM;
-	isp116x_write_reg32(isp116x, HCRHDESCB, val);
-	isp116x->rhdescb = isp116x_read_reg32(isp116x, HCRHDESCB);
-
-	val = 0;
-	if (board->remote_wakeup_enable) {
-		if (!device_can_wakeup(hcd->self.controller))
-			device_init_wakeup(hcd->self.controller, 1);
-		val |= RH_HS_DRWE;
-	}
-	isp116x_write_reg32(isp116x, HCRHSTATUS, val);
-	isp116x->rhstatus = isp116x_read_reg32(isp116x, HCRHSTATUS);
-
-	isp116x_write_reg32(isp116x, HCFMINTVL, 0x27782edf);
-
-	hcd->state = HC_STATE_RUNNING;
-
-	/* Set up interrupts */
-	isp116x->intenb = HCINT_MIE | HCINT_RHSC | HCINT_UE;
-	if (board->remote_wakeup_enable)
-		isp116x->intenb |= HCINT_RD;
-	isp116x->irqenb = HCuPINT_ATL | HCuPINT_OPR;	/* | HCuPINT_SUSP; */
-	isp116x_write_reg32(isp116x, HCINTENB, isp116x->intenb);
-	isp116x_write_reg16(isp116x, HCuPINTENB, isp116x->irqenb);
-
-	/* Go operational */
-	val = HCCONTROL_USB_OPER;
-	if (board->remote_wakeup_enable)
-		val |= HCCONTROL_RWE;
-	isp116x_write_reg32(isp116x, HCCONTROL, val);
-
-	/* Disable ports to avoid race in device enumeration */
-	isp116x_write_reg32(isp116x, HCRHPORT1, RH_PS_CCS);
-	isp116x_write_reg32(isp116x, HCRHPORT2, RH_PS_CCS);
-
-	isp116x_show_regs_log(isp116x);
-	spin_unlock_irqrestore(&isp116x->lock, flags);
-	return 0;
-}
-
-#ifdef	CONFIG_PM
-
-static int isp116x_bus_suspend(struct usb_hcd *hcd)
-{
-	struct isp116x *isp116x = hcd_to_isp116x(hcd);
-	unsigned long flags;
-	u32 val;
-	int ret = 0;
-
-	spin_lock_irqsave(&isp116x->lock, flags);
-	val = isp116x_read_reg32(isp116x, HCCONTROL);
-
-	switch (val & HCCONTROL_HCFS) {
-	case HCCONTROL_USB_OPER:
-		spin_unlock_irqrestore(&isp116x->lock, flags);
-		val &= (~HCCONTROL_HCFS & ~HCCONTROL_RWE);
-		val |= HCCONTROL_USB_SUSPEND;
-		if (device_may_wakeup(&hcd->self.root_hub->dev))
-			val |= HCCONTROL_RWE;
-		/* Wait for usb transfers to finish */
-		msleep(2);
-		spin_lock_irqsave(&isp116x->lock, flags);
-		isp116x_write_reg32(isp116x, HCCONTROL, val);
-		spin_unlock_irqrestore(&isp116x->lock, flags);
-		/* Wait for devices to suspend */
-		msleep(5);
-		break;
-	case HCCONTROL_USB_RESUME:
-		isp116x_write_reg32(isp116x, HCCONTROL,
-				    (val & ~HCCONTROL_HCFS) |
-				    HCCONTROL_USB_RESET);
-	case HCCONTROL_USB_RESET:
-		ret = -EBUSY;
-	default:		/* HCCONTROL_USB_SUSPEND */
-		spin_unlock_irqrestore(&isp116x->lock, flags);
-		break;
-	}
-
-	return ret;
-}
-
-static int isp116x_bus_resume(struct usb_hcd *hcd)
-{
-	struct isp116x *isp116x = hcd_to_isp116x(hcd);
-	u32 val;
-
-	msleep(5);
-	spin_lock_irq(&isp116x->lock);
-
-	val = isp116x_read_reg32(isp116x, HCCONTROL);
-	switch (val & HCCONTROL_HCFS) {
-	case HCCONTROL_USB_SUSPEND:
-		val &= ~HCCONTROL_HCFS;
-		val |= HCCONTROL_USB_RESUME;
-		isp116x_write_reg32(isp116x, HCCONTROL, val);
-	case HCCONTROL_USB_RESUME:
-		break;
-	case HCCONTROL_USB_OPER:
-		spin_unlock_irq(&isp116x->lock);
-		/* Without setting power_state here the
-		   SUSPENDED state won't be removed from
-		   sysfs/usbN/power.state as a response to remote
-		   wakeup. Maybe in the future. */
-		hcd->self.root_hub->dev.power.power_state = PMSG_ON;
-		return 0;
-	default:
-		/* HCCONTROL_USB_RESET: this may happen, when during
-		   suspension the HC lost power. Reinitialize completely */
-		spin_unlock_irq(&isp116x->lock);
-		DBG("Chip has been reset while suspended. Reinit from scratch.\n");
-		isp116x_reset(hcd);
-		isp116x_start(hcd);
-		isp116x_hub_control(hcd, SetPortFeature,
-				    USB_PORT_FEAT_POWER, 1, NULL, 0);
-		if ((isp116x->rhdesca & RH_A_NDP) == 2)
-			isp116x_hub_control(hcd, SetPortFeature,
-					    USB_PORT_FEAT_POWER, 2, NULL, 0);
-		hcd->self.root_hub->dev.power.power_state = PMSG_ON;
-		return 0;
-	}
-
-	val = isp116x->rhdesca & RH_A_NDP;
-	while (val--) {
-		u32 stat =
-		    isp116x_read_reg32(isp116x, val ? HCRHPORT2 : HCRHPORT1);
-		/* force global, not selective, resume */
-		if (!(stat & RH_PS_PSS))
-			continue;
-		DBG("%s: Resuming port %d\n", __func__, val);
-		isp116x_write_reg32(isp116x, RH_PS_POCI, val
-				    ? HCRHPORT2 : HCRHPORT1);
-	}
-	spin_unlock_irq(&isp116x->lock);
-
-	hcd->state = HC_STATE_RESUMING;
-	msleep(20);
-
-	/* Go operational */
-	spin_lock_irq(&isp116x->lock);
-	val = isp116x_read_reg32(isp116x, HCCONTROL);
-	isp116x_write_reg32(isp116x, HCCONTROL,
-			    (val & ~HCCONTROL_HCFS) | HCCONTROL_USB_OPER);
-	spin_unlock_irq(&isp116x->lock);
-	/* see analogous comment above */
-	hcd->self.root_hub->dev.power.power_state = PMSG_ON;
-	hcd->state = HC_STATE_RUNNING;
-
-	return 0;
-}
-
-#else
-
-#define	isp116x_bus_suspend	NULL
-#define	isp116x_bus_resume	NULL
-
-#endif
-
-static struct hc_driver isp116x_hc_driver = {
-	.description = hcd_name,
-	.product_desc = "ISP116x Host Controller",
-	.hcd_priv_size = sizeof(struct isp116x),
-
-	.irq = isp116x_irq,
-	.flags = HCD_USB11,
-
-	.reset = isp116x_reset,
-	.start = isp116x_start,
-	.stop = isp116x_stop,
-
-	.urb_enqueue = isp116x_urb_enqueue,
-	.urb_dequeue = isp116x_urb_dequeue,
-	.endpoint_disable = isp116x_endpoint_disable,
-
-	.get_frame_number = isp116x_get_frame,
-
-	.hub_status_data = isp116x_hub_status_data,
-	.hub_control = isp116x_hub_control,
-	.bus_suspend = isp116x_bus_suspend,
-	.bus_resume = isp116x_bus_resume,
-};
-
-/*----------------------------------------------------------------*/
-
-static int isp116x_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-	struct isp116x *isp116x;
-	struct resource *res;
-
-	if (!hcd)
-		return 0;
-	isp116x = hcd_to_isp116x(hcd);
-	remove_debug_file(isp116x);
-	usb_remove_hcd(hcd);
-
-	iounmap(isp116x->data_reg);
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-	release_mem_region(res->start, 2);
-	iounmap(isp116x->addr_reg);
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	release_mem_region(res->start, 2);
-
-	usb_put_hcd(hcd);
-	return 0;
-}
-
-#define resource_len(r) (((r)->end - (r)->start) + 1)
-
-static int __devinit isp116x_probe(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd;
-	struct isp116x *isp116x;
-	struct resource *addr, *data;
-	void __iomem *addr_reg;
-	void __iomem *data_reg;
-	int irq;
-	int ret = 0;
-
-	if (pdev->num_resources < 3) {
-		ret = -ENODEV;
-		goto err1;
-	}
-
-	data = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	addr = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-	irq = platform_get_irq(pdev, 0);
-	if (!addr || !data || irq < 0) {
-		ret = -ENODEV;
-		goto err1;
-	}
-
-	if (pdev->dev.dma_mask) {
-		DBG("DMA not supported\n");
-		ret = -EINVAL;
-		goto err1;
-	}
-
-	if (!request_mem_region(addr->start, 2, hcd_name)) {
-		ret = -EBUSY;
-		goto err1;
-	}
-	addr_reg = ioremap(addr->start, resource_len(addr));
-	if (addr_reg == NULL) {
-		ret = -ENOMEM;
-		goto err2;
-	}
-	if (!request_mem_region(data->start, 2, hcd_name)) {
-		ret = -EBUSY;
-		goto err3;
-	}
-	data_reg = ioremap(data->start, resource_len(data));
-	if (data_reg == NULL) {
-		ret = -ENOMEM;
-		goto err4;
-	}
-
-	/* allocate and initialize hcd */
-	hcd = usb_create_hcd(&isp116x_hc_driver, &pdev->dev, pdev->dev.bus_id);
-	if (!hcd) {
-		ret = -ENOMEM;
-		goto err5;
-	}
-	/* this rsrc_start is bogus */
-	hcd->rsrc_start = addr->start;
-	isp116x = hcd_to_isp116x(hcd);
-	isp116x->data_reg = data_reg;
-	isp116x->addr_reg = addr_reg;
-	spin_lock_init(&isp116x->lock);
-	INIT_LIST_HEAD(&isp116x->async);
-	isp116x->board = pdev->dev.platform_data;
-
-	if (!isp116x->board) {
-		ERR("Platform data structure not initialized\n");
-		ret = -ENODEV;
-		goto err6;
-	}
-	if (isp116x_check_platform_delay(isp116x)) {
-		ERR("USE_PLATFORM_DELAY defined, but delay function not "
-		    "implemented.\n");
-		ERR("See comments in drivers/usb/host/isp116x-hcd.c\n");
-		ret = -ENODEV;
-		goto err6;
-	}
-
-	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED);
-	if (ret)
-		goto err6;
-
-	ret = create_debug_file(isp116x);
-	if (ret) {
-		ERR("Couldn't create debugfs entry\n");
-		goto err7;
-	}
-
-	return 0;
-
-      err7:
-	usb_remove_hcd(hcd);
-      err6:
-	usb_put_hcd(hcd);
-      err5:
-	iounmap(data_reg);
-      err4:
-	release_mem_region(data->start, 2);
-      err3:
-	iounmap(addr_reg);
-      err2:
-	release_mem_region(addr->start, 2);
-      err1:
-	ERR("init error, %d\n", ret);
-	return ret;
-}
-
-#ifdef	CONFIG_PM
-/*
-  Suspend of platform device
-*/
-static int isp116x_suspend(struct platform_device *dev, pm_message_t state)
-{
-	VDBG("%s: state %x\n", __func__, state.event);
-	dev->dev.power.power_state = state;
-	return 0;
-}
-
-/*
-  Resume platform device
-*/
-static int isp116x_resume(struct platform_device *dev)
-{
-	VDBG("%s:  state %x\n", __func__, dev->power.power_state.event);
-	dev->dev.power.power_state = PMSG_ON;
-	return 0;
-}
-
-#else
-
-#define	isp116x_suspend    NULL
-#define	isp116x_resume     NULL
-
-#endif
-
-static struct platform_driver isp116x_driver = {
-	.probe = isp116x_probe,
-	.remove = isp116x_remove,
-	.suspend = isp116x_suspend,
-	.resume = isp116x_resume,
-	.driver = {
-		   .name = (char *)hcd_name,
-		   },
-};
-
-/*-----------------------------------------------------------------*/
-
-static int __init isp116x_init(void)
-{
-	if (usb_disabled())
-		return -ENODEV;
-
-	INFO("driver %s, %s\n", hcd_name, DRIVER_VERSION);
-	return platform_driver_register(&isp116x_driver);
-}
-
-module_init(isp116x_init);
-
-static void __exit isp116x_cleanup(void)
-{
-	platform_driver_unregister(&isp116x_driver);
-}
-
-module_exit(isp116x_cleanup);
diff -urN host/.svn/text-base/isp116x.h.svn-base host.new/.svn/text-base/isp116x.h.svn-base
--- host/.svn/text-base/isp116x.h.svn-base	2009-02-24 19:00:15.787950733 +0100
+++ host.new/.svn/text-base/isp116x.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,607 +0,0 @@
-/*
- * ISP116x register declarations and HCD data structures
- *
- * Copyright (C) 2005 Olav Kongas <ok@artecdesign.ee>
- * Portions:
- * Copyright (C) 2004 Lothar Wassmann
- * Copyright (C) 2004 Psion Teklogix
- * Copyright (C) 2004 David Brownell
- */
-
-/* us of 1ms frame */
-#define  MAX_LOAD_LIMIT		850
-
-/* Full speed: max # of bytes to transfer for a single urb
-   at a time must be < 1024 && must be multiple of 64.
-   832 allows transfering 4kiB within 5 frames. */
-#define MAX_TRANSFER_SIZE_FULLSPEED	832
-
-/* Low speed: there is no reason to schedule in very big
-   chunks; often the requested long transfers are for
-   string descriptors containing short strings. */
-#define MAX_TRANSFER_SIZE_LOWSPEED	64
-
-/* Bytetime (us), a rough indication of how much time it
-   would take to transfer a byte of useful data over USB */
-#define BYTE_TIME_FULLSPEED	1
-#define BYTE_TIME_LOWSPEED	20
-
-/* Buffer sizes */
-#define ISP116x_BUF_SIZE	4096
-#define ISP116x_ITL_BUFSIZE	0
-#define ISP116x_ATL_BUFSIZE	((ISP116x_BUF_SIZE) - 2*(ISP116x_ITL_BUFSIZE))
-
-#define ISP116x_WRITE_OFFSET	0x80
-
-/*------------ ISP116x registers/bits ------------*/
-#define	HCREVISION	0x00
-#define	HCCONTROL	0x01
-#define		HCCONTROL_HCFS	(3 << 6)	/* host controller
-						   functional state */
-#define		HCCONTROL_USB_RESET	(0 << 6)
-#define		HCCONTROL_USB_RESUME	(1 << 6)
-#define		HCCONTROL_USB_OPER	(2 << 6)
-#define		HCCONTROL_USB_SUSPEND	(3 << 6)
-#define		HCCONTROL_RWC	(1 << 9)	/* remote wakeup connected */
-#define		HCCONTROL_RWE	(1 << 10)	/* remote wakeup enable */
-#define	HCCMDSTAT	0x02
-#define		HCCMDSTAT_HCR	(1 << 0)	/* host controller reset */
-#define		HCCMDSTAT_SOC	(3 << 16)	/* scheduling overrun count */
-#define	HCINTSTAT	0x03
-#define		HCINT_SO	(1 << 0)	/* scheduling overrun */
-#define		HCINT_WDH	(1 << 1)	/* writeback of done_head */
-#define		HCINT_SF	(1 << 2)	/* start frame */
-#define		HCINT_RD	(1 << 3)	/* resume detect */
-#define		HCINT_UE	(1 << 4)	/* unrecoverable error */
-#define		HCINT_FNO	(1 << 5)	/* frame number overflow */
-#define		HCINT_RHSC	(1 << 6)	/* root hub status change */
-#define		HCINT_OC	(1 << 30)	/* ownership change */
-#define		HCINT_MIE	(1 << 31)	/* master interrupt enable */
-#define	HCINTENB	0x04
-#define	HCINTDIS	0x05
-#define	HCFMINTVL	0x0d
-#define	HCFMREM		0x0e
-#define	HCFMNUM		0x0f
-#define	HCLSTHRESH	0x11
-#define	HCRHDESCA	0x12
-#define		RH_A_NDP	(0x3 << 0)	/* # downstream ports */
-#define		RH_A_PSM	(1 << 8)	/* power switching mode */
-#define		RH_A_NPS	(1 << 9)	/* no power switching */
-#define		RH_A_DT		(1 << 10)	/* device type (mbz) */
-#define		RH_A_OCPM	(1 << 11)	/* overcurrent protection
-						   mode */
-#define		RH_A_NOCP	(1 << 12)	/* no overcurrent protection */
-#define		RH_A_POTPGT	(0xff << 24)	/* power on -> power good
-						   time */
-#define	HCRHDESCB	0x13
-#define		RH_B_DR		(0xffff << 0)	/* device removable flags */
-#define		RH_B_PPCM	(0xffff << 16)	/* port power control mask */
-#define	HCRHSTATUS	0x14
-#define		RH_HS_LPS	(1 << 0)	/* local power status */
-#define		RH_HS_OCI	(1 << 1)	/* over current indicator */
-#define		RH_HS_DRWE	(1 << 15)	/* device remote wakeup
-						   enable */
-#define		RH_HS_LPSC	(1 << 16)	/* local power status change */
-#define		RH_HS_OCIC	(1 << 17)	/* over current indicator
-						   change */
-#define		RH_HS_CRWE	(1 << 31)	/* clear remote wakeup
-						   enable */
-#define	HCRHPORT1	0x15
-#define		RH_PS_CCS	(1 << 0)	/* current connect status */
-#define		RH_PS_PES	(1 << 1)	/* port enable status */
-#define		RH_PS_PSS	(1 << 2)	/* port suspend status */
-#define		RH_PS_POCI	(1 << 3)	/* port over current
-						   indicator */
-#define		RH_PS_PRS	(1 << 4)	/* port reset status */
-#define		RH_PS_PPS	(1 << 8)	/* port power status */
-#define		RH_PS_LSDA	(1 << 9)	/* low speed device attached */
-#define		RH_PS_CSC	(1 << 16)	/* connect status change */
-#define		RH_PS_PESC	(1 << 17)	/* port enable status change */
-#define		RH_PS_PSSC	(1 << 18)	/* port suspend status
-						   change */
-#define		RH_PS_OCIC	(1 << 19)	/* over current indicator
-						   change */
-#define		RH_PS_PRSC	(1 << 20)	/* port reset status change */
-#define		HCRHPORT_CLRMASK	(0x1f << 16)
-#define	HCRHPORT2	0x16
-#define	HCHWCFG		0x20
-#define		HCHWCFG_15KRSEL		(1 << 12)
-#define		HCHWCFG_CLKNOTSTOP	(1 << 11)
-#define		HCHWCFG_ANALOG_OC	(1 << 10)
-#define		HCHWCFG_DACK_MODE	(1 << 8)
-#define		HCHWCFG_EOT_POL		(1 << 7)
-#define		HCHWCFG_DACK_POL	(1 << 6)
-#define		HCHWCFG_DREQ_POL	(1 << 5)
-#define		HCHWCFG_DBWIDTH_MASK	(0x03 << 3)
-#define		HCHWCFG_DBWIDTH(n)	(((n) << 3) & HCHWCFG_DBWIDTH_MASK)
-#define		HCHWCFG_INT_POL		(1 << 2)
-#define		HCHWCFG_INT_TRIGGER	(1 << 1)
-#define		HCHWCFG_INT_ENABLE	(1 << 0)
-#define	HCDMACFG	0x21
-#define		HCDMACFG_BURST_LEN_MASK	(0x03 << 5)
-#define		HCDMACFG_BURST_LEN(n)	(((n) << 5) & HCDMACFG_BURST_LEN_MASK)
-#define		HCDMACFG_BURST_LEN_1	HCDMACFG_BURST_LEN(0)
-#define		HCDMACFG_BURST_LEN_4	HCDMACFG_BURST_LEN(1)
-#define		HCDMACFG_BURST_LEN_8	HCDMACFG_BURST_LEN(2)
-#define		HCDMACFG_DMA_ENABLE	(1 << 4)
-#define		HCDMACFG_BUF_TYPE_MASK	(0x07 << 1)
-#define		HCDMACFG_CTR_SEL	(1 << 2)
-#define		HCDMACFG_ITLATL_SEL	(1 << 1)
-#define		HCDMACFG_DMA_RW_SELECT	(1 << 0)
-#define	HCXFERCTR	0x22
-#define	HCuPINT		0x24
-#define		HCuPINT_SOF		(1 << 0)
-#define		HCuPINT_ATL		(1 << 1)
-#define		HCuPINT_AIIEOT		(1 << 2)
-#define		HCuPINT_OPR		(1 << 4)
-#define		HCuPINT_SUSP		(1 << 5)
-#define		HCuPINT_CLKRDY		(1 << 6)
-#define	HCuPINTENB	0x25
-#define	HCCHIPID	0x27
-#define		HCCHIPID_MASK		0xff00
-#define		HCCHIPID_MAGIC		0x6100
-#define	HCSCRATCH	0x28
-#define	HCSWRES		0x29
-#define		HCSWRES_MAGIC		0x00f6
-#define	HCITLBUFLEN	0x2a
-#define	HCATLBUFLEN	0x2b
-#define	HCBUFSTAT	0x2c
-#define		HCBUFSTAT_ITL0_FULL	(1 << 0)
-#define		HCBUFSTAT_ITL1_FULL	(1 << 1)
-#define		HCBUFSTAT_ATL_FULL	(1 << 2)
-#define		HCBUFSTAT_ITL0_DONE	(1 << 3)
-#define		HCBUFSTAT_ITL1_DONE	(1 << 4)
-#define		HCBUFSTAT_ATL_DONE	(1 << 5)
-#define	HCRDITL0LEN	0x2d
-#define	HCRDITL1LEN	0x2e
-#define	HCITLPORT	0x40
-#define	HCATLPORT	0x41
-
-/* Philips transfer descriptor */
-struct ptd {
-	u16 count;
-#define	PTD_COUNT_MSK	(0x3ff << 0)
-#define	PTD_TOGGLE_MSK	(1 << 10)
-#define	PTD_ACTIVE_MSK	(1 << 11)
-#define	PTD_CC_MSK	(0xf << 12)
-	u16 mps;
-#define	PTD_MPS_MSK	(0x3ff << 0)
-#define	PTD_SPD_MSK	(1 << 10)
-#define	PTD_LAST_MSK	(1 << 11)
-#define	PTD_EP_MSK	(0xf << 12)
-	u16 len;
-#define	PTD_LEN_MSK	(0x3ff << 0)
-#define	PTD_DIR_MSK	(3 << 10)
-#define	PTD_DIR_SETUP	(0)
-#define	PTD_DIR_OUT	(1)
-#define	PTD_DIR_IN	(2)
-#define	PTD_B5_5_MSK	(1 << 13)
-	u16 faddr;
-#define	PTD_FA_MSK	(0x7f << 0)
-#define	PTD_FMT_MSK	(1 << 7)
-} __attribute__ ((packed, aligned(2)));
-
-/* PTD accessor macros. */
-#define PTD_GET_COUNT(p)	(((p)->count & PTD_COUNT_MSK) >> 0)
-#define PTD_COUNT(v)		(((v) << 0) & PTD_COUNT_MSK)
-#define PTD_GET_TOGGLE(p)	(((p)->count & PTD_TOGGLE_MSK) >> 10)
-#define PTD_TOGGLE(v)		(((v) << 10) & PTD_TOGGLE_MSK)
-#define PTD_GET_ACTIVE(p)	(((p)->count & PTD_ACTIVE_MSK) >> 11)
-#define PTD_ACTIVE(v)		(((v) << 11) & PTD_ACTIVE_MSK)
-#define PTD_GET_CC(p)		(((p)->count & PTD_CC_MSK) >> 12)
-#define PTD_CC(v)		(((v) << 12) & PTD_CC_MSK)
-#define PTD_GET_MPS(p)		(((p)->mps & PTD_MPS_MSK) >> 0)
-#define PTD_MPS(v)		(((v) << 0) & PTD_MPS_MSK)
-#define PTD_GET_SPD(p)		(((p)->mps & PTD_SPD_MSK) >> 10)
-#define PTD_SPD(v)		(((v) << 10) & PTD_SPD_MSK)
-#define PTD_GET_LAST(p)		(((p)->mps & PTD_LAST_MSK) >> 11)
-#define PTD_LAST(v)		(((v) << 11) & PTD_LAST_MSK)
-#define PTD_GET_EP(p)		(((p)->mps & PTD_EP_MSK) >> 12)
-#define PTD_EP(v)		(((v) << 12) & PTD_EP_MSK)
-#define PTD_GET_LEN(p)		(((p)->len & PTD_LEN_MSK) >> 0)
-#define PTD_LEN(v)		(((v) << 0) & PTD_LEN_MSK)
-#define PTD_GET_DIR(p)		(((p)->len & PTD_DIR_MSK) >> 10)
-#define PTD_DIR(v)		(((v) << 10) & PTD_DIR_MSK)
-#define PTD_GET_B5_5(p)		(((p)->len & PTD_B5_5_MSK) >> 13)
-#define PTD_B5_5(v)		(((v) << 13) & PTD_B5_5_MSK)
-#define PTD_GET_FA(p)		(((p)->faddr & PTD_FA_MSK) >> 0)
-#define PTD_FA(v)		(((v) << 0) & PTD_FA_MSK)
-#define PTD_GET_FMT(p)		(((p)->faddr & PTD_FMT_MSK) >> 7)
-#define PTD_FMT(v)		(((v) << 7) & PTD_FMT_MSK)
-
-/*  Hardware transfer status codes -- CC from ptd->count */
-#define TD_CC_NOERROR      0x00
-#define TD_CC_CRC          0x01
-#define TD_CC_BITSTUFFING  0x02
-#define TD_CC_DATATOGGLEM  0x03
-#define TD_CC_STALL        0x04
-#define TD_DEVNOTRESP      0x05
-#define TD_PIDCHECKFAIL    0x06
-#define TD_UNEXPECTEDPID   0x07
-#define TD_DATAOVERRUN     0x08
-#define TD_DATAUNDERRUN    0x09
-    /* 0x0A, 0x0B reserved for hardware */
-#define TD_BUFFEROVERRUN   0x0C
-#define TD_BUFFERUNDERRUN  0x0D
-    /* 0x0E, 0x0F reserved for HCD */
-#define TD_NOTACCESSED     0x0F
-
-/* map PTD status codes (CC) to errno values */
-static const int cc_to_error[16] = {
-	/* No  Error  */ 0,
-	/* CRC Error  */ -EILSEQ,
-	/* Bit Stuff  */ -EPROTO,
-	/* Data Togg  */ -EILSEQ,
-	/* Stall      */ -EPIPE,
-	/* DevNotResp */ -ETIME,
-	/* PIDCheck   */ -EPROTO,
-	/* UnExpPID   */ -EPROTO,
-	/* DataOver   */ -EOVERFLOW,
-	/* DataUnder  */ -EREMOTEIO,
-	/* (for hw)   */ -EIO,
-	/* (for hw)   */ -EIO,
-	/* BufferOver */ -ECOMM,
-	/* BuffUnder  */ -ENOSR,
-	/* (for HCD)  */ -EALREADY,
-	/* (for HCD)  */ -EALREADY
-};
-
-/*--------------------------------------------------------------*/
-
-#define	LOG2_PERIODIC_SIZE	5	/* arbitrary; this matches OHCI */
-#define	PERIODIC_SIZE		(1 << LOG2_PERIODIC_SIZE)
-
-struct isp116x {
-	spinlock_t lock;
-
-	void __iomem *addr_reg;
-	void __iomem *data_reg;
-
-	struct isp116x_platform_data *board;
-
-	struct dentry *dentry;
-	unsigned long stat1, stat2, stat4, stat8, stat16;
-
-	/* HC registers */
-	u32 intenb;		/* "OHCI" interrupts */
-	u16 irqenb;		/* uP interrupts */
-
-	/* Root hub registers */
-	u32 rhdesca;
-	u32 rhdescb;
-	u32 rhstatus;
-	u32 rhport[2];
-
-	/* async schedule: control, bulk */
-	struct list_head async;
-
-	/* periodic schedule: int */
-	u16 load[PERIODIC_SIZE];
-	struct isp116x_ep *periodic[PERIODIC_SIZE];
-	unsigned periodic_count;
-	u16 fmindex;
-
-	/* Schedule for the current frame */
-	struct isp116x_ep *atl_active;
-	int atl_buflen;
-	int atl_bufshrt;
-	int atl_last_dir;
-	atomic_t atl_finishing;
-};
-
-static inline struct isp116x *hcd_to_isp116x(struct usb_hcd *hcd)
-{
-	return (struct isp116x *)(hcd->hcd_priv);
-}
-
-static inline struct usb_hcd *isp116x_to_hcd(struct isp116x *isp116x)
-{
-	return container_of((void *)isp116x, struct usb_hcd, hcd_priv);
-}
-
-struct isp116x_ep {
-	struct usb_host_endpoint *hep;
-	struct usb_device *udev;
-	struct ptd ptd;
-
-	u8 maxpacket;
-	u8 epnum;
-	u8 nextpid;
-	u16 error_count;
-	u16 length;		/* of current packet */
-	unsigned char *data;	/* to databuf */
-	/* queue of active EP's (the ones scheduled for the
-	   current frame) */
-	struct isp116x_ep *active;
-
-	/* periodic schedule */
-	u16 period;
-	u16 branch;
-	u16 load;
-	struct isp116x_ep *next;
-
-	/* async schedule */
-	struct list_head schedule;
-};
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef DEBUG
-#define DBG(stuff...)		printk(KERN_DEBUG "116x: " stuff)
-#else
-#define DBG(stuff...)		do{}while(0)
-#endif
-
-#ifdef VERBOSE
-#    define VDBG		DBG
-#else
-#    define VDBG(stuff...)	do{}while(0)
-#endif
-
-#define ERR(stuff...)		printk(KERN_ERR "116x: " stuff)
-#define WARN(stuff...)		printk(KERN_WARNING "116x: " stuff)
-#define INFO(stuff...)		printk(KERN_INFO "116x: " stuff)
-
-/* ------------------------------------------------- */
-
-#if defined(USE_PLATFORM_DELAY)
-#if defined(USE_NDELAY)
-#error USE_PLATFORM_DELAY and USE_NDELAY simultaneously defined.
-#endif
-#define	isp116x_delay(h,d)	(h)->board->delay(	\
-				isp116x_to_hcd(h)->self.controller,d)
-#define isp116x_check_platform_delay(h)	((h)->board->delay == NULL)
-#elif defined(USE_NDELAY)
-#define	isp116x_delay(h,d)	ndelay(d)
-#define isp116x_check_platform_delay(h)	0
-#else
-#define	isp116x_delay(h,d)	do{}while(0)
-#define isp116x_check_platform_delay(h)	0
-#endif
-
-#if defined(DEBUG)
-#define	IRQ_TEST()	BUG_ON(!irqs_disabled())
-#else
-#define	IRQ_TEST()	do{}while(0)
-#endif
-
-static inline void isp116x_write_addr(struct isp116x *isp116x, unsigned reg)
-{
-	IRQ_TEST();
-	writew(reg & 0xff, isp116x->addr_reg);
-	isp116x_delay(isp116x, 300);
-}
-
-static inline void isp116x_write_data16(struct isp116x *isp116x, u16 val)
-{
-	writew(val, isp116x->data_reg);
-	isp116x_delay(isp116x, 150);
-}
-
-static inline void isp116x_raw_write_data16(struct isp116x *isp116x, u16 val)
-{
-	__raw_writew(val, isp116x->data_reg);
-	isp116x_delay(isp116x, 150);
-}
-
-static inline u16 isp116x_read_data16(struct isp116x *isp116x)
-{
-	u16 val;
-
-	val = readw(isp116x->data_reg);
-	isp116x_delay(isp116x, 150);
-	return val;
-}
-
-static inline u16 isp116x_raw_read_data16(struct isp116x *isp116x)
-{
-	u16 val;
-
-	val = __raw_readw(isp116x->data_reg);
-	isp116x_delay(isp116x, 150);
-	return val;
-}
-
-static inline void isp116x_write_data32(struct isp116x *isp116x, u32 val)
-{
-	writew(val & 0xffff, isp116x->data_reg);
-	isp116x_delay(isp116x, 150);
-	writew(val >> 16, isp116x->data_reg);
-	isp116x_delay(isp116x, 150);
-}
-
-static inline u32 isp116x_read_data32(struct isp116x *isp116x)
-{
-	u32 val;
-
-	val = (u32) readw(isp116x->data_reg);
-	isp116x_delay(isp116x, 150);
-	val |= ((u32) readw(isp116x->data_reg)) << 16;
-	isp116x_delay(isp116x, 150);
-	return val;
-}
-
-/* Let's keep register access functions out of line. Hint:
-   we wait at least 150 ns at every access.
-*/
-static u16 isp116x_read_reg16(struct isp116x *isp116x, unsigned reg)
-{
-	isp116x_write_addr(isp116x, reg);
-	return isp116x_read_data16(isp116x);
-}
-
-static u32 isp116x_read_reg32(struct isp116x *isp116x, unsigned reg)
-{
-	isp116x_write_addr(isp116x, reg);
-	return isp116x_read_data32(isp116x);
-}
-
-static void isp116x_write_reg16(struct isp116x *isp116x, unsigned reg,
-				unsigned val)
-{
-	isp116x_write_addr(isp116x, reg | ISP116x_WRITE_OFFSET);
-	isp116x_write_data16(isp116x, (u16) (val & 0xffff));
-}
-
-static void isp116x_write_reg32(struct isp116x *isp116x, unsigned reg,
-				unsigned val)
-{
-	isp116x_write_addr(isp116x, reg | ISP116x_WRITE_OFFSET);
-	isp116x_write_data32(isp116x, (u32) val);
-}
-
-#define isp116x_show_reg_log(d,r,s) {				\
-	if ((r) < 0x20) {			                \
-		DBG("%-12s[%02x]: %08x\n", #r,			\
-			r, isp116x_read_reg32(d, r));		\
-	} else {						\
-		DBG("%-12s[%02x]:     %04x\n", #r,		\
-			r, isp116x_read_reg16(d, r));	    	\
-	}							\
-}
-#define isp116x_show_reg_seq(d,r,s) {				\
-	if ((r) < 0x20) {					\
-		seq_printf(s, "%-12s[%02x]: %08x\n", #r,	\
-			r, isp116x_read_reg32(d, r));		\
-	} else {						\
-		seq_printf(s, "%-12s[%02x]:     %04x\n", #r,	\
-			r, isp116x_read_reg16(d, r));		\
-	}							\
-}
-
-#define isp116x_show_regs(d,type,s) {			\
-	isp116x_show_reg_##type(d, HCREVISION, s);	\
-	isp116x_show_reg_##type(d, HCCONTROL, s);	\
-	isp116x_show_reg_##type(d, HCCMDSTAT, s);	\
-	isp116x_show_reg_##type(d, HCINTSTAT, s);	\
-	isp116x_show_reg_##type(d, HCINTENB, s);	\
-	isp116x_show_reg_##type(d, HCFMINTVL, s);	\
-	isp116x_show_reg_##type(d, HCFMREM, s);		\
-	isp116x_show_reg_##type(d, HCFMNUM, s);		\
-	isp116x_show_reg_##type(d, HCLSTHRESH, s);	\
-	isp116x_show_reg_##type(d, HCRHDESCA, s);	\
-	isp116x_show_reg_##type(d, HCRHDESCB, s);	\
-	isp116x_show_reg_##type(d, HCRHSTATUS, s);	\
-	isp116x_show_reg_##type(d, HCRHPORT1, s);	\
-	isp116x_show_reg_##type(d, HCRHPORT2, s);	\
-	isp116x_show_reg_##type(d, HCHWCFG, s);		\
-	isp116x_show_reg_##type(d, HCDMACFG, s);	\
-	isp116x_show_reg_##type(d, HCXFERCTR, s);	\
-	isp116x_show_reg_##type(d, HCuPINT, s);		\
-	isp116x_show_reg_##type(d, HCuPINTENB, s);	\
-	isp116x_show_reg_##type(d, HCCHIPID, s);	\
-	isp116x_show_reg_##type(d, HCSCRATCH, s);	\
-	isp116x_show_reg_##type(d, HCITLBUFLEN, s);	\
-	isp116x_show_reg_##type(d, HCATLBUFLEN, s);	\
-	isp116x_show_reg_##type(d, HCBUFSTAT, s);	\
-	isp116x_show_reg_##type(d, HCRDITL0LEN, s);	\
-	isp116x_show_reg_##type(d, HCRDITL1LEN, s);	\
-}
-
-/*
-   Dump registers for debugfs.
-*/
-static inline void isp116x_show_regs_seq(struct isp116x *isp116x,
-					  struct seq_file *s)
-{
-	isp116x_show_regs(isp116x, seq, s);
-}
-
-/*
-   Dump registers to syslog.
-*/
-static inline void isp116x_show_regs_log(struct isp116x *isp116x)
-{
-	isp116x_show_regs(isp116x, log, NULL);
-}
-
-#if defined(URB_TRACE)
-
-#define PIPETYPE(pipe)  ({ char *__s;			\
-	if (usb_pipecontrol(pipe))	__s = "ctrl";	\
-	else if (usb_pipeint(pipe))	__s = "int";	\
-	else if (usb_pipebulk(pipe))	__s = "bulk";	\
-	else				__s = "iso";	\
-	__s;})
-#define PIPEDIR(pipe)   ({ usb_pipein(pipe) ? "in" : "out"; })
-#define URB_NOTSHORT(urb) ({ (urb)->transfer_flags & URB_SHORT_NOT_OK ? \
-	"short_not_ok" : ""; })
-
-/* print debug info about the URB */
-static void urb_dbg(struct urb *urb, char *msg)
-{
-	unsigned int pipe;
-
-	if (!urb) {
-		DBG("%s: zero urb\n", msg);
-		return;
-	}
-	pipe = urb->pipe;
-	DBG("%s: FA %d ep%d%s %s: len %d/%d %s\n", msg,
-	    usb_pipedevice(pipe), usb_pipeendpoint(pipe),
-	    PIPEDIR(pipe), PIPETYPE(pipe),
-	    urb->transfer_buffer_length, urb->actual_length, URB_NOTSHORT(urb));
-}
-
-#else
-
-#define  urb_dbg(urb,msg)   do{}while(0)
-
-#endif				/* ! defined(URB_TRACE) */
-
-#if defined(PTD_TRACE)
-
-#define PTD_DIR_STR(ptd)  ({char __c;		\
-	switch(PTD_GET_DIR(ptd)){		\
-	case 0:  __c = 's'; break;		\
-	case 1:  __c = 'o'; break;		\
-	default: __c = 'i'; break;		\
-	}; __c;})
-
-/*
-  Dump PTD info. The code documents the format
-  perfectly, right :)
-*/
-static inline void dump_ptd(struct ptd *ptd)
-{
-	printk("td: %x %d%c%d %d,%d,%d  %x %x%x%x\n",
-	       PTD_GET_CC(ptd), PTD_GET_FA(ptd),
-	       PTD_DIR_STR(ptd), PTD_GET_EP(ptd),
-	       PTD_GET_COUNT(ptd), PTD_GET_LEN(ptd), PTD_GET_MPS(ptd),
-	       PTD_GET_TOGGLE(ptd), PTD_GET_ACTIVE(ptd),
-	       PTD_GET_SPD(ptd), PTD_GET_LAST(ptd));
-}
-
-static inline void dump_ptd_out_data(struct ptd *ptd, u8 * buf)
-{
-	int k;
-
-	if (PTD_GET_DIR(ptd) != PTD_DIR_IN && PTD_GET_LEN(ptd)) {
-		printk("-> ");
-		for (k = 0; k < PTD_GET_LEN(ptd); ++k)
-			printk("%02x ", ((u8 *) buf)[k]);
-		printk("\n");
-	}
-}
-
-static inline void dump_ptd_in_data(struct ptd *ptd, u8 * buf)
-{
-	int k;
-
-	if (PTD_GET_DIR(ptd) == PTD_DIR_IN && PTD_GET_COUNT(ptd)) {
-		printk("<- ");
-		for (k = 0; k < PTD_GET_COUNT(ptd); ++k)
-			printk("%02x ", ((u8 *) buf)[k]);
-		printk("\n");
-	}
-	if (PTD_GET_LAST(ptd))
-		printk("-\n");
-}
-
-#else
-
-#define dump_ptd(ptd)               do{}while(0)
-#define dump_ptd_in_data(ptd,buf)   do{}while(0)
-#define dump_ptd_out_data(ptd,buf)  do{}while(0)
-
-#endif				/* ! defined(PTD_TRACE) */
diff -urN host/.svn/text-base/ohci-at91.c.svn-base host.new/.svn/text-base/ohci-at91.c.svn-base
--- host/.svn/text-base/ohci-at91.c.svn-base	2009-02-24 19:00:15.787950733 +0100
+++ host.new/.svn/text-base/ohci-at91.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,340 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- *  Copyright (C) 2004 SAN People (Pty) Ltd.
- *  Copyright (C) 2005 Thibaut VARENE <varenet@parisc-linux.org>
- *
- * AT91 Bus Glue
- *
- * Based on fragments of 2.4 driver by Rick Bronson.
- * Based on ohci-omap.c
- *
- * This file is licenced under the GPL.
- */
-
-#include <linux/clk.h>
-#include <linux/platform_device.h>
-
-#include <asm/mach-types.h>
-#include <asm/hardware.h>
-#include <asm/arch/board.h>
-#include <asm/arch/cpu.h>
-
-#ifndef CONFIG_ARCH_AT91
-#error "CONFIG_ARCH_AT91 must be defined."
-#endif
-
-/* interface and function clocks; sometimes also an AHB clock */
-static struct clk *iclk, *fclk, *hclk;
-static int clocked;
-
-extern int usb_disabled(void);
-
-/*-------------------------------------------------------------------------*/
-
-static void at91_start_clock(void)
-{
-	if (cpu_is_at91sam9261())
-		clk_enable(hclk);
-	clk_enable(iclk);
-	clk_enable(fclk);
-	clocked = 1;
-}
-
-static void at91_stop_clock(void)
-{
-	clk_disable(fclk);
-	clk_disable(iclk);
-	if (cpu_is_at91sam9261())
-		clk_disable(hclk);
-	clocked = 0;
-}
-
-static void at91_start_hc(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-	struct ohci_regs __iomem *regs = hcd->regs;
-
-	dev_dbg(&pdev->dev, "start\n");
-
-	/*
-	 * Start the USB clocks.
-	 */
-	at91_start_clock();
-
-	/*
-	 * The USB host controller must remain in reset.
-	 */
-	writel(0, &regs->control);
-}
-
-static void at91_stop_hc(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-	struct ohci_regs __iomem *regs = hcd->regs;
-
-	dev_dbg(&pdev->dev, "stop\n");
-
-	/*
-	 * Put the USB host controller into reset.
-	 */
-	writel(0, &regs->control);
-
-	/*
-	 * Stop the USB clocks.
-	 */
-	at91_stop_clock();
-}
-
-
-/*-------------------------------------------------------------------------*/
-
-static int usb_hcd_at91_remove (struct usb_hcd *, struct platform_device *);
-
-/* configure so an HC device and id are always provided */
-/* always called with process context; sleeping is OK */
-
-
-/**
- * usb_hcd_at91_probe - initialize AT91-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- */
-static int usb_hcd_at91_probe(const struct hc_driver *driver,
-			struct platform_device *pdev)
-{
-	int retval;
-	struct usb_hcd *hcd = NULL;
-
-	if (pdev->num_resources != 2) {
-		pr_debug("hcd probe: invalid num_resources");
-		return -ENODEV;
-	}
-
-	if ((pdev->resource[0].flags != IORESOURCE_MEM)
-			|| (pdev->resource[1].flags != IORESOURCE_IRQ)) {
-		pr_debug("hcd probe: invalid resource type\n");
-		return -ENODEV;
-	}
-
-	hcd = usb_create_hcd(driver, &pdev->dev, "at91");
-	if (!hcd)
-		return -ENOMEM;
-	hcd->rsrc_start = pdev->resource[0].start;
-	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		pr_debug("request_mem_region failed\n");
-		retval = -EBUSY;
-		goto err1;
-	}
-
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-	if (!hcd->regs) {
-		pr_debug("ioremap failed\n");
-		retval = -EIO;
-		goto err2;
-	}
-
-	iclk = clk_get(&pdev->dev, "ohci_clk");
-	fclk = clk_get(&pdev->dev, "uhpck");
-	if (cpu_is_at91sam9261())
-		hclk = clk_get(&pdev->dev, "hck0");
-
-	at91_start_hc(pdev);
-	ohci_hcd_init(hcd_to_ohci(hcd));
-
-	retval = usb_add_hcd(hcd, pdev->resource[1].start, IRQF_DISABLED);
-	if (retval == 0)
-		return retval;
-
-	/* Error handling */
-	at91_stop_hc(pdev);
-
-	if (cpu_is_at91sam9261())
-		clk_put(hclk);
-	clk_put(fclk);
-	clk_put(iclk);
-
-	iounmap(hcd->regs);
-
- err2:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-
- err1:
-	usb_put_hcd(hcd);
-	return retval;
-}
-
-
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_hcd_at91_remove - shutdown processing for AT91-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_hcd_at91_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, "rmmod" or something similar.
- *
- */
-static int usb_hcd_at91_remove(struct usb_hcd *hcd,
-				struct platform_device *pdev)
-{
-	usb_remove_hcd(hcd);
-	at91_stop_hc(pdev);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-
-	if (cpu_is_at91sam9261())
-		clk_put(hclk);
-	clk_put(fclk);
-	clk_put(iclk);
-	fclk = iclk = hclk = NULL;
-
-	dev_set_drvdata(&pdev->dev, NULL);
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int __devinit
-ohci_at91_start (struct usb_hcd *hcd)
-{
-	struct at91_usbh_data	*board = hcd->self.controller->platform_data;
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-	int			ret;
-
-	if ((ret = ohci_init(ohci)) < 0)
-		return ret;
-
-	ohci->num_ports = board->ports;
-
-	if ((ret = ohci_run(ohci)) < 0) {
-		err("can't start %s", hcd->self.bus_name);
-		ohci_stop(hcd);
-		return ret;
-	}
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static const struct hc_driver ohci_at91_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"AT91 OHCI",
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ohci_irq,
-	.flags =		HCD_USB11 | HCD_MEMORY,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.start =		ohci_at91_start,
-	.stop =			ohci_stop,
-	.shutdown =		ohci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ohci_urb_enqueue,
-	.urb_dequeue =		ohci_urb_dequeue,
-	.endpoint_disable =	ohci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ohci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ohci_hub_status_data,
-	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
-#ifdef CONFIG_PM
-	.bus_suspend =		ohci_bus_suspend,
-	.bus_resume =		ohci_bus_resume,
-#endif
-	.start_port_reset =	ohci_start_port_reset,
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int ohci_hcd_at91_drv_probe(struct platform_device *pdev)
-{
-	device_init_wakeup(&pdev->dev, 1);
-	return usb_hcd_at91_probe(&ohci_at91_hc_driver, pdev);
-}
-
-static int ohci_hcd_at91_drv_remove(struct platform_device *pdev)
-{
-	device_init_wakeup(&pdev->dev, 0);
-	return usb_hcd_at91_remove(platform_get_drvdata(pdev), pdev);
-}
-
-#ifdef CONFIG_PM
-
-static int
-ohci_hcd_at91_drv_suspend(struct platform_device *pdev, pm_message_t mesg)
-{
-	struct usb_hcd	*hcd = platform_get_drvdata(pdev);
-	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
-
-	if (device_may_wakeup(&pdev->dev))
-		enable_irq_wake(hcd->irq);
-
-	/*
-	 * The integrated transceivers seem unable to notice disconnect,
-	 * reconnect, or wakeup without the 48 MHz clock active.  so for
-	 * correctness, always discard connection state (using reset).
-	 *
-	 * REVISIT: some boards will be able to turn VBUS off...
-	 */
-	if (at91_suspend_entering_slow_clock()) {
-		ohci_usb_reset (ohci);
-		at91_stop_clock();
-	}
-
-	return 0;
-}
-
-static int ohci_hcd_at91_drv_resume(struct platform_device *pdev)
-{
-	struct usb_hcd	*hcd = platform_get_drvdata(pdev);
-
-	if (device_may_wakeup(&pdev->dev))
-		disable_irq_wake(hcd->irq);
-
-	if (!clocked)
-		at91_start_clock();
-
-	return 0;
-}
-#else
-#define ohci_hcd_at91_drv_suspend NULL
-#define ohci_hcd_at91_drv_resume  NULL
-#endif
-
-MODULE_ALIAS("at91_ohci");
-
-static struct platform_driver ohci_hcd_at91_driver = {
-	.probe		= ohci_hcd_at91_drv_probe,
-	.remove		= ohci_hcd_at91_drv_remove,
-	.shutdown	= usb_hcd_platform_shutdown,
-	.suspend	= ohci_hcd_at91_drv_suspend,
-	.resume		= ohci_hcd_at91_drv_resume,
-	.driver		= {
-		.name	= "at91_ohci",
-		.owner	= THIS_MODULE,
-	},
-};
-
diff -urN host/.svn/text-base/ohci-au1xxx.c.svn-base host.new/.svn/text-base/ohci-au1xxx.c.svn-base
--- host/.svn/text-base/ohci-au1xxx.c.svn-base	2009-02-24 19:00:15.787950733 +0100
+++ host.new/.svn/text-base/ohci-au1xxx.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,347 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- * (C) Copyright 2002 Hewlett-Packard Company
- *
- * Bus Glue for AMD Alchemy Au1xxx
- *
- * Written by Christopher Hoover <ch@hpl.hp.com>
- * Based on fragments of previous driver by Rusell King et al.
- *
- * Modified for LH7A404 from ohci-sa1111.c
- *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
- * Modified for AMD Alchemy Au1xxx
- *  by Matt Porter <mporter@kernel.crashing.org>
- *
- * This file is licenced under the GPL.
- */
-
-#include <linux/platform_device.h>
-#include <linux/signal.h>
-
-#include <asm/mach-au1x00/au1000.h>
-
-#ifndef	CONFIG_SOC_AU1200
-
-#define USBH_ENABLE_BE (1<<0)
-#define USBH_ENABLE_C  (1<<1)
-#define USBH_ENABLE_E  (1<<2)
-#define USBH_ENABLE_CE (1<<3)
-#define USBH_ENABLE_RD (1<<4)
-
-#ifdef __LITTLE_ENDIAN
-#define USBH_ENABLE_INIT (USBH_ENABLE_CE | USBH_ENABLE_E | USBH_ENABLE_C)
-#elif __BIG_ENDIAN
-#define USBH_ENABLE_INIT (USBH_ENABLE_CE | USBH_ENABLE_E | USBH_ENABLE_C | USBH_ENABLE_BE)
-#else
-#error not byte order defined
-#endif
-
-#else   /* Au1200 */
-
-#define USB_HOST_CONFIG    (USB_MSR_BASE + USB_MSR_MCFG)
-#define USB_MCFG_PFEN     (1<<31)
-#define USB_MCFG_RDCOMB   (1<<30)
-#define USB_MCFG_SSDEN    (1<<23)
-#define USB_MCFG_OHCCLKEN (1<<16)
-#define USB_MCFG_UCAM     (1<<7)
-#define USB_MCFG_OBMEN    (1<<1)
-#define USB_MCFG_OMEMEN   (1<<0)
-
-#define USBH_ENABLE_CE    USB_MCFG_OHCCLKEN
-#ifdef CONFIG_DMA_COHERENT
-#define USBH_ENABLE_INIT  (USB_MCFG_OHCCLKEN \
-                         | USB_MCFG_PFEN | USB_MCFG_RDCOMB \
-                         | USB_MCFG_SSDEN | USB_MCFG_UCAM \
-                         | USB_MCFG_OBMEN | USB_MCFG_OMEMEN)
-#else
-#define USBH_ENABLE_INIT  (USB_MCFG_OHCCLKEN \
-                         | USB_MCFG_PFEN | USB_MCFG_RDCOMB \
-                         | USB_MCFG_SSDEN \
-                         | USB_MCFG_OBMEN | USB_MCFG_OMEMEN)
-#endif
-#define USBH_DISABLE      (USB_MCFG_OBMEN | USB_MCFG_OMEMEN)
-
-#endif  /* Au1200 */
-
-extern int usb_disabled(void);
-
-/*-------------------------------------------------------------------------*/
-
-static void au1xxx_start_ohc(struct platform_device *dev)
-{
-	printk(KERN_DEBUG __FILE__
-		": starting Au1xxx OHCI USB Controller\n");
-
-	/* enable host controller */
-
-#ifndef CONFIG_SOC_AU1200
-
-	au_writel(USBH_ENABLE_CE, USB_HOST_CONFIG);
-	udelay(1000);
-	au_writel(USBH_ENABLE_INIT, USB_HOST_CONFIG);
-	udelay(1000);
-
-#else   /* Au1200 */
-
-	/* write HW defaults again in case Yamon cleared them */
-	if (au_readl(USB_HOST_CONFIG) == 0) {
-		au_writel(0x00d02000, USB_HOST_CONFIG);
-		au_readl(USB_HOST_CONFIG);
-		udelay(1000);
-	}
-	au_writel(USBH_ENABLE_CE | au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
-	udelay(1000);
-	au_writel(USBH_ENABLE_INIT | au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
-	udelay(1000);
-
-#endif  /* Au1200 */
-
-#ifndef CONFIG_SOC_AU1200
-	/* wait for reset complete (read register twice; see au1500 errata) */
-	while (au_readl(USB_HOST_CONFIG),
-		!(au_readl(USB_HOST_CONFIG) & USBH_ENABLE_RD))
-#endif
-		udelay(1000);
-
-	printk(KERN_DEBUG __FILE__
-	": Clock to USB host has been enabled \n");
-}
-
-static void au1xxx_stop_ohc(struct platform_device *dev)
-{
-	printk(KERN_DEBUG __FILE__
-	       ": stopping Au1xxx OHCI USB Controller\n");
-
-#ifndef CONFIG_SOC_AU1200
-
-	/* Disable clock */
-	au_writel(au_readl(USB_HOST_CONFIG) & ~USBH_ENABLE_CE, USB_HOST_CONFIG);
-
-#else   /* Au1200 */
-
-	/* Disable mem */
-	au_writel(~USBH_DISABLE & au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
-	udelay(1000);
-	/* Disable clock */
-	au_writel(~USBH_ENABLE_CE & au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
-#endif  /* Au1200 */
-}
-
-
-/*-------------------------------------------------------------------------*/
-
-/* configure so an HC device and id are always provided */
-/* always called with process context; sleeping is OK */
-
-
-/**
- * usb_ohci_au1xxx_probe - initialize Au1xxx-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- *
- */
-static int usb_ohci_au1xxx_probe(const struct hc_driver *driver,
-			  struct platform_device *dev)
-{
-	int retval;
-	struct usb_hcd *hcd;
-
-#if defined(CONFIG_SOC_AU1200) && defined(CONFIG_DMA_COHERENT)
-	/* Au1200 AB USB does not support coherent memory */
-	if (!(read_c0_prid() & 0xff)) {
-		pr_info("%s: this is chip revision AB !!\n",
-			dev->name);
-		pr_info("%s: update your board or re-configure the kernel\n",
-			dev->name);
-		return -ENODEV;
-	}
-#endif
-
-	if (dev->resource[1].flags != IORESOURCE_IRQ) {
-		pr_debug("resource[1] is not IORESOURCE_IRQ\n");
-		return -ENOMEM;
-	}
-
-	hcd = usb_create_hcd(driver, &dev->dev, "au1xxx");
-	if (!hcd)
-		return -ENOMEM;
-	hcd->rsrc_start = dev->resource[0].start;
-	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		pr_debug("request_mem_region failed\n");
-		retval = -EBUSY;
-		goto err1;
-	}
-
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-	if (!hcd->regs) {
-		pr_debug("ioremap failed\n");
-		retval = -ENOMEM;
-		goto err2;
-	}
-
-	au1xxx_start_ohc(dev);
-	ohci_hcd_init(hcd_to_ohci(hcd));
-
-	retval = usb_add_hcd(hcd, dev->resource[1].start, IRQF_DISABLED | IRQF_SHARED);
-	if (retval == 0)
-		return retval;
-
-	au1xxx_stop_ohc(dev);
-	iounmap(hcd->regs);
- err2:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
- err1:
-	usb_put_hcd(hcd);
-	return retval;
-}
-
-
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_hcd_au1xxx_remove - shutdown processing for Au1xxx-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_hcd_au1xxx_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
- */
-static void usb_ohci_au1xxx_remove(struct usb_hcd *hcd, struct platform_device *dev)
-{
-	usb_remove_hcd(hcd);
-	au1xxx_stop_ohc(dev);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int __devinit
-ohci_au1xxx_start (struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ret;
-
-	ohci_dbg (ohci, "ohci_au1xxx_start, ohci:%p", ohci);
-
-	if ((ret = ohci_init (ohci)) < 0)
-		return ret;
-
-	if ((ret = ohci_run (ohci)) < 0) {
-		err ("can't start %s", hcd->self.bus_name);
-		ohci_stop (hcd);
-		return ret;
-	}
-
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static const struct hc_driver ohci_au1xxx_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"Au1xxx OHCI",
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ohci_irq,
-	.flags =		HCD_USB11 | HCD_MEMORY,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.start =		ohci_au1xxx_start,
-	.stop =			ohci_stop,
-	.shutdown =		ohci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ohci_urb_enqueue,
-	.urb_dequeue =		ohci_urb_dequeue,
-	.endpoint_disable =	ohci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ohci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ohci_hub_status_data,
-	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
-#ifdef	CONFIG_PM
-	.bus_suspend =		ohci_bus_suspend,
-	.bus_resume =		ohci_bus_resume,
-#endif
-	.start_port_reset =	ohci_start_port_reset,
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int ohci_hcd_au1xxx_drv_probe(struct platform_device *pdev)
-{
-	int ret;
-
-	pr_debug ("In ohci_hcd_au1xxx_drv_probe");
-
-	if (usb_disabled())
-		return -ENODEV;
-
-	ret = usb_ohci_au1xxx_probe(&ohci_au1xxx_hc_driver, pdev);
-	return ret;
-}
-
-static int ohci_hcd_au1xxx_drv_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	usb_ohci_au1xxx_remove(hcd, pdev);
-	return 0;
-}
-	/*TBD*/
-/*static int ohci_hcd_au1xxx_drv_suspend(struct platform_device *dev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(dev);
-
-	return 0;
-}
-static int ohci_hcd_au1xxx_drv_resume(struct platform_device *dev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(dev);
-
-	return 0;
-}
-*/
-
-static struct platform_driver ohci_hcd_au1xxx_driver = {
-	.probe		= ohci_hcd_au1xxx_drv_probe,
-	.remove		= ohci_hcd_au1xxx_drv_remove,
-	.shutdown	= usb_hcd_platform_shutdown,
-	/*.suspend	= ohci_hcd_au1xxx_drv_suspend, */
-	/*.resume	= ohci_hcd_au1xxx_drv_resume, */
-	.driver		= {
-		.name	= "au1xxx-ohci",
-		.owner	= THIS_MODULE,
-	},
-};
-
diff -urN host/.svn/text-base/ohci-dbg.c.svn-base host.new/.svn/text-base/ohci-dbg.c.svn-base
--- host/.svn/text-base/ohci-dbg.c.svn-base	2009-02-24 19:00:15.787950733 +0100
+++ host.new/.svn/text-base/ohci-dbg.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,708 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- *
- * This file is licenced under the GPL.
- */
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef DEBUG
-
-#define edstring(ed_type) ({ char *temp; \
-	switch (ed_type) { \
-	case PIPE_CONTROL:	temp = "ctrl"; break; \
-	case PIPE_BULK:		temp = "bulk"; break; \
-	case PIPE_INTERRUPT:	temp = "intr"; break; \
-	default:		temp = "isoc"; break; \
-	}; temp;})
-#define pipestring(pipe) edstring(usb_pipetype(pipe))
-
-/* debug| print the main components of an URB
- * small: 0) header + data packets 1) just header
- */
-static void __maybe_unused
-urb_print (struct urb * urb, char * str, int small)
-{
-	unsigned int pipe= urb->pipe;
-
-	if (!urb->dev || !urb->dev->bus) {
-		dbg("%s URB: no dev", str);
-		return;
-	}
-
-#ifndef	OHCI_VERBOSE_DEBUG
-	if (urb->status != 0)
-#endif
-	dbg("%s %p dev=%d ep=%d%s-%s flags=%x len=%d/%d stat=%d",
-		    str,
-		    urb,
-		    usb_pipedevice (pipe),
-		    usb_pipeendpoint (pipe),
-		    usb_pipeout (pipe)? "out" : "in",
-		    pipestring (pipe),
-		    urb->transfer_flags,
-		    urb->actual_length,
-		    urb->transfer_buffer_length,
-		    urb->status);
-
-#ifdef	OHCI_VERBOSE_DEBUG
-	if (!small) {
-		int i, len;
-
-		if (usb_pipecontrol (pipe)) {
-			printk (KERN_DEBUG __FILE__ ": setup(8):");
-			for (i = 0; i < 8 ; i++)
-				printk (" %02x", ((__u8 *) urb->setup_packet) [i]);
-			printk ("\n");
-		}
-		if (urb->transfer_buffer_length > 0 && urb->transfer_buffer) {
-			printk (KERN_DEBUG __FILE__ ": data(%d/%d):",
-				urb->actual_length,
-				urb->transfer_buffer_length);
-			len = usb_pipeout (pipe)?
-						urb->transfer_buffer_length: urb->actual_length;
-			for (i = 0; i < 16 && i < len; i++)
-				printk (" %02x", ((__u8 *) urb->transfer_buffer) [i]);
-			printk ("%s stat:%d\n", i < len? "...": "", urb->status);
-		}
-	}
-#endif
-}
-
-#define ohci_dbg_sw(ohci, next, size, format, arg...) \
-	do { \
-	if (next != NULL) { \
-		unsigned s_len; \
-		s_len = scnprintf (*next, *size, format, ## arg ); \
-		*size -= s_len; *next += s_len; \
-	} else \
-		ohci_dbg(ohci,format, ## arg ); \
-	} while (0);
-
-
-static void ohci_dump_intr_mask (
-	struct ohci_hcd *ohci,
-	char *label,
-	u32 mask,
-	char **next,
-	unsigned *size)
-{
-	ohci_dbg_sw (ohci, next, size, "%s 0x%08x%s%s%s%s%s%s%s%s%s\n",
-		label,
-		mask,
-		(mask & OHCI_INTR_MIE) ? " MIE" : "",
-		(mask & OHCI_INTR_OC) ? " OC" : "",
-		(mask & OHCI_INTR_RHSC) ? " RHSC" : "",
-		(mask & OHCI_INTR_FNO) ? " FNO" : "",
-		(mask & OHCI_INTR_UE) ? " UE" : "",
-		(mask & OHCI_INTR_RD) ? " RD" : "",
-		(mask & OHCI_INTR_SF) ? " SF" : "",
-		(mask & OHCI_INTR_WDH) ? " WDH" : "",
-		(mask & OHCI_INTR_SO) ? " SO" : ""
-		);
-}
-
-static void maybe_print_eds (
-	struct ohci_hcd *ohci,
-	char *label,
-	u32 value,
-	char **next,
-	unsigned *size)
-{
-	if (value)
-		ohci_dbg_sw (ohci, next, size, "%s %08x\n", label, value);
-}
-
-static char *hcfs2string (int state)
-{
-	switch (state) {
-		case OHCI_USB_RESET:	return "reset";
-		case OHCI_USB_RESUME:	return "resume";
-		case OHCI_USB_OPER:	return "operational";
-		case OHCI_USB_SUSPEND:	return "suspend";
-	}
-	return "?";
-}
-
-// dump control and status registers
-static void
-ohci_dump_status (struct ohci_hcd *controller, char **next, unsigned *size)
-{
-	struct ohci_regs __iomem *regs = controller->regs;
-	u32			temp;
-
-	temp = ohci_readl (controller, &regs->revision) & 0xff;
-	ohci_dbg_sw (controller, next, size,
-		"OHCI %d.%d, %s legacy support registers\n",
-		0x03 & (temp >> 4), (temp & 0x0f),
-		(temp & 0x0100) ? "with" : "NO");
-
-	temp = ohci_readl (controller, &regs->control);
-	ohci_dbg_sw (controller, next, size,
-		"control 0x%03x%s%s%s HCFS=%s%s%s%s%s CBSR=%d\n",
-		temp,
-		(temp & OHCI_CTRL_RWE) ? " RWE" : "",
-		(temp & OHCI_CTRL_RWC) ? " RWC" : "",
-		(temp & OHCI_CTRL_IR) ? " IR" : "",
-		hcfs2string (temp & OHCI_CTRL_HCFS),
-		(temp & OHCI_CTRL_BLE) ? " BLE" : "",
-		(temp & OHCI_CTRL_CLE) ? " CLE" : "",
-		(temp & OHCI_CTRL_IE) ? " IE" : "",
-		(temp & OHCI_CTRL_PLE) ? " PLE" : "",
-		temp & OHCI_CTRL_CBSR
-		);
-
-	temp = ohci_readl (controller, &regs->cmdstatus);
-	ohci_dbg_sw (controller, next, size,
-		"cmdstatus 0x%05x SOC=%d%s%s%s%s\n", temp,
-		(temp & OHCI_SOC) >> 16,
-		(temp & OHCI_OCR) ? " OCR" : "",
-		(temp & OHCI_BLF) ? " BLF" : "",
-		(temp & OHCI_CLF) ? " CLF" : "",
-		(temp & OHCI_HCR) ? " HCR" : ""
-		);
-
-	ohci_dump_intr_mask (controller, "intrstatus",
-			ohci_readl (controller, &regs->intrstatus),
-			next, size);
-	ohci_dump_intr_mask (controller, "intrenable",
-			ohci_readl (controller, &regs->intrenable),
-			next, size);
-	// intrdisable always same as intrenable
-
-	maybe_print_eds (controller, "ed_periodcurrent",
-			ohci_readl (controller, &regs->ed_periodcurrent),
-			next, size);
-
-	maybe_print_eds (controller, "ed_controlhead",
-			ohci_readl (controller, &regs->ed_controlhead),
-			next, size);
-	maybe_print_eds (controller, "ed_controlcurrent",
-			ohci_readl (controller, &regs->ed_controlcurrent),
-			next, size);
-
-	maybe_print_eds (controller, "ed_bulkhead",
-			ohci_readl (controller, &regs->ed_bulkhead),
-			next, size);
-	maybe_print_eds (controller, "ed_bulkcurrent",
-			ohci_readl (controller, &regs->ed_bulkcurrent),
-			next, size);
-
-	maybe_print_eds (controller, "donehead",
-			ohci_readl (controller, &regs->donehead), next, size);
-}
-
-#define dbg_port_sw(hc,num,value,next,size) \
-	ohci_dbg_sw (hc, next, size, \
-		"roothub.portstatus [%d] " \
-		"0x%08x%s%s%s%s%s%s%s%s%s%s%s%s\n", \
-		num, temp, \
-		(temp & RH_PS_PRSC) ? " PRSC" : "", \
-		(temp & RH_PS_OCIC) ? " OCIC" : "", \
-		(temp & RH_PS_PSSC) ? " PSSC" : "", \
-		(temp & RH_PS_PESC) ? " PESC" : "", \
-		(temp & RH_PS_CSC) ? " CSC" : "", \
-		\
-		(temp & RH_PS_LSDA) ? " LSDA" : "", \
-		(temp & RH_PS_PPS) ? " PPS" : "", \
-		(temp & RH_PS_PRS) ? " PRS" : "", \
-		(temp & RH_PS_POCI) ? " POCI" : "", \
-		(temp & RH_PS_PSS) ? " PSS" : "", \
-		\
-		(temp & RH_PS_PES) ? " PES" : "", \
-		(temp & RH_PS_CCS) ? " CCS" : "" \
-		);
-
-
-static void
-ohci_dump_roothub (
-	struct ohci_hcd *controller,
-	int verbose,
-	char **next,
-	unsigned *size)
-{
-	u32			temp, i;
-
-	temp = roothub_a (controller);
-	if (temp == ~(u32)0)
-		return;
-
-	if (verbose) {
-		ohci_dbg_sw (controller, next, size,
-			"roothub.a %08x POTPGT=%d%s%s%s%s%s NDP=%d(%d)\n", temp,
-			((temp & RH_A_POTPGT) >> 24) & 0xff,
-			(temp & RH_A_NOCP) ? " NOCP" : "",
-			(temp & RH_A_OCPM) ? " OCPM" : "",
-			(temp & RH_A_DT) ? " DT" : "",
-			(temp & RH_A_NPS) ? " NPS" : "",
-			(temp & RH_A_PSM) ? " PSM" : "",
-			(temp & RH_A_NDP), controller->num_ports
-			);
-		temp = roothub_b (controller);
-		ohci_dbg_sw (controller, next, size,
-			"roothub.b %08x PPCM=%04x DR=%04x\n",
-			temp,
-			(temp & RH_B_PPCM) >> 16,
-			(temp & RH_B_DR)
-			);
-		temp = roothub_status (controller);
-		ohci_dbg_sw (controller, next, size,
-			"roothub.status %08x%s%s%s%s%s%s\n",
-			temp,
-			(temp & RH_HS_CRWE) ? " CRWE" : "",
-			(temp & RH_HS_OCIC) ? " OCIC" : "",
-			(temp & RH_HS_LPSC) ? " LPSC" : "",
-			(temp & RH_HS_DRWE) ? " DRWE" : "",
-			(temp & RH_HS_OCI) ? " OCI" : "",
-			(temp & RH_HS_LPS) ? " LPS" : ""
-			);
-	}
-
-	for (i = 0; i < controller->num_ports; i++) {
-		temp = roothub_portstatus (controller, i);
-		dbg_port_sw (controller, i, temp, next, size);
-	}
-}
-
-static void ohci_dump (struct ohci_hcd *controller, int verbose)
-{
-	ohci_dbg (controller, "OHCI controller state\n");
-
-	// dumps some of the state we know about
-	ohci_dump_status (controller, NULL, NULL);
-	if (controller->hcca)
-		ohci_dbg (controller,
-			"hcca frame #%04x\n", ohci_frame_no(controller));
-	ohci_dump_roothub (controller, 1, NULL, NULL);
-}
-
-static const char data0 [] = "DATA0";
-static const char data1 [] = "DATA1";
-
-static void ohci_dump_td (const struct ohci_hcd *ohci, const char *label,
-		const struct td *td)
-{
-	u32	tmp = hc32_to_cpup (ohci, &td->hwINFO);
-
-	ohci_dbg (ohci, "%s td %p%s; urb %p index %d; hw next td %08x\n",
-		label, td,
-		(tmp & TD_DONE) ? " (DONE)" : "",
-		td->urb, td->index,
-		hc32_to_cpup (ohci, &td->hwNextTD));
-	if ((tmp & TD_ISO) == 0) {
-		const char	*toggle, *pid;
-		u32	cbp, be;
-
-		switch (tmp & TD_T) {
-		case TD_T_DATA0: toggle = data0; break;
-		case TD_T_DATA1: toggle = data1; break;
-		case TD_T_TOGGLE: toggle = "(CARRY)"; break;
-		default: toggle = "(?)"; break;
-		}
-		switch (tmp & TD_DP) {
-		case TD_DP_SETUP: pid = "SETUP"; break;
-		case TD_DP_IN: pid = "IN"; break;
-		case TD_DP_OUT: pid = "OUT"; break;
-		default: pid = "(bad pid)"; break;
-		}
-		ohci_dbg (ohci, "     info %08x CC=%x %s DI=%d %s %s\n", tmp,
-			TD_CC_GET(tmp), /* EC, */ toggle,
-			(tmp & TD_DI) >> 21, pid,
-			(tmp & TD_R) ? "R" : "");
-		cbp = hc32_to_cpup (ohci, &td->hwCBP);
-		be = hc32_to_cpup (ohci, &td->hwBE);
-		ohci_dbg (ohci, "     cbp %08x be %08x (len %d)\n", cbp, be,
-			cbp ? (be + 1 - cbp) : 0);
-	} else {
-		unsigned	i;
-		ohci_dbg (ohci, "  info %08x CC=%x FC=%d DI=%d SF=%04x\n", tmp,
-			TD_CC_GET(tmp),
-			(tmp >> 24) & 0x07,
-			(tmp & TD_DI) >> 21,
-			tmp & 0x0000ffff);
-		ohci_dbg (ohci, "  bp0 %08x be %08x\n",
-			hc32_to_cpup (ohci, &td->hwCBP) & ~0x0fff,
-			hc32_to_cpup (ohci, &td->hwBE));
-		for (i = 0; i < MAXPSW; i++) {
-			u16	psw = ohci_hwPSW (ohci, td, i);
-			int	cc = (psw >> 12) & 0x0f;
-			ohci_dbg (ohci, "    psw [%d] = %2x, CC=%x %s=%d\n", i,
-				psw, cc,
-				(cc >= 0x0e) ? "OFFSET" : "SIZE",
-				psw & 0x0fff);
-		}
-	}
-}
-
-/* caller MUST own hcd spinlock if verbose is set! */
-static void __maybe_unused
-ohci_dump_ed (const struct ohci_hcd *ohci, const char *label,
-		const struct ed *ed, int verbose)
-{
-	u32	tmp = hc32_to_cpu (ohci, ed->hwINFO);
-	char	*type = "";
-
-	ohci_dbg (ohci, "%s, ed %p state 0x%x type %s; next ed %08x\n",
-		label,
-		ed, ed->state, edstring (ed->type),
-		hc32_to_cpup (ohci, &ed->hwNextED));
-	switch (tmp & (ED_IN|ED_OUT)) {
-	case ED_OUT: type = "-OUT"; break;
-	case ED_IN: type = "-IN"; break;
-	/* else from TDs ... control */
-	}
-	ohci_dbg (ohci,
-		"  info %08x MAX=%d%s%s%s%s EP=%d%s DEV=%d\n", tmp,
-		0x03ff & (tmp >> 16),
-		(tmp & ED_DEQUEUE) ? " DQ" : "",
-		(tmp & ED_ISO) ? " ISO" : "",
-		(tmp & ED_SKIP) ? " SKIP" : "",
-		(tmp & ED_LOWSPEED) ? " LOW" : "",
-		0x000f & (tmp >> 7),
-		type,
-		0x007f & tmp);
-	tmp = hc32_to_cpup (ohci, &ed->hwHeadP);
-	ohci_dbg (ohci, "  tds: head %08x %s%s tail %08x%s\n",
-		tmp,
-		(tmp & ED_C) ? data1 : data0,
-		(tmp & ED_H) ? " HALT" : "",
-		hc32_to_cpup (ohci, &ed->hwTailP),
-		verbose ? "" : " (not listing)");
-	if (verbose) {
-		struct list_head	*tmp;
-
-		/* use ed->td_list because HC concurrently modifies
-		 * hwNextTD as it accumulates ed_donelist.
-		 */
-		list_for_each (tmp, &ed->td_list) {
-			struct td		*td;
-			td = list_entry (tmp, struct td, td_list);
-			ohci_dump_td (ohci, "  ->", td);
-		}
-	}
-}
-
-#else
-static inline void ohci_dump (struct ohci_hcd *controller, int verbose) {}
-
-#undef OHCI_VERBOSE_DEBUG
-
-#endif /* DEBUG */
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef STUB_DEBUG_FILES
-
-static inline void create_debug_files (struct ohci_hcd *bus) { }
-static inline void remove_debug_files (struct ohci_hcd *bus) { }
-
-#else
-
-static ssize_t
-show_list (struct ohci_hcd *ohci, char *buf, size_t count, struct ed *ed)
-{
-	unsigned		temp, size = count;
-
-	if (!ed)
-		return 0;
-
-	/* print first --> last */
-	while (ed->ed_prev)
-		ed = ed->ed_prev;
-
-	/* dump a snapshot of the bulk or control schedule */
-	while (ed) {
-		u32		info = hc32_to_cpu (ohci, ed->hwINFO);
-		u32		headp = hc32_to_cpu (ohci, ed->hwHeadP);
-		struct list_head *entry;
-		struct td	*td;
-
-		temp = scnprintf (buf, size,
-			"ed/%p %cs dev%d ep%d%s max %d %08x%s%s %s",
-			ed,
-			(info & ED_LOWSPEED) ? 'l' : 'f',
-			info & 0x7f,
-			(info >> 7) & 0xf,
-			(info & ED_IN) ? "in" : "out",
-			0x03ff & (info >> 16),
-			info,
-			(info & ED_SKIP) ? " s" : "",
-			(headp & ED_H) ? " H" : "",
-			(headp & ED_C) ? data1 : data0);
-		size -= temp;
-		buf += temp;
-
-		list_for_each (entry, &ed->td_list) {
-			u32		cbp, be;
-
-			td = list_entry (entry, struct td, td_list);
-			info = hc32_to_cpup (ohci, &td->hwINFO);
-			cbp = hc32_to_cpup (ohci, &td->hwCBP);
-			be = hc32_to_cpup (ohci, &td->hwBE);
-			temp = scnprintf (buf, size,
-					"\n\ttd %p %s %d cc=%x urb %p (%08x)",
-					td,
-					({ char *pid;
-					switch (info & TD_DP) {
-					case TD_DP_SETUP: pid = "setup"; break;
-					case TD_DP_IN: pid = "in"; break;
-					case TD_DP_OUT: pid = "out"; break;
-					default: pid = "(?)"; break;
-					 } pid;}),
-					cbp ? (be + 1 - cbp) : 0,
-					TD_CC_GET (info), td->urb, info);
-			size -= temp;
-			buf += temp;
-		}
-
-		temp = scnprintf (buf, size, "\n");
-		size -= temp;
-		buf += temp;
-
-		ed = ed->ed_next;
-	}
-	return count - size;
-}
-
-static ssize_t
-show_async (struct class_device *class_dev, char *buf)
-{
-	struct usb_bus		*bus;
-	struct usb_hcd		*hcd;
-	struct ohci_hcd		*ohci;
-	size_t			temp;
-	unsigned long		flags;
-
-	bus = class_get_devdata(class_dev);
-	hcd = bus_to_hcd(bus);
-	ohci = hcd_to_ohci(hcd);
-
-	/* display control and bulk lists together, for simplicity */
-	spin_lock_irqsave (&ohci->lock, flags);
-	temp = show_list (ohci, buf, PAGE_SIZE, ohci->ed_controltail);
-	temp += show_list (ohci, buf + temp, PAGE_SIZE - temp, ohci->ed_bulktail);
-	spin_unlock_irqrestore (&ohci->lock, flags);
-
-	return temp;
-}
-static CLASS_DEVICE_ATTR (async, S_IRUGO, show_async, NULL);
-
-
-#define DBG_SCHED_LIMIT 64
-
-static ssize_t
-show_periodic (struct class_device *class_dev, char *buf)
-{
-	struct usb_bus		*bus;
-	struct usb_hcd		*hcd;
-	struct ohci_hcd		*ohci;
-	struct ed		**seen, *ed;
-	unsigned long		flags;
-	unsigned		temp, size, seen_count;
-	char			*next;
-	unsigned		i;
-
-	if (!(seen = kmalloc (DBG_SCHED_LIMIT * sizeof *seen, GFP_ATOMIC)))
-		return 0;
-	seen_count = 0;
-
-	bus = class_get_devdata(class_dev);
-	hcd = bus_to_hcd(bus);
-	ohci = hcd_to_ohci(hcd);
-	next = buf;
-	size = PAGE_SIZE;
-
-	temp = scnprintf (next, size, "size = %d\n", NUM_INTS);
-	size -= temp;
-	next += temp;
-
-	/* dump a snapshot of the periodic schedule (and load) */
-	spin_lock_irqsave (&ohci->lock, flags);
-	for (i = 0; i < NUM_INTS; i++) {
-		if (!(ed = ohci->periodic [i]))
-			continue;
-
-		temp = scnprintf (next, size, "%2d [%3d]:", i, ohci->load [i]);
-		size -= temp;
-		next += temp;
-
-		do {
-			temp = scnprintf (next, size, " ed%d/%p",
-				ed->interval, ed);
-			size -= temp;
-			next += temp;
-			for (temp = 0; temp < seen_count; temp++) {
-				if (seen [temp] == ed)
-					break;
-			}
-
-			/* show more info the first time around */
-			if (temp == seen_count) {
-				u32	info = hc32_to_cpu (ohci, ed->hwINFO);
-				struct list_head	*entry;
-				unsigned		qlen = 0;
-
-				/* qlen measured here in TDs, not urbs */
-				list_for_each (entry, &ed->td_list)
-					qlen++;
-
-				temp = scnprintf (next, size,
-					" (%cs dev%d ep%d%s-%s qlen %u"
-					" max %d %08x%s%s)",
-					(info & ED_LOWSPEED) ? 'l' : 'f',
-					info & 0x7f,
-					(info >> 7) & 0xf,
-					(info & ED_IN) ? "in" : "out",
-					(info & ED_ISO) ? "iso" : "int",
-					qlen,
-					0x03ff & (info >> 16),
-					info,
-					(info & ED_SKIP) ? " K" : "",
-					(ed->hwHeadP &
-						cpu_to_hc32(ohci, ED_H)) ?
-							" H" : "");
-				size -= temp;
-				next += temp;
-
-				if (seen_count < DBG_SCHED_LIMIT)
-					seen [seen_count++] = ed;
-
-				ed = ed->ed_next;
-
-			} else {
-				/* we've seen it and what's after */
-				temp = 0;
-				ed = NULL;
-			}
-
-		} while (ed);
-
-		temp = scnprintf (next, size, "\n");
-		size -= temp;
-		next += temp;
-	}
-	spin_unlock_irqrestore (&ohci->lock, flags);
-	kfree (seen);
-
-	return PAGE_SIZE - size;
-}
-static CLASS_DEVICE_ATTR (periodic, S_IRUGO, show_periodic, NULL);
-
-
-#undef DBG_SCHED_LIMIT
-
-static ssize_t
-show_registers (struct class_device *class_dev, char *buf)
-{
-	struct usb_bus		*bus;
-	struct usb_hcd		*hcd;
-	struct ohci_hcd		*ohci;
-	struct ohci_regs __iomem *regs;
-	unsigned long		flags;
-	unsigned		temp, size;
-	char			*next;
-	u32			rdata;
-
-	bus = class_get_devdata(class_dev);
-	hcd = bus_to_hcd(bus);
-	ohci = hcd_to_ohci(hcd);
-	regs = ohci->regs;
-	next = buf;
-	size = PAGE_SIZE;
-
-	spin_lock_irqsave (&ohci->lock, flags);
-
-	/* dump driver info, then registers in spec order */
-
-	ohci_dbg_sw (ohci, &next, &size,
-		"bus %s, device %s\n"
-		"%s\n"
-		"%s version " DRIVER_VERSION "\n",
-		hcd->self.controller->bus->name,
-		hcd->self.controller->bus_id,
-		hcd->product_desc,
-		hcd_name);
-
-	if (bus->controller->power.power_state.event) {
-		size -= scnprintf (next, size,
-			"SUSPENDED (no register access)\n");
-		goto done;
-	}
-
-	ohci_dump_status(ohci, &next, &size);
-
-	/* hcca */
-	if (ohci->hcca)
-		ohci_dbg_sw (ohci, &next, &size,
-			"hcca frame 0x%04x\n", ohci_frame_no(ohci));
-
-	/* other registers mostly affect frame timings */
-	rdata = ohci_readl (ohci, &regs->fminterval);
-	temp = scnprintf (next, size,
-			"fmintvl 0x%08x %sFSMPS=0x%04x FI=0x%04x\n",
-			rdata, (rdata >> 31) ? "FIT " : "",
-			(rdata >> 16) & 0xefff, rdata & 0xffff);
-	size -= temp;
-	next += temp;
-
-	rdata = ohci_readl (ohci, &regs->fmremaining);
-	temp = scnprintf (next, size, "fmremaining 0x%08x %sFR=0x%04x\n",
-			rdata, (rdata >> 31) ? "FRT " : "",
-			rdata & 0x3fff);
-	size -= temp;
-	next += temp;
-
-	rdata = ohci_readl (ohci, &regs->periodicstart);
-	temp = scnprintf (next, size, "periodicstart 0x%04x\n",
-			rdata & 0x3fff);
-	size -= temp;
-	next += temp;
-
-	rdata = ohci_readl (ohci, &regs->lsthresh);
-	temp = scnprintf (next, size, "lsthresh 0x%04x\n",
-			rdata & 0x3fff);
-	size -= temp;
-	next += temp;
-
-	temp = scnprintf (next, size, "hub poll timer %s\n",
-			ohci_to_hcd(ohci)->poll_rh ? "ON" : "off");
-	size -= temp;
-	next += temp;
-
-	/* roothub */
-	ohci_dump_roothub (ohci, 1, &next, &size);
-
-done:
-	spin_unlock_irqrestore (&ohci->lock, flags);
-	return PAGE_SIZE - size;
-}
-static CLASS_DEVICE_ATTR (registers, S_IRUGO, show_registers, NULL);
-
-
-static inline void create_debug_files (struct ohci_hcd *ohci)
-{
-	struct class_device *cldev = ohci_to_hcd(ohci)->self.class_dev;
-	int retval;
-
-	retval = class_device_create_file(cldev, &class_device_attr_async);
-	retval = class_device_create_file(cldev, &class_device_attr_periodic);
-	retval = class_device_create_file(cldev, &class_device_attr_registers);
-	ohci_dbg (ohci, "created debug files\n");
-}
-
-static inline void remove_debug_files (struct ohci_hcd *ohci)
-{
-	struct class_device *cldev = ohci_to_hcd(ohci)->self.class_dev;
-
-	class_device_remove_file(cldev, &class_device_attr_async);
-	class_device_remove_file(cldev, &class_device_attr_periodic);
-	class_device_remove_file(cldev, &class_device_attr_registers);
-}
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
diff -urN host/.svn/text-base/ohci-ep93xx.c.svn-base host.new/.svn/text-base/ohci-ep93xx.c.svn-base
--- host/.svn/text-base/ohci-ep93xx.c.svn-base	2009-02-24 19:00:15.787950733 +0100
+++ host.new/.svn/text-base/ohci-ep93xx.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,216 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- * (C) Copyright 2002 Hewlett-Packard Company
- *
- * Bus Glue for ep93xx.
- *
- * Written by Christopher Hoover <ch@hpl.hp.com>
- * Based on fragments of previous driver by Russell King et al.
- *
- * Modified for LH7A404 from ohci-sa1111.c
- *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
- *
- * Modified for pxa27x from ohci-lh7a404.c
- *  by Nick Bane <nick@cecomputing.co.uk> 26-8-2004
- *
- * Modified for ep93xx from ohci-pxa27x.c
- *  by Lennert Buytenhek <buytenh@wantstofly.org> 28-2-2006
- *  Based on an earlier driver by Ray Lehtiniemi
- *
- * This file is licenced under the GPL.
- */
-
-#include <linux/clk.h>
-#include <linux/device.h>
-#include <linux/signal.h>
-#include <linux/platform_device.h>
-
-#include <asm/mach-types.h>
-#include <asm/hardware.h>
-
-static struct clk *usb_host_clock;
-
-static void ep93xx_start_hc(struct device *dev)
-{
-	clk_enable(usb_host_clock);
-}
-
-static void ep93xx_stop_hc(struct device *dev)
-{
-	clk_disable(usb_host_clock);
-}
-
-static int usb_hcd_ep93xx_probe(const struct hc_driver *driver,
-			 struct platform_device *pdev)
-{
-	int retval;
-	struct usb_hcd *hcd;
-
-	if (pdev->resource[1].flags != IORESOURCE_IRQ) {
-		pr_debug("resource[1] is not IORESOURCE_IRQ");
-		return -ENOMEM;
-	}
-
-	hcd = usb_create_hcd(driver, &pdev->dev, "ep93xx");
-	if (hcd == NULL)
-		return -ENOMEM;
-
-	hcd->rsrc_start = pdev->resource[0].start;
-	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		usb_put_hcd(hcd);
-		retval = -EBUSY;
-		goto err1;
-	}
-
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-	if (hcd->regs == NULL) {
-		pr_debug("ioremap failed");
-		retval = -ENOMEM;
-		goto err2;
-	}
-
-	usb_host_clock = clk_get(&pdev->dev, "usb_host");
-	ep93xx_start_hc(&pdev->dev);
-
-	ohci_hcd_init(hcd_to_ohci(hcd));
-
-	retval = usb_add_hcd(hcd, pdev->resource[1].start, IRQF_DISABLED);
-	if (retval == 0)
-		return retval;
-
-	ep93xx_stop_hc(&pdev->dev);
-	iounmap(hcd->regs);
-err2:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-err1:
-	usb_put_hcd(hcd);
-
-	return retval;
-}
-
-static void usb_hcd_ep93xx_remove(struct usb_hcd *hcd,
-			struct platform_device *pdev)
-{
-	usb_remove_hcd(hcd);
-	ep93xx_stop_hc(&pdev->dev);
-	clk_put(usb_host_clock);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-}
-
-static int __devinit ohci_ep93xx_start(struct usb_hcd *hcd)
-{
-	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
-	int ret;
-
-	if ((ret = ohci_init(ohci)) < 0)
-		return ret;
-
-	if ((ret = ohci_run(ohci)) < 0) {
-		err("can't start %s", hcd->self.bus_name);
-		ohci_stop(hcd);
-		return ret;
-	}
-
-	return 0;
-}
-
-static struct hc_driver ohci_ep93xx_hc_driver = {
-	.description		= hcd_name,
-	.product_desc		= "EP93xx OHCI",
-	.hcd_priv_size		= sizeof(struct ohci_hcd),
-	.irq			= ohci_irq,
-	.flags			= HCD_USB11 | HCD_MEMORY,
-	.start			= ohci_ep93xx_start,
-	.stop			= ohci_stop,
-	.shutdown		= ohci_shutdown,
-	.urb_enqueue		= ohci_urb_enqueue,
-	.urb_dequeue		= ohci_urb_dequeue,
-	.endpoint_disable	= ohci_endpoint_disable,
-	.get_frame_number	= ohci_get_frame,
-	.hub_status_data	= ohci_hub_status_data,
-	.hub_control		= ohci_hub_control,
-	.hub_irq_enable		= ohci_rhsc_enable,
-#ifdef CONFIG_PM
-	.bus_suspend		= ohci_bus_suspend,
-	.bus_resume		= ohci_bus_resume,
-#endif
-	.start_port_reset	= ohci_start_port_reset,
-};
-
-extern int usb_disabled(void);
-
-static int ohci_hcd_ep93xx_drv_probe(struct platform_device *pdev)
-{
-	int ret;
-
-	ret = -ENODEV;
-	if (!usb_disabled())
-		ret = usb_hcd_ep93xx_probe(&ohci_ep93xx_hc_driver, pdev);
-
-	return ret;
-}
-
-static int ohci_hcd_ep93xx_drv_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	usb_hcd_ep93xx_remove(hcd, pdev);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int ohci_hcd_ep93xx_drv_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
-
-	if (time_before(jiffies, ohci->next_statechange))
-		msleep(5);
-	ohci->next_statechange = jiffies;
-
-	ep93xx_stop_hc(&pdev->dev);
-	hcd->state = HC_STATE_SUSPENDED;
-	pdev->dev.power.power_state = PMSG_SUSPEND;
-
-	return 0;
-}
-
-static int ohci_hcd_ep93xx_drv_resume(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
-	int status;
-
-	if (time_before(jiffies, ohci->next_statechange))
-		msleep(5);
-	ohci->next_statechange = jiffies;
-
-	ep93xx_start_hc(&pdev->dev);
-	pdev->dev.power.power_state = PMSG_ON;
-	usb_hcd_resume_root_hub(hcd);
-
-	return 0;
-}
-#endif
-
-
-static struct platform_driver ohci_hcd_ep93xx_driver = {
-	.probe		= ohci_hcd_ep93xx_drv_probe,
-	.remove		= ohci_hcd_ep93xx_drv_remove,
-	.shutdown	= usb_hcd_platform_shutdown,
-#ifdef CONFIG_PM
-	.suspend	= ohci_hcd_ep93xx_drv_suspend,
-	.resume		= ohci_hcd_ep93xx_drv_resume,
-#endif
-	.driver		= {
-		.name	= "ep93xx-ohci",
-	},
-};
-
diff -urN host/.svn/text-base/ohci-hcd.c.svn-base host.new/.svn/text-base/ohci-hcd.c.svn-base
--- host/.svn/text-base/ohci-hcd.c.svn-base	2009-02-24 19:00:15.791950530 +0100
+++ host.new/.svn/text-base/ohci-hcd.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,1023 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2004 David Brownell <dbrownell@users.sourceforge.net>
- *
- * [ Initialisation is based on Linus'  ]
- * [ uhci code and gregs ohci fragments ]
- * [ (C) Copyright 1999 Linus Torvalds  ]
- * [ (C) Copyright 1999 Gregory P. Smith]
- *
- *
- * OHCI is the main "non-Intel/VIA" standard for USB 1.1 host controller
- * interfaces (though some non-x86 Intel chips use it).  It supports
- * smarter hardware than UHCI.  A download link for the spec available
- * through the http://www.usb.org website.
- *
- * This file is licenced under the GPL.
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/pci.h>
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/ioport.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/timer.h>
-#include <linux/list.h>
-#include <linux/usb.h>
-#include <linux/usb/otg.h>
-#include <linux/dma-mapping.h>
-#include <linux/dmapool.h>
-#include <linux/reboot.h>
-#include <linux/workqueue.h>
-
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/system.h>
-#include <asm/unaligned.h>
-#include <asm/byteorder.h>
-
-#include "../core/hcd.h"
-
-#define DRIVER_VERSION "2006 August 04"
-#define DRIVER_AUTHOR "Roman Weissgaerber, David Brownell"
-#define DRIVER_DESC "USB 1.1 'Open' Host Controller (OHCI) Driver"
-
-/*-------------------------------------------------------------------------*/
-
-#undef OHCI_VERBOSE_DEBUG	/* not always helpful */
-
-/* For initializing controller (mask in an HCFS mode too) */
-#define	OHCI_CONTROL_INIT	OHCI_CTRL_CBSR
-#define	OHCI_INTR_INIT \
-		(OHCI_INTR_MIE | OHCI_INTR_RHSC | OHCI_INTR_UE \
-		| OHCI_INTR_RD | OHCI_INTR_WDH)
-
-#ifdef __hppa__
-/* On PA-RISC, PDC can leave IR set incorrectly; ignore it there. */
-#define	IR_DISABLE
-#endif
-
-#ifdef CONFIG_ARCH_OMAP
-/* OMAP doesn't support IR (no SMM; not needed) */
-#define	IR_DISABLE
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-static const char	hcd_name [] = "ohci_hcd";
-
-#define	STATECHANGE_DELAY	msecs_to_jiffies(300)
-
-#include "ohci.h"
-
-static void ohci_dump (struct ohci_hcd *ohci, int verbose);
-static int ohci_init (struct ohci_hcd *ohci);
-static void ohci_stop (struct usb_hcd *hcd);
-static int ohci_restart (struct ohci_hcd *ohci);
-static void ohci_quirk_nec_worker (struct work_struct *work);
-
-#include "ohci-hub.c"
-#include "ohci-dbg.c"
-#include "ohci-mem.c"
-#include "ohci-q.c"
-
-
-/*
- * On architectures with edge-triggered interrupts we must never return
- * IRQ_NONE.
- */
-#if defined(CONFIG_SA1111)  /* ... or other edge-triggered systems */
-#define IRQ_NOTMINE	IRQ_HANDLED
-#else
-#define IRQ_NOTMINE	IRQ_NONE
-#endif
-
-
-/* Some boards misreport power switching/overcurrent */
-static int distrust_firmware = 1;
-module_param (distrust_firmware, bool, 0);
-MODULE_PARM_DESC (distrust_firmware,
-	"true to distrust firmware power/overcurrent setup");
-
-/* Some boards leave IR set wrongly, since they fail BIOS/SMM handshakes */
-static int no_handshake = 0;
-module_param (no_handshake, bool, 0);
-MODULE_PARM_DESC (no_handshake, "true (not default) disables BIOS handshake");
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * queue up an urb for anything except the root hub
- */
-static int ohci_urb_enqueue (
-	struct usb_hcd	*hcd,
-	struct usb_host_endpoint *ep,
-	struct urb	*urb,
-	gfp_t		mem_flags
-) {
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	struct ed	*ed;
-	urb_priv_t	*urb_priv;
-	unsigned int	pipe = urb->pipe;
-	int		i, size = 0;
-	unsigned long	flags;
-	int		retval = 0;
-
-#ifdef OHCI_VERBOSE_DEBUG
-	urb_print (urb, "SUB", usb_pipein (pipe));
-#endif
-
-	/* every endpoint has a ed, locate and maybe (re)initialize it */
-	if (! (ed = ed_get (ohci, ep, urb->dev, pipe, urb->interval)))
-		return -ENOMEM;
-
-	/* for the private part of the URB we need the number of TDs (size) */
-	switch (ed->type) {
-		case PIPE_CONTROL:
-			/* td_submit_urb() doesn't yet handle these */
-			if (urb->transfer_buffer_length > 4096)
-				return -EMSGSIZE;
-
-			/* 1 TD for setup, 1 for ACK, plus ... */
-			size = 2;
-			/* FALLTHROUGH */
-		// case PIPE_INTERRUPT:
-		// case PIPE_BULK:
-		default:
-			/* one TD for every 4096 Bytes (can be upto 8K) */
-			size += urb->transfer_buffer_length / 4096;
-			/* ... and for any remaining bytes ... */
-			if ((urb->transfer_buffer_length % 4096) != 0)
-				size++;
-			/* ... and maybe a zero length packet to wrap it up */
-			if (size == 0)
-				size++;
-			else if ((urb->transfer_flags & URB_ZERO_PACKET) != 0
-				&& (urb->transfer_buffer_length
-					% usb_maxpacket (urb->dev, pipe,
-						usb_pipeout (pipe))) == 0)
-				size++;
-			break;
-		case PIPE_ISOCHRONOUS: /* number of packets from URB */
-			size = urb->number_of_packets;
-			break;
-	}
-
-	/* allocate the private part of the URB */
-	urb_priv = kzalloc (sizeof (urb_priv_t) + size * sizeof (struct td *),
-			mem_flags);
-	if (!urb_priv)
-		return -ENOMEM;
-	INIT_LIST_HEAD (&urb_priv->pending);
-	urb_priv->length = size;
-	urb_priv->ed = ed;
-
-	/* allocate the TDs (deferring hash chain updates) */
-	for (i = 0; i < size; i++) {
-		urb_priv->td [i] = td_alloc (ohci, mem_flags);
-		if (!urb_priv->td [i]) {
-			urb_priv->length = i;
-			urb_free_priv (ohci, urb_priv);
-			return -ENOMEM;
-		}
-	}
-
-	spin_lock_irqsave (&ohci->lock, flags);
-
-	/* don't submit to a dead HC */
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {
-		retval = -ENODEV;
-		goto fail;
-	}
-	if (!HC_IS_RUNNING(hcd->state)) {
-		retval = -ENODEV;
-		goto fail;
-	}
-
-	/* in case of unlink-during-submit */
-	spin_lock (&urb->lock);
-	if (urb->status != -EINPROGRESS) {
-		spin_unlock (&urb->lock);
-		urb->hcpriv = urb_priv;
-		finish_urb (ohci, urb);
-		retval = 0;
-		goto fail;
-	}
-
-	/* schedule the ed if needed */
-	if (ed->state == ED_IDLE) {
-		retval = ed_schedule (ohci, ed);
-		if (retval < 0)
-			goto fail0;
-		if (ed->type == PIPE_ISOCHRONOUS) {
-			u16	frame = ohci_frame_no(ohci);
-
-			/* delay a few frames before the first TD */
-			frame += max_t (u16, 8, ed->interval);
-			frame &= ~(ed->interval - 1);
-			frame |= ed->branch;
-			urb->start_frame = frame;
-
-			/* yes, only URB_ISO_ASAP is supported, and
-			 * urb->start_frame is never used as input.
-			 */
-		}
-	} else if (ed->type == PIPE_ISOCHRONOUS)
-		urb->start_frame = ed->last_iso + ed->interval;
-
-	/* fill the TDs and link them to the ed; and
-	 * enable that part of the schedule, if needed
-	 * and update count of queued periodic urbs
-	 */
-	urb->hcpriv = urb_priv;
-	td_submit_urb (ohci, urb);
-
-fail0:
-	spin_unlock (&urb->lock);
-fail:
-	if (retval)
-		urb_free_priv (ohci, urb_priv);
-	spin_unlock_irqrestore (&ohci->lock, flags);
-	return retval;
-}
-
-/*
- * decouple the URB from the HC queues (TDs, urb_priv); it's
- * already marked using urb->status.  reporting is always done
- * asynchronously, and we might be dealing with an urb that's
- * partially transferred, or an ED with other urbs being unlinked.
- */
-static int ohci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
-{
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-	unsigned long		flags;
-
-#ifdef OHCI_VERBOSE_DEBUG
-	urb_print (urb, "UNLINK", 1);
-#endif
-
-	spin_lock_irqsave (&ohci->lock, flags);
-	if (HC_IS_RUNNING(hcd->state)) {
-		urb_priv_t  *urb_priv;
-
-		/* Unless an IRQ completed the unlink while it was being
-		 * handed to us, flag it for unlink and giveback, and force
-		 * some upcoming INTR_SF to call finish_unlinks()
-		 */
-		urb_priv = urb->hcpriv;
-		if (urb_priv) {
-			if (urb_priv->ed->state == ED_OPER)
-				start_ed_unlink (ohci, urb_priv->ed);
-		}
-	} else {
-		/*
-		 * with HC dead, we won't respect hc queue pointers
-		 * any more ... just clean up every urb's memory.
-		 */
-		if (urb->hcpriv)
-			finish_urb (ohci, urb);
-	}
-	spin_unlock_irqrestore (&ohci->lock, flags);
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* frees config/altsetting state for endpoints,
- * including ED memory, dummy TD, and bulk/intr data toggle
- */
-
-static void
-ohci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
-{
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-	unsigned long		flags;
-	struct ed		*ed = ep->hcpriv;
-	unsigned		limit = 1000;
-
-	/* ASSERT:  any requests/urbs are being unlinked */
-	/* ASSERT:  nobody can be submitting urbs for this any more */
-
-	if (!ed)
-		return;
-
-rescan:
-	spin_lock_irqsave (&ohci->lock, flags);
-
-	if (!HC_IS_RUNNING (hcd->state)) {
-sanitize:
-		ed->state = ED_IDLE;
-		finish_unlinks (ohci, 0);
-	}
-
-	switch (ed->state) {
-	case ED_UNLINK:		/* wait for hw to finish? */
-		/* major IRQ delivery trouble loses INTR_SF too... */
-		if (limit-- == 0) {
-			ohci_warn (ohci, "IRQ INTR_SF lossage\n");
-			goto sanitize;
-		}
-		spin_unlock_irqrestore (&ohci->lock, flags);
-		schedule_timeout_uninterruptible(1);
-		goto rescan;
-	case ED_IDLE:		/* fully unlinked */
-		if (list_empty (&ed->td_list)) {
-			td_free (ohci, ed->dummy);
-			ed_free (ohci, ed);
-			break;
-		}
-		/* else FALL THROUGH */
-	default:
-		/* caller was supposed to have unlinked any requests;
-		 * that's not our job.  can't recover; must leak ed.
-		 */
-		ohci_err (ohci, "leak ed %p (#%02x) state %d%s\n",
-			ed, ep->desc.bEndpointAddress, ed->state,
-			list_empty (&ed->td_list) ? "" : " (has tds)");
-		td_free (ohci, ed->dummy);
-		break;
-	}
-	ep->hcpriv = NULL;
-	spin_unlock_irqrestore (&ohci->lock, flags);
-	return;
-}
-
-static int ohci_get_frame (struct usb_hcd *hcd)
-{
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-
-	return ohci_frame_no(ohci);
-}
-
-static void ohci_usb_reset (struct ohci_hcd *ohci)
-{
-	ohci->hc_control = ohci_readl (ohci, &ohci->regs->control);
-	ohci->hc_control &= OHCI_CTRL_RWC;
-	ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
-}
-
-/* ohci_shutdown forcibly disables IRQs and DMA, helping kexec and
- * other cases where the next software may expect clean state from the
- * "firmware".  this is bus-neutral, unlike shutdown() methods.
- */
-static void
-ohci_shutdown (struct usb_hcd *hcd)
-{
-	struct ohci_hcd *ohci;
-
-	ohci = hcd_to_ohci (hcd);
-	ohci_writel (ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
-	ohci_usb_reset (ohci);
-	/* flush the writes */
-	(void) ohci_readl (ohci, &ohci->regs->control);
-}
-
-/*-------------------------------------------------------------------------*
- * HC functions
- *-------------------------------------------------------------------------*/
-
-/* init memory, and kick BIOS/SMM off */
-
-static int ohci_init (struct ohci_hcd *ohci)
-{
-	int ret;
-	struct usb_hcd *hcd = ohci_to_hcd(ohci);
-
-	disable (ohci);
-	ohci->regs = hcd->regs;
-
-	/* REVISIT this BIOS handshake is now moved into PCI "quirks", and
-	 * was never needed for most non-PCI systems ... remove the code?
-	 */
-
-#ifndef IR_DISABLE
-	/* SMM owns the HC?  not for long! */
-	if (!no_handshake && ohci_readl (ohci,
-					&ohci->regs->control) & OHCI_CTRL_IR) {
-		u32 temp;
-
-		ohci_dbg (ohci, "USB HC TakeOver from BIOS/SMM\n");
-
-		/* this timeout is arbitrary.  we make it long, so systems
-		 * depending on usb keyboards may be usable even if the
-		 * BIOS/SMM code seems pretty broken.
-		 */
-		temp = 500;	/* arbitrary: five seconds */
-
-		ohci_writel (ohci, OHCI_INTR_OC, &ohci->regs->intrenable);
-		ohci_writel (ohci, OHCI_OCR, &ohci->regs->cmdstatus);
-		while (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_IR) {
-			msleep (10);
-			if (--temp == 0) {
-				ohci_err (ohci, "USB HC takeover failed!"
-					"  (BIOS/SMM bug)\n");
-				return -EBUSY;
-			}
-		}
-		ohci_usb_reset (ohci);
-	}
-#endif
-
-	/* Disable HC interrupts */
-	ohci_writel (ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
-
-	/* flush the writes, and save key bits like RWC */
-	if (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_RWC)
-		ohci->hc_control |= OHCI_CTRL_RWC;
-
-	/* Read the number of ports unless overridden */
-	if (ohci->num_ports == 0)
-		ohci->num_ports = roothub_a(ohci) & RH_A_NDP;
-
-	if (ohci->hcca)
-		return 0;
-
-	ohci->hcca = dma_alloc_coherent (hcd->self.controller,
-			sizeof *ohci->hcca, &ohci->hcca_dma, 0);
-	if (!ohci->hcca)
-		return -ENOMEM;
-
-	if ((ret = ohci_mem_init (ohci)) < 0)
-		ohci_stop (hcd);
-	else {
-		create_debug_files (ohci);
-	}
-
-	return ret;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* Start an OHCI controller, set the BUS operational
- * resets USB and controller
- * enable interrupts
- */
-static int ohci_run (struct ohci_hcd *ohci)
-{
-	u32			mask, temp;
-	int			first = ohci->fminterval == 0;
-	struct usb_hcd		*hcd = ohci_to_hcd(ohci);
-
-	disable (ohci);
-
-	/* boot firmware should have set this up (5.1.1.3.1) */
-	if (first) {
-
-		temp = ohci_readl (ohci, &ohci->regs->fminterval);
-		ohci->fminterval = temp & 0x3fff;
-		if (ohci->fminterval != FI)
-			ohci_dbg (ohci, "fminterval delta %d\n",
-				ohci->fminterval - FI);
-		ohci->fminterval |= FSMP (ohci->fminterval) << 16;
-		/* also: power/overcurrent flags in roothub.a */
-	}
-
-	/* Reset USB nearly "by the book".  RemoteWakeupConnected was
-	 * saved if boot firmware (BIOS/SMM/...) told us it's connected,
-	 * or if bus glue did the same (e.g. for PCI add-in cards with
-	 * PCI PM support).
-	 */
-	if ((ohci->hc_control & OHCI_CTRL_RWC) != 0
-			&& !device_may_wakeup(hcd->self.controller))
-		device_init_wakeup(hcd->self.controller, 1);
-
-	switch (ohci->hc_control & OHCI_CTRL_HCFS) {
-	case OHCI_USB_OPER:
-		temp = 0;
-		break;
-	case OHCI_USB_SUSPEND:
-	case OHCI_USB_RESUME:
-		ohci->hc_control &= OHCI_CTRL_RWC;
-		ohci->hc_control |= OHCI_USB_RESUME;
-		temp = 10 /* msec wait */;
-		break;
-	// case OHCI_USB_RESET:
-	default:
-		ohci->hc_control &= OHCI_CTRL_RWC;
-		ohci->hc_control |= OHCI_USB_RESET;
-		temp = 50 /* msec wait */;
-		break;
-	}
-	ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
-	// flush the writes
-	(void) ohci_readl (ohci, &ohci->regs->control);
-	msleep(temp);
-
-	memset (ohci->hcca, 0, sizeof (struct ohci_hcca));
-
-	/* 2msec timelimit here means no irqs/preempt */
-	spin_lock_irq (&ohci->lock);
-
-retry:
-	/* HC Reset requires max 10 us delay */
-	ohci_writel (ohci, OHCI_HCR,  &ohci->regs->cmdstatus);
-	temp = 30;	/* ... allow extra time */
-	while ((ohci_readl (ohci, &ohci->regs->cmdstatus) & OHCI_HCR) != 0) {
-		if (--temp == 0) {
-			spin_unlock_irq (&ohci->lock);
-			ohci_err (ohci, "USB HC reset timed out!\n");
-			return -1;
-		}
-		udelay (1);
-	}
-
-	/* now we're in the SUSPEND state ... must go OPERATIONAL
-	 * within 2msec else HC enters RESUME
-	 *
-	 * ... but some hardware won't init fmInterval "by the book"
-	 * (SiS, OPTi ...), so reset again instead.  SiS doesn't need
-	 * this if we write fmInterval after we're OPERATIONAL.
-	 * Unclear about ALi, ServerWorks, and others ... this could
-	 * easily be a longstanding bug in chip init on Linux.
-	 */
-	if (ohci->flags & OHCI_QUIRK_INITRESET) {
-		ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
-		// flush those writes
-		(void) ohci_readl (ohci, &ohci->regs->control);
-	}
-
-	/* Tell the controller where the control and bulk lists are
-	 * The lists are empty now. */
-	ohci_writel (ohci, 0, &ohci->regs->ed_controlhead);
-	ohci_writel (ohci, 0, &ohci->regs->ed_bulkhead);
-
-	/* a reset clears this */
-	ohci_writel (ohci, (u32) ohci->hcca_dma, &ohci->regs->hcca);
-
-	periodic_reinit (ohci);
-
-	/* some OHCI implementations are finicky about how they init.
-	 * bogus values here mean not even enumeration could work.
-	 */
-	if ((ohci_readl (ohci, &ohci->regs->fminterval) & 0x3fff0000) == 0
-			|| !ohci_readl (ohci, &ohci->regs->periodicstart)) {
-		if (!(ohci->flags & OHCI_QUIRK_INITRESET)) {
-			ohci->flags |= OHCI_QUIRK_INITRESET;
-			ohci_dbg (ohci, "enabling initreset quirk\n");
-			goto retry;
-		}
-		spin_unlock_irq (&ohci->lock);
-		ohci_err (ohci, "init err (%08x %04x)\n",
-			ohci_readl (ohci, &ohci->regs->fminterval),
-			ohci_readl (ohci, &ohci->regs->periodicstart));
-		return -EOVERFLOW;
-	}
-
-	/* use rhsc irqs after khubd is fully initialized */
-	hcd->poll_rh = 1;
-	hcd->uses_new_polling = 1;
-
-	/* start controller operations */
-	ohci->hc_control &= OHCI_CTRL_RWC;
-	ohci->hc_control |= OHCI_CONTROL_INIT | OHCI_USB_OPER;
-	ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
-	hcd->state = HC_STATE_RUNNING;
-
-	/* wake on ConnectStatusChange, matching external hubs */
-	ohci_writel (ohci, RH_HS_DRWE, &ohci->regs->roothub.status);
-
-	/* Choose the interrupts we care about now, others later on demand */
-	mask = OHCI_INTR_INIT;
-	ohci_writel (ohci, ~0, &ohci->regs->intrstatus);
-	ohci_writel (ohci, mask, &ohci->regs->intrenable);
-
-	/* handle root hub init quirks ... */
-	temp = roothub_a (ohci);
-	temp &= ~(RH_A_PSM | RH_A_OCPM);
-	if (ohci->flags & OHCI_QUIRK_SUPERIO) {
-		/* NSC 87560 and maybe others */
-		temp |= RH_A_NOCP;
-		temp &= ~(RH_A_POTPGT | RH_A_NPS);
-		ohci_writel (ohci, temp, &ohci->regs->roothub.a);
-	} else if ((ohci->flags & OHCI_QUIRK_AMD756) || distrust_firmware) {
-		/* hub power always on; required for AMD-756 and some
-		 * Mac platforms.  ganged overcurrent reporting, if any.
-		 */
-		temp |= RH_A_NPS;
-		ohci_writel (ohci, temp, &ohci->regs->roothub.a);
-	}
-	ohci_writel (ohci, RH_HS_LPSC, &ohci->regs->roothub.status);
-	ohci_writel (ohci, (temp & RH_A_NPS) ? 0 : RH_B_PPCM,
-						&ohci->regs->roothub.b);
-	// flush those writes
-	(void) ohci_readl (ohci, &ohci->regs->control);
-
-	ohci->next_statechange = jiffies + STATECHANGE_DELAY;
-	spin_unlock_irq (&ohci->lock);
-
-	// POTPGT delay is bits 24-31, in 2 ms units.
-	mdelay ((temp >> 23) & 0x1fe);
-	hcd->state = HC_STATE_RUNNING;
-
-	ohci_dump (ohci, 1);
-
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* an interrupt happens */
-
-static irqreturn_t ohci_irq (struct usb_hcd *hcd)
-{
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-	struct ohci_regs __iomem *regs = ohci->regs;
- 	int			ints; 
-
-	/* we can eliminate a (slow) ohci_readl()
-	   if _only_ WDH caused this irq */
-	if ((ohci->hcca->done_head != 0)
-			&& ! (hc32_to_cpup (ohci, &ohci->hcca->done_head)
-				& 0x01)) {
-		ints =  OHCI_INTR_WDH;
-
-	/* cardbus/... hardware gone before remove() */
-	} else if ((ints = ohci_readl (ohci, &regs->intrstatus)) == ~(u32)0) {
-		disable (ohci);
-		ohci_dbg (ohci, "device removed!\n");
-		return IRQ_HANDLED;
-
-	/* interrupt for some other device? */
-	} else if ((ints &= ohci_readl (ohci, &regs->intrenable)) == 0) {
-		return IRQ_NOTMINE;
-	}
-
-	if (ints & OHCI_INTR_UE) {
-		// e.g. due to PCI Master/Target Abort
-		if (ohci->flags & OHCI_QUIRK_NEC) {
-			/* Workaround for a silicon bug in some NEC chips used
-			 * in Apple's PowerBooks. Adapted from Darwin code.
-			 */
-			ohci_err (ohci, "OHCI Unrecoverable Error, scheduling NEC chip restart\n");
-
-			ohci_writel (ohci, OHCI_INTR_UE, &regs->intrdisable);
-
-			schedule_work (&ohci->nec_work);
-		} else {
-			disable (ohci);
-			ohci_err (ohci, "OHCI Unrecoverable Error, disabled\n");
-		}
-
-		ohci_dump (ohci, 1);
-		ohci_usb_reset (ohci);
-	}
-
-	if (ints & OHCI_INTR_RHSC) {
-		ohci_vdbg(ohci, "rhsc\n");
-		ohci->next_statechange = jiffies + STATECHANGE_DELAY;
-		ohci_writel(ohci, OHCI_INTR_RD | OHCI_INTR_RHSC,
-				&regs->intrstatus);
-
-		/* NOTE: Vendors didn't always make the same implementation
-		 * choices for RHSC.  Many followed the spec; RHSC triggers
-		 * on an edge, like setting and maybe clearing a port status
-		 * change bit.  With others it's level-triggered, active
-		 * until khubd clears all the port status change bits.  We'll
-		 * always disable it here and rely on polling until khubd
-		 * re-enables it.
-		 */
-		ohci_writel(ohci, OHCI_INTR_RHSC, &regs->intrdisable);
-		usb_hcd_poll_rh_status(hcd);
-	}
-
-	/* For connect and disconnect events, we expect the controller
-	 * to turn on RHSC along with RD.  But for remote wakeup events
-	 * this might not happen.
-	 */
-	else if (ints & OHCI_INTR_RD) {
-		ohci_vdbg(ohci, "resume detect\n");
-		ohci_writel(ohci, OHCI_INTR_RD, &regs->intrstatus);
-		hcd->poll_rh = 1;
-		if (ohci->autostop) {
-			spin_lock (&ohci->lock);
-			ohci_rh_resume (ohci);
-			spin_unlock (&ohci->lock);
-		} else
-			usb_hcd_resume_root_hub(hcd);
-	}
-
-	if (ints & OHCI_INTR_WDH) {
-		if (HC_IS_RUNNING(hcd->state))
-			ohci_writel (ohci, OHCI_INTR_WDH, &regs->intrdisable);
-		spin_lock (&ohci->lock);
-		dl_done_list (ohci);
-		spin_unlock (&ohci->lock);
-		if (HC_IS_RUNNING(hcd->state))
-			ohci_writel (ohci, OHCI_INTR_WDH, &regs->intrenable);
-	}
-
-	/* could track INTR_SO to reduce available PCI/... bandwidth */
-
-	/* handle any pending URB/ED unlinks, leaving INTR_SF enabled
-	 * when there's still unlinking to be done (next frame).
-	 */
-	spin_lock (&ohci->lock);
-	if (ohci->ed_rm_list)
-		finish_unlinks (ohci, ohci_frame_no(ohci));
-	if ((ints & OHCI_INTR_SF) != 0 && !ohci->ed_rm_list
-			&& HC_IS_RUNNING(hcd->state))
-		ohci_writel (ohci, OHCI_INTR_SF, &regs->intrdisable);
-	spin_unlock (&ohci->lock);
-
-	if (HC_IS_RUNNING(hcd->state)) {
-		ohci_writel (ohci, ints, &regs->intrstatus);
-		ohci_writel (ohci, OHCI_INTR_MIE, &regs->intrenable);
-		// flush those writes
-		(void) ohci_readl (ohci, &ohci->regs->control);
-	}
-
-	return IRQ_HANDLED;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static void ohci_stop (struct usb_hcd *hcd)
-{
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-
-	ohci_dump (ohci, 1);
-
-	flush_scheduled_work();
-
-	ohci_usb_reset (ohci);
-	ohci_writel (ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
-	free_irq(hcd->irq, hcd);
-	hcd->irq = -1;
-
-	remove_debug_files (ohci);
-	ohci_mem_cleanup (ohci);
-	if (ohci->hcca) {
-		dma_free_coherent (hcd->self.controller,
-				sizeof *ohci->hcca,
-				ohci->hcca, ohci->hcca_dma);
-		ohci->hcca = NULL;
-		ohci->hcca_dma = 0;
-	}
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* must not be called from interrupt context */
-static int ohci_restart (struct ohci_hcd *ohci)
-{
-	int temp;
-	int i;
-	struct urb_priv *priv;
-
-	spin_lock_irq(&ohci->lock);
-	disable (ohci);
-
-	/* Recycle any "live" eds/tds (and urbs). */
-	if (!list_empty (&ohci->pending))
-		ohci_dbg(ohci, "abort schedule...\n");
-	list_for_each_entry (priv, &ohci->pending, pending) {
-		struct urb	*urb = priv->td[0]->urb;
-		struct ed	*ed = priv->ed;
-
-		switch (ed->state) {
-		case ED_OPER:
-			ed->state = ED_UNLINK;
-			ed->hwINFO |= cpu_to_hc32(ohci, ED_DEQUEUE);
-			ed_deschedule (ohci, ed);
-
-			ed->ed_next = ohci->ed_rm_list;
-			ed->ed_prev = NULL;
-			ohci->ed_rm_list = ed;
-			/* FALLTHROUGH */
-		case ED_UNLINK:
-			break;
-		default:
-			ohci_dbg(ohci, "bogus ed %p state %d\n",
-					ed, ed->state);
-		}
-
-		spin_lock (&urb->lock);
-		urb->status = -ESHUTDOWN;
-		spin_unlock (&urb->lock);
-	}
-	finish_unlinks (ohci, 0);
-	spin_unlock_irq(&ohci->lock);
-
-	/* paranoia, in case that didn't work: */
-
-	/* empty the interrupt branches */
-	for (i = 0; i < NUM_INTS; i++) ohci->load [i] = 0;
-	for (i = 0; i < NUM_INTS; i++) ohci->hcca->int_table [i] = 0;
-
-	/* no EDs to remove */
-	ohci->ed_rm_list = NULL;
-
-	/* empty control and bulk lists */
-	ohci->ed_controltail = NULL;
-	ohci->ed_bulktail    = NULL;
-
-	if ((temp = ohci_run (ohci)) < 0) {
-		ohci_err (ohci, "can't restart, %d\n", temp);
-		return temp;
-	}
-	ohci_dbg(ohci, "restart complete\n");
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* NEC workaround */
-static void ohci_quirk_nec_worker(struct work_struct *work)
-{
-	struct ohci_hcd *ohci = container_of(work, struct ohci_hcd, nec_work);
-	int status;
-
-	status = ohci_init(ohci);
-	if (status != 0) {
-		ohci_err(ohci, "Restarting NEC controller failed "
-			 "in ohci_init, %d\n", status);
-		return;
-	}
-
-	status = ohci_restart(ohci);
-	if (status != 0)
-		ohci_err(ohci, "Restarting NEC controller failed "
-			 "in ohci_restart, %d\n", status);
-}
-
-/*-------------------------------------------------------------------------*/
-
-#define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
-
-MODULE_AUTHOR (DRIVER_AUTHOR);
-MODULE_DESCRIPTION (DRIVER_INFO);
-MODULE_LICENSE ("GPL");
-
-#ifdef CONFIG_PCI
-#include "ohci-pci.c"
-#define PCI_DRIVER		ohci_pci_driver
-#endif
-
-#ifdef CONFIG_SA1111
-#include "ohci-sa1111.c"
-#define SA1111_DRIVER		ohci_hcd_sa1111_driver
-#endif
-
-#ifdef CONFIG_ARCH_S3C2410
-#include "ohci-s3c2410.c"
-#define PLATFORM_DRIVER		ohci_hcd_s3c2410_driver
-#endif
-
-#ifdef CONFIG_ARCH_OMAP
-#include "ohci-omap.c"
-#define PLATFORM_DRIVER		ohci_hcd_omap_driver
-#endif
-
-#ifdef CONFIG_ARCH_LH7A404
-#include "ohci-lh7a404.c"
-#define PLATFORM_DRIVER		ohci_hcd_lh7a404_driver
-#endif
-
-#ifdef CONFIG_PXA27x
-#include "ohci-pxa27x.c"
-#define PLATFORM_DRIVER		ohci_hcd_pxa27x_driver
-#endif
-
-#ifdef CONFIG_ARCH_EP93XX
-#include "ohci-ep93xx.c"
-#define PLATFORM_DRIVER		ohci_hcd_ep93xx_driver
-#endif
-
-#ifdef CONFIG_SOC_AU1X00
-#include "ohci-au1xxx.c"
-#define PLATFORM_DRIVER		ohci_hcd_au1xxx_driver
-#endif
-
-#ifdef CONFIG_PNX8550
-#include "ohci-pnx8550.c"
-#define PLATFORM_DRIVER		ohci_hcd_pnx8550_driver
-#endif
-
-#ifdef CONFIG_USB_OHCI_HCD_PPC_SOC
-#include "ohci-ppc-soc.c"
-#define PLATFORM_DRIVER		ohci_hcd_ppc_soc_driver
-#endif
-
-#ifdef CONFIG_ARCH_AT91
-#include "ohci-at91.c"
-#define PLATFORM_DRIVER		ohci_hcd_at91_driver
-#endif
-
-#ifdef CONFIG_ARCH_PNX4008
-#include "ohci-pnx4008.c"
-#define PLATFORM_DRIVER		usb_hcd_pnx4008_driver
-#endif
-
-
-#ifdef CONFIG_USB_OHCI_HCD_PPC_OF
-#include "ohci-ppc-of.c"
-#define OF_PLATFORM_DRIVER	ohci_hcd_ppc_of_driver
-#endif
-
-#ifdef CONFIG_PPC_PS3
-#include "ohci-ps3.c"
-#define PS3_SYSTEM_BUS_DRIVER	ps3_ohci_driver
-#endif
-
-#if	!defined(PCI_DRIVER) &&		\
-	!defined(PLATFORM_DRIVER) &&	\
-	!defined(OF_PLATFORM_DRIVER) &&	\
-	!defined(SA1111_DRIVER) &&	\
-	!defined(PS3_SYSTEM_BUS_DRIVER)
-#error "missing bus glue for ohci-hcd"
-#endif
-
-static int __init ohci_hcd_mod_init(void)
-{
-	int retval = 0;
-
-	if (usb_disabled())
-		return -ENODEV;
-
-	printk (KERN_DEBUG "%s: " DRIVER_INFO "\n", hcd_name);
-	pr_debug ("%s: block sizes: ed %Zd td %Zd\n", hcd_name,
-		sizeof (struct ed), sizeof (struct td));
-
-#ifdef PS3_SYSTEM_BUS_DRIVER
-	retval = ps3_ohci_driver_register(&PS3_SYSTEM_BUS_DRIVER);
-	if (retval < 0)
-		goto error_ps3;
-#endif
-
-#ifdef PLATFORM_DRIVER
-	retval = platform_driver_register(&PLATFORM_DRIVER);
-	if (retval < 0)
-		goto error_platform;
-#endif
-
-#ifdef OF_PLATFORM_DRIVER
-	retval = of_register_platform_driver(&OF_PLATFORM_DRIVER);
-	if (retval < 0)
-		goto error_of_platform;
-#endif
-
-#ifdef SA1111_DRIVER
-	retval = sa1111_driver_register(&SA1111_DRIVER);
-	if (retval < 0)
-		goto error_sa1111;
-#endif
-
-#ifdef PCI_DRIVER
-	retval = pci_register_driver(&PCI_DRIVER);
-	if (retval < 0)
-		goto error_pci;
-#endif
-
-	return retval;
-
-	/* Error path */
-#ifdef PCI_DRIVER
- error_pci:
-#endif
-#ifdef SA1111_DRIVER
-	sa1111_driver_unregister(&SA1111_DRIVER);
- error_sa1111:
-#endif
-#ifdef OF_PLATFORM_DRIVER
-	of_unregister_platform_driver(&OF_PLATFORM_DRIVER);
- error_of_platform:
-#endif
-#ifdef PLATFORM_DRIVER
-	platform_driver_unregister(&PLATFORM_DRIVER);
- error_platform:
-#endif
-#ifdef PS3_SYSTEM_BUS_DRIVER
-	ps3_ohci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
- error_ps3:
-#endif
-	return retval;
-}
-module_init(ohci_hcd_mod_init);
-
-static void __exit ohci_hcd_mod_exit(void)
-{
-#ifdef PCI_DRIVER
-	pci_unregister_driver(&PCI_DRIVER);
-#endif
-#ifdef SA1111_DRIVER
-	sa1111_driver_unregister(&SA1111_DRIVER);
-#endif
-#ifdef OF_PLATFORM_DRIVER
-	of_unregister_platform_driver(&OF_PLATFORM_DRIVER);
-#endif
-#ifdef PLATFORM_DRIVER
-	platform_driver_unregister(&PLATFORM_DRIVER);
-#endif
-#ifdef PS3_SYSTEM_BUS_DRIVER
-	ps3_ohci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
-#endif
-}
-module_exit(ohci_hcd_mod_exit);
-
diff -urN host/.svn/text-base/ohci-hub.c.svn-base host.new/.svn/text-base/ohci-hub.c.svn-base
--- host/.svn/text-base/ohci-hub.c.svn-base	2009-02-24 19:00:15.803949920 +0100
+++ host.new/.svn/text-base/ohci-hub.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,727 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2004 David Brownell <dbrownell@users.sourceforge.net>
- *
- * This file is licenced under GPL
- */
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * OHCI Root Hub ... the nonsharable stuff
- */
-
-#define dbg_port(hc,label,num,value) \
-	ohci_dbg (hc, \
-		"%s roothub.portstatus [%d] " \
-		"= 0x%08x%s%s%s%s%s%s%s%s%s%s%s%s\n", \
-		label, num, temp, \
-		(temp & RH_PS_PRSC) ? " PRSC" : "", \
-		(temp & RH_PS_OCIC) ? " OCIC" : "", \
-		(temp & RH_PS_PSSC) ? " PSSC" : "", \
-		(temp & RH_PS_PESC) ? " PESC" : "", \
-		(temp & RH_PS_CSC) ? " CSC" : "", \
-		\
-		(temp & RH_PS_LSDA) ? " LSDA" : "", \
-		(temp & RH_PS_PPS) ? " PPS" : "", \
-		(temp & RH_PS_PRS) ? " PRS" : "", \
-		(temp & RH_PS_POCI) ? " POCI" : "", \
-		(temp & RH_PS_PSS) ? " PSS" : "", \
-		\
-		(temp & RH_PS_PES) ? " PES" : "", \
-		(temp & RH_PS_CCS) ? " CCS" : "" \
-		);
-
-/*-------------------------------------------------------------------------*/
-
-/* hcd->hub_irq_enable() */
-static void ohci_rhsc_enable (struct usb_hcd *hcd)
-{
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-
-	spin_lock_irq(&ohci->lock);
-	if (!ohci->autostop)
-		del_timer(&hcd->rh_timer);	/* Prevent next poll */
-	ohci_writel(ohci, OHCI_INTR_RHSC, &ohci->regs->intrenable);
-	spin_unlock_irq(&ohci->lock);
-}
-
-#define OHCI_SCHED_ENABLES \
-	(OHCI_CTRL_CLE|OHCI_CTRL_BLE|OHCI_CTRL_PLE|OHCI_CTRL_IE)
-
-static void dl_done_list (struct ohci_hcd *);
-static void finish_unlinks (struct ohci_hcd *, u16);
-
-#ifdef	CONFIG_PM
-static int ohci_rh_suspend (struct ohci_hcd *ohci, int autostop)
-__releases(ohci->lock)
-__acquires(ohci->lock)
-{
-	int			status = 0;
-
-	ohci->hc_control = ohci_readl (ohci, &ohci->regs->control);
-	switch (ohci->hc_control & OHCI_CTRL_HCFS) {
-	case OHCI_USB_RESUME:
-		ohci_dbg (ohci, "resume/suspend?\n");
-		ohci->hc_control &= ~OHCI_CTRL_HCFS;
-		ohci->hc_control |= OHCI_USB_RESET;
-		ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
-		(void) ohci_readl (ohci, &ohci->regs->control);
-		/* FALL THROUGH */
-	case OHCI_USB_RESET:
-		status = -EBUSY;
-		ohci_dbg (ohci, "needs reinit!\n");
-		goto done;
-	case OHCI_USB_SUSPEND:
-		if (!ohci->autostop) {
-			ohci_dbg (ohci, "already suspended\n");
-			goto done;
-		}
-	}
-	ohci_dbg (ohci, "%s root hub\n",
-			autostop ? "auto-stop" : "suspend");
-
-	/* First stop any processing */
-	if (!autostop && (ohci->hc_control & OHCI_SCHED_ENABLES)) {
-		ohci->hc_control &= ~OHCI_SCHED_ENABLES;
-		ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
-		ohci->hc_control = ohci_readl (ohci, &ohci->regs->control);
-		ohci_writel (ohci, OHCI_INTR_SF, &ohci->regs->intrstatus);
-
-		/* sched disables take effect on the next frame,
-		 * then the last WDH could take 6+ msec
-		 */
-		ohci_dbg (ohci, "stopping schedules ...\n");
-		ohci->autostop = 0;
-		spin_unlock_irq (&ohci->lock);
-		msleep (8);
-		spin_lock_irq (&ohci->lock);
-	}
-	dl_done_list (ohci);
-	finish_unlinks (ohci, ohci_frame_no(ohci));
-
-	/* maybe resume can wake root hub */
-	if (device_may_wakeup(&ohci_to_hcd(ohci)->self.root_hub->dev) ||
-			autostop)
-		ohci->hc_control |= OHCI_CTRL_RWE;
-	else {
-		ohci_writel (ohci, OHCI_INTR_RHSC, &ohci->regs->intrdisable);
-		ohci->hc_control &= ~OHCI_CTRL_RWE;
-	}
-
-	/* Suspend hub ... this is the "global (to this bus) suspend" mode,
-	 * which doesn't imply ports will first be individually suspended.
-	 */
-	ohci->hc_control &= ~OHCI_CTRL_HCFS;
-	ohci->hc_control |= OHCI_USB_SUSPEND;
-	ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
-	(void) ohci_readl (ohci, &ohci->regs->control);
-
-	/* no resumes until devices finish suspending */
-	if (!autostop) {
-		ohci->next_statechange = jiffies + msecs_to_jiffies (5);
-		ohci->autostop = 0;
-	}
-
-done:
-	return status;
-}
-
-static inline struct ed *find_head (struct ed *ed)
-{
-	/* for bulk and control lists */
-	while (ed->ed_prev)
-		ed = ed->ed_prev;
-	return ed;
-}
-
-/* caller has locked the root hub */
-static int ohci_rh_resume (struct ohci_hcd *ohci)
-__releases(ohci->lock)
-__acquires(ohci->lock)
-{
-	struct usb_hcd		*hcd = ohci_to_hcd (ohci);
-	u32			temp, enables;
-	int			status = -EINPROGRESS;
-	int			autostopped = ohci->autostop;
-
-	ohci->autostop = 0;
-	ohci->hc_control = ohci_readl (ohci, &ohci->regs->control);
-
-	if (ohci->hc_control & (OHCI_CTRL_IR | OHCI_SCHED_ENABLES)) {
-		/* this can happen after resuming a swsusp snapshot */
-		if (hcd->state == HC_STATE_RESUMING) {
-			ohci_dbg (ohci, "BIOS/SMM active, control %03x\n",
-					ohci->hc_control);
-			status = -EBUSY;
-		/* this happens when pmcore resumes HC then root */
-		} else {
-			ohci_dbg (ohci, "duplicate resume\n");
-			status = 0;
-		}
-	} else switch (ohci->hc_control & OHCI_CTRL_HCFS) {
-	case OHCI_USB_SUSPEND:
-		ohci->hc_control &= ~(OHCI_CTRL_HCFS|OHCI_SCHED_ENABLES);
-		ohci->hc_control |= OHCI_USB_RESUME;
-		ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
-		(void) ohci_readl (ohci, &ohci->regs->control);
-		ohci_dbg (ohci, "%s root hub\n",
-				autostopped ? "auto-start" : "resume");
-		break;
-	case OHCI_USB_RESUME:
-		/* HCFS changes sometime after INTR_RD */
-		ohci_dbg(ohci, "%swakeup root hub\n",
-				autostopped ? "auto-" : "");
-		break;
-	case OHCI_USB_OPER:
-		/* this can happen after resuming a swsusp snapshot */
-		ohci_dbg (ohci, "snapshot resume? reinit\n");
-		status = -EBUSY;
-		break;
-	default:		/* RESET, we lost power */
-		ohci_dbg (ohci, "lost power\n");
-		status = -EBUSY;
-	}
-	if (status == -EBUSY) {
-		if (!autostopped) {
-			spin_unlock_irq (&ohci->lock);
-			(void) ohci_init (ohci);
-			status = ohci_restart (ohci);
-
-			usb_root_hub_lost_power(hcd->self.root_hub);
-
-			spin_lock_irq (&ohci->lock);
-		}
-		return status;
-	}
-	if (status != -EINPROGRESS)
-		return status;
-	if (autostopped)
-		goto skip_resume;
-	spin_unlock_irq (&ohci->lock);
-
-	/* Some controllers (lucent erratum) need extra-long delays */
-	msleep (20 /* usb 11.5.1.10 */ + 12 /* 32 msec counter */ + 1);
-
-	temp = ohci_readl (ohci, &ohci->regs->control);
-	temp &= OHCI_CTRL_HCFS;
-	if (temp != OHCI_USB_RESUME) {
-		ohci_err (ohci, "controller won't resume\n");
-		spin_lock_irq(&ohci->lock);
-		return -EBUSY;
-	}
-
-	/* disable old schedule state, reinit from scratch */
-	ohci_writel (ohci, 0, &ohci->regs->ed_controlhead);
-	ohci_writel (ohci, 0, &ohci->regs->ed_controlcurrent);
-	ohci_writel (ohci, 0, &ohci->regs->ed_bulkhead);
-	ohci_writel (ohci, 0, &ohci->regs->ed_bulkcurrent);
-	ohci_writel (ohci, 0, &ohci->regs->ed_periodcurrent);
-	ohci_writel (ohci, (u32) ohci->hcca_dma, &ohci->regs->hcca);
-
-	/* Sometimes PCI D3 suspend trashes frame timings ... */
-	periodic_reinit (ohci);
-
-	/* the following code is executed with ohci->lock held and
-	 * irqs disabled if and only if autostopped is true
-	 */
-
-skip_resume:
-	/* interrupts might have been disabled */
-	ohci_writel (ohci, OHCI_INTR_INIT, &ohci->regs->intrenable);
-	if (ohci->ed_rm_list)
-		ohci_writel (ohci, OHCI_INTR_SF, &ohci->regs->intrenable);
-
-	/* Then re-enable operations */
-	ohci_writel (ohci, OHCI_USB_OPER, &ohci->regs->control);
-	(void) ohci_readl (ohci, &ohci->regs->control);
-	if (!autostopped)
-		msleep (3);
-
-	temp = ohci->hc_control;
-	temp &= OHCI_CTRL_RWC;
-	temp |= OHCI_CONTROL_INIT | OHCI_USB_OPER;
-	ohci->hc_control = temp;
-	ohci_writel (ohci, temp, &ohci->regs->control);
-	(void) ohci_readl (ohci, &ohci->regs->control);
-
-	/* TRSMRCY */
-	if (!autostopped) {
-		msleep (10);
-		spin_lock_irq (&ohci->lock);
-	}
-	/* now ohci->lock is always held and irqs are always disabled */
-
-	/* keep it alive for more than ~5x suspend + resume costs */
-	ohci->next_statechange = jiffies + STATECHANGE_DELAY;
-
-	/* maybe turn schedules back on */
-	enables = 0;
-	temp = 0;
-	if (!ohci->ed_rm_list) {
-		if (ohci->ed_controltail) {
-			ohci_writel (ohci,
-					find_head (ohci->ed_controltail)->dma,
-					&ohci->regs->ed_controlhead);
-			enables |= OHCI_CTRL_CLE;
-			temp |= OHCI_CLF;
-		}
-		if (ohci->ed_bulktail) {
-			ohci_writel (ohci, find_head (ohci->ed_bulktail)->dma,
-				&ohci->regs->ed_bulkhead);
-			enables |= OHCI_CTRL_BLE;
-			temp |= OHCI_BLF;
-		}
-	}
-	if (hcd->self.bandwidth_isoc_reqs || hcd->self.bandwidth_int_reqs)
-		enables |= OHCI_CTRL_PLE|OHCI_CTRL_IE;
-	if (enables) {
-		ohci_dbg (ohci, "restarting schedules ... %08x\n", enables);
-		ohci->hc_control |= enables;
-		ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
-		if (temp)
-			ohci_writel (ohci, temp, &ohci->regs->cmdstatus);
-		(void) ohci_readl (ohci, &ohci->regs->control);
-	}
-
-	return 0;
-}
-
-static int ohci_bus_suspend (struct usb_hcd *hcd)
-{
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-	int			rc;
-
-	spin_lock_irq (&ohci->lock);
-
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)))
-		rc = -ESHUTDOWN;
-	else
-		rc = ohci_rh_suspend (ohci, 0);
-	spin_unlock_irq (&ohci->lock);
-	return rc;
-}
-
-static int ohci_bus_resume (struct usb_hcd *hcd)
-{
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-	int			rc;
-
-	if (time_before (jiffies, ohci->next_statechange))
-		msleep(5);
-
-	spin_lock_irq (&ohci->lock);
-
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)))
-		rc = -ESHUTDOWN;
-	else
-		rc = ohci_rh_resume (ohci);
-	spin_unlock_irq (&ohci->lock);
-
-	/* poll until we know a device is connected or we autostop */
-	if (rc == 0)
-		usb_hcd_poll_rh_status(hcd);
-	return rc;
-}
-
-/* Carry out polling-, autostop-, and autoresume-related state changes */
-static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
-		int any_connected)
-{
-	int	poll_rh = 1;
-
-	switch (ohci->hc_control & OHCI_CTRL_HCFS) {
-
-	case OHCI_USB_OPER:
-		/* keep on polling until we know a device is connected
-		 * and RHSC is enabled */
-		if (!ohci->autostop) {
-			if (any_connected ||
-					!device_may_wakeup(&ohci_to_hcd(ohci)
-						->self.root_hub->dev)) {
-				if (ohci_readl(ohci, &ohci->regs->intrenable) &
-						OHCI_INTR_RHSC)
-					poll_rh = 0;
-			} else {
-				ohci->autostop = 1;
-				ohci->next_statechange = jiffies + HZ;
-			}
-
-		/* if no devices have been attached for one second, autostop */
-		} else {
-			if (changed || any_connected) {
-				ohci->autostop = 0;
-				ohci->next_statechange = jiffies +
-						STATECHANGE_DELAY;
-			} else if (time_after_eq(jiffies,
-						ohci->next_statechange)
-					&& !ohci->ed_rm_list
-					&& !(ohci->hc_control &
-						OHCI_SCHED_ENABLES)) {
-				ohci_rh_suspend(ohci, 1);
-			}
-		}
-		break;
-
-	/* if there is a port change, autostart or ask to be resumed */
-	case OHCI_USB_SUSPEND:
-	case OHCI_USB_RESUME:
-		if (changed) {
-			if (ohci->autostop)
-				ohci_rh_resume(ohci);
-			else
-				usb_hcd_resume_root_hub(ohci_to_hcd(ohci));
-		} else {
-			/* everything is idle, no need for polling */
-			poll_rh = 0;
-		}
-		break;
-	}
-	return poll_rh;
-}
-
-#else	/* CONFIG_PM */
-
-static inline int ohci_rh_resume(struct ohci_hcd *ohci)
-{
-	return 0;
-}
-
-/* Carry out polling-related state changes.
- * autostop isn't used when CONFIG_PM is turned off.
- */
-static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
-		int any_connected)
-{
-	int	poll_rh = 1;
-
-	/* keep on polling until RHSC is enabled */
-	if (ohci_readl(ohci, &ohci->regs->intrenable) & OHCI_INTR_RHSC)
-		poll_rh = 0;
-	return poll_rh;
-}
-
-#endif	/* CONFIG_PM */
-
-/*-------------------------------------------------------------------------*/
-
-/* build "status change" packet (one or two bytes) from HC registers */
-
-static int
-ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		i, changed = 0, length = 1;
-	int		any_connected = 0;
-	unsigned long	flags;
-
-	spin_lock_irqsave (&ohci->lock, flags);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags))
-		goto done;
-
-	/* undocumented erratum seen on at least rev D */
-	if ((ohci->flags & OHCI_QUIRK_AMD756)
-			&& (roothub_a (ohci) & RH_A_NDP) > MAX_ROOT_PORTS) {
-		ohci_warn (ohci, "bogus NDP, rereads as NDP=%d\n",
-			  ohci_readl (ohci, &ohci->regs->roothub.a) & RH_A_NDP);
-		/* retry later; "should not happen" */
-		goto done;
-	}
-
-	/* init status */
-	if (roothub_status (ohci) & (RH_HS_LPSC | RH_HS_OCIC))
-		buf [0] = changed = 1;
-	else
-		buf [0] = 0;
-	if (ohci->num_ports > 7) {
-		buf [1] = 0;
-		length++;
-	}
-
-	/* look at each port */
-	for (i = 0; i < ohci->num_ports; i++) {
-		u32	status = roothub_portstatus (ohci, i);
-
-		/* can't autostop if ports are connected */
-		any_connected |= (status & RH_PS_CCS);
-
-		if (status & (RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC
-				| RH_PS_OCIC | RH_PS_PRSC)) {
-			changed = 1;
-			if (i < 7)
-			    buf [0] |= 1 << (i + 1);
-			else
-			    buf [1] |= 1 << (i - 7);
-		}
-	}
-
-	hcd->poll_rh = ohci_root_hub_state_changes(ohci, changed,
-			any_connected);
-
-done:
-	spin_unlock_irqrestore (&ohci->lock, flags);
-
-	return changed ? length : 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static void
-ohci_hub_descriptor (
-	struct ohci_hcd			*ohci,
-	struct usb_hub_descriptor	*desc
-) {
-	u32		rh = roothub_a (ohci);
-	u16		temp;
-
-	desc->bDescriptorType = 0x29;
-	desc->bPwrOn2PwrGood = (rh & RH_A_POTPGT) >> 24;
-	desc->bHubContrCurrent = 0;
-
-	desc->bNbrPorts = ohci->num_ports;
-	temp = 1 + (ohci->num_ports / 8);
-	desc->bDescLength = 7 + 2 * temp;
-
-	temp = 0;
-	if (rh & RH_A_NPS)		/* no power switching? */
-	    temp |= 0x0002;
-	if (rh & RH_A_PSM)		/* per-port power switching? */
-	    temp |= 0x0001;
-	if (rh & RH_A_NOCP)		/* no overcurrent reporting? */
-	    temp |= 0x0010;
-	else if (rh & RH_A_OCPM)	/* per-port overcurrent reporting? */
-	    temp |= 0x0008;
-	desc->wHubCharacteristics = (__force __u16)cpu_to_hc16(ohci, temp);
-
-	/* two bitmaps:  ports removable, and usb 1.0 legacy PortPwrCtrlMask */
-	rh = roothub_b (ohci);
-	memset(desc->bitmap, 0xff, sizeof(desc->bitmap));
-	desc->bitmap [0] = rh & RH_B_DR;
-	if (ohci->num_ports > 7) {
-		desc->bitmap [1] = (rh & RH_B_DR) >> 8;
-		desc->bitmap [2] = 0xff;
-	} else
-		desc->bitmap [1] = 0xff;
-}
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef	CONFIG_USB_OTG
-
-static int ohci_start_port_reset (struct usb_hcd *hcd, unsigned port)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	u32			status;
-
-	if (!port)
-		return -EINVAL;
-	port--;
-
-	/* start port reset before HNP protocol times out */
-	status = ohci_readl(ohci, &ohci->regs->roothub.portstatus [port]);
-	if (!(status & RH_PS_CCS))
-		return -ENODEV;
-
-	/* khubd will finish the reset later */
-	ohci_writel(ohci, RH_PS_PRS, &ohci->regs->roothub.portstatus [port]);
-	return 0;
-}
-
-static void start_hnp(struct ohci_hcd *ohci);
-
-#else
-
-#define	ohci_start_port_reset		NULL
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-
-/* See usb 7.1.7.5:  root hubs must issue at least 50 msec reset signaling,
- * not necessarily continuous ... to guard against resume signaling.
- * The short timeout is safe for non-root hubs, and is backward-compatible
- * with earlier Linux hosts.
- */
-#ifdef	CONFIG_USB_SUSPEND
-#define	PORT_RESET_MSEC		50
-#else
-#define	PORT_RESET_MSEC		10
-#endif
-
-/* this timer value might be vendor-specific ... */
-#define	PORT_RESET_HW_MSEC	10
-
-/* wrap-aware logic morphed from <linux/jiffies.h> */
-#define tick_before(t1,t2) ((s16)(((s16)(t1))-((s16)(t2))) < 0)
-
-/* called from some task, normally khubd */
-static inline int root_port_reset (struct ohci_hcd *ohci, unsigned port)
-{
-	__hc32 __iomem *portstat = &ohci->regs->roothub.portstatus [port];
-	u32	temp;
-	u16	now = ohci_readl(ohci, &ohci->regs->fmnumber);
-	u16	reset_done = now + PORT_RESET_MSEC;
-
-	/* build a "continuous enough" reset signal, with up to
-	 * 3msec gap between pulses.  scheduler HZ==100 must work;
-	 * this might need to be deadline-scheduled.
-	 */
-	do {
-		/* spin until any current reset finishes */
-		for (;;) {
-			temp = ohci_readl (ohci, portstat);
-			/* handle e.g. CardBus eject */
-			if (temp == ~(u32)0)
-				return -ESHUTDOWN;
-			if (!(temp & RH_PS_PRS))
-				break;
-			udelay (500);
-		}
-
-		if (!(temp & RH_PS_CCS))
-			break;
-		if (temp & RH_PS_PRSC)
-			ohci_writel (ohci, RH_PS_PRSC, portstat);
-
-		/* start the next reset, sleep till it's probably done */
-		ohci_writel (ohci, RH_PS_PRS, portstat);
-		msleep(PORT_RESET_HW_MSEC);
-		now = ohci_readl(ohci, &ohci->regs->fmnumber);
-	} while (tick_before(now, reset_done));
-	/* caller synchronizes using PRSC */
-
-	return 0;
-}
-
-static int ohci_hub_control (
-	struct usb_hcd	*hcd,
-	u16		typeReq,
-	u16		wValue,
-	u16		wIndex,
-	char		*buf,
-	u16		wLength
-) {
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ports = hcd_to_bus (hcd)->root_hub->maxchild;
-	u32		temp;
-	int		retval = 0;
-
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)))
-		return -ESHUTDOWN;
-
-	switch (typeReq) {
-	case ClearHubFeature:
-		switch (wValue) {
-		case C_HUB_OVER_CURRENT:
-			ohci_writel (ohci, RH_HS_OCIC,
-					&ohci->regs->roothub.status);
-		case C_HUB_LOCAL_POWER:
-			break;
-		default:
-			goto error;
-		}
-		break;
-	case ClearPortFeature:
-		if (!wIndex || wIndex > ports)
-			goto error;
-		wIndex--;
-
-		switch (wValue) {
-		case USB_PORT_FEAT_ENABLE:
-			temp = RH_PS_CCS;
-			break;
-		case USB_PORT_FEAT_C_ENABLE:
-			temp = RH_PS_PESC;
-			break;
-		case USB_PORT_FEAT_SUSPEND:
-			temp = RH_PS_POCI;
-			break;
-		case USB_PORT_FEAT_C_SUSPEND:
-			temp = RH_PS_PSSC;
-			break;
-		case USB_PORT_FEAT_POWER:
-			temp = RH_PS_LSDA;
-			break;
-		case USB_PORT_FEAT_C_CONNECTION:
-			temp = RH_PS_CSC;
-			break;
-		case USB_PORT_FEAT_C_OVER_CURRENT:
-			temp = RH_PS_OCIC;
-			break;
-		case USB_PORT_FEAT_C_RESET:
-			temp = RH_PS_PRSC;
-			break;
-		default:
-			goto error;
-		}
-		ohci_writel (ohci, temp,
-				&ohci->regs->roothub.portstatus [wIndex]);
-		// ohci_readl (ohci, &ohci->regs->roothub.portstatus [wIndex]);
-		break;
-	case GetHubDescriptor:
-		ohci_hub_descriptor (ohci, (struct usb_hub_descriptor *) buf);
-		break;
-	case GetHubStatus:
-		temp = roothub_status (ohci) & ~(RH_HS_CRWE | RH_HS_DRWE);
-		put_unaligned(cpu_to_le32 (temp), (__le32 *) buf);
-		break;
-	case GetPortStatus:
-		if (!wIndex || wIndex > ports)
-			goto error;
-		wIndex--;
-		temp = roothub_portstatus (ohci, wIndex);
-		put_unaligned(cpu_to_le32 (temp), (__le32 *) buf);
-
-#ifndef	OHCI_VERBOSE_DEBUG
-	if (*(u16*)(buf+2))	/* only if wPortChange is interesting */
-#endif
-		dbg_port (ohci, "GetStatus", wIndex, temp);
-		break;
-	case SetHubFeature:
-		switch (wValue) {
-		case C_HUB_OVER_CURRENT:
-			// FIXME:  this can be cleared, yes?
-		case C_HUB_LOCAL_POWER:
-			break;
-		default:
-			goto error;
-		}
-		break;
-	case SetPortFeature:
-		if (!wIndex || wIndex > ports)
-			goto error;
-		wIndex--;
-		switch (wValue) {
-		case USB_PORT_FEAT_SUSPEND:
-#ifdef	CONFIG_USB_OTG
-			if (hcd->self.otg_port == (wIndex + 1)
-					&& hcd->self.b_hnp_enable)
-				start_hnp(ohci);
-			else
-#endif
-			ohci_writel (ohci, RH_PS_PSS,
-				&ohci->regs->roothub.portstatus [wIndex]);
-			break;
-		case USB_PORT_FEAT_POWER:
-			ohci_writel (ohci, RH_PS_PPS,
-				&ohci->regs->roothub.portstatus [wIndex]);
-			break;
-		case USB_PORT_FEAT_RESET:
-			retval = root_port_reset (ohci, wIndex);
-			break;
-		default:
-			goto error;
-		}
-		break;
-
-	default:
-error:
-		/* "protocol stall" on error */
-		retval = -EPIPE;
-	}
-	return retval;
-}
-
diff -urN host/.svn/text-base/ohci-lh7a404.c.svn-base host.new/.svn/text-base/ohci-lh7a404.c.svn-base
--- host/.svn/text-base/ohci-lh7a404.c.svn-base	2009-02-24 19:00:15.807949717 +0100
+++ host.new/.svn/text-base/ohci-lh7a404.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,253 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- * (C) Copyright 2002 Hewlett-Packard Company
- *
- * Bus Glue for Sharp LH7A404
- *
- * Written by Christopher Hoover <ch@hpl.hp.com>
- * Based on fragments of previous driver by Rusell King et al.
- *
- * Modified for LH7A404 from ohci-sa1111.c
- *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
- *
- * This file is licenced under the GPL.
- */
-
-#include <linux/platform_device.h>
-#include <linux/signal.h>
-
-#include <asm/hardware.h>
-
-
-extern int usb_disabled(void);
-
-/*-------------------------------------------------------------------------*/
-
-static void lh7a404_start_hc(struct platform_device *dev)
-{
-	printk(KERN_DEBUG __FILE__
-	       ": starting LH7A404 OHCI USB Controller\n");
-
-	/*
-	 * Now, carefully enable the USB clock, and take
-	 * the USB host controller out of reset.
-	 */
-	CSC_PWRCNT |= CSC_PWRCNT_USBH_EN; /* Enable clock */
-	udelay(1000);
-	USBH_CMDSTATUS = OHCI_HCR;
-
-	printk(KERN_DEBUG __FILE__
-		   ": Clock to USB host has been enabled \n");
-}
-
-static void lh7a404_stop_hc(struct platform_device *dev)
-{
-	printk(KERN_DEBUG __FILE__
-	       ": stopping LH7A404 OHCI USB Controller\n");
-
-	CSC_PWRCNT &= ~CSC_PWRCNT_USBH_EN; /* Disable clock */
-}
-
-
-/*-------------------------------------------------------------------------*/
-
-/* configure so an HC device and id are always provided */
-/* always called with process context; sleeping is OK */
-
-
-/**
- * usb_hcd_lh7a404_probe - initialize LH7A404-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- *
- */
-int usb_hcd_lh7a404_probe (const struct hc_driver *driver,
-			  struct platform_device *dev)
-{
-	int retval;
-	struct usb_hcd *hcd;
-
-	if (dev->resource[1].flags != IORESOURCE_IRQ) {
-		pr_debug("resource[1] is not IORESOURCE_IRQ");
-		return -ENOMEM;
-	}
-
-	hcd = usb_create_hcd(driver, &dev->dev, "lh7a404");
-	if (!hcd)
-		return -ENOMEM;
-	hcd->rsrc_start = dev->resource[0].start;
-	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		pr_debug("request_mem_region failed");
-		retval = -EBUSY;
-		goto err1;
-	}
-
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-	if (!hcd->regs) {
-		pr_debug("ioremap failed");
-		retval = -ENOMEM;
-		goto err2;
-	}
-
-	lh7a404_start_hc(dev);
-	ohci_hcd_init(hcd_to_ohci(hcd));
-
-	retval = usb_add_hcd(hcd, dev->resource[1].start, IRQF_DISABLED);
-	if (retval == 0)
-		return retval;
-
-	lh7a404_stop_hc(dev);
-	iounmap(hcd->regs);
- err2:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
- err1:
-	usb_put_hcd(hcd);
-	return retval;
-}
-
-
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_hcd_lh7a404_remove - shutdown processing for LH7A404-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_hcd_lh7a404_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
- */
-void usb_hcd_lh7a404_remove (struct usb_hcd *hcd, struct platform_device *dev)
-{
-	usb_remove_hcd(hcd);
-	lh7a404_stop_hc(dev);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int __devinit
-ohci_lh7a404_start (struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ret;
-
-	ohci_dbg (ohci, "ohci_lh7a404_start, ohci:%p", ohci);
-	if ((ret = ohci_init(ohci)) < 0)
-		return ret;
-
-	if ((ret = ohci_run (ohci)) < 0) {
-		err ("can't start %s", hcd->self.bus_name);
-		ohci_stop (hcd);
-		return ret;
-	}
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static const struct hc_driver ohci_lh7a404_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"LH7A404 OHCI",
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ohci_irq,
-	.flags =		HCD_USB11 | HCD_MEMORY,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.start =		ohci_lh7a404_start,
-	.stop =			ohci_stop,
-	.shutdown =		ohci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ohci_urb_enqueue,
-	.urb_dequeue =		ohci_urb_dequeue,
-	.endpoint_disable =	ohci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ohci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ohci_hub_status_data,
-	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
-#ifdef	CONFIG_PM
-	.bus_suspend =		ohci_bus_suspend,
-	.bus_resume =		ohci_bus_resume,
-#endif
-	.start_port_reset =	ohci_start_port_reset,
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int ohci_hcd_lh7a404_drv_probe(struct platform_device *pdev)
-{
-	int ret;
-
-	pr_debug ("In ohci_hcd_lh7a404_drv_probe");
-
-	if (usb_disabled())
-		return -ENODEV;
-
-	ret = usb_hcd_lh7a404_probe(&ohci_lh7a404_hc_driver, pdev);
-	return ret;
-}
-
-static int ohci_hcd_lh7a404_drv_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	usb_hcd_lh7a404_remove(hcd, pdev);
-	return 0;
-}
-	/*TBD*/
-/*static int ohci_hcd_lh7a404_drv_suspend(struct platform_device *dev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(dev);
-
-	return 0;
-}
-static int ohci_hcd_lh7a404_drv_resume(struct platform_device *dev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(dev);
-
-
-	return 0;
-}
-*/
-
-static struct platform_driver ohci_hcd_lh7a404_driver = {
-	.probe		= ohci_hcd_lh7a404_drv_probe,
-	.remove		= ohci_hcd_lh7a404_drv_remove,
-	.shutdown	= usb_hcd_platform_shutdown,
-	/*.suspend	= ohci_hcd_lh7a404_drv_suspend, */
-	/*.resume	= ohci_hcd_lh7a404_drv_resume, */
-	.driver		= {
-		.name	= "lh7a404-ohci",
-		.owner	= THIS_MODULE,
-	},
-};
-
diff -urN host/.svn/text-base/ohci-mem.c.svn-base host.new/.svn/text-base/ohci-mem.c.svn-base
--- host/.svn/text-base/ohci-mem.c.svn-base	2009-02-24 19:00:15.807949717 +0100
+++ host.new/.svn/text-base/ohci-mem.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,139 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- *
- * This file is licenced under the GPL.
- */
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * OHCI deals with three types of memory:
- *	- data used only by the HCD ... kmalloc is fine
- *	- async and periodic schedules, shared by HC and HCD ... these
- *	  need to use dma_pool or dma_alloc_coherent
- *	- driver buffers, read/written by HC ... the hcd glue or the
- *	  device driver provides us with dma addresses
- *
- * There's also "register" data, which is memory mapped.
- * No memory seen by this driver (or any HCD) may be paged out.
- */
-
-/*-------------------------------------------------------------------------*/
-
-static void ohci_hcd_init (struct ohci_hcd *ohci)
-{
-	ohci->next_statechange = jiffies;
-	spin_lock_init (&ohci->lock);
-	INIT_LIST_HEAD (&ohci->pending);
-	INIT_WORK (&ohci->nec_work, ohci_quirk_nec_worker);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int ohci_mem_init (struct ohci_hcd *ohci)
-{
-	ohci->td_cache = dma_pool_create ("ohci_td",
-		ohci_to_hcd(ohci)->self.controller,
-		sizeof (struct td),
-		32 /* byte alignment */,
-		0 /* no page-crossing issues */);
-	if (!ohci->td_cache)
-		return -ENOMEM;
-	ohci->ed_cache = dma_pool_create ("ohci_ed",
-		ohci_to_hcd(ohci)->self.controller,
-		sizeof (struct ed),
-		16 /* byte alignment */,
-		0 /* no page-crossing issues */);
-	if (!ohci->ed_cache) {
-		dma_pool_destroy (ohci->td_cache);
-		return -ENOMEM;
-	}
-	return 0;
-}
-
-static void ohci_mem_cleanup (struct ohci_hcd *ohci)
-{
-	if (ohci->td_cache) {
-		dma_pool_destroy (ohci->td_cache);
-		ohci->td_cache = NULL;
-	}
-	if (ohci->ed_cache) {
-		dma_pool_destroy (ohci->ed_cache);
-		ohci->ed_cache = NULL;
-	}
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* ohci "done list" processing needs this mapping */
-static inline struct td *
-dma_to_td (struct ohci_hcd *hc, dma_addr_t td_dma)
-{
-	struct td *td;
-
-	td_dma &= TD_MASK;
-	td = hc->td_hash [TD_HASH_FUNC(td_dma)];
-	while (td && td->td_dma != td_dma)
-		td = td->td_hash;
-	return td;
-}
-
-/* TDs ... */
-static struct td *
-td_alloc (struct ohci_hcd *hc, gfp_t mem_flags)
-{
-	dma_addr_t	dma;
-	struct td	*td;
-
-	td = dma_pool_alloc (hc->td_cache, mem_flags, &dma);
-	if (td) {
-		/* in case hc fetches it, make it look dead */
-		memset (td, 0, sizeof *td);
-		td->hwNextTD = cpu_to_hc32 (hc, dma);
-		td->td_dma = dma;
-		/* hashed in td_fill */
-	}
-	return td;
-}
-
-static void
-td_free (struct ohci_hcd *hc, struct td *td)
-{
-	struct td	**prev = &hc->td_hash [TD_HASH_FUNC (td->td_dma)];
-
-	while (*prev && *prev != td)
-		prev = &(*prev)->td_hash;
-	if (*prev)
-		*prev = td->td_hash;
-	else if ((td->hwINFO & cpu_to_hc32(hc, TD_DONE)) != 0)
-		ohci_dbg (hc, "no hash for td %p\n", td);
-	dma_pool_free (hc->td_cache, td, td->td_dma);
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* EDs ... */
-static struct ed *
-ed_alloc (struct ohci_hcd *hc, gfp_t mem_flags)
-{
-	dma_addr_t	dma;
-	struct ed	*ed;
-
-	ed = dma_pool_alloc (hc->ed_cache, mem_flags, &dma);
-	if (ed) {
-		memset (ed, 0, sizeof (*ed));
-		INIT_LIST_HEAD (&ed->td_list);
-		ed->dma = dma;
-	}
-	return ed;
-}
-
-static void
-ed_free (struct ohci_hcd *hc, struct ed *ed)
-{
-	dma_pool_free (hc->ed_cache, ed, ed->dma);
-}
-
diff -urN host/.svn/text-base/ohci-omap.c.svn-base host.new/.svn/text-base/ohci-omap.c.svn-base
--- host/.svn/text-base/ohci-omap.c.svn-base	2009-02-24 19:00:15.827948700 +0100
+++ host.new/.svn/text-base/ohci-omap.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,546 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2005 David Brownell
- * (C) Copyright 2002 Hewlett-Packard Company
- *
- * OMAP Bus Glue
- *
- * Modified for OMAP by Tony Lindgren <tony@atomide.com>
- * Based on the 2.4 OMAP OHCI driver originally done by MontaVista Software Inc.
- * and on ohci-sa1111.c by Christopher Hoover <ch@hpl.hp.com>
- *
- * This file is licenced under the GPL.
- */
-
-#include <linux/signal.h>	/* IRQF_DISABLED */
-#include <linux/jiffies.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-
-#include <asm/hardware.h>
-#include <asm/io.h>
-#include <asm/mach-types.h>
-
-#include <asm/arch/mux.h>
-#include <asm/arch/irqs.h>
-#include <asm/arch/gpio.h>
-#include <asm/arch/fpga.h>
-#include <asm/arch/usb.h>
-
-
-/* OMAP-1510 OHCI has its own MMU for DMA */
-#define OMAP1510_LB_MEMSIZE	32	/* Should be same as SDRAM size */
-#define OMAP1510_LB_CLOCK_DIV	0xfffec10c
-#define OMAP1510_LB_MMU_CTL	0xfffec208
-#define OMAP1510_LB_MMU_LCK	0xfffec224
-#define OMAP1510_LB_MMU_LD_TLB	0xfffec228
-#define OMAP1510_LB_MMU_CAM_H	0xfffec22c
-#define OMAP1510_LB_MMU_CAM_L	0xfffec230
-#define OMAP1510_LB_MMU_RAM_H	0xfffec234
-#define OMAP1510_LB_MMU_RAM_L	0xfffec238
-
-
-#ifndef CONFIG_ARCH_OMAP
-#error "This file is OMAP bus glue.  CONFIG_OMAP must be defined."
-#endif
-
-#ifdef CONFIG_TPS65010
-#include <asm/arch/tps65010.h>
-#else
-
-#define LOW	0
-#define HIGH	1
-
-#define GPIO1	1
-
-static inline int tps65010_set_gpio_out_value(unsigned gpio, unsigned value)
-{
-	return 0;
-}
-
-#endif
-
-extern int usb_disabled(void);
-extern int ocpi_enable(void);
-
-static struct clk *usb_host_ck;
-static struct clk *usb_dc_ck;
-static int host_enabled;
-static int host_initialized;
-
-static void omap_ohci_clock_power(int on)
-{
-	if (on) {
-		clk_enable(usb_dc_ck);
-		clk_enable(usb_host_ck);
-		/* guesstimate for T5 == 1x 32K clock + APLL lock time */
-		udelay(100);
-	} else {
-		clk_disable(usb_host_ck);
-		clk_disable(usb_dc_ck);
-	}
-}
-
-/*
- * Board specific gang-switched transceiver power on/off.
- * NOTE:  OSK supplies power from DC, not battery.
- */
-static int omap_ohci_transceiver_power(int on)
-{
-	if (on) {
-		if (machine_is_omap_innovator() && cpu_is_omap1510())
-			fpga_write(fpga_read(INNOVATOR_FPGA_CAM_USB_CONTROL)
-				| ((1 << 5/*usb1*/) | (1 << 3/*usb2*/)),
-			       INNOVATOR_FPGA_CAM_USB_CONTROL);
-		else if (machine_is_omap_osk())
-			tps65010_set_gpio_out_value(GPIO1, LOW);
-	} else {
-		if (machine_is_omap_innovator() && cpu_is_omap1510())
-			fpga_write(fpga_read(INNOVATOR_FPGA_CAM_USB_CONTROL)
-				& ~((1 << 5/*usb1*/) | (1 << 3/*usb2*/)),
-			       INNOVATOR_FPGA_CAM_USB_CONTROL);
-		else if (machine_is_omap_osk())
-			tps65010_set_gpio_out_value(GPIO1, HIGH);
-	}
-
-	return 0;
-}
-
-#ifdef CONFIG_ARCH_OMAP15XX
-/*
- * OMAP-1510 specific Local Bus clock on/off
- */
-static int omap_1510_local_bus_power(int on)
-{
-	if (on) {
-		omap_writel((1 << 1) | (1 << 0), OMAP1510_LB_MMU_CTL);
-		udelay(200);
-	} else {
-		omap_writel(0, OMAP1510_LB_MMU_CTL);
-	}
-
-	return 0;
-}
-
-/*
- * OMAP-1510 specific Local Bus initialization
- * NOTE: This assumes 32MB memory size in OMAP1510LB_MEMSIZE.
- *       See also arch/mach-omap/memory.h for __virt_to_dma() and
- *       __dma_to_virt() which need to match with the physical
- *       Local Bus address below.
- */
-static int omap_1510_local_bus_init(void)
-{
-	unsigned int tlb;
-	unsigned long lbaddr, physaddr;
-
-	omap_writel((omap_readl(OMAP1510_LB_CLOCK_DIV) & 0xfffffff8) | 0x4,
-	       OMAP1510_LB_CLOCK_DIV);
-
-	/* Configure the Local Bus MMU table */
-	for (tlb = 0; tlb < OMAP1510_LB_MEMSIZE; tlb++) {
-		lbaddr = tlb * 0x00100000 + OMAP1510_LB_OFFSET;
-		physaddr = tlb * 0x00100000 + PHYS_OFFSET;
-		omap_writel((lbaddr & 0x0fffffff) >> 22, OMAP1510_LB_MMU_CAM_H);
-		omap_writel(((lbaddr & 0x003ffc00) >> 6) | 0xc,
-		       OMAP1510_LB_MMU_CAM_L);
-		omap_writel(physaddr >> 16, OMAP1510_LB_MMU_RAM_H);
-		omap_writel((physaddr & 0x0000fc00) | 0x300, OMAP1510_LB_MMU_RAM_L);
-		omap_writel(tlb << 4, OMAP1510_LB_MMU_LCK);
-		omap_writel(0x1, OMAP1510_LB_MMU_LD_TLB);
-	}
-
-	/* Enable the walking table */
-	omap_writel(omap_readl(OMAP1510_LB_MMU_CTL) | (1 << 3), OMAP1510_LB_MMU_CTL);
-	udelay(200);
-
-	return 0;
-}
-#else
-#define omap_1510_local_bus_power(x)	{}
-#define omap_1510_local_bus_init()	{}
-#endif
-
-#ifdef	CONFIG_USB_OTG
-
-static void start_hnp(struct ohci_hcd *ohci)
-{
-	const unsigned	port = ohci_to_hcd(ohci)->self.otg_port - 1;
-	unsigned long	flags;
-
-	otg_start_hnp(ohci->transceiver);
-
-	local_irq_save(flags);
-	ohci->transceiver->state = OTG_STATE_A_SUSPEND;
-	writel (RH_PS_PSS, &ohci->regs->roothub.portstatus [port]);
-	OTG_CTRL_REG &= ~OTG_A_BUSREQ;
-	local_irq_restore(flags);
-}
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-static int ohci_omap_init(struct usb_hcd *hcd)
-{
-	struct ohci_hcd		*ohci = hcd_to_ohci(hcd);
-	struct omap_usb_config	*config = hcd->self.controller->platform_data;
-	int			need_transceiver = (config->otg != 0);
-	int			ret;
-
-	dev_dbg(hcd->self.controller, "starting USB Controller\n");
-
-	if (config->otg) {
-		ohci_to_hcd(ohci)->self.otg_port = config->otg;
-		/* default/minimum OTG power budget:  8 mA */
-		ohci_to_hcd(ohci)->power_budget = 8;
-	}
-
-	/* boards can use OTG transceivers in non-OTG modes */
-	need_transceiver = need_transceiver
-			|| machine_is_omap_h2() || machine_is_omap_h3();
-
-	if (cpu_is_omap16xx())
-		ocpi_enable();
-
-#ifdef	CONFIG_ARCH_OMAP_OTG
-	if (need_transceiver) {
-		ohci->transceiver = otg_get_transceiver();
-		if (ohci->transceiver) {
-			int	status = otg_set_host(ohci->transceiver,
-						&ohci_to_hcd(ohci)->self);
-			dev_dbg(hcd->self.controller, "init %s transceiver, status %d\n",
-					ohci->transceiver->label, status);
-			if (status) {
-				if (ohci->transceiver)
-					put_device(ohci->transceiver->dev);
-				return status;
-			}
-		} else {
-			dev_err(hcd->self.controller, "can't find transceiver\n");
-			return -ENODEV;
-		}
-	}
-#endif
-
-	omap_ohci_clock_power(1);
-
-	if (cpu_is_omap1510()) {
-		omap_1510_local_bus_power(1);
-		omap_1510_local_bus_init();
-	}
-
-	if ((ret = ohci_init(ohci)) < 0)
-		return ret;
-
-	/* board-specific power switching and overcurrent support */
-	if (machine_is_omap_osk() || machine_is_omap_innovator()) {
-		u32	rh = roothub_a (ohci);
-
-		/* power switching (ganged by default) */
-		rh &= ~RH_A_NPS;
-
-		/* TPS2045 switch for internal transceiver (port 1) */
-		if (machine_is_omap_osk()) {
-			ohci_to_hcd(ohci)->power_budget = 250;
-
-			rh &= ~RH_A_NOCP;
-
-			/* gpio9 for overcurrent detction */
-			omap_cfg_reg(W8_1610_GPIO9);
-			omap_request_gpio(9);
-			omap_set_gpio_direction(9, 1 /* IN */);
-
-			/* for paranoia's sake:  disable USB.PUEN */
-			omap_cfg_reg(W4_USB_HIGHZ);
-		}
-		ohci_writel(ohci, rh, &ohci->regs->roothub.a);
-		distrust_firmware = 0;
-	} else if (machine_is_nokia770()) {
-		/* We require a self-powered hub, which should have
-		 * plenty of power. */
-		ohci_to_hcd(ohci)->power_budget = 0;
-	}
-
-	/* FIXME khubd hub requests should manage power switching */
-	omap_ohci_transceiver_power(1);
-
-	/* board init will have already handled HMC and mux setup.
-	 * any external transceiver should already be initialized
-	 * too, so all configured ports use the right signaling now.
-	 */
-
-	return 0;
-}
-
-static void ohci_omap_stop(struct usb_hcd *hcd)
-{
-	dev_dbg(hcd->self.controller, "stopping USB Controller\n");
-	omap_ohci_clock_power(0);
-}
-
-
-/*-------------------------------------------------------------------------*/
-
-/**
- * usb_hcd_omap_probe - initialize OMAP-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- */
-static int usb_hcd_omap_probe (const struct hc_driver *driver,
-			  struct platform_device *pdev)
-{
-	int retval, irq;
-	struct usb_hcd *hcd = 0;
-	struct ohci_hcd *ohci;
-
-	if (pdev->num_resources != 2) {
-		printk(KERN_ERR "hcd probe: invalid num_resources: %i\n",
-		       pdev->num_resources);
-		return -ENODEV;
-	}
-
-	if (pdev->resource[0].flags != IORESOURCE_MEM
-			|| pdev->resource[1].flags != IORESOURCE_IRQ) {
-		printk(KERN_ERR "hcd probe: invalid resource type\n");
-		return -ENODEV;
-	}
-
-	usb_host_ck = clk_get(0, "usb_hhc_ck");
-	if (IS_ERR(usb_host_ck))
-		return PTR_ERR(usb_host_ck);
-
-	if (!cpu_is_omap1510())
-		usb_dc_ck = clk_get(0, "usb_dc_ck");
-	else
-		usb_dc_ck = clk_get(0, "lb_ck");
-
-	if (IS_ERR(usb_dc_ck)) {
-		clk_put(usb_host_ck);
-		return PTR_ERR(usb_dc_ck);
-	}
-
-
-	hcd = usb_create_hcd (driver, &pdev->dev, pdev->dev.bus_id);
-	if (!hcd) {
-		retval = -ENOMEM;
-		goto err0;
-	}
-	hcd->rsrc_start = pdev->resource[0].start;
-	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		dev_dbg(&pdev->dev, "request_mem_region failed\n");
-		retval = -EBUSY;
-		goto err1;
-	}
-
-	hcd->regs = (void __iomem *) (int) IO_ADDRESS(hcd->rsrc_start);
-
-	ohci = hcd_to_ohci(hcd);
-	ohci_hcd_init(ohci);
-
-	host_initialized = 0;
-	host_enabled = 1;
-
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		retval = -ENXIO;
-		goto err2;
-	}
-	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED);
-	if (retval)
-		goto err2;
-
-	host_initialized = 1;
-
-	if (!host_enabled)
-		omap_ohci_clock_power(0);
-
-	return 0;
-err2:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-err1:
-	usb_put_hcd(hcd);
-err0:
-	clk_put(usb_dc_ck);
-	clk_put(usb_host_ck);
-	return retval;
-}
-
-
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_hcd_omap_remove - shutdown processing for OMAP-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_hcd_omap_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- */
-static inline void
-usb_hcd_omap_remove (struct usb_hcd *hcd, struct platform_device *pdev)
-{
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-
-	usb_remove_hcd(hcd);
-	if (ohci->transceiver) {
-		(void) otg_set_host(ohci->transceiver, 0);
-		put_device(ohci->transceiver->dev);
-	}
-	if (machine_is_omap_osk())
-		omap_free_gpio(9);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-	clk_put(usb_dc_ck);
-	clk_put(usb_host_ck);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int
-ohci_omap_start (struct usb_hcd *hcd)
-{
-	struct omap_usb_config *config;
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ret;
-
-	if (!host_enabled)
-		return 0;
-	config = hcd->self.controller->platform_data;
-	if (config->otg || config->rwc) {
-		ohci->hc_control = OHCI_CTRL_RWC;
-		writel(OHCI_CTRL_RWC, &ohci->regs->control);
-	}
-
-	if ((ret = ohci_run (ohci)) < 0) {
-		dev_err(hcd->self.controller, "can't start\n");
-		ohci_stop (hcd);
-		return ret;
-	}
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static const struct hc_driver ohci_omap_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"OMAP OHCI",
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ohci_irq,
-	.flags =		HCD_USB11 | HCD_MEMORY,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset =		ohci_omap_init,
-	.start =		ohci_omap_start,
-	.stop =			ohci_omap_stop,
-	.shutdown =		ohci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ohci_urb_enqueue,
-	.urb_dequeue =		ohci_urb_dequeue,
-	.endpoint_disable =	ohci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ohci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ohci_hub_status_data,
-	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
-#ifdef	CONFIG_PM
-	.bus_suspend =		ohci_bus_suspend,
-	.bus_resume =		ohci_bus_resume,
-#endif
-	.start_port_reset =	ohci_start_port_reset,
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int ohci_hcd_omap_drv_probe(struct platform_device *dev)
-{
-	return usb_hcd_omap_probe(&ohci_omap_hc_driver, dev);
-}
-
-static int ohci_hcd_omap_drv_remove(struct platform_device *dev)
-{
-	struct usb_hcd		*hcd = platform_get_drvdata(dev);
-
-	usb_hcd_omap_remove(hcd, dev);
-	platform_set_drvdata(dev, NULL);
-
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef	CONFIG_PM
-
-static int ohci_omap_suspend(struct platform_device *dev, pm_message_t message)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci(platform_get_drvdata(dev));
-
-	if (time_before(jiffies, ohci->next_statechange))
-		msleep(5);
-	ohci->next_statechange = jiffies;
-
-	omap_ohci_clock_power(0);
-	ohci_to_hcd(ohci)->state = HC_STATE_SUSPENDED;
-	dev->dev.power.power_state = PMSG_SUSPEND;
-	return 0;
-}
-
-static int ohci_omap_resume(struct platform_device *dev)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci(platform_get_drvdata(dev));
-
-	if (time_before(jiffies, ohci->next_statechange))
-		msleep(5);
-	ohci->next_statechange = jiffies;
-
-	omap_ohci_clock_power(1);
-	dev->dev.power.power_state = PMSG_ON;
-	usb_hcd_resume_root_hub(platform_get_drvdata(dev));
-	return 0;
-}
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * Driver definition to register with the OMAP bus
- */
-static struct platform_driver ohci_hcd_omap_driver = {
-	.probe		= ohci_hcd_omap_drv_probe,
-	.remove		= ohci_hcd_omap_drv_remove,
-	.shutdown	= usb_hcd_platform_shutdown,
-#ifdef	CONFIG_PM
-	.suspend	= ohci_omap_suspend,
-	.resume		= ohci_omap_resume,
-#endif
-	.driver		= {
-		.owner	= THIS_MODULE,
-		.name	= "ohci",
-	},
-};
-
diff -urN host/.svn/text-base/ohci-pci.c.svn-base host.new/.svn/text-base/ohci-pci.c.svn-base
--- host/.svn/text-base/ohci-pci.c.svn-base	2009-02-24 19:00:15.835948294 +0100
+++ host.new/.svn/text-base/ohci-pci.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,384 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- *
- * [ Initialisation is based on Linus'  ]
- * [ uhci code and gregs ohci fragments ]
- * [ (C) Copyright 1999 Linus Torvalds  ]
- * [ (C) Copyright 1999 Gregory P. Smith]
- *
- * PCI Bus Glue
- *
- * This file is licenced under the GPL.
- */
-
-#ifndef CONFIG_PCI
-#error "This file is PCI bus glue.  CONFIG_PCI must be defined."
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-static int broken_suspend(struct usb_hcd *hcd)
-{
-	device_init_wakeup(&hcd->self.root_hub->dev, 0);
-	return 0;
-}
-
-/* AMD 756, for most chips (early revs), corrupts register
- * values on read ... so enable the vendor workaround.
- */
-static int ohci_quirk_amd756(struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-
-	ohci->flags = OHCI_QUIRK_AMD756;
-	ohci_dbg (ohci, "AMD756 erratum 4 workaround\n");
-
-	/* also erratum 10 (suspend/resume issues) */
-	return broken_suspend(hcd);
-}
-
-/* Apple's OHCI driver has a lot of bizarre workarounds
- * for this chip.  Evidently control and bulk lists
- * can get confused.  (B&W G3 models, and ...)
- */
-static int ohci_quirk_opti(struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-
-	ohci_dbg (ohci, "WARNING: OPTi workarounds unavailable\n");
-
-	return 0;
-}
-
-/* Check for NSC87560. We have to look at the bridge (fn1) to
- * identify the USB (fn2). This quirk might apply to more or
- * even all NSC stuff.
- */
-static int ohci_quirk_ns(struct usb_hcd *hcd)
-{
-	struct pci_dev *pdev = to_pci_dev(hcd->self.controller);
-	struct pci_dev	*b;
-
-	b  = pci_get_slot (pdev->bus, PCI_DEVFN (PCI_SLOT (pdev->devfn), 1));
-	if (b && b->device == PCI_DEVICE_ID_NS_87560_LIO
-	    && b->vendor == PCI_VENDOR_ID_NS) {
-		struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-
-		ohci->flags |= OHCI_QUIRK_SUPERIO;
-		ohci_dbg (ohci, "Using NSC SuperIO setup\n");
-	}
-	pci_dev_put(b);
-
-	return 0;
-}
-
-/* Check for Compaq's ZFMicro chipset, which needs short
- * delays before control or bulk queues get re-activated
- * in finish_unlinks()
- */
-static int ohci_quirk_zfmicro(struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-
-	ohci->flags |= OHCI_QUIRK_ZFMICRO;
-	ohci_dbg (ohci, "enabled Compaq ZFMicro chipset quirk\n");
-
-	return 0;
-}
-
-/* Check for Toshiba SCC OHCI which has big endian registers
- * and little endian in memory data structures
- */
-static int ohci_quirk_toshiba_scc(struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-
-	/* That chip is only present in the southbridge of some
-	 * cell based platforms which are supposed to select
-	 * CONFIG_USB_OHCI_BIG_ENDIAN_MMIO. We verify here if
-	 * that was the case though.
-	 */
-#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
-	ohci->flags |= OHCI_QUIRK_BE_MMIO;
-	ohci_dbg (ohci, "enabled big endian Toshiba quirk\n");
-	return 0;
-#else
-	ohci_err (ohci, "unsupported big endian Toshiba quirk\n");
-	return -ENXIO;
-#endif
-}
-
-/* Check for NEC chip and apply quirk for allegedly lost interrupts.
- */
-static int ohci_quirk_nec(struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-
-	ohci->flags |= OHCI_QUIRK_NEC;
-	ohci_dbg (ohci, "enabled NEC chipset lost interrupt quirk\n");
-
-	return 0;
-}
-
-/* List of quirks for OHCI */
-static const struct pci_device_id ohci_pci_quirks[] = {
-	{
-		PCI_DEVICE(PCI_VENDOR_ID_AMD, 0x740c),
-		.driver_data = (unsigned long)ohci_quirk_amd756,
-	},
-	{
-		PCI_DEVICE(PCI_VENDOR_ID_OPTI, 0xc861),
-		.driver_data = (unsigned long)ohci_quirk_opti,
-	},
-	{
-		PCI_DEVICE(PCI_VENDOR_ID_NS, PCI_ANY_ID),
-		.driver_data = (unsigned long)ohci_quirk_ns,
-	},
-	{
-		PCI_DEVICE(PCI_VENDOR_ID_COMPAQ, 0xa0f8),
-		.driver_data = (unsigned long)ohci_quirk_zfmicro,
-	},
-	{
-		PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA_2, 0x01b6),
-		.driver_data = (unsigned long)ohci_quirk_toshiba_scc,
-	},
-	{
-		PCI_DEVICE(PCI_VENDOR_ID_NEC, PCI_DEVICE_ID_NEC_USB),
-		.driver_data = (unsigned long)ohci_quirk_nec,
-	},
-	{
-		/* Toshiba portege 4000 */
-		.vendor		= PCI_VENDOR_ID_AL,
-		.device		= 0x5237,
-		.subvendor	= PCI_VENDOR_ID_TOSHIBA,
-		.subdevice	= 0x0004,
-		.driver_data	= (unsigned long) broken_suspend,
-	},
-	{
-		PCI_DEVICE(PCI_VENDOR_ID_ITE, 0x8152),
-		.driver_data = (unsigned long) broken_suspend,
-	},
-	/* FIXME for some of the early AMD 760 southbridges, OHCI
-	 * won't work at all.  blacklist them.
-	 */
-
-	{},
-};
-
-static int ohci_pci_reset (struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int ret = 0;
-
-	if (hcd->self.controller) {
-		struct pci_dev *pdev = to_pci_dev(hcd->self.controller);
-		const struct pci_device_id *quirk_id;
-
-		quirk_id = pci_match_id(ohci_pci_quirks, pdev);
-		if (quirk_id != NULL) {
-			int (*quirk)(struct usb_hcd *ohci);
-			quirk = (void *)quirk_id->driver_data;
-			ret = quirk(hcd);
-		}
-	}
-	if (ret == 0) {
-		ohci_hcd_init (ohci);
-		return ohci_init (ohci);
-	}
-	return ret;
-}
-
-
-static int __devinit ohci_pci_start (struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ret;
-
-#ifdef CONFIG_PM /* avoid warnings about unused pdev */
-	if (hcd->self.controller) {
-		struct pci_dev *pdev = to_pci_dev(hcd->self.controller);
-
-		/* RWC may not be set for add-in PCI cards, since boot
-		 * firmware probably ignored them.  This transfers PCI
-		 * PM wakeup capabilities (once the PCI layer is fixed).
-		 */
-		if (device_may_wakeup(&pdev->dev))
-			ohci->hc_control |= OHCI_CTRL_RWC;
-	}
-#endif /* CONFIG_PM */
-
-	ret = ohci_run (ohci);
-	if (ret < 0) {
-		ohci_err (ohci, "can't start\n");
-		ohci_stop (hcd);
-	}
-	return ret;
-}
-
-#if	defined(CONFIG_USB_PERSIST) && (defined(CONFIG_USB_EHCI_HCD) || \
-		defined(CONFIG_USB_EHCI_HCD_MODULE))
-
-/* Following a power loss, we must prepare to regain control of the ports
- * we used to own.  This means turning on the port power before ehci-hcd
- * tries to switch ownership.
- *
- * This isn't a 100% perfect solution.  On most systems the OHCI controllers
- * lie at lower PCI addresses than the EHCI controller, so they will be
- * discovered (and hence resumed) first.  But there is no guarantee things
- * will always work this way.  If the EHCI controller is resumed first and
- * the OHCI ports are unpowered, then the handover will fail.
- */
-static void prepare_for_handover(struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
-	int		port;
-
-	/* Here we "know" root ports should always stay powered */
-	ohci_dbg(ohci, "powerup ports\n");
-	for (port = 0; port < ohci->num_ports; port++)
-		ohci_writel(ohci, RH_PS_PPS,
-				&ohci->regs->roothub.portstatus[port]);
-
-	/* Flush those writes */
-	ohci_readl(ohci, &ohci->regs->control);
-	msleep(20);
-}
-
-#else
-
-static inline void prepare_for_handover(struct usb_hcd *hcd)
-{ }
-
-#endif	/* CONFIG_USB_PERSIST etc. */
-
-#ifdef	CONFIG_PM
-
-static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	unsigned long	flags;
-	int		rc = 0;
-
-	/* Root hub was already suspended. Disable irq emission and
-	 * mark HW unaccessible, bail out if RH has been resumed. Use
-	 * the spinlock to properly synchronize with possible pending
-	 * RH suspend or resume activity.
-	 *
-	 * This is still racy as hcd->state is manipulated outside of
-	 * any locks =P But that will be a different fix.
-	 */
-	spin_lock_irqsave (&ohci->lock, flags);
-	if (hcd->state != HC_STATE_SUSPENDED) {
-		rc = -EINVAL;
-		goto bail;
-	}
-	ohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
-	(void)ohci_readl(ohci, &ohci->regs->intrdisable);
-
-	/* make sure snapshot being resumed re-enumerates everything */
-	if (message.event == PM_EVENT_PRETHAW)
-		ohci_usb_reset(ohci);
-
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
- bail:
-	spin_unlock_irqrestore (&ohci->lock, flags);
-
-	return rc;
-}
-
-
-static int ohci_pci_resume (struct usb_hcd *hcd)
-{
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-
-	/* FIXME: we should try to detect loss of VBUS power here */
-	prepare_for_handover(hcd);
-
-	return 0;
-}
-
-#endif	/* CONFIG_PM */
-
-
-/*-------------------------------------------------------------------------*/
-
-static const struct hc_driver ohci_pci_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"OHCI Host Controller",
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ohci_irq,
-	.flags =		HCD_MEMORY | HCD_USB11,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset =		ohci_pci_reset,
-	.start =		ohci_pci_start,
-	.stop =			ohci_stop,
-	.shutdown =		ohci_shutdown,
-
-#ifdef	CONFIG_PM
-	/* these suspend/resume entries are for upstream PCI glue ONLY */
-	.suspend =		ohci_pci_suspend,
-	.resume =		ohci_pci_resume,
-#endif
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ohci_urb_enqueue,
-	.urb_dequeue =		ohci_urb_dequeue,
-	.endpoint_disable =	ohci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ohci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ohci_hub_status_data,
-	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
-#ifdef	CONFIG_PM
-	.bus_suspend =		ohci_bus_suspend,
-	.bus_resume =		ohci_bus_resume,
-#endif
-	.start_port_reset =	ohci_start_port_reset,
-};
-
-/*-------------------------------------------------------------------------*/
-
-
-static const struct pci_device_id pci_ids [] = { {
-	/* handle any USB OHCI controller */
-	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_OHCI, ~0),
-	.driver_data =	(unsigned long) &ohci_pci_hc_driver,
-	}, { /* end: all zeroes */ }
-};
-MODULE_DEVICE_TABLE (pci, pci_ids);
-
-/* pci driver glue; this is a "new style" PCI driver module */
-static struct pci_driver ohci_pci_driver = {
-	.name =		(char *) hcd_name,
-	.id_table =	pci_ids,
-
-	.probe =	usb_hcd_pci_probe,
-	.remove =	usb_hcd_pci_remove,
-
-#ifdef	CONFIG_PM
-	.suspend =	usb_hcd_pci_suspend,
-	.resume =	usb_hcd_pci_resume,
-#endif
-
-	.shutdown =	usb_hcd_pci_shutdown,
-};
-
diff -urN host/.svn/text-base/ohci-pnx4008.c.svn-base host.new/.svn/text-base/ohci-pnx4008.c.svn-base
--- host/.svn/text-base/ohci-pnx4008.c.svn-base	2009-02-24 19:00:15.839948091 +0100
+++ host.new/.svn/text-base/ohci-pnx4008.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,467 +0,0 @@
-/*
- * drivers/usb/host/ohci-pnx4008.c
- *
- * driver for Philips PNX4008 USB Host
- *
- * Authors: Dmitry Chigirev <source@mvista.com>
- *	    Vitaly Wool <vitalywool@gmail.com>
- *
- * register initialization is based on code examples provided by Philips
- * Copyright (c) 2005 Koninklijke Philips Electronics N.V.
- *
- * NOTE: This driver does not have suspend/resume functionality
- * This driver is intended for engineering development purposes only
- *
- * 2005-2006 (c) MontaVista Software, Inc. This file is licensed under
- * the terms of the GNU General Public License version 2. This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
- */
-#include <linux/clk.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-
-#include <asm/hardware.h>
-#include <asm/io.h>
-#include <asm/mach-types.h>
-
-#include <asm/arch/platform.h>
-#include <asm/arch/irqs.h>
-#include <asm/arch/gpio.h>
-
-#define USB_CTRL	IO_ADDRESS(PNX4008_PWRMAN_BASE + 0x64)
-
-/* USB_CTRL bit defines */
-#define USB_SLAVE_HCLK_EN	(1 << 24)
-#define USB_HOST_NEED_CLK_EN	(1 << 21)
-
-#define USB_OTG_CLK_CTRL	IO_ADDRESS(PNX4008_USB_CONFIG_BASE + 0xFF4)
-#define USB_OTG_CLK_STAT	IO_ADDRESS(PNX4008_USB_CONFIG_BASE + 0xFF8)
-
-/* USB_OTG_CLK_CTRL bit defines */
-#define AHB_M_CLOCK_ON		(1 << 4)
-#define OTG_CLOCK_ON		(1 << 3)
-#define I2C_CLOCK_ON		(1 << 2)
-#define DEV_CLOCK_ON		(1 << 1)
-#define HOST_CLOCK_ON		(1 << 0)
-
-#define USB_OTG_STAT_CONTROL	IO_ADDRESS(PNX4008_USB_CONFIG_BASE + 0x110)
-
-/* USB_OTG_STAT_CONTROL bit defines */
-#define TRANSPARENT_I2C_EN	(1 << 7)
-#define HOST_EN			(1 << 0)
-
-/* ISP1301 USB transceiver I2C registers */
-#define	ISP1301_MODE_CONTROL_1		0x04	/* u8 read, set, +1 clear */
-
-#define	MC1_SPEED_REG		(1 << 0)
-#define	MC1_SUSPEND_REG		(1 << 1)
-#define	MC1_DAT_SE0		(1 << 2)
-#define	MC1_TRANSPARENT		(1 << 3)
-#define	MC1_BDIS_ACON_EN	(1 << 4)
-#define	MC1_OE_INT_EN		(1 << 5)
-#define	MC1_UART_EN		(1 << 6)
-#define	MC1_MASK		0x7f
-
-#define	ISP1301_MODE_CONTROL_2		0x12	/* u8 read, set, +1 clear */
-
-#define	MC2_GLOBAL_PWR_DN	(1 << 0)
-#define	MC2_SPD_SUSP_CTRL	(1 << 1)
-#define	MC2_BI_DI		(1 << 2)
-#define	MC2_TRANSP_BDIR0	(1 << 3)
-#define	MC2_TRANSP_BDIR1	(1 << 4)
-#define	MC2_AUDIO_EN		(1 << 5)
-#define	MC2_PSW_EN		(1 << 6)
-#define	MC2_EN2V7		(1 << 7)
-
-#define	ISP1301_OTG_CONTROL_1		0x06	/* u8 read, set, +1 clear */
-#	define	OTG1_DP_PULLUP		(1 << 0)
-#	define	OTG1_DM_PULLUP		(1 << 1)
-#	define	OTG1_DP_PULLDOWN	(1 << 2)
-#	define	OTG1_DM_PULLDOWN	(1 << 3)
-#	define	OTG1_ID_PULLDOWN	(1 << 4)
-#	define	OTG1_VBUS_DRV		(1 << 5)
-#	define	OTG1_VBUS_DISCHRG	(1 << 6)
-#	define	OTG1_VBUS_CHRG		(1 << 7)
-#define	ISP1301_OTG_STATUS		0x10	/* u8 readonly */
-#	define	OTG_B_SESS_END		(1 << 6)
-#	define	OTG_B_SESS_VLD		(1 << 7)
-
-#define ISP1301_I2C_ADDR 0x2C
-
-#define ISP1301_I2C_MODE_CONTROL_1 0x4
-#define ISP1301_I2C_MODE_CONTROL_2 0x12
-#define ISP1301_I2C_OTG_CONTROL_1 0x6
-#define ISP1301_I2C_OTG_CONTROL_2 0x10
-#define ISP1301_I2C_INTERRUPT_SOURCE 0x8
-#define ISP1301_I2C_INTERRUPT_LATCH 0xA
-#define ISP1301_I2C_INTERRUPT_FALLING 0xC
-#define ISP1301_I2C_INTERRUPT_RISING 0xE
-#define ISP1301_I2C_REG_CLEAR_ADDR 1
-
-struct i2c_driver isp1301_driver;
-struct i2c_client *isp1301_i2c_client;
-
-extern int usb_disabled(void);
-extern int ocpi_enable(void);
-
-static struct clk *usb_clk;
-
-static int isp1301_probe(struct i2c_adapter *adap);
-static int isp1301_detach(struct i2c_client *client);
-static int isp1301_command(struct i2c_client *client, unsigned int cmd,
-			   void *arg);
-
-static unsigned short normal_i2c[] =
-    { ISP1301_I2C_ADDR, ISP1301_I2C_ADDR + 1, I2C_CLIENT_END };
-static unsigned short dummy_i2c_addrlist[] = { I2C_CLIENT_END };
-
-static struct i2c_client_address_data addr_data = {
-	.normal_i2c = normal_i2c,
-	.probe = dummy_i2c_addrlist,
-	.ignore = dummy_i2c_addrlist,
-};
-
-struct i2c_driver isp1301_driver = {
-	.id = I2C_DRIVERID_I2CDEV,	/* Fake Id */
-	.class = I2C_CLASS_HWMON,
-	.attach_adapter = isp1301_probe,
-	.detach_client = isp1301_detach,
-	.command = isp1301_command
-};
-
-static int isp1301_attach(struct i2c_adapter *adap, int addr, int kind)
-{
-	struct i2c_client *c;
-
-	c = kzalloc(sizeof(*c), GFP_KERNEL);
-
-	if (!c)
-		return -ENOMEM;
-
-	strcpy(c->name, "isp1301");
-	c->flags = 0;
-	c->addr = addr;
-	c->adapter = adap;
-	c->driver = &isp1301_driver;
-
-	isp1301_i2c_client = c;
-
-	return i2c_attach_client(c);
-}
-
-static int isp1301_probe(struct i2c_adapter *adap)
-{
-	return i2c_probe(adap, &addr_data, isp1301_attach);
-}
-
-static int isp1301_detach(struct i2c_client *client)
-{
-	i2c_detach_client(client);
-	kfree(isp1301_i2c_client);
-	return 0;
-}
-
-/* No commands defined */
-static int isp1301_command(struct i2c_client *client, unsigned int cmd,
-			   void *arg)
-{
-	return 0;
-}
-
-static void i2c_write(u8 buf, u8 subaddr)
-{
-	char tmpbuf[2];
-
-	tmpbuf[0] = subaddr;	/*register number */
-	tmpbuf[1] = buf;	/*register data */
-	i2c_master_send(isp1301_i2c_client, &tmpbuf[0], 2);
-}
-
-static void isp1301_configure(void)
-{
-	/* PNX4008 only supports DAT_SE0 USB mode */
-	/* PNX4008 R2A requires setting the MAX603 to output 3.6V */
-	/* Power up externel charge-pump */
-
-	i2c_write(MC1_DAT_SE0 | MC1_SPEED_REG, ISP1301_I2C_MODE_CONTROL_1);
-	i2c_write(~(MC1_DAT_SE0 | MC1_SPEED_REG),
-		  ISP1301_I2C_MODE_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR);
-	i2c_write(MC2_BI_DI | MC2_PSW_EN | MC2_SPD_SUSP_CTRL,
-		  ISP1301_I2C_MODE_CONTROL_2);
-	i2c_write(~(MC2_BI_DI | MC2_PSW_EN | MC2_SPD_SUSP_CTRL),
-		  ISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR);
-	i2c_write(OTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN,
-		  ISP1301_I2C_OTG_CONTROL_1);
-	i2c_write(~(OTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN),
-		  ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR);
-	i2c_write(0xFF,
-		  ISP1301_I2C_INTERRUPT_LATCH | ISP1301_I2C_REG_CLEAR_ADDR);
-	i2c_write(0xFF,
-		  ISP1301_I2C_INTERRUPT_FALLING | ISP1301_I2C_REG_CLEAR_ADDR);
-	i2c_write(0xFF,
-		  ISP1301_I2C_INTERRUPT_RISING | ISP1301_I2C_REG_CLEAR_ADDR);
-
-}
-
-static inline void isp1301_vbus_on(void)
-{
-	i2c_write(OTG1_VBUS_DRV, ISP1301_I2C_OTG_CONTROL_1);
-}
-
-static inline void isp1301_vbus_off(void)
-{
-	i2c_write(OTG1_VBUS_DRV,
-		  ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR);
-}
-
-static void pnx4008_start_hc(void)
-{
-	unsigned long tmp = __raw_readl(USB_OTG_STAT_CONTROL) | HOST_EN;
-	__raw_writel(tmp, USB_OTG_STAT_CONTROL);
-	isp1301_vbus_on();
-}
-
-static void pnx4008_stop_hc(void)
-{
-	unsigned long tmp;
-	isp1301_vbus_off();
-	tmp = __raw_readl(USB_OTG_STAT_CONTROL) & ~HOST_EN;
-	__raw_writel(tmp, USB_OTG_STAT_CONTROL);
-}
-
-static int __devinit ohci_pnx4008_start(struct usb_hcd *hcd)
-{
-	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
-	int ret;
-
-	if ((ret = ohci_init(ohci)) < 0)
-		return ret;
-
-	if ((ret = ohci_run(ohci)) < 0) {
-		dev_err(hcd->self.controller, "can't start\n");
-		ohci_stop(hcd);
-		return ret;
-	}
-	return 0;
-}
-
-static const struct hc_driver ohci_pnx4008_hc_driver = {
-	.description = hcd_name,
-	.product_desc =		"pnx4008 OHCI",
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq = ohci_irq,
-	.flags = HCD_USB11 | HCD_MEMORY,
-
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
-	/*
-	 * basic lifecycle operations
-	 */
-	.start = ohci_pnx4008_start,
-	.stop = ohci_stop,
-	.shutdown = ohci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue = ohci_urb_enqueue,
-	.urb_dequeue = ohci_urb_dequeue,
-	.endpoint_disable = ohci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number = ohci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data = ohci_hub_status_data,
-	.hub_control = ohci_hub_control,
-	.hub_irq_enable = ohci_rhsc_enable,
-#ifdef	CONFIG_PM
-	.bus_suspend = ohci_bus_suspend,
-	.bus_resume = ohci_bus_resume,
-#endif
-	.start_port_reset = ohci_start_port_reset,
-};
-
-#define USB_CLOCK_MASK (AHB_M_CLOCK_ON| OTG_CLOCK_ON | HOST_CLOCK_ON | I2C_CLOCK_ON)
-
-static void pnx4008_set_usb_bits(void)
-{
-	start_int_set_falling_edge(SE_USB_OTG_ATX_INT_N);
-	start_int_ack(SE_USB_OTG_ATX_INT_N);
-	start_int_umask(SE_USB_OTG_ATX_INT_N);
-
-	start_int_set_rising_edge(SE_USB_OTG_TIMER_INT);
-	start_int_ack(SE_USB_OTG_TIMER_INT);
-	start_int_umask(SE_USB_OTG_TIMER_INT);
-
-	start_int_set_rising_edge(SE_USB_I2C_INT);
-	start_int_ack(SE_USB_I2C_INT);
-	start_int_umask(SE_USB_I2C_INT);
-
-	start_int_set_rising_edge(SE_USB_INT);
-	start_int_ack(SE_USB_INT);
-	start_int_umask(SE_USB_INT);
-
-	start_int_set_rising_edge(SE_USB_NEED_CLK_INT);
-	start_int_ack(SE_USB_NEED_CLK_INT);
-	start_int_umask(SE_USB_NEED_CLK_INT);
-
-	start_int_set_rising_edge(SE_USB_AHB_NEED_CLK_INT);
-	start_int_ack(SE_USB_AHB_NEED_CLK_INT);
-	start_int_umask(SE_USB_AHB_NEED_CLK_INT);
-}
-
-static void pnx4008_unset_usb_bits(void)
-{
-	start_int_mask(SE_USB_OTG_ATX_INT_N);
-	start_int_mask(SE_USB_OTG_TIMER_INT);
-	start_int_mask(SE_USB_I2C_INT);
-	start_int_mask(SE_USB_INT);
-	start_int_mask(SE_USB_NEED_CLK_INT);
-	start_int_mask(SE_USB_AHB_NEED_CLK_INT);
-}
-
-static int __devinit usb_hcd_pnx4008_probe(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = 0;
-	struct ohci_hcd *ohci;
-	const struct hc_driver *driver = &ohci_pnx4008_hc_driver;
-
-	int ret = 0, irq;
-
-	dev_dbg(&pdev->dev, "%s: " DRIVER_INFO " (pnx4008)\n", hcd_name);
-	if (usb_disabled()) {
-		err("USB is disabled");
-		ret = -ENODEV;
-		goto out;
-	}
-
-	if (pdev->num_resources != 2
-	    || pdev->resource[0].flags != IORESOURCE_MEM
-	    || pdev->resource[1].flags != IORESOURCE_IRQ) {
-		err("Invalid resource configuration");
-		ret = -ENODEV;
-		goto out;
-	}
-
-	/* Enable AHB slave USB clock, needed for further USB clock control */
-	__raw_writel(USB_SLAVE_HCLK_EN | (1 << 19), USB_CTRL);
-
-	ret = i2c_add_driver(&isp1301_driver);
-	if (ret < 0) {
-		err("failed to connect I2C to ISP1301 USB Transceiver");
-		goto out;
-	}
-
-	isp1301_configure();
-
-	/* Enable USB PLL */
-	usb_clk = clk_get(&pdev->dev, "ck_pll5");
-	if (IS_ERR(usb_clk)) {
-		err("failed to acquire USB PLL");
-		ret = PTR_ERR(usb_clk);
-		goto out1;
-	}
-
-	ret = clk_enable(usb_clk);
-	if (ret < 0) {
-		err("failed to start USB PLL");
-		goto out2;
-	}
-
-	ret = clk_set_rate(usb_clk, 48000);
-	if (ret < 0) {
-		err("failed to set USB clock rate");
-		goto out3;
-	}
-
-	__raw_writel(__raw_readl(USB_CTRL) | USB_HOST_NEED_CLK_EN, USB_CTRL);
-
-	/* Set to enable all needed USB clocks */
-	__raw_writel(USB_CLOCK_MASK, USB_OTG_CLK_CTRL);
-
-	while ((__raw_readl(USB_OTG_CLK_STAT) & USB_CLOCK_MASK) !=
-	       USB_CLOCK_MASK) ;
-
-	hcd = usb_create_hcd (driver, &pdev->dev, pdev->dev.bus_id);
-	if (!hcd) {
-		err("Failed to allocate HC buffer");
-		ret = -ENOMEM;
-		goto out3;
-	}
-
-	/* Set all USB bits in the Start Enable register */
-	pnx4008_set_usb_bits();
-
-	hcd->rsrc_start = pdev->resource[0].start;
-	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		dev_dbg(&pdev->dev, "request_mem_region failed\n");
-		ret =  -ENOMEM;
-		goto out4;
-	}
-	hcd->regs = (void __iomem *)pdev->resource[0].start;
-
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		ret = -ENXIO;
-		goto out4;
-	}
-
-	pnx4008_start_hc();
-	platform_set_drvdata(pdev, hcd);
-	ohci = hcd_to_ohci(hcd);
-	ohci_hcd_init(ohci);
-
-	dev_info(&pdev->dev, "at 0x%p, irq %d\n", hcd->regs, hcd->irq);
-	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED);
-	if (ret == 0)
-		return ret;
-
-	pnx4008_stop_hc();
-out4:
-	pnx4008_unset_usb_bits();
-	usb_put_hcd(hcd);
-out3:
-	clk_disable(usb_clk);
-out2:
-	clk_put(usb_clk);
-out1:
-	i2c_del_driver(&isp1301_driver);
-out:
-	return ret;
-}
-
-static int usb_hcd_pnx4008_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	usb_remove_hcd(hcd);
-	pnx4008_stop_hc();
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-	pnx4008_unset_usb_bits();
-	clk_disable(usb_clk);
-	clk_put(usb_clk);
-	i2c_del_driver(&isp1301_driver);
-
-	platform_set_drvdata(pdev, NULL);
-
-	return 0;
-}
-
-static struct platform_driver usb_hcd_pnx4008_driver = {
-	.driver = {
-		.name = "usb-ohci",
-	},
-	.probe = usb_hcd_pnx4008_probe,
-	.remove = usb_hcd_pnx4008_remove,
-};
-
diff -urN host/.svn/text-base/ohci-pnx8550.c.svn-base host.new/.svn/text-base/ohci-pnx8550.c.svn-base
--- host/.svn/text-base/ohci-pnx8550.c.svn-base	2009-02-24 19:00:15.839948091 +0100
+++ host.new/.svn/text-base/ohci-pnx8550.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,242 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- * (C) Copyright 2002 Hewlett-Packard Company
- * (C) Copyright 2005 Embedded Alley Solutions, Inc.
- *
- * Bus Glue for PNX8550
- *
- * Written by Christopher Hoover <ch@hpl.hp.com>
- * Based on fragments of previous driver by Russell King et al.
- *
- * Modified for LH7A404 from ohci-sa1111.c
- *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
- *
- * Modified for PNX8550 from ohci-sa1111.c and sa-omap.c
- *  by Vitaly Wool <vitalywool@gmail.com>
- *
- * This file is licenced under the GPL.
- */
-
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <asm/mach-pnx8550/usb.h>
-#include <asm/mach-pnx8550/int.h>
-#include <asm/mach-pnx8550/pci.h>
-
-#ifndef CONFIG_PNX8550
-#error "This file is PNX8550 bus glue.  CONFIG_PNX8550 must be defined."
-#endif
-
-extern int usb_disabled(void);
-
-/*-------------------------------------------------------------------------*/
-
-static void pnx8550_start_hc(struct platform_device *dev)
-{
-	/*
-	 * Set register CLK48CTL to enable and 48MHz
-	 */
-	outl(0x00000003, PCI_BASE | 0x0004770c);
-
-	/*
-	 * Set register CLK12CTL to enable and 48MHz
-	 */
-	outl(0x00000003, PCI_BASE | 0x00047710);
-
-	udelay(100);
-}
-
-static void pnx8550_stop_hc(struct platform_device *dev)
-{
-	udelay(10);
-}
-
-
-/*-------------------------------------------------------------------------*/
-
-/* configure so an HC device and id are always provided */
-/* always called with process context; sleeping is OK */
-
-
-/**
- * usb_hcd_pnx8550_probe - initialize pnx8550-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- *
- */
-int usb_hcd_pnx8550_probe (const struct hc_driver *driver,
-			  struct platform_device *dev)
-{
-	int retval;
-	struct usb_hcd *hcd;
-
-	if (dev->resource[0].flags != IORESOURCE_MEM ||
-			dev->resource[1].flags != IORESOURCE_IRQ) {
-		dev_err (&dev->dev,"invalid resource type\n");
-		return -ENOMEM;
-	}
-
-	hcd = usb_create_hcd (driver, &dev->dev, "pnx8550");
-	if (!hcd)
-		return -ENOMEM;
-	hcd->rsrc_start = dev->resource[0].start;
-	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		dev_err(&dev->dev, "request_mem_region [0x%08llx, 0x%08llx] "
-				"failed\n", hcd->rsrc_start, hcd->rsrc_len);
-		retval = -EBUSY;
-		goto err1;
-	}
-
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-	if (!hcd->regs) {
-		dev_err(&dev->dev, "ioremap [[0x%08llx, 0x%08llx] failed\n",
-				hcd->rsrc_start, hcd->rsrc_len);
-		retval = -ENOMEM;
-		goto err2;
-	}
-
-	pnx8550_start_hc(dev);
-
-	ohci_hcd_init(hcd_to_ohci(hcd));
-
-	retval = usb_add_hcd(hcd, dev->resource[1].start, IRQF_DISABLED);
-	if (retval == 0)
-		return retval;
-
-	pnx8550_stop_hc(dev);
-	iounmap(hcd->regs);
- err2:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
- err1:
-	usb_put_hcd(hcd);
-	return retval;
-}
-
-
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_hcd_pnx8550_remove - shutdown processing for pnx8550-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_hcd_pnx8550_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
- */
-void usb_hcd_pnx8550_remove (struct usb_hcd *hcd, struct platform_device *dev)
-{
-	usb_remove_hcd(hcd);
-	pnx8550_stop_hc(dev);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int __devinit
-ohci_pnx8550_start (struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ret;
-
-	ohci_dbg (ohci, "ohci_pnx8550_start, ohci:%p", ohci);
-
-	if ((ret = ohci_init(ohci)) < 0)
-		return ret;
-
-	if ((ret = ohci_run (ohci)) < 0) {
-		err ("can't start %s", hcd->self.bus_name);
-		ohci_stop (hcd);
-		return ret;
-	}
-
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static const struct hc_driver ohci_pnx8550_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"PNX8550 OHCI",
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ohci_irq,
-	.flags =		HCD_USB11 | HCD_MEMORY,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.start =		ohci_pnx8550_start,
-	.stop =			ohci_stop,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ohci_urb_enqueue,
-	.urb_dequeue =		ohci_urb_dequeue,
-	.endpoint_disable =	ohci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ohci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ohci_hub_status_data,
-	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
-#ifdef	CONFIG_PM
-	.bus_suspend =		ohci_bus_suspend,
-	.bus_resume =		ohci_bus_resume,
-#endif
-	.start_port_reset =	ohci_start_port_reset,
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int ohci_hcd_pnx8550_drv_probe(struct platform_device *pdev)
-{
-	int ret;
-
-	if (usb_disabled())
-		return -ENODEV;
-
-	ret = usb_hcd_pnx8550_probe(&ohci_pnx8550_hc_driver, pdev);
-	return ret;
-}
-
-static int ohci_hcd_pnx8550_drv_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	usb_hcd_pnx8550_remove(hcd, pdev);
-	return 0;
-}
-
-MODULE_ALIAS("pnx8550-ohci");
-
-static struct platform_driver ohci_hcd_pnx8550_driver = {
-	.driver = {
-		.name		= "pnx8550-ohci",
-	},
-	.probe		= ohci_hcd_pnx8550_drv_probe,
-	.remove		= ohci_hcd_pnx8550_drv_remove,
-};
-
diff -urN host/.svn/text-base/ohci-ppc-of.c.svn-base host.new/.svn/text-base/ohci-ppc-of.c.svn-base
--- host/.svn/text-base/ohci-ppc-of.c.svn-base	2009-02-24 19:00:15.843947887 +0100
+++ host.new/.svn/text-base/ohci-ppc-of.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,232 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- * (C) Copyright 2002 Hewlett-Packard Company
- * (C) Copyright 2006 Sylvain Munaut <tnt@246tNt.com>
- *
- * Bus glue for OHCI HC on the of_platform bus
- *
- * Modified for of_platform bus from ohci-sa1111.c
- *
- * This file is licenced under the GPL.
- */
-
-#include <linux/signal.h>
-
-#include <asm/of_platform.h>
-#include <asm/prom.h>
-
-
-static int __devinit
-ohci_ppc_of_start(struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
-	int		ret;
-
-	if ((ret = ohci_init(ohci)) < 0)
-		return ret;
-
-	if ((ret = ohci_run(ohci)) < 0) {
-		err("can't start %s", ohci_to_hcd(ohci)->self.bus_name);
-		ohci_stop(hcd);
-		return ret;
-	}
-
-	return 0;
-}
-
-static const struct hc_driver ohci_ppc_of_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"OF OHCI",
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ohci_irq,
-	.flags =		HCD_USB11 | HCD_MEMORY,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.start =		ohci_ppc_of_start,
-	.stop =			ohci_stop,
-	.shutdown = 		ohci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ohci_urb_enqueue,
-	.urb_dequeue =		ohci_urb_dequeue,
-	.endpoint_disable =	ohci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ohci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ohci_hub_status_data,
-	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
-#ifdef	CONFIG_PM
-	.bus_suspend =		ohci_bus_suspend,
-	.bus_resume =		ohci_bus_resume,
-#endif
-	.start_port_reset =	ohci_start_port_reset,
-};
-
-
-static int __devinit
-ohci_hcd_ppc_of_probe(struct of_device *op, const struct of_device_id *match)
-{
-	struct device_node *dn = op->node;
-	struct usb_hcd *hcd;
-	struct ohci_hcd	*ohci;
-	struct resource res;
-	int irq;
-
-	int rv;
-	int is_bigendian;
-
-	if (usb_disabled())
-		return -ENODEV;
-
-	is_bigendian =
-		of_device_is_compatible(dn, "ohci-bigendian") ||
-		of_device_is_compatible(dn, "ohci-be");
-
-	dev_dbg(&op->dev, "initializing PPC-OF USB Controller\n");
-
-	rv = of_address_to_resource(dn, 0, &res);
-	if (rv)
-		return rv;
-
-	hcd = usb_create_hcd(&ohci_ppc_of_hc_driver, &op->dev, "PPC-OF USB");
-	if (!hcd)
-		return -ENOMEM;
-
-	hcd->rsrc_start = res.start;
-	hcd->rsrc_len = res.end - res.start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		printk(KERN_ERR __FILE__ ": request_mem_region failed\n");
-		rv = -EBUSY;
-		goto err_rmr;
-	}
-
-	irq = irq_of_parse_and_map(dn, 0);
-	if (irq == NO_IRQ) {
-		printk(KERN_ERR __FILE__ ": irq_of_parse_and_map failed\n");
-		rv = -EBUSY;
-		goto err_irq;
-	}
-
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-	if (!hcd->regs) {
-		printk(KERN_ERR __FILE__ ": ioremap failed\n");
-		rv = -ENOMEM;
-		goto err_ioremap;
-	}
-
-	ohci = hcd_to_ohci(hcd);
-	if (is_bigendian)
-		ohci->flags |= OHCI_QUIRK_BE_MMIO | OHCI_QUIRK_BE_DESC;
-
-	ohci_hcd_init(ohci);
-
-	rv = usb_add_hcd(hcd, irq, 0);
-	if (rv == 0)
-		return 0;
-
-	iounmap(hcd->regs);
-err_ioremap:
-	irq_dispose_mapping(irq);
-err_irq:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-err_rmr:
- 	usb_put_hcd(hcd);
-
-	return rv;
-}
-
-static int ohci_hcd_ppc_of_remove(struct of_device *op)
-{
-	struct usb_hcd *hcd = dev_get_drvdata(&op->dev);
-	dev_set_drvdata(&op->dev, NULL);
-
-	dev_dbg(&op->dev, "stopping PPC-OF USB Controller\n");
-
-	usb_remove_hcd(hcd);
-
-	iounmap(hcd->regs);
-	irq_dispose_mapping(hcd->irq);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-
-	usb_put_hcd(hcd);
-
-	return 0;
-}
-
-static int ohci_hcd_ppc_of_shutdown(struct of_device *op)
-{
-	struct usb_hcd *hcd = dev_get_drvdata(&op->dev);
-
-        if (hcd->driver->shutdown)
-                hcd->driver->shutdown(hcd);
-
-	return 0;
-}
-
-
-static struct of_device_id ohci_hcd_ppc_of_match[] = {
-#ifdef CONFIG_USB_OHCI_HCD_PPC_OF_BE
-	{
-		.name = "usb",
-		.compatible = "ohci-bigendian",
-	},
-	{
-		.name = "usb",
-		.compatible = "ohci-be",
-	},
-#endif
-#ifdef CONFIG_USB_OHCI_HCD_PPC_OF_LE
-	{
-		.name = "usb",
-		.compatible = "ohci-littledian",
-	},
-	{
-		.name = "usb",
-		.compatible = "ohci-le",
-	},
-#endif
-	{},
-};
-MODULE_DEVICE_TABLE(of, ohci_hcd_ppc_of_match);
-
-#if	!defined(CONFIG_USB_OHCI_HCD_PPC_OF_BE) && \
-	!defined(CONFIG_USB_OHCI_HCD_PPC_OF_LE)
-#error "No endianess selected for ppc-of-ohci"
-#endif
-
-
-static struct of_platform_driver ohci_hcd_ppc_of_driver = {
-	.name		= "ppc-of-ohci",
-	.match_table	= ohci_hcd_ppc_of_match,
-	.probe		= ohci_hcd_ppc_of_probe,
-	.remove		= ohci_hcd_ppc_of_remove,
-	.shutdown 	= ohci_hcd_ppc_of_shutdown,
-#ifdef CONFIG_PM
-	/*.suspend	= ohci_hcd_ppc_soc_drv_suspend,*/
-	/*.resume	= ohci_hcd_ppc_soc_drv_resume,*/
-#endif
-	.driver		= {
-		.name	= "ppc-of-ohci",
-		.owner	= THIS_MODULE,
-	},
-};
-
diff -urN host/.svn/text-base/ohci-ppc-soc.c.svn-base host.new/.svn/text-base/ohci-ppc-soc.c.svn-base
--- host/.svn/text-base/ohci-ppc-soc.c.svn-base	2009-02-24 19:00:15.843947887 +0100
+++ host.new/.svn/text-base/ohci-ppc-soc.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,210 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- * (C) Copyright 2002 Hewlett-Packard Company
- * (C) Copyright 2003-2005 MontaVista Software Inc.
- *
- * Bus Glue for PPC On-Chip OHCI driver
- * Tested on Freescale MPC5200 and IBM STB04xxx
- *
- * Modified by Dale Farnsworth <dale@farnsworth.org> from ohci-sa1111.c
- *
- * This file is licenced under the GPL.
- */
-
-#include <linux/platform_device.h>
-#include <linux/signal.h>
-
-/* configure so an HC device and id are always provided */
-/* always called with process context; sleeping is OK */
-
-/**
- * usb_hcd_ppc_soc_probe - initialize On-Chip HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller.
- *
- * Store this function in the HCD's struct pci_driver as probe().
- */
-static int usb_hcd_ppc_soc_probe(const struct hc_driver *driver,
-			  struct platform_device *pdev)
-{
-	int retval;
-	struct usb_hcd *hcd;
-	struct ohci_hcd	*ohci;
-	struct resource *res;
-	int irq;
-
-	pr_debug("initializing PPC-SOC USB Controller\n");
-
-	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (!res) {
-		pr_debug(__FILE__ ": no irq\n");
-		return -ENODEV;
-	}
-	irq = res->start;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		pr_debug(__FILE__ ": no reg addr\n");
-		return -ENODEV;
-	}
-
-	hcd = usb_create_hcd(driver, &pdev->dev, "PPC-SOC USB");
-	if (!hcd)
-		return -ENOMEM;
-	hcd->rsrc_start = res->start;
-	hcd->rsrc_len = res->end - res->start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		pr_debug(__FILE__ ": request_mem_region failed\n");
-		retval = -EBUSY;
-		goto err1;
-	}
-
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-	if (!hcd->regs) {
-		pr_debug(__FILE__ ": ioremap failed\n");
-		retval = -ENOMEM;
-		goto err2;
-	}
-
-	ohci = hcd_to_ohci(hcd);
-	ohci->flags |= OHCI_QUIRK_BE_MMIO | OHCI_QUIRK_BE_DESC;
-	ohci_hcd_init(ohci);
-
-	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED);
-	if (retval == 0)
-		return retval;
-
-	pr_debug("Removing PPC-SOC USB Controller\n");
-
-	iounmap(hcd->regs);
- err2:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
- err1:
-	usb_put_hcd(hcd);
-	return retval;
-}
-
-
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_hcd_ppc_soc_remove - shutdown processing for On-Chip HCDs
- * @pdev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_hcd_ppc_soc_probe().
- * It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
- */
-static void usb_hcd_ppc_soc_remove(struct usb_hcd *hcd,
-		struct platform_device *pdev)
-{
-	usb_remove_hcd(hcd);
-
-	pr_debug("stopping PPC-SOC USB Controller\n");
-
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-}
-
-static int __devinit
-ohci_ppc_soc_start(struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
-	int		ret;
-
-	if ((ret = ohci_init(ohci)) < 0)
-		return ret;
-
-	if ((ret = ohci_run(ohci)) < 0) {
-		err("can't start %s", ohci_to_hcd(ohci)->self.bus_name);
-		ohci_stop(hcd);
-		return ret;
-	}
-
-	return 0;
-}
-
-static const struct hc_driver ohci_ppc_soc_hc_driver = {
-	.description =		hcd_name,
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ohci_irq,
-	.flags =		HCD_USB11 | HCD_MEMORY,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.start =		ohci_ppc_soc_start,
-	.stop =			ohci_stop,
-	.shutdown =		ohci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ohci_urb_enqueue,
-	.urb_dequeue =		ohci_urb_dequeue,
-	.endpoint_disable =	ohci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ohci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ohci_hub_status_data,
-	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
-#ifdef	CONFIG_PM
-	.bus_suspend =		ohci_bus_suspend,
-	.bus_resume =		ohci_bus_resume,
-#endif
-	.start_port_reset =	ohci_start_port_reset,
-};
-
-static int ohci_hcd_ppc_soc_drv_probe(struct platform_device *pdev)
-{
-	int ret;
-
-	if (usb_disabled())
-		return -ENODEV;
-
-	ret = usb_hcd_ppc_soc_probe(&ohci_ppc_soc_hc_driver, pdev);
-	return ret;
-}
-
-static int ohci_hcd_ppc_soc_drv_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	usb_hcd_ppc_soc_remove(hcd, pdev);
-	return 0;
-}
-
-static struct platform_driver ohci_hcd_ppc_soc_driver = {
-	.probe		= ohci_hcd_ppc_soc_drv_probe,
-	.remove		= ohci_hcd_ppc_soc_drv_remove,
-	.shutdown	= usb_hcd_platform_shutdown,
-#ifdef	CONFIG_PM
-	/*.suspend	= ohci_hcd_ppc_soc_drv_suspend,*/
-	/*.resume	= ohci_hcd_ppc_soc_drv_resume,*/
-#endif
-	.driver		= {
-		.name	= "ppc-soc-ohci",
-		.owner	= THIS_MODULE,
-	},
-};
-
diff -urN host/.svn/text-base/ohci-ps3.c.svn-base host.new/.svn/text-base/ohci-ps3.c.svn-base
--- host/.svn/text-base/ohci-ps3.c.svn-base	2009-02-24 19:00:15.843947887 +0100
+++ host.new/.svn/text-base/ohci-ps3.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,251 +0,0 @@
-/*
- *  PS3 OHCI Host Controller driver
- *
- *  Copyright (C) 2006 Sony Computer Entertainment Inc.
- *  Copyright 2006 Sony Corp.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <asm/firmware.h>
-#include <asm/ps3.h>
-
-static int ps3_ohci_hc_reset(struct usb_hcd *hcd)
-{
-	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
-
-	ohci->flags |= OHCI_QUIRK_BE_MMIO;
-	ohci_hcd_init(ohci);
-	return ohci_init(ohci);
-}
-
-static int __devinit ps3_ohci_hc_start(struct usb_hcd *hcd)
-{
-	int result;
-	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
-
-	/* Handle root hub init quirk in spider south bridge. */
-	/* Also set PwrOn2PwrGood to 0x7f (254ms). */
-
-	ohci_writel(ohci, 0x7f000000 | RH_A_PSM | RH_A_OCPM,
-		&ohci->regs->roothub.a);
-	ohci_writel(ohci, 0x00060000, &ohci->regs->roothub.b);
-
-	result = ohci_run(ohci);
-
-	if (result < 0) {
-		err("can't start %s", hcd->self.bus_name);
-		ohci_stop(hcd);
-	}
-
-	return result;
-}
-
-static const struct hc_driver ps3_ohci_hc_driver = {
-	.description		= hcd_name,
-	.product_desc		= "PS3 OHCI Host Controller",
-	.hcd_priv_size		= sizeof(struct ohci_hcd),
-	.irq			= ohci_irq,
-	.flags			= HCD_MEMORY | HCD_USB11,
-	.reset			= ps3_ohci_hc_reset,
-	.start			= ps3_ohci_hc_start,
-	.stop			= ohci_stop,
-	.shutdown		= ohci_shutdown,
-	.urb_enqueue		= ohci_urb_enqueue,
-	.urb_dequeue		= ohci_urb_dequeue,
-	.endpoint_disable	= ohci_endpoint_disable,
-	.get_frame_number	= ohci_get_frame,
-	.hub_status_data	= ohci_hub_status_data,
-	.hub_control		= ohci_hub_control,
-	.hub_irq_enable		= ohci_rhsc_enable,
-	.start_port_reset	= ohci_start_port_reset,
-#if defined(CONFIG_PM)
-	.bus_suspend 		= ohci_bus_suspend,
-	.bus_resume 		= ohci_bus_resume,
-#endif
-};
-
-static int ps3_ohci_probe(struct ps3_system_bus_device *dev)
-{
-	int result;
-	struct usb_hcd *hcd;
-	unsigned int virq;
-	static u64 dummy_mask = DMA_32BIT_MASK;
-
-	if (usb_disabled()) {
-		result = -ENODEV;
-		goto fail_start;
-	}
-
-	result = ps3_open_hv_device(dev);
-
-	if (result) {
-		dev_dbg(&dev->core, "%s:%d: ps3_open_hv_device failed: %s\n",
-			__func__, __LINE__, ps3_result(result));
-		result = -EPERM;
-		goto fail_open;
-	}
-
-	result = ps3_dma_region_create(dev->d_region);
-
-	if (result) {
-		dev_dbg(&dev->core, "%s:%d: ps3_dma_region_create failed: "
-			"(%d)\n", __func__, __LINE__, result);
-		BUG_ON("check region type");
-		goto fail_dma_region;
-	}
-
-	result = ps3_mmio_region_create(dev->m_region);
-
-	if (result) {
-		dev_dbg(&dev->core, "%s:%d: ps3_map_mmio_region failed\n",
-			__func__, __LINE__);
-		result = -EPERM;
-		goto fail_mmio_region;
-	}
-
-	dev_dbg(&dev->core, "%s:%d: mmio mapped_addr %lxh\n", __func__,
-		__LINE__, dev->m_region->lpar_addr);
-
-	result = ps3_io_irq_setup(PS3_BINDING_CPU_ANY, dev->interrupt_id, &virq);
-
-	if (result) {
-		dev_dbg(&dev->core, "%s:%d: ps3_construct_io_irq(%d) failed.\n",
-			__func__, __LINE__, virq);
-		result = -EPERM;
-		goto fail_irq;
-	}
-
-	dev->core.power.power_state = PMSG_ON;
-	dev->core.dma_mask = &dummy_mask; /* FIXME: for improper usb code */
-
-	hcd = usb_create_hcd(&ps3_ohci_hc_driver, &dev->core, dev->core.bus_id);
-
-	if (!hcd) {
-		dev_dbg(&dev->core, "%s:%d: usb_create_hcd failed\n", __func__,
-			__LINE__);
-		result = -ENOMEM;
-		goto fail_create_hcd;
-	}
-
-	hcd->rsrc_start = dev->m_region->lpar_addr;
-	hcd->rsrc_len = dev->m_region->len;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name))
-		dev_dbg(&dev->core, "%s:%d: request_mem_region failed\n",
-			__func__, __LINE__);
-
-	hcd->regs = ioremap(dev->m_region->lpar_addr, dev->m_region->len);
-
-	if (!hcd->regs) {
-		dev_dbg(&dev->core, "%s:%d: ioremap failed\n", __func__,
-			__LINE__);
-		result = -EPERM;
-		goto fail_ioremap;
-	}
-
-	dev_dbg(&dev->core, "%s:%d: hcd->rsrc_start %lxh\n", __func__, __LINE__,
-		(unsigned long)hcd->rsrc_start);
-	dev_dbg(&dev->core, "%s:%d: hcd->rsrc_len   %lxh\n", __func__, __LINE__,
-		(unsigned long)hcd->rsrc_len);
-	dev_dbg(&dev->core, "%s:%d: hcd->regs       %lxh\n", __func__, __LINE__,
-		(unsigned long)hcd->regs);
-	dev_dbg(&dev->core, "%s:%d: virq            %lu\n", __func__, __LINE__,
-		(unsigned long)virq);
-
-	ps3_system_bus_set_driver_data(dev, hcd);
-
-	result = usb_add_hcd(hcd, virq, IRQF_DISABLED);
-
-	if (result) {
-		dev_dbg(&dev->core, "%s:%d: usb_add_hcd failed (%d)\n",
-			__func__, __LINE__, result);
-		goto fail_add_hcd;
-	}
-
-	return result;
-
-fail_add_hcd:
-	iounmap(hcd->regs);
-fail_ioremap:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-fail_create_hcd:
-	ps3_io_irq_destroy(virq);
-fail_irq:
-	ps3_free_mmio_region(dev->m_region);
-fail_mmio_region:
-	ps3_dma_region_free(dev->d_region);
-fail_dma_region:
-	ps3_close_hv_device(dev);
-fail_open:
-fail_start:
-	return result;
-}
-
-static int ps3_ohci_remove (struct ps3_system_bus_device *dev)
-{
-	unsigned int tmp;
-	struct usb_hcd *hcd =
-		(struct usb_hcd *)ps3_system_bus_get_driver_data(dev);
-
-	BUG_ON(!hcd);
-
-	dev_dbg(&dev->core, "%s:%d: regs %p\n", __func__, __LINE__, hcd->regs);
-	dev_dbg(&dev->core, "%s:%d: irq %u\n", __func__, __LINE__, hcd->irq);
-
-	tmp = hcd->irq;
-
-	usb_remove_hcd(hcd);
-
-	ps3_system_bus_set_driver_data(dev, NULL);
-
-	BUG_ON(!hcd->regs);
-	iounmap(hcd->regs);
-
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-
-	ps3_io_irq_destroy(tmp);
-	ps3_free_mmio_region(dev->m_region);
-
-	ps3_dma_region_free(dev->d_region);
-	ps3_close_hv_device(dev);
-
-	return 0;
-}
-
-static int ps3_ohci_driver_register(struct ps3_system_bus_driver *drv)
-{
-	return firmware_has_feature(FW_FEATURE_PS3_LV1)
-		? ps3_system_bus_driver_register(drv)
-		: 0;
-}
-
-static void ps3_ohci_driver_unregister(struct ps3_system_bus_driver *drv)
-{
-	if (firmware_has_feature(FW_FEATURE_PS3_LV1))
-		ps3_system_bus_driver_unregister(drv);
-}
-
-MODULE_ALIAS(PS3_MODULE_ALIAS_OHCI);
-
-static struct ps3_system_bus_driver ps3_ohci_driver = {
-	.core.name = "ps3-ohci-driver",
-	.core.owner = THIS_MODULE,
-	.match_id = PS3_MATCH_ID_OHCI,
-	.probe = ps3_ohci_probe,
-	.remove = ps3_ohci_remove,
-	.shutdown = ps3_ohci_remove,
-};
diff -urN host/.svn/text-base/ohci-pxa27x.c.svn-base host.new/.svn/text-base/ohci-pxa27x.c.svn-base
--- host/.svn/text-base/ohci-pxa27x.c.svn-base	2009-02-24 19:00:15.855947278 +0100
+++ host.new/.svn/text-base/ohci-pxa27x.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,371 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- * (C) Copyright 2002 Hewlett-Packard Company
- *
- * Bus Glue for pxa27x
- *
- * Written by Christopher Hoover <ch@hpl.hp.com>
- * Based on fragments of previous driver by Russell King et al.
- *
- * Modified for LH7A404 from ohci-sa1111.c
- *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
- *
- * Modified for pxa27x from ohci-lh7a404.c
- *  by Nick Bane <nick@cecomputing.co.uk> 26-8-2004
- *
- * This file is licenced under the GPL.
- */
-
-#include <linux/device.h>
-#include <linux/signal.h>
-#include <linux/platform_device.h>
-
-#include <asm/mach-types.h>
-#include <asm/hardware.h>
-#include <asm/arch/pxa-regs.h>
-#include <asm/arch/ohci.h>
-
-#define PXA_UHC_MAX_PORTNUM    3
-
-#define UHCRHPS(x)              __REG2( 0x4C000050, (x)<<2 )
-
-/*
-  PMM_NPS_MODE -- PMM Non-power switching mode
-      Ports are powered continuously.
-
-  PMM_GLOBAL_MODE -- PMM global switching mode
-      All ports are powered at the same time.
-
-  PMM_PERPORT_MODE -- PMM per port switching mode
-      Ports are powered individually.
- */
-static int pxa27x_ohci_select_pmm( int mode )
-{
-	switch ( mode ) {
-	case PMM_NPS_MODE:
-		UHCRHDA |= RH_A_NPS;
-		break;
-	case PMM_GLOBAL_MODE:
-		UHCRHDA &= ~(RH_A_NPS & RH_A_PSM);
-		break;
-	case PMM_PERPORT_MODE:
-		UHCRHDA &= ~(RH_A_NPS);
-		UHCRHDA |= RH_A_PSM;
-
-		/* Set port power control mask bits, only 3 ports. */
-		UHCRHDB |= (0x7<<17);
-		break;
-	default:
-		printk( KERN_ERR
-			"Invalid mode %d, set to non-power switch mode.\n",
-			mode );
-
-		UHCRHDA |= RH_A_NPS;
-	}
-
-	return 0;
-}
-
-extern int usb_disabled(void);
-
-/*-------------------------------------------------------------------------*/
-
-static int pxa27x_start_hc(struct device *dev)
-{
-	int retval = 0;
-	struct pxaohci_platform_data *inf;
-
-	inf = dev->platform_data;
-
-	pxa_set_cken(CKEN_USBHOST, 1);
-
-	UHCHR |= UHCHR_FHR;
-	udelay(11);
-	UHCHR &= ~UHCHR_FHR;
-
-	UHCHR |= UHCHR_FSBIR;
-	while (UHCHR & UHCHR_FSBIR)
-		cpu_relax();
-
-	if (inf->init)
-		retval = inf->init(dev);
-
-	if (retval < 0)
-		return retval;
-
-	UHCHR &= ~UHCHR_SSE;
-
-	UHCHIE = (UHCHIE_UPRIE | UHCHIE_RWIE);
-
-	/* Clear any OTG Pin Hold */
-	if (PSSR & PSSR_OTGPH)
-		PSSR |= PSSR_OTGPH;
-
-	return 0;
-}
-
-static void pxa27x_stop_hc(struct device *dev)
-{
-	struct pxaohci_platform_data *inf;
-
-	inf = dev->platform_data;
-
-	if (inf->exit)
-		inf->exit(dev);
-
-	UHCHR |= UHCHR_FHR;
-	udelay(11);
-	UHCHR &= ~UHCHR_FHR;
-
-	UHCCOMS |= 1;
-	udelay(10);
-
-	pxa_set_cken(CKEN_USBHOST, 0);
-}
-
-
-/*-------------------------------------------------------------------------*/
-
-/* configure so an HC device and id are always provided */
-/* always called with process context; sleeping is OK */
-
-
-/**
- * usb_hcd_pxa27x_probe - initialize pxa27x-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- *
- */
-int usb_hcd_pxa27x_probe (const struct hc_driver *driver, struct platform_device *pdev)
-{
-	int retval;
-	struct usb_hcd *hcd;
-	struct pxaohci_platform_data *inf;
-
-	inf = pdev->dev.platform_data;
-
-	if (!inf)
-		return -ENODEV;
-
-	if (pdev->resource[1].flags != IORESOURCE_IRQ) {
-		pr_debug ("resource[1] is not IORESOURCE_IRQ");
-		return -ENOMEM;
-	}
-
-	hcd = usb_create_hcd (driver, &pdev->dev, "pxa27x");
-	if (!hcd)
-		return -ENOMEM;
-	hcd->rsrc_start = pdev->resource[0].start;
-	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		pr_debug("request_mem_region failed");
-		retval = -EBUSY;
-		goto err1;
-	}
-
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-	if (!hcd->regs) {
-		pr_debug("ioremap failed");
-		retval = -ENOMEM;
-		goto err2;
-	}
-
-	if ((retval = pxa27x_start_hc(&pdev->dev)) < 0) {
-		pr_debug("pxa27x_start_hc failed");
-		goto err3;
-	}
-
-	/* Select Power Management Mode */
-	pxa27x_ohci_select_pmm(inf->port_mode);
-
-	if (inf->power_budget)
-		hcd->power_budget = inf->power_budget;
-
-	ohci_hcd_init(hcd_to_ohci(hcd));
-
-	retval = usb_add_hcd(hcd, pdev->resource[1].start, IRQF_DISABLED);
-	if (retval == 0)
-		return retval;
-
-	pxa27x_stop_hc(&pdev->dev);
- err3:
-	iounmap(hcd->regs);
- err2:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
- err1:
-	usb_put_hcd(hcd);
-	return retval;
-}
-
-
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_hcd_pxa27x_remove - shutdown processing for pxa27x-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_hcd_pxa27x_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
- */
-void usb_hcd_pxa27x_remove (struct usb_hcd *hcd, struct platform_device *pdev)
-{
-	usb_remove_hcd(hcd);
-	pxa27x_stop_hc(&pdev->dev);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int __devinit
-ohci_pxa27x_start (struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ret;
-
-	ohci_dbg (ohci, "ohci_pxa27x_start, ohci:%p", ohci);
-
-	/* The value of NDP in roothub_a is incorrect on this hardware */
-	ohci->num_ports = 3;
-
-	if ((ret = ohci_init(ohci)) < 0)
-		return ret;
-
-	if ((ret = ohci_run (ohci)) < 0) {
-		err ("can't start %s", hcd->self.bus_name);
-		ohci_stop (hcd);
-		return ret;
-	}
-
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static const struct hc_driver ohci_pxa27x_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"PXA27x OHCI",
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ohci_irq,
-	.flags =		HCD_USB11 | HCD_MEMORY,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.start =		ohci_pxa27x_start,
-	.stop =			ohci_stop,
-	.shutdown =		ohci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ohci_urb_enqueue,
-	.urb_dequeue =		ohci_urb_dequeue,
-	.endpoint_disable =	ohci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ohci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ohci_hub_status_data,
-	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
-#ifdef  CONFIG_PM
-	.bus_suspend =		ohci_bus_suspend,
-	.bus_resume =		ohci_bus_resume,
-#endif
-	.start_port_reset =	ohci_start_port_reset,
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int ohci_hcd_pxa27x_drv_probe(struct platform_device *pdev)
-{
-	pr_debug ("In ohci_hcd_pxa27x_drv_probe");
-
-	if (usb_disabled())
-		return -ENODEV;
-
-	return usb_hcd_pxa27x_probe(&ohci_pxa27x_hc_driver, pdev);
-}
-
-static int ohci_hcd_pxa27x_drv_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	usb_hcd_pxa27x_remove(hcd, pdev);
-	platform_set_drvdata(pdev, NULL);
-	return 0;
-}
-
-#ifdef	CONFIG_PM
-static int ohci_hcd_pxa27x_drv_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
-
-	if (time_before(jiffies, ohci->next_statechange))
-		msleep(5);
-	ohci->next_statechange = jiffies;
-
-	pxa27x_stop_hc(&pdev->dev);
-	hcd->state = HC_STATE_SUSPENDED;
-	pdev->dev.power.power_state = PMSG_SUSPEND;
-
-	return 0;
-}
-
-static int ohci_hcd_pxa27x_drv_resume(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
-	int status;
-
-	if (time_before(jiffies, ohci->next_statechange))
-		msleep(5);
-	ohci->next_statechange = jiffies;
-
-	if ((status = pxa27x_start_hc(&pdev->dev)) < 0)
-		return status;
-
-	pdev->dev.power.power_state = PMSG_ON;
-	usb_hcd_resume_root_hub(hcd);
-
-	return 0;
-}
-#endif
-
-
-static struct platform_driver ohci_hcd_pxa27x_driver = {
-	.probe		= ohci_hcd_pxa27x_drv_probe,
-	.remove		= ohci_hcd_pxa27x_drv_remove,
-	.shutdown	= usb_hcd_platform_shutdown,
-#ifdef CONFIG_PM
-	.suspend	= ohci_hcd_pxa27x_drv_suspend,
-	.resume		= ohci_hcd_pxa27x_drv_resume,
-#endif
-	.driver		= {
-		.name	= "pxa27x-ohci",
-	},
-};
-
diff -urN host/.svn/text-base/ohci-q.c.svn-base host.new/.svn/text-base/ohci-q.c.svn-base
--- host/.svn/text-base/ohci-q.c.svn-base	2009-02-24 19:00:15.871946464 +0100
+++ host.new/.svn/text-base/ohci-q.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,1117 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- *
- * This file is licenced under the GPL.
- */
-
-#include <linux/irq.h>
-
-static void urb_free_priv (struct ohci_hcd *hc, urb_priv_t *urb_priv)
-{
-	int		last = urb_priv->length - 1;
-
-	if (last >= 0) {
-		int		i;
-		struct td	*td;
-
-		for (i = 0; i <= last; i++) {
-			td = urb_priv->td [i];
-			if (td)
-				td_free (hc, td);
-		}
-	}
-
-	list_del (&urb_priv->pending);
-	kfree (urb_priv);
-}
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * URB goes back to driver, and isn't reissued.
- * It's completely gone from HC data structures.
- * PRECONDITION:  ohci lock held, irqs blocked.
- */
-static void
-finish_urb (struct ohci_hcd *ohci, struct urb *urb)
-__releases(ohci->lock)
-__acquires(ohci->lock)
-{
-	// ASSERT (urb->hcpriv != 0);
-
-	urb_free_priv (ohci, urb->hcpriv);
-	urb->hcpriv = NULL;
-
-	spin_lock (&urb->lock);
-	if (likely (urb->status == -EINPROGRESS))
-		urb->status = 0;
-	/* report short control reads right even though the data TD always
-	 * has TD_R set.  (much simpler, but creates the 1-td limit.)
-	 */
-	if (unlikely (urb->transfer_flags & URB_SHORT_NOT_OK)
-			&& unlikely (usb_pipecontrol (urb->pipe))
-			&& urb->actual_length < urb->transfer_buffer_length
-			&& usb_pipein (urb->pipe)
-			&& urb->status == 0) {
-		urb->status = -EREMOTEIO;
-	}
-	spin_unlock (&urb->lock);
-
-	switch (usb_pipetype (urb->pipe)) {
-	case PIPE_ISOCHRONOUS:
-		ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs--;
-		break;
-	case PIPE_INTERRUPT:
-		ohci_to_hcd(ohci)->self.bandwidth_int_reqs--;
-		break;
-	}
-
-#ifdef OHCI_VERBOSE_DEBUG
-	urb_print (urb, "RET", usb_pipeout (urb->pipe));
-#endif
-
-	/* urb->complete() can reenter this HCD */
-	spin_unlock (&ohci->lock);
-	usb_hcd_giveback_urb (ohci_to_hcd(ohci), urb);
-	spin_lock (&ohci->lock);
-
-	/* stop periodic dma if it's not needed */
-	if (ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs == 0
-			&& ohci_to_hcd(ohci)->self.bandwidth_int_reqs == 0) {
-		ohci->hc_control &= ~(OHCI_CTRL_PLE|OHCI_CTRL_IE);
-		ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
-	}
-}
-
-
-/*-------------------------------------------------------------------------*
- * ED handling functions
- *-------------------------------------------------------------------------*/
-
-/* search for the right schedule branch to use for a periodic ed.
- * does some load balancing; returns the branch, or negative errno.
- */
-static int balance (struct ohci_hcd *ohci, int interval, int load)
-{
-	int	i, branch = -ENOSPC;
-
-	/* iso periods can be huge; iso tds specify frame numbers */
-	if (interval > NUM_INTS)
-		interval = NUM_INTS;
-
-	/* search for the least loaded schedule branch of that period
-	 * that has enough bandwidth left unreserved.
-	 */
-	for (i = 0; i < interval ; i++) {
-		if (branch < 0 || ohci->load [branch] > ohci->load [i]) {
-			int	j;
-
-			/* usb 1.1 says 90% of one frame */
-			for (j = i; j < NUM_INTS; j += interval) {
-				if ((ohci->load [j] + load) > 900)
-					break;
-			}
-			if (j < NUM_INTS)
-				continue;
-			branch = i;
-		}
-	}
-	return branch;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* both iso and interrupt requests have periods; this routine puts them
- * into the schedule tree in the apppropriate place.  most iso devices use
- * 1msec periods, but that's not required.
- */
-static void periodic_link (struct ohci_hcd *ohci, struct ed *ed)
-{
-	unsigned	i;
-
-	ohci_vdbg (ohci, "link %sed %p branch %d [%dus.], interval %d\n",
-		(ed->hwINFO & cpu_to_hc32 (ohci, ED_ISO)) ? "iso " : "",
-		ed, ed->branch, ed->load, ed->interval);
-
-	for (i = ed->branch; i < NUM_INTS; i += ed->interval) {
-		struct ed	**prev = &ohci->periodic [i];
-		__hc32		*prev_p = &ohci->hcca->int_table [i];
-		struct ed	*here = *prev;
-
-		/* sorting each branch by period (slow before fast)
-		 * lets us share the faster parts of the tree.
-		 * (plus maybe: put interrupt eds before iso)
-		 */
-		while (here && ed != here) {
-			if (ed->interval > here->interval)
-				break;
-			prev = &here->ed_next;
-			prev_p = &here->hwNextED;
-			here = *prev;
-		}
-		if (ed != here) {
-			ed->ed_next = here;
-			if (here)
-				ed->hwNextED = *prev_p;
-			wmb ();
-			*prev = ed;
-			*prev_p = cpu_to_hc32(ohci, ed->dma);
-			wmb();
-		}
-		ohci->load [i] += ed->load;
-	}
-	ohci_to_hcd(ohci)->self.bandwidth_allocated += ed->load / ed->interval;
-}
-
-/* link an ed into one of the HC chains */
-
-static int ed_schedule (struct ohci_hcd *ohci, struct ed *ed)
-{
-	int	branch;
-
-	if (ohci_to_hcd(ohci)->state == HC_STATE_QUIESCING)
-		return -EAGAIN;
-
-	ed->state = ED_OPER;
-	ed->ed_prev = NULL;
-	ed->ed_next = NULL;
-	ed->hwNextED = 0;
-	wmb ();
-
-	/* we care about rm_list when setting CLE/BLE in case the HC was at
-	 * work on some TD when CLE/BLE was turned off, and isn't quiesced
-	 * yet.  finish_unlinks() restarts as needed, some upcoming INTR_SF.
-	 *
-	 * control and bulk EDs are doubly linked (ed_next, ed_prev), but
-	 * periodic ones are singly linked (ed_next). that's because the
-	 * periodic schedule encodes a tree like figure 3-5 in the ohci
-	 * spec:  each qh can have several "previous" nodes, and the tree
-	 * doesn't have unused/idle descriptors.
-	 */
-	switch (ed->type) {
-	case PIPE_CONTROL:
-		if (ohci->ed_controltail == NULL) {
-			WARN_ON (ohci->hc_control & OHCI_CTRL_CLE);
-			ohci_writel (ohci, ed->dma,
-					&ohci->regs->ed_controlhead);
-		} else {
-			ohci->ed_controltail->ed_next = ed;
-			ohci->ed_controltail->hwNextED = cpu_to_hc32 (ohci,
-								ed->dma);
-		}
-		ed->ed_prev = ohci->ed_controltail;
-		if (!ohci->ed_controltail && !ohci->ed_rm_list) {
-			wmb();
-			ohci->hc_control |= OHCI_CTRL_CLE;
-			ohci_writel (ohci, 0, &ohci->regs->ed_controlcurrent);
-			ohci_writel (ohci, ohci->hc_control,
-					&ohci->regs->control);
-		}
-		ohci->ed_controltail = ed;
-		break;
-
-	case PIPE_BULK:
-		if (ohci->ed_bulktail == NULL) {
-			WARN_ON (ohci->hc_control & OHCI_CTRL_BLE);
-			ohci_writel (ohci, ed->dma, &ohci->regs->ed_bulkhead);
-		} else {
-			ohci->ed_bulktail->ed_next = ed;
-			ohci->ed_bulktail->hwNextED = cpu_to_hc32 (ohci,
-								ed->dma);
-		}
-		ed->ed_prev = ohci->ed_bulktail;
-		if (!ohci->ed_bulktail && !ohci->ed_rm_list) {
-			wmb();
-			ohci->hc_control |= OHCI_CTRL_BLE;
-			ohci_writel (ohci, 0, &ohci->regs->ed_bulkcurrent);
-			ohci_writel (ohci, ohci->hc_control,
-					&ohci->regs->control);
-		}
-		ohci->ed_bulktail = ed;
-		break;
-
-	// case PIPE_INTERRUPT:
-	// case PIPE_ISOCHRONOUS:
-	default:
-		branch = balance (ohci, ed->interval, ed->load);
-		if (branch < 0) {
-			ohci_dbg (ohci,
-				"ERR %d, interval %d msecs, load %d\n",
-				branch, ed->interval, ed->load);
-			// FIXME if there are TDs queued, fail them!
-			return branch;
-		}
-		ed->branch = branch;
-		periodic_link (ohci, ed);
-	}
-
-	/* the HC may not see the schedule updates yet, but if it does
-	 * then they'll be properly ordered.
-	 */
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* scan the periodic table to find and unlink this ED */
-static void periodic_unlink (struct ohci_hcd *ohci, struct ed *ed)
-{
-	int	i;
-
-	for (i = ed->branch; i < NUM_INTS; i += ed->interval) {
-		struct ed	*temp;
-		struct ed	**prev = &ohci->periodic [i];
-		__hc32		*prev_p = &ohci->hcca->int_table [i];
-
-		while (*prev && (temp = *prev) != ed) {
-			prev_p = &temp->hwNextED;
-			prev = &temp->ed_next;
-		}
-		if (*prev) {
-			*prev_p = ed->hwNextED;
-			*prev = ed->ed_next;
-		}
-		ohci->load [i] -= ed->load;
-	}
-	ohci_to_hcd(ohci)->self.bandwidth_allocated -= ed->load / ed->interval;
-
-	ohci_vdbg (ohci, "unlink %sed %p branch %d [%dus.], interval %d\n",
-		(ed->hwINFO & cpu_to_hc32 (ohci, ED_ISO)) ? "iso " : "",
-		ed, ed->branch, ed->load, ed->interval);
-}
-
-/* unlink an ed from one of the HC chains.
- * just the link to the ed is unlinked.
- * the link from the ed still points to another operational ed or 0
- * so the HC can eventually finish the processing of the unlinked ed
- * (assuming it already started that, which needn't be true).
- *
- * ED_UNLINK is a transient state: the HC may still see this ED, but soon
- * it won't.  ED_SKIP means the HC will finish its current transaction,
- * but won't start anything new.  The TD queue may still grow; device
- * drivers don't know about this HCD-internal state.
- *
- * When the HC can't see the ED, something changes ED_UNLINK to one of:
- *
- *  - ED_OPER: when there's any request queued, the ED gets rescheduled
- *    immediately.  HC should be working on them.
- *
- *  - ED_IDLE:  when there's no TD queue. there's no reason for the HC
- *    to care about this ED; safe to disable the endpoint.
- *
- * When finish_unlinks() runs later, after SOF interrupt, it will often
- * complete one or more URB unlinks before making that state change.
- */
-static void ed_deschedule (struct ohci_hcd *ohci, struct ed *ed)
-{
-	ed->hwINFO |= cpu_to_hc32 (ohci, ED_SKIP);
-	wmb ();
-	ed->state = ED_UNLINK;
-
-	/* To deschedule something from the control or bulk list, just
-	 * clear CLE/BLE and wait.  There's no safe way to scrub out list
-	 * head/current registers until later, and "later" isn't very
-	 * tightly specified.  Figure 6-5 and Section 6.4.2.2 show how
-	 * the HC is reading the ED queues (while we modify them).
-	 *
-	 * For now, ed_schedule() is "later".  It might be good paranoia
-	 * to scrub those registers in finish_unlinks(), in case of bugs
-	 * that make the HC try to use them.
-	 */
-	switch (ed->type) {
-	case PIPE_CONTROL:
-		/* remove ED from the HC's list: */
-		if (ed->ed_prev == NULL) {
-			if (!ed->hwNextED) {
-				ohci->hc_control &= ~OHCI_CTRL_CLE;
-				ohci_writel (ohci, ohci->hc_control,
-						&ohci->regs->control);
-				// a ohci_readl() later syncs CLE with the HC
-			} else
-				ohci_writel (ohci,
-					hc32_to_cpup (ohci, &ed->hwNextED),
-					&ohci->regs->ed_controlhead);
-		} else {
-			ed->ed_prev->ed_next = ed->ed_next;
-			ed->ed_prev->hwNextED = ed->hwNextED;
-		}
-		/* remove ED from the HCD's list: */
-		if (ohci->ed_controltail == ed) {
-			ohci->ed_controltail = ed->ed_prev;
-			if (ohci->ed_controltail)
-				ohci->ed_controltail->ed_next = NULL;
-		} else if (ed->ed_next) {
-			ed->ed_next->ed_prev = ed->ed_prev;
-		}
-		break;
-
-	case PIPE_BULK:
-		/* remove ED from the HC's list: */
-		if (ed->ed_prev == NULL) {
-			if (!ed->hwNextED) {
-				ohci->hc_control &= ~OHCI_CTRL_BLE;
-				ohci_writel (ohci, ohci->hc_control,
-						&ohci->regs->control);
-				// a ohci_readl() later syncs BLE with the HC
-			} else
-				ohci_writel (ohci,
-					hc32_to_cpup (ohci, &ed->hwNextED),
-					&ohci->regs->ed_bulkhead);
-		} else {
-			ed->ed_prev->ed_next = ed->ed_next;
-			ed->ed_prev->hwNextED = ed->hwNextED;
-		}
-		/* remove ED from the HCD's list: */
-		if (ohci->ed_bulktail == ed) {
-			ohci->ed_bulktail = ed->ed_prev;
-			if (ohci->ed_bulktail)
-				ohci->ed_bulktail->ed_next = NULL;
-		} else if (ed->ed_next) {
-			ed->ed_next->ed_prev = ed->ed_prev;
-		}
-		break;
-
-	// case PIPE_INTERRUPT:
-	// case PIPE_ISOCHRONOUS:
-	default:
-		periodic_unlink (ohci, ed);
-		break;
-	}
-}
-
-
-/*-------------------------------------------------------------------------*/
-
-/* get and maybe (re)init an endpoint. init _should_ be done only as part
- * of enumeration, usb_set_configuration() or usb_set_interface().
- */
-static struct ed *ed_get (
-	struct ohci_hcd		*ohci,
-	struct usb_host_endpoint *ep,
-	struct usb_device	*udev,
-	unsigned int		pipe,
-	int			interval
-) {
-	struct ed		*ed;
-	unsigned long		flags;
-
-	spin_lock_irqsave (&ohci->lock, flags);
-
-	if (!(ed = ep->hcpriv)) {
-		struct td	*td;
-		int		is_out;
-		u32		info;
-
-		ed = ed_alloc (ohci, GFP_ATOMIC);
-		if (!ed) {
-			/* out of memory */
-			goto done;
-		}
-
-		/* dummy td; end of td list for ed */
-		td = td_alloc (ohci, GFP_ATOMIC);
-		if (!td) {
-			/* out of memory */
-			ed_free (ohci, ed);
-			ed = NULL;
-			goto done;
-		}
-		ed->dummy = td;
-		ed->hwTailP = cpu_to_hc32 (ohci, td->td_dma);
-		ed->hwHeadP = ed->hwTailP;	/* ED_C, ED_H zeroed */
-		ed->state = ED_IDLE;
-
-		is_out = !(ep->desc.bEndpointAddress & USB_DIR_IN);
-
-		/* FIXME usbcore changes dev->devnum before SET_ADDRESS
-		 * suceeds ... otherwise we wouldn't need "pipe".
-		 */
-		info = usb_pipedevice (pipe);
-		ed->type = usb_pipetype(pipe);
-
-		info |= (ep->desc.bEndpointAddress & ~USB_DIR_IN) << 7;
-		info |= le16_to_cpu(ep->desc.wMaxPacketSize) << 16;
-		if (udev->speed == USB_SPEED_LOW)
-			info |= ED_LOWSPEED;
-		/* only control transfers store pids in tds */
-		if (ed->type != PIPE_CONTROL) {
-			info |= is_out ? ED_OUT : ED_IN;
-			if (ed->type != PIPE_BULK) {
-				/* periodic transfers... */
-				if (ed->type == PIPE_ISOCHRONOUS)
-					info |= ED_ISO;
-				else if (interval > 32)	/* iso can be bigger */
-					interval = 32;
-				ed->interval = interval;
-				ed->load = usb_calc_bus_time (
-					udev->speed, !is_out,
-					ed->type == PIPE_ISOCHRONOUS,
-					le16_to_cpu(ep->desc.wMaxPacketSize))
-						/ 1000;
-			}
-		}
-		ed->hwINFO = cpu_to_hc32(ohci, info);
-
-		ep->hcpriv = ed;
-	}
-
-done:
-	spin_unlock_irqrestore (&ohci->lock, flags);
-	return ed;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* request unlinking of an endpoint from an operational HC.
- * put the ep on the rm_list
- * real work is done at the next start frame (SF) hardware interrupt
- * caller guarantees HCD is running, so hardware access is safe,
- * and that ed->state is ED_OPER
- */
-static void start_ed_unlink (struct ohci_hcd *ohci, struct ed *ed)
-{
-	ed->hwINFO |= cpu_to_hc32 (ohci, ED_DEQUEUE);
-	ed_deschedule (ohci, ed);
-
-	/* rm_list is just singly linked, for simplicity */
-	ed->ed_next = ohci->ed_rm_list;
-	ed->ed_prev = NULL;
-	ohci->ed_rm_list = ed;
-
-	/* enable SOF interrupt */
-	ohci_writel (ohci, OHCI_INTR_SF, &ohci->regs->intrstatus);
-	ohci_writel (ohci, OHCI_INTR_SF, &ohci->regs->intrenable);
-	// flush those writes, and get latest HCCA contents
-	(void) ohci_readl (ohci, &ohci->regs->control);
-
-	/* SF interrupt might get delayed; record the frame counter value that
-	 * indicates when the HC isn't looking at it, so concurrent unlinks
-	 * behave.  frame_no wraps every 2^16 msec, and changes right before
-	 * SF is triggered.
-	 */
-	ed->tick = ohci_frame_no(ohci) + 1;
-
-}
-
-/*-------------------------------------------------------------------------*
- * TD handling functions
- *-------------------------------------------------------------------------*/
-
-/* enqueue next TD for this URB (OHCI spec 5.2.8.2) */
-
-static void
-td_fill (struct ohci_hcd *ohci, u32 info,
-	dma_addr_t data, int len,
-	struct urb *urb, int index)
-{
-	struct td		*td, *td_pt;
-	struct urb_priv		*urb_priv = urb->hcpriv;
-	int			is_iso = info & TD_ISO;
-	int			hash;
-
-	// ASSERT (index < urb_priv->length);
-
-	/* aim for only one interrupt per urb.  mostly applies to control
-	 * and iso; other urbs rarely need more than one TD per urb.
-	 * this way, only final tds (or ones with an error) cause IRQs.
-	 * at least immediately; use DI=6 in case any control request is
-	 * tempted to die part way through.  (and to force the hc to flush
-	 * its donelist soonish, even on unlink paths.)
-	 *
-	 * NOTE: could delay interrupts even for the last TD, and get fewer
-	 * interrupts ... increasing per-urb latency by sharing interrupts.
-	 * Drivers that queue bulk urbs may request that behavior.
-	 */
-	if (index != (urb_priv->length - 1)
-			|| (urb->transfer_flags & URB_NO_INTERRUPT))
-		info |= TD_DI_SET (6);
-
-	/* use this td as the next dummy */
-	td_pt = urb_priv->td [index];
-
-	/* fill the old dummy TD */
-	td = urb_priv->td [index] = urb_priv->ed->dummy;
-	urb_priv->ed->dummy = td_pt;
-
-	td->ed = urb_priv->ed;
-	td->next_dl_td = NULL;
-	td->index = index;
-	td->urb = urb;
-	td->data_dma = data;
-	if (!len)
-		data = 0;
-
-	td->hwINFO = cpu_to_hc32 (ohci, info);
-	if (is_iso) {
-		td->hwCBP = cpu_to_hc32 (ohci, data & 0xFFFFF000);
-		*ohci_hwPSWp(ohci, td, 0) = cpu_to_hc16 (ohci,
-						(data & 0x0FFF) | 0xE000);
-		td->ed->last_iso = info & 0xffff;
-	} else {
-		td->hwCBP = cpu_to_hc32 (ohci, data);
-	}
-	if (data)
-		td->hwBE = cpu_to_hc32 (ohci, data + len - 1);
-	else
-		td->hwBE = 0;
-	td->hwNextTD = cpu_to_hc32 (ohci, td_pt->td_dma);
-
-	/* append to queue */
-	list_add_tail (&td->td_list, &td->ed->td_list);
-
-	/* hash it for later reverse mapping */
-	hash = TD_HASH_FUNC (td->td_dma);
-	td->td_hash = ohci->td_hash [hash];
-	ohci->td_hash [hash] = td;
-
-	/* HC might read the TD (or cachelines) right away ... */
-	wmb ();
-	td->ed->hwTailP = td->hwNextTD;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* Prepare all TDs of a transfer, and queue them onto the ED.
- * Caller guarantees HC is active.
- * Usually the ED is already on the schedule, so TDs might be
- * processed as soon as they're queued.
- */
-static void td_submit_urb (
-	struct ohci_hcd	*ohci,
-	struct urb	*urb
-) {
-	struct urb_priv	*urb_priv = urb->hcpriv;
-	dma_addr_t	data;
-	int		data_len = urb->transfer_buffer_length;
-	int		cnt = 0;
-	u32		info = 0;
-	int		is_out = usb_pipeout (urb->pipe);
-	int		periodic = 0;
-
-	/* OHCI handles the bulk/interrupt data toggles itself.  We just
-	 * use the device toggle bits for resetting, and rely on the fact
-	 * that resetting toggle is meaningless if the endpoint is active.
-	 */
-	if (!usb_gettoggle (urb->dev, usb_pipeendpoint (urb->pipe), is_out)) {
-		usb_settoggle (urb->dev, usb_pipeendpoint (urb->pipe),
-			is_out, 1);
-		urb_priv->ed->hwHeadP &= ~cpu_to_hc32 (ohci, ED_C);
-	}
-
-	urb_priv->td_cnt = 0;
-	list_add (&urb_priv->pending, &ohci->pending);
-
-	if (data_len)
-		data = urb->transfer_dma;
-	else
-		data = 0;
-
-	/* NOTE:  TD_CC is set so we can tell which TDs the HC processed by
-	 * using TD_CC_GET, as well as by seeing them on the done list.
-	 * (CC = NotAccessed ... 0x0F, or 0x0E in PSWs for ISO.)
-	 */
-	switch (urb_priv->ed->type) {
-
-	/* Bulk and interrupt are identical except for where in the schedule
-	 * their EDs live.
-	 */
-	case PIPE_INTERRUPT:
-		/* ... and periodic urbs have extra accounting */
-		periodic = ohci_to_hcd(ohci)->self.bandwidth_int_reqs++ == 0
-			&& ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs == 0;
-		/* FALLTHROUGH */
-	case PIPE_BULK:
-		info = is_out
-			? TD_T_TOGGLE | TD_CC | TD_DP_OUT
-			: TD_T_TOGGLE | TD_CC | TD_DP_IN;
-		/* TDs _could_ transfer up to 8K each */
-		while (data_len > 4096) {
-			td_fill (ohci, info, data, 4096, urb, cnt);
-			data += 4096;
-			data_len -= 4096;
-			cnt++;
-		}
-		/* maybe avoid ED halt on final TD short read */
-		if (!(urb->transfer_flags & URB_SHORT_NOT_OK))
-			info |= TD_R;
-		td_fill (ohci, info, data, data_len, urb, cnt);
-		cnt++;
-		if ((urb->transfer_flags & URB_ZERO_PACKET)
-				&& cnt < urb_priv->length) {
-			td_fill (ohci, info, 0, 0, urb, cnt);
-			cnt++;
-		}
-		/* maybe kickstart bulk list */
-		if (urb_priv->ed->type == PIPE_BULK) {
-			wmb ();
-			ohci_writel (ohci, OHCI_BLF, &ohci->regs->cmdstatus);
-		}
-		break;
-
-	/* control manages DATA0/DATA1 toggle per-request; SETUP resets it,
-	 * any DATA phase works normally, and the STATUS ack is special.
-	 */
-	case PIPE_CONTROL:
-		info = TD_CC | TD_DP_SETUP | TD_T_DATA0;
-		td_fill (ohci, info, urb->setup_dma, 8, urb, cnt++);
-		if (data_len > 0) {
-			info = TD_CC | TD_R | TD_T_DATA1;
-			info |= is_out ? TD_DP_OUT : TD_DP_IN;
-			/* NOTE:  mishandles transfers >8K, some >4K */
-			td_fill (ohci, info, data, data_len, urb, cnt++);
-		}
-		info = (is_out || data_len == 0)
-			? TD_CC | TD_DP_IN | TD_T_DATA1
-			: TD_CC | TD_DP_OUT | TD_T_DATA1;
-		td_fill (ohci, info, data, 0, urb, cnt++);
-		/* maybe kickstart control list */
-		wmb ();
-		ohci_writel (ohci, OHCI_CLF, &ohci->regs->cmdstatus);
-		break;
-
-	/* ISO has no retransmit, so no toggle; and it uses special TDs.
-	 * Each TD could handle multiple consecutive frames (interval 1);
-	 * we could often reduce the number of TDs here.
-	 */
-	case PIPE_ISOCHRONOUS:
-		for (cnt = 0; cnt < urb->number_of_packets; cnt++) {
-			int	frame = urb->start_frame;
-
-			// FIXME scheduling should handle frame counter
-			// roll-around ... exotic case (and OHCI has
-			// a 2^16 iso range, vs other HCs max of 2^10)
-			frame += cnt * urb->interval;
-			frame &= 0xffff;
-			td_fill (ohci, TD_CC | TD_ISO | frame,
-				data + urb->iso_frame_desc [cnt].offset,
-				urb->iso_frame_desc [cnt].length, urb, cnt);
-		}
-		periodic = ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs++ == 0
-			&& ohci_to_hcd(ohci)->self.bandwidth_int_reqs == 0;
-		break;
-	}
-
-	/* start periodic dma if needed */
-	if (periodic) {
-		wmb ();
-		ohci->hc_control |= OHCI_CTRL_PLE|OHCI_CTRL_IE;
-		ohci_writel (ohci, ohci->hc_control, &ohci->regs->control);
-	}
-
-	// ASSERT (urb_priv->length == cnt);
-}
-
-/*-------------------------------------------------------------------------*
- * Done List handling functions
- *-------------------------------------------------------------------------*/
-
-/* calculate transfer length/status and update the urb
- * PRECONDITION:  irqsafe (only for urb->status locking)
- */
-static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
-{
-	u32	tdINFO = hc32_to_cpup (ohci, &td->hwINFO);
-	int	cc = 0;
-
-	list_del (&td->td_list);
-
-	/* ISO ... drivers see per-TD length/status */
-	if (tdINFO & TD_ISO) {
-		u16	tdPSW = ohci_hwPSW (ohci, td, 0);
-		int	dlen = 0;
-
-		/* NOTE:  assumes FC in tdINFO == 0, and that
-		 * only the first of 0..MAXPSW psws is used.
-		 */
-
-		cc = (tdPSW >> 12) & 0xF;
-		if (tdINFO & TD_CC)	/* hc didn't touch? */
-			return;
-
-		if (usb_pipeout (urb->pipe))
-			dlen = urb->iso_frame_desc [td->index].length;
-		else {
-			/* short reads are always OK for ISO */
-			if (cc == TD_DATAUNDERRUN)
-				cc = TD_CC_NOERROR;
-			dlen = tdPSW & 0x3ff;
-		}
-		urb->actual_length += dlen;
-		urb->iso_frame_desc [td->index].actual_length = dlen;
-		urb->iso_frame_desc [td->index].status = cc_to_error [cc];
-
-		if (cc != TD_CC_NOERROR)
-			ohci_vdbg (ohci,
-				"urb %p iso td %p (%d) len %d cc %d\n",
-				urb, td, 1 + td->index, dlen, cc);
-
-	/* BULK, INT, CONTROL ... drivers see aggregate length/status,
-	 * except that "setup" bytes aren't counted and "short" transfers
-	 * might not be reported as errors.
-	 */
-	} else {
-		int	type = usb_pipetype (urb->pipe);
-		u32	tdBE = hc32_to_cpup (ohci, &td->hwBE);
-
-		cc = TD_CC_GET (tdINFO);
-
-		/* update packet status if needed (short is normally ok) */
-		if (cc == TD_DATAUNDERRUN
-				&& !(urb->transfer_flags & URB_SHORT_NOT_OK))
-			cc = TD_CC_NOERROR;
-		if (cc != TD_CC_NOERROR && cc < 0x0E) {
-			spin_lock (&urb->lock);
-			if (urb->status == -EINPROGRESS)
-				urb->status = cc_to_error [cc];
-			spin_unlock (&urb->lock);
-		}
-
-		/* count all non-empty packets except control SETUP packet */
-		if ((type != PIPE_CONTROL || td->index != 0) && tdBE != 0) {
-			if (td->hwCBP == 0)
-				urb->actual_length += tdBE - td->data_dma + 1;
-			else
-				urb->actual_length +=
-					  hc32_to_cpup (ohci, &td->hwCBP)
-					- td->data_dma;
-		}
-
-		if (cc != TD_CC_NOERROR && cc < 0x0E)
-			ohci_vdbg (ohci,
-				"urb %p td %p (%d) cc %d, len=%d/%d\n",
-				urb, td, 1 + td->index, cc,
-				urb->actual_length,
-				urb->transfer_buffer_length);
-	}
-}
-
-/*-------------------------------------------------------------------------*/
-
-static inline struct td *
-ed_halted (struct ohci_hcd *ohci, struct td *td, int cc, struct td *rev)
-{
-	struct urb		*urb = td->urb;
-	struct ed		*ed = td->ed;
-	struct list_head	*tmp = td->td_list.next;
-	__hc32			toggle = ed->hwHeadP & cpu_to_hc32 (ohci, ED_C);
-
-	/* clear ed halt; this is the td that caused it, but keep it inactive
-	 * until its urb->complete() has a chance to clean up.
-	 */
-	ed->hwINFO |= cpu_to_hc32 (ohci, ED_SKIP);
-	wmb ();
-	ed->hwHeadP &= ~cpu_to_hc32 (ohci, ED_H);
-
-	/* put any later tds from this urb onto the donelist, after 'td',
-	 * order won't matter here: no errors, and nothing was transferred.
-	 * also patch the ed so it looks as if those tds completed normally.
-	 */
-	while (tmp != &ed->td_list) {
-		struct td	*next;
-		__hc32		info;
-
-		next = list_entry (tmp, struct td, td_list);
-		tmp = next->td_list.next;
-
-		if (next->urb != urb)
-			break;
-
-		/* NOTE: if multi-td control DATA segments get supported,
-		 * this urb had one of them, this td wasn't the last td
-		 * in that segment (TD_R clear), this ed halted because
-		 * of a short read, _and_ URB_SHORT_NOT_OK is clear ...
-		 * then we need to leave the control STATUS packet queued
-		 * and clear ED_SKIP.
-		 */
-		info = next->hwINFO;
-		info |= cpu_to_hc32 (ohci, TD_DONE);
-		info &= ~cpu_to_hc32 (ohci, TD_CC);
-		next->hwINFO = info;
-
-		next->next_dl_td = rev;
-		rev = next;
-
-		ed->hwHeadP = next->hwNextTD | toggle;
-	}
-
-	/* help for troubleshooting:  report anything that
-	 * looks odd ... that doesn't include protocol stalls
-	 * (or maybe some other things)
-	 */
-	switch (cc) {
-	case TD_DATAUNDERRUN:
-		if ((urb->transfer_flags & URB_SHORT_NOT_OK) == 0)
-			break;
-		/* fallthrough */
-	case TD_CC_STALL:
-		if (usb_pipecontrol (urb->pipe))
-			break;
-		/* fallthrough */
-	default:
-		ohci_dbg (ohci,
-			"urb %p path %s ep%d%s %08x cc %d --> status %d\n",
-			urb, urb->dev->devpath,
-			usb_pipeendpoint (urb->pipe),
-			usb_pipein (urb->pipe) ? "in" : "out",
-			hc32_to_cpu (ohci, td->hwINFO),
-			cc, cc_to_error [cc]);
-	}
-
-	return rev;
-}
-
-/* replies to the request have to be on a FIFO basis so
- * we unreverse the hc-reversed done-list
- */
-static struct td *dl_reverse_done_list (struct ohci_hcd *ohci)
-{
-	u32		td_dma;
-	struct td	*td_rev = NULL;
-	struct td	*td = NULL;
-
-	td_dma = hc32_to_cpup (ohci, &ohci->hcca->done_head);
-	ohci->hcca->done_head = 0;
-	wmb();
-
-	/* get TD from hc's singly linked list, and
-	 * prepend to ours.  ed->td_list changes later.
-	 */
-	while (td_dma) {
-		int		cc;
-
-		td = dma_to_td (ohci, td_dma);
-		if (!td) {
-			ohci_err (ohci, "bad entry %8x\n", td_dma);
-			break;
-		}
-
-		td->hwINFO |= cpu_to_hc32 (ohci, TD_DONE);
-		cc = TD_CC_GET (hc32_to_cpup (ohci, &td->hwINFO));
-
-		/* Non-iso endpoints can halt on error; un-halt,
-		 * and dequeue any other TDs from this urb.
-		 * No other TD could have caused the halt.
-		 */
-		if (cc != TD_CC_NOERROR
-				&& (td->ed->hwHeadP & cpu_to_hc32 (ohci, ED_H)))
-			td_rev = ed_halted (ohci, td, cc, td_rev);
-
-		td->next_dl_td = td_rev;
-		td_rev = td;
-		td_dma = hc32_to_cpup (ohci, &td->hwNextTD);
-	}
-	return td_rev;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* there are some urbs/eds to unlink; called in_irq(), with HCD locked */
-static void
-finish_unlinks (struct ohci_hcd *ohci, u16 tick)
-{
-	struct ed	*ed, **last;
-
-rescan_all:
-	for (last = &ohci->ed_rm_list, ed = *last; ed != NULL; ed = *last) {
-		struct list_head	*entry, *tmp;
-		int			completed, modified;
-		__hc32			*prev;
-
-		/* only take off EDs that the HC isn't using, accounting for
-		 * frame counter wraps and EDs with partially retired TDs
-		 */
-		if (likely (HC_IS_RUNNING(ohci_to_hcd(ohci)->state))) {
-			if (tick_before (tick, ed->tick)) {
-skip_ed:
-				last = &ed->ed_next;
-				continue;
-			}
-
-			if (!list_empty (&ed->td_list)) {
-				struct td	*td;
-				u32		head;
-
-				td = list_entry (ed->td_list.next, struct td,
-							td_list);
-				head = hc32_to_cpu (ohci, ed->hwHeadP) &
-								TD_MASK;
-
-				/* INTR_WDH may need to clean up first */
-				if (td->td_dma != head)
-					goto skip_ed;
-			}
-		}
-
-		/* reentrancy:  if we drop the schedule lock, someone might
-		 * have modified this list.  normally it's just prepending
-		 * entries (which we'd ignore), but paranoia won't hurt.
-		 */
-		*last = ed->ed_next;
-		ed->ed_next = NULL;
-		modified = 0;
-
-		/* unlink urbs as requested, but rescan the list after
-		 * we call a completion since it might have unlinked
-		 * another (earlier) urb
-		 *
-		 * When we get here, the HC doesn't see this ed.  But it
-		 * must not be rescheduled until all completed URBs have
-		 * been given back to the driver.
-		 */
-rescan_this:
-		completed = 0;
-		prev = &ed->hwHeadP;
-		list_for_each_safe (entry, tmp, &ed->td_list) {
-			struct td	*td;
-			struct urb	*urb;
-			urb_priv_t	*urb_priv;
-			__hc32		savebits;
-
-			td = list_entry (entry, struct td, td_list);
-			urb = td->urb;
-			urb_priv = td->urb->hcpriv;
-
-			if (urb->status == -EINPROGRESS) {
-				prev = &td->hwNextTD;
-				continue;
-			}
-
-			/* patch pointer hc uses */
-			savebits = *prev & ~cpu_to_hc32 (ohci, TD_MASK);
-			*prev = td->hwNextTD | savebits;
-
-			/* HC may have partly processed this TD */
-			td_done (ohci, urb, td);
-			urb_priv->td_cnt++;
-
-			/* if URB is done, clean up */
-			if (urb_priv->td_cnt == urb_priv->length) {
-				modified = completed = 1;
-				finish_urb (ohci, urb);
-			}
-		}
-		if (completed && !list_empty (&ed->td_list))
-			goto rescan_this;
-
-		/* ED's now officially unlinked, hc doesn't see */
-		ed->state = ED_IDLE;
-		ed->hwHeadP &= ~cpu_to_hc32(ohci, ED_H);
-		ed->hwNextED = 0;
-		wmb ();
-		ed->hwINFO &= ~cpu_to_hc32 (ohci, ED_SKIP | ED_DEQUEUE);
-
-		/* but if there's work queued, reschedule */
-		if (!list_empty (&ed->td_list)) {
-			if (HC_IS_RUNNING(ohci_to_hcd(ohci)->state))
-				ed_schedule (ohci, ed);
-		}
-
-		if (modified)
-			goto rescan_all;
-	}
-
-	/* maybe reenable control and bulk lists */
-	if (HC_IS_RUNNING(ohci_to_hcd(ohci)->state)
-			&& ohci_to_hcd(ohci)->state != HC_STATE_QUIESCING
-			&& !ohci->ed_rm_list) {
-		u32	command = 0, control = 0;
-
-		if (ohci->ed_controltail) {
-			command |= OHCI_CLF;
-			if (ohci->flags & OHCI_QUIRK_ZFMICRO)
-				mdelay(1);
-			if (!(ohci->hc_control & OHCI_CTRL_CLE)) {
-				control |= OHCI_CTRL_CLE;
-				ohci_writel (ohci, 0,
-					&ohci->regs->ed_controlcurrent);
-			}
-		}
-		if (ohci->ed_bulktail) {
-			command |= OHCI_BLF;
-			if (ohci->flags & OHCI_QUIRK_ZFMICRO)
-				mdelay(1);
-			if (!(ohci->hc_control & OHCI_CTRL_BLE)) {
-				control |= OHCI_CTRL_BLE;
-				ohci_writel (ohci, 0,
-					&ohci->regs->ed_bulkcurrent);
-			}
-		}
-
-		/* CLE/BLE to enable, CLF/BLF to (maybe) kickstart */
-		if (control) {
-			ohci->hc_control |= control;
-			if (ohci->flags & OHCI_QUIRK_ZFMICRO)
-				mdelay(1);
-			ohci_writel (ohci, ohci->hc_control,
-					&ohci->regs->control);
-		}
-		if (command) {
-			if (ohci->flags & OHCI_QUIRK_ZFMICRO)
-				mdelay(1);
-			ohci_writel (ohci, command, &ohci->regs->cmdstatus);
-		}
-	}
-}
-
-
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * Process normal completions (error or success) and clean the schedules.
- *
- * This is the main path for handing urbs back to drivers.  The only other
- * path is finish_unlinks(), which unlinks URBs using ed_rm_list, instead of
- * scanning the (re-reversed) donelist as this does.
- */
-static void
-dl_done_list (struct ohci_hcd *ohci)
-{
-	struct td	*td = dl_reverse_done_list (ohci);
-
-	while (td) {
-		struct td	*td_next = td->next_dl_td;
-		struct urb	*urb = td->urb;
-		urb_priv_t	*urb_priv = urb->hcpriv;
-		struct ed	*ed = td->ed;
-
-		/* update URB's length and status from TD */
-		td_done (ohci, urb, td);
-		urb_priv->td_cnt++;
-
-		/* If all this urb's TDs are done, call complete() */
-		if (urb_priv->td_cnt == urb_priv->length)
-			finish_urb (ohci, urb);
-
-		/* clean schedule:  unlink EDs that are no longer busy */
-		if (list_empty (&ed->td_list)) {
-			if (ed->state == ED_OPER)
-				start_ed_unlink (ohci, ed);
-
-		/* ... reenabling halted EDs only after fault cleanup */
-		} else if ((ed->hwINFO & cpu_to_hc32 (ohci,
-						ED_SKIP | ED_DEQUEUE))
-					== cpu_to_hc32 (ohci, ED_SKIP)) {
-			td = list_entry (ed->td_list.next, struct td, td_list);
-			if (!(td->hwINFO & cpu_to_hc32 (ohci, TD_DONE))) {
-				ed->hwINFO &= ~cpu_to_hc32 (ohci, ED_SKIP);
-				/* ... hc may need waking-up */
-				switch (ed->type) {
-				case PIPE_CONTROL:
-					ohci_writel (ohci, OHCI_CLF,
-						&ohci->regs->cmdstatus);
-					break;
-				case PIPE_BULK:
-					ohci_writel (ohci, OHCI_BLF,
-						&ohci->regs->cmdstatus);
-					break;
-				}
-			}
-		}
-
-		td = td_next;
-	}
-}
diff -urN host/.svn/text-base/ohci-s3c2410.c.svn-base host.new/.svn/text-base/ohci-s3c2410.c.svn-base
--- host/.svn/text-base/ohci-s3c2410.c.svn-base	2009-02-24 19:00:15.875946261 +0100
+++ host.new/.svn/text-base/ohci-s3c2410.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,503 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- * (C) Copyright 2002 Hewlett-Packard Company
- *
- * USB Bus Glue for Samsung S3C2410
- *
- * Written by Christopher Hoover <ch@hpl.hp.com>
- * Based on fragments of previous driver by Rusell King et al.
- *
- * Modified for S3C2410 from ohci-sa1111.c, ohci-omap.c and ohci-lh7a40.c
- *	by Ben Dooks, <ben@simtec.co.uk>
- *	Copyright (C) 2004 Simtec Electronics
- *
- * Thanks to basprog@mail.ru for updates to newer kernels
- *
- * This file is licenced under the GPL.
-*/
-
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-
-#include <asm/hardware.h>
-#include <asm/arch/usb-control.h>
-
-#define valid_port(idx) ((idx) == 1 || (idx) == 2)
-
-/* clock device associated with the hcd */
-
-static struct clk *clk;
-static struct clk *usb_clk;
-
-/* forward definitions */
-
-static void s3c2410_hcd_oc(struct s3c2410_hcd_info *info, int port_oc);
-
-/* conversion functions */
-
-static struct s3c2410_hcd_info *to_s3c2410_info(struct usb_hcd *hcd)
-{
-	return hcd->self.controller->platform_data;
-}
-
-static void s3c2410_start_hc(struct platform_device *dev, struct usb_hcd *hcd)
-{
-	struct s3c2410_hcd_info *info = dev->dev.platform_data;
-
-	dev_dbg(&dev->dev, "s3c2410_start_hc:\n");
-
-	clk_enable(usb_clk);
-	mdelay(2);			/* let the bus clock stabilise */
-
-	clk_enable(clk);
-
-	if (info != NULL) {
-		info->hcd	= hcd;
-		info->report_oc = s3c2410_hcd_oc;
-
-		if (info->enable_oc != NULL) {
-			(info->enable_oc)(info, 1);
-		}
-	}
-}
-
-static void s3c2410_stop_hc(struct platform_device *dev)
-{
-	struct s3c2410_hcd_info *info = dev->dev.platform_data;
-
-	dev_dbg(&dev->dev, "s3c2410_stop_hc:\n");
-
-	if (info != NULL) {
-		info->report_oc = NULL;
-		info->hcd	= NULL;
-
-		if (info->enable_oc != NULL) {
-			(info->enable_oc)(info, 0);
-		}
-	}
-
-	clk_disable(clk);
-	clk_disable(usb_clk);
-}
-
-/* ohci_s3c2410_hub_status_data
- *
- * update the status data from the hub with anything that
- * has been detected by our system
-*/
-
-static int
-ohci_s3c2410_hub_status_data (struct usb_hcd *hcd, char *buf)
-{
-	struct s3c2410_hcd_info *info = to_s3c2410_info(hcd);
-	struct s3c2410_hcd_port *port;
-	int orig;
-	int portno;
-
-	orig  = ohci_hub_status_data (hcd, buf);
-
-	if (info == NULL)
-		return orig;
-
-	port = &info->port[0];
-
-	/* mark any changed port as changed */
-
-	for (portno = 0; portno < 2; port++, portno++) {
-		if (port->oc_changed == 1 &&
-		    port->flags & S3C_HCDFLG_USED) {
-			dev_dbg(hcd->self.controller,
-				"oc change on port %d\n", portno);
-
-			if (orig < 1)
-				orig = 1;
-
-			buf[0] |= 1<<(portno+1);
-		}
-	}
-
-	return orig;
-}
-
-/* s3c2410_usb_set_power
- *
- * configure the power on a port, by calling the platform device
- * routine registered with the platform device
-*/
-
-static void s3c2410_usb_set_power(struct s3c2410_hcd_info *info,
-				  int port, int to)
-{
-	if (info == NULL)
-		return;
-
-	if (info->power_control != NULL) {
-		info->port[port-1].power = to;
-		(info->power_control)(port-1, to);
-	}
-}
-
-/* ohci_s3c2410_hub_control
- *
- * look at control requests to the hub, and see if we need
- * to take any action or over-ride the results from the
- * request.
-*/
-
-static int ohci_s3c2410_hub_control (
-	struct usb_hcd	*hcd,
-	u16		typeReq,
-	u16		wValue,
-	u16		wIndex,
-	char		*buf,
-	u16		wLength)
-{
-	struct s3c2410_hcd_info *info = to_s3c2410_info(hcd);
-	struct usb_hub_descriptor *desc;
-	int ret = -EINVAL;
-	u32 *data = (u32 *)buf;
-
-	dev_dbg(hcd->self.controller,
-		"s3c2410_hub_control(%p,0x%04x,0x%04x,0x%04x,%p,%04x)\n",
-		hcd, typeReq, wValue, wIndex, buf, wLength);
-
-	/* if we are only an humble host without any special capabilities
-	 * process the request straight away and exit */
-
-	if (info == NULL) {
-		ret = ohci_hub_control(hcd, typeReq, wValue,
-				       wIndex, buf, wLength);
-		goto out;
-	}
-
-	/* check the request to see if it needs handling */
-
-	switch (typeReq) {
-	case SetPortFeature:
-		if (wValue == USB_PORT_FEAT_POWER) {
-			dev_dbg(hcd->self.controller, "SetPortFeat: POWER\n");
-			s3c2410_usb_set_power(info, wIndex, 1);
-			goto out;
-		}
-		break;
-
-	case ClearPortFeature:
-		switch (wValue) {
-		case USB_PORT_FEAT_C_OVER_CURRENT:
-			dev_dbg(hcd->self.controller,
-				"ClearPortFeature: C_OVER_CURRENT\n");
-
-			if (valid_port(wIndex)) {
-				info->port[wIndex-1].oc_changed = 0;
-				info->port[wIndex-1].oc_status = 0;
-			}
-
-			goto out;
-
-		case USB_PORT_FEAT_OVER_CURRENT:
-			dev_dbg(hcd->self.controller,
-				"ClearPortFeature: OVER_CURRENT\n");
-
-			if (valid_port(wIndex)) {
-				info->port[wIndex-1].oc_status = 0;
-			}
-
-			goto out;
-
-		case USB_PORT_FEAT_POWER:
-			dev_dbg(hcd->self.controller,
-				"ClearPortFeature: POWER\n");
-
-			if (valid_port(wIndex)) {
-				s3c2410_usb_set_power(info, wIndex, 0);
-				return 0;
-			}
-		}
-		break;
-	}
-
-	ret = ohci_hub_control(hcd, typeReq, wValue, wIndex, buf, wLength);
-	if (ret)
-		goto out;
-
-	switch (typeReq) {
-	case GetHubDescriptor:
-
-		/* update the hub's descriptor */
-
-		desc = (struct usb_hub_descriptor *)buf;
-
-		if (info->power_control == NULL)
-			return ret;
-
-		dev_dbg(hcd->self.controller, "wHubCharacteristics 0x%04x\n",
-			desc->wHubCharacteristics);
-
-		/* remove the old configurations for power-switching, and
-		 * over-current protection, and insert our new configuration
-		 */
-
-		desc->wHubCharacteristics &= ~cpu_to_le16(HUB_CHAR_LPSM);
-		desc->wHubCharacteristics |= cpu_to_le16(0x0001);
-
-		if (info->enable_oc) {
-			desc->wHubCharacteristics &= ~cpu_to_le16(HUB_CHAR_OCPM);
-			desc->wHubCharacteristics |=  cpu_to_le16(0x0008|0x0001);
-		}
-
-		dev_dbg(hcd->self.controller, "wHubCharacteristics after 0x%04x\n",
-			desc->wHubCharacteristics);
-
-		return ret;
-
-	case GetPortStatus:
-		/* check port status */
-
-		dev_dbg(hcd->self.controller, "GetPortStatus(%d)\n", wIndex);
-
-		if (valid_port(wIndex)) {
-			if (info->port[wIndex-1].oc_changed) {
-				*data |= cpu_to_le32(RH_PS_OCIC);
-			}
-
-			if (info->port[wIndex-1].oc_status) {
-				*data |= cpu_to_le32(RH_PS_POCI);
-			}
-		}
-	}
-
- out:
-	return ret;
-}
-
-/* s3c2410_hcd_oc
- *
- * handle an over-current report
-*/
-
-static void s3c2410_hcd_oc(struct s3c2410_hcd_info *info, int port_oc)
-{
-	struct s3c2410_hcd_port *port;
-	struct usb_hcd *hcd;
-	unsigned long flags;
-	int portno;
-
-	if (info == NULL)
-		return;
-
-	port = &info->port[0];
-	hcd = info->hcd;
-
-	local_irq_save(flags);
-
-	for (portno = 0; portno < 2; port++, portno++) {
-		if (port_oc & (1<<portno) &&
-		    port->flags & S3C_HCDFLG_USED) {
-			port->oc_status = 1;
-			port->oc_changed = 1;
-
-			/* ok, once over-current is detected,
-			   the port needs to be powered down */
-			s3c2410_usb_set_power(info, portno+1, 0);
-		}
-	}
-
-	local_irq_restore(flags);
-}
-
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/*
- * usb_hcd_s3c2410_remove - shutdown processing for HCD
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_hcd_3c2410_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
-*/
-
-static void
-usb_hcd_s3c2410_remove (struct usb_hcd *hcd, struct platform_device *dev)
-{
-	usb_remove_hcd(hcd);
-	s3c2410_stop_hc(dev);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-}
-
-/**
- * usb_hcd_s3c2410_probe - initialize S3C2410-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- *
- */
-static int usb_hcd_s3c2410_probe (const struct hc_driver *driver,
-				  struct platform_device *dev)
-{
-	struct usb_hcd *hcd = NULL;
-	int retval;
-
-	s3c2410_usb_set_power(dev->dev.platform_data, 1, 1);
-	s3c2410_usb_set_power(dev->dev.platform_data, 2, 1);
-
-	hcd = usb_create_hcd(driver, &dev->dev, "s3c24xx");
-	if (hcd == NULL)
-		return -ENOMEM;
-
-	hcd->rsrc_start = dev->resource[0].start;
-	hcd->rsrc_len   = dev->resource[0].end - dev->resource[0].start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		dev_err(&dev->dev, "request_mem_region failed");
-		retval = -EBUSY;
-		goto err_put;
-	}
-
-	clk = clk_get(&dev->dev, "usb-host");
-	if (IS_ERR(clk)) {
-		dev_err(&dev->dev, "cannot get usb-host clock\n");
-		retval = -ENOENT;
-		goto err_mem;
-	}
-
-	usb_clk = clk_get(&dev->dev, "usb-bus-host");
-	if (IS_ERR(usb_clk)) {
-		dev_err(&dev->dev, "cannot get usb-host clock\n");
-		retval = -ENOENT;
-		goto err_clk;
-	}
-
-	s3c2410_start_hc(dev, hcd);
-
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-	if (!hcd->regs) {
-		dev_err(&dev->dev, "ioremap failed\n");
-		retval = -ENOMEM;
-		goto err_ioremap;
-	}
-
-	ohci_hcd_init(hcd_to_ohci(hcd));
-
-	retval = usb_add_hcd(hcd, dev->resource[1].start, IRQF_DISABLED);
-	if (retval != 0)
-		goto err_ioremap;
-
-	return 0;
-
- err_ioremap:
-	s3c2410_stop_hc(dev);
-	iounmap(hcd->regs);
-	clk_put(usb_clk);
-
- err_clk:
-	clk_put(clk);
-
- err_mem:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-
- err_put:
-	usb_put_hcd(hcd);
-	return retval;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int
-ohci_s3c2410_start (struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int ret;
-
-	if ((ret = ohci_init(ohci)) < 0)
-		return ret;
-
-	if ((ret = ohci_run (ohci)) < 0) {
-		err ("can't start %s", hcd->self.bus_name);
-		ohci_stop (hcd);
-		return ret;
-	}
-
-	return 0;
-}
-
-
-static const struct hc_driver ohci_s3c2410_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"S3C24XX OHCI",
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ohci_irq,
-	.flags =		HCD_USB11 | HCD_MEMORY,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.start =		ohci_s3c2410_start,
-	.stop =			ohci_stop,
-	.shutdown =		ohci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ohci_urb_enqueue,
-	.urb_dequeue =		ohci_urb_dequeue,
-	.endpoint_disable =	ohci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ohci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ohci_s3c2410_hub_status_data,
-	.hub_control =		ohci_s3c2410_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
-#ifdef	CONFIG_PM
-	.bus_suspend =		ohci_bus_suspend,
-	.bus_resume =		ohci_bus_resume,
-#endif
-	.start_port_reset =	ohci_start_port_reset,
-};
-
-/* device driver */
-
-static int ohci_hcd_s3c2410_drv_probe(struct platform_device *pdev)
-{
-	return usb_hcd_s3c2410_probe(&ohci_s3c2410_hc_driver, pdev);
-}
-
-static int ohci_hcd_s3c2410_drv_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	usb_hcd_s3c2410_remove(hcd, pdev);
-	return 0;
-}
-
-static struct platform_driver ohci_hcd_s3c2410_driver = {
-	.probe		= ohci_hcd_s3c2410_drv_probe,
-	.remove		= ohci_hcd_s3c2410_drv_remove,
-	.shutdown	= usb_hcd_platform_shutdown,
-	/*.suspend	= ohci_hcd_s3c2410_drv_suspend, */
-	/*.resume	= ohci_hcd_s3c2410_drv_resume, */
-	.driver		= {
-		.owner	= THIS_MODULE,
-		.name	= "s3c2410-ohci",
-	},
-};
-
diff -urN host/.svn/text-base/ohci-sa1111.c.svn-base host.new/.svn/text-base/ohci-sa1111.c.svn-base
--- host/.svn/text-base/ohci-sa1111.c.svn-base	2009-02-24 19:00:15.875946261 +0100
+++ host.new/.svn/text-base/ohci-sa1111.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,271 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- * (C) Copyright 2002 Hewlett-Packard Company
- *
- * SA1111 Bus Glue
- *
- * Written by Christopher Hoover <ch@hpl.hp.com>
- * Based on fragments of previous driver by Rusell King et al.
- *
- * This file is licenced under the GPL.
- */
-
-#include <asm/hardware.h>
-#include <asm/mach-types.h>
-#include <asm/arch/assabet.h>
-#include <asm/arch/badge4.h>
-#include <asm/hardware/sa1111.h>
-
-#ifndef CONFIG_SA1111
-#error "This file is SA-1111 bus glue.  CONFIG_SA1111 must be defined."
-#endif
-
-extern int usb_disabled(void);
-
-/*-------------------------------------------------------------------------*/
-
-static void sa1111_start_hc(struct sa1111_dev *dev)
-{
-	unsigned int usb_rst = 0;
-
-	printk(KERN_DEBUG __FILE__
-	       ": starting SA-1111 OHCI USB Controller\n");
-
-#ifdef CONFIG_SA1100_BADGE4
-	if (machine_is_badge4()) {
-		badge4_set_5V(BADGE4_5V_USB, 1);
-	}
-#endif
-
-	if (machine_is_xp860() ||
-	    machine_has_neponset() ||
-	    machine_is_pfs168() ||
-	    machine_is_badge4())
-		usb_rst = USB_RESET_PWRSENSELOW | USB_RESET_PWRCTRLLOW;
-
-	/*
-	 * Configure the power sense and control lines.  Place the USB
-	 * host controller in reset.
-	 */
-	sa1111_writel(usb_rst | USB_RESET_FORCEIFRESET | USB_RESET_FORCEHCRESET,
-		      dev->mapbase + SA1111_USB_RESET);
-
-	/*
-	 * Now, carefully enable the USB clock, and take
-	 * the USB host controller out of reset.
-	 */
-	sa1111_enable_device(dev);
-	udelay(11);
-	sa1111_writel(usb_rst, dev->mapbase + SA1111_USB_RESET);
-}
-
-static void sa1111_stop_hc(struct sa1111_dev *dev)
-{
-	unsigned int usb_rst;
-	printk(KERN_DEBUG __FILE__
-	       ": stopping SA-1111 OHCI USB Controller\n");
-
-	/*
-	 * Put the USB host controller into reset.
-	 */
-	usb_rst = sa1111_readl(dev->mapbase + SA1111_USB_RESET);
-	sa1111_writel(usb_rst | USB_RESET_FORCEIFRESET | USB_RESET_FORCEHCRESET,
-		      dev->mapbase + SA1111_USB_RESET);
-
-	/*
-	 * Stop the USB clock.
-	 */
-	sa1111_disable_device(dev);
-
-#ifdef CONFIG_SA1100_BADGE4
-	if (machine_is_badge4()) {
-		/* Disable power to the USB bus */
-		badge4_set_5V(BADGE4_5V_USB, 0);
-	}
-#endif
-}
-
-
-/*-------------------------------------------------------------------------*/
-
-#if 0
-static void dump_hci_status(struct usb_hcd *hcd, const char *label)
-{
-	unsigned long status = sa1111_readl(hcd->regs + SA1111_USB_STATUS);
-
-	dbg ("%s USB_STATUS = { %s%s%s%s%s}", label,
-	     ((status & USB_STATUS_IRQHCIRMTWKUP) ? "IRQHCIRMTWKUP " : ""),
-	     ((status & USB_STATUS_IRQHCIBUFFACC) ? "IRQHCIBUFFACC " : ""),
-	     ((status & USB_STATUS_NIRQHCIM) ? "" : "IRQHCIM "),
-	     ((status & USB_STATUS_NHCIMFCLR) ? "" : "HCIMFCLR "),
-	     ((status & USB_STATUS_USBPWRSENSE) ? "USBPWRSENSE " : ""));
-}
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-/* configure so an HC device and id are always provided */
-/* always called with process context; sleeping is OK */
-
-
-/**
- * usb_hcd_sa1111_probe - initialize SA-1111-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- *
- * Store this function in the HCD's struct pci_driver as probe().
- */
-int usb_hcd_sa1111_probe (const struct hc_driver *driver,
-			  struct sa1111_dev *dev)
-{
-	struct usb_hcd *hcd;
-	int retval;
-
-	hcd = usb_create_hcd (driver, &dev->dev, "sa1111");
-	if (!hcd)
-		return -ENOMEM;
-	hcd->rsrc_start = dev->res.start;
-	hcd->rsrc_len = dev->res.end - dev->res.start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		dbg("request_mem_region failed");
-		retval = -EBUSY;
-		goto err1;
-	}
-	hcd->regs = dev->mapbase;
-
-	sa1111_start_hc(dev);
-	ohci_hcd_init(hcd_to_ohci(hcd));
-
-	retval = usb_add_hcd(hcd, dev->irq[1], IRQF_DISABLED);
-	if (retval == 0)
-		return retval;
-
-	sa1111_stop_hc(dev);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
- err1:
-	usb_put_hcd(hcd);
-	return retval;
-}
-
-
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_hcd_sa1111_remove - shutdown processing for SA-1111-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_hcd_sa1111_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
- */
-void usb_hcd_sa1111_remove (struct usb_hcd *hcd, struct sa1111_dev *dev)
-{
-	usb_remove_hcd(hcd);
-	sa1111_stop_hc(dev);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int __devinit
-ohci_sa1111_start (struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ret;
-
-	if ((ret = ohci_init(ohci)) < 0)
-		return ret;
-
-	if ((ret = ohci_run (ohci)) < 0) {
-		err ("can't start %s", hcd->self.bus_name);
-		ohci_stop (hcd);
-		return ret;
-	}
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static const struct hc_driver ohci_sa1111_hc_driver = {
-	.description =		hcd_name,
-	.product_desc =		"SA-1111 OHCI",
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			ohci_irq,
-	.flags =		HCD_USB11 | HCD_MEMORY,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.start =		ohci_sa1111_start,
-	.stop =			ohci_stop,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		ohci_urb_enqueue,
-	.urb_dequeue =		ohci_urb_dequeue,
-	.endpoint_disable =	ohci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number =	ohci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	ohci_hub_status_data,
-	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
-#ifdef	CONFIG_PM
-	.bus_suspend =		ohci_bus_suspend,
-	.bus_resume =		ohci_bus_resume,
-#endif
-	.start_port_reset =	ohci_start_port_reset,
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int ohci_hcd_sa1111_drv_probe(struct sa1111_dev *dev)
-{
-	int ret;
-
-	if (usb_disabled())
-		return -ENODEV;
-
-	ret = usb_hcd_sa1111_probe(&ohci_sa1111_hc_driver, dev);
-	return ret;
-}
-
-static int ohci_hcd_sa1111_drv_remove(struct sa1111_dev *dev)
-{
-	struct usb_hcd *hcd = sa1111_get_drvdata(dev);
-
-	usb_hcd_sa1111_remove(hcd, dev);
-	return 0;
-}
-
-static struct sa1111_driver ohci_hcd_sa1111_driver = {
-	.drv = {
-		.name	= "sa1111-ohci",
-	},
-	.devid		= SA1111_DEVID_USB,
-	.probe		= ohci_hcd_sa1111_drv_probe,
-	.remove		= ohci_hcd_sa1111_drv_remove,
-};
-
diff -urN host/.svn/text-base/ohci.h.svn-base host.new/.svn/text-base/ohci.h.svn-base
--- host/.svn/text-base/ohci.h.svn-base	2009-02-24 19:00:15.883945855 +0100
+++ host.new/.svn/text-base/ohci.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,689 +0,0 @@
-/*
- * OHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
- * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- *
- * This file is licenced under the GPL.
- */
-
-/*
- * __hc32 and __hc16 are "Host Controller" types, they may be equivalent to
- * __leXX (normally) or __beXX (given OHCI_BIG_ENDIAN), depending on the
- * host controller implementation.
- */
-typedef __u32 __bitwise __hc32;
-typedef __u16 __bitwise __hc16;
-
-/*
- * OHCI Endpoint Descriptor (ED) ... holds TD queue
- * See OHCI spec, section 4.2
- *
- * This is a "Queue Head" for those transfers, which is why
- * both EHCI and UHCI call similar structures a "QH".
- */
-struct ed {
-	/* first fields are hardware-specified */
-	__hc32			hwINFO;      /* endpoint config bitmap */
-	/* info bits defined by hcd */
-#define ED_DEQUEUE	(1 << 27)
-	/* info bits defined by the hardware */
-#define ED_ISO		(1 << 15)
-#define ED_SKIP		(1 << 14)
-#define ED_LOWSPEED	(1 << 13)
-#define ED_OUT		(0x01 << 11)
-#define ED_IN		(0x02 << 11)
-	__hc32			hwTailP;	/* tail of TD list */
-	__hc32			hwHeadP;	/* head of TD list (hc r/w) */
-#define ED_C		(0x02)			/* toggle carry */
-#define ED_H		(0x01)			/* halted */
-	__hc32			hwNextED;	/* next ED in list */
-
-	/* rest are purely for the driver's use */
-	dma_addr_t		dma;		/* addr of ED */
-	struct td		*dummy;		/* next TD to activate */
-
-	/* host's view of schedule */
-	struct ed		*ed_next;	/* on schedule or rm_list */
-	struct ed		*ed_prev;	/* for non-interrupt EDs */
-	struct list_head	td_list;	/* "shadow list" of our TDs */
-
-	/* create --> IDLE --> OPER --> ... --> IDLE --> destroy
-	 * usually:  OPER --> UNLINK --> (IDLE | OPER) --> ...
-	 */
-	u8			state;		/* ED_{IDLE,UNLINK,OPER} */
-#define ED_IDLE		0x00		/* NOT linked to HC */
-#define ED_UNLINK	0x01		/* being unlinked from hc */
-#define ED_OPER		0x02		/* IS linked to hc */
-
-	u8			type;		/* PIPE_{BULK,...} */
-
-	/* periodic scheduling params (for intr and iso) */
-	u8			branch;
-	u16			interval;
-	u16			load;
-	u16			last_iso;	/* iso only */
-
-	/* HC may see EDs on rm_list until next frame (frame_no == tick) */
-	u16			tick;
-} __attribute__ ((aligned(16)));
-
-#define ED_MASK	((u32)~0x0f)		/* strip hw status in low addr bits */
-
-
-/*
- * OHCI Transfer Descriptor (TD) ... one per transfer segment
- * See OHCI spec, sections 4.3.1 (general = control/bulk/interrupt)
- * and 4.3.2 (iso)
- */
-struct td {
-	/* first fields are hardware-specified */
-	__hc32		hwINFO;		/* transfer info bitmask */
-
-	/* hwINFO bits for both general and iso tds: */
-#define TD_CC       0xf0000000			/* condition code */
-#define TD_CC_GET(td_p) ((td_p >>28) & 0x0f)
-//#define TD_CC_SET(td_p, cc) (td_p) = ((td_p) & 0x0fffffff) | (((cc) & 0x0f) << 28)
-#define TD_DI       0x00E00000			/* frames before interrupt */
-#define TD_DI_SET(X) (((X) & 0x07)<< 21)
-	/* these two bits are available for definition/use by HCDs in both
-	 * general and iso tds ... others are available for only one type
-	 */
-#define TD_DONE     0x00020000			/* retired to donelist */
-#define TD_ISO      0x00010000			/* copy of ED_ISO */
-
-	/* hwINFO bits for general tds: */
-#define TD_EC       0x0C000000			/* error count */
-#define TD_T        0x03000000			/* data toggle state */
-#define TD_T_DATA0  0x02000000				/* DATA0 */
-#define TD_T_DATA1  0x03000000				/* DATA1 */
-#define TD_T_TOGGLE 0x00000000				/* uses ED_C */
-#define TD_DP       0x00180000			/* direction/pid */
-#define TD_DP_SETUP 0x00000000			/* SETUP pid */
-#define TD_DP_IN    0x00100000				/* IN pid */
-#define TD_DP_OUT   0x00080000				/* OUT pid */
-							/* 0x00180000 rsvd */
-#define TD_R        0x00040000			/* round: short packets OK? */
-
-	/* (no hwINFO #defines yet for iso tds) */
-
-	__hc32		hwCBP;		/* Current Buffer Pointer (or 0) */
-	__hc32		hwNextTD;	/* Next TD Pointer */
-	__hc32		hwBE;		/* Memory Buffer End Pointer */
-
-	/* PSW is only for ISO.  Only 1 PSW entry is used, but on
-	 * big-endian PPC hardware that's the second entry.
-	 */
-#define MAXPSW	2
-	__hc16		hwPSW [MAXPSW];
-
-	/* rest are purely for the driver's use */
-	__u8		index;
-	struct ed	*ed;
-	struct td	*td_hash;	/* dma-->td hashtable */
-	struct td	*next_dl_td;
-	struct urb	*urb;
-
-	dma_addr_t	td_dma;		/* addr of this TD */
-	dma_addr_t	data_dma;	/* addr of data it points to */
-
-	struct list_head td_list;	/* "shadow list", TDs on same ED */
-} __attribute__ ((aligned(32)));	/* c/b/i need 16; only iso needs 32 */
-
-#define TD_MASK	((u32)~0x1f)		/* strip hw status in low addr bits */
-
-/*
- * Hardware transfer status codes -- CC from td->hwINFO or td->hwPSW
- */
-#define TD_CC_NOERROR      0x00
-#define TD_CC_CRC          0x01
-#define TD_CC_BITSTUFFING  0x02
-#define TD_CC_DATATOGGLEM  0x03
-#define TD_CC_STALL        0x04
-#define TD_DEVNOTRESP      0x05
-#define TD_PIDCHECKFAIL    0x06
-#define TD_UNEXPECTEDPID   0x07
-#define TD_DATAOVERRUN     0x08
-#define TD_DATAUNDERRUN    0x09
-    /* 0x0A, 0x0B reserved for hardware */
-#define TD_BUFFEROVERRUN   0x0C
-#define TD_BUFFERUNDERRUN  0x0D
-    /* 0x0E, 0x0F reserved for HCD */
-#define TD_NOTACCESSED     0x0F
-
-
-/* map OHCI TD status codes (CC) to errno values */
-static const int cc_to_error [16] = {
-	/* No  Error  */               0,
-	/* CRC Error  */               -EILSEQ,
-	/* Bit Stuff  */               -EPROTO,
-	/* Data Togg  */               -EILSEQ,
-	/* Stall      */               -EPIPE,
-	/* DevNotResp */               -ETIME,
-	/* PIDCheck   */               -EPROTO,
-	/* UnExpPID   */               -EPROTO,
-	/* DataOver   */               -EOVERFLOW,
-	/* DataUnder  */               -EREMOTEIO,
-	/* (for hw)   */               -EIO,
-	/* (for hw)   */               -EIO,
-	/* BufferOver */               -ECOMM,
-	/* BuffUnder  */               -ENOSR,
-	/* (for HCD)  */               -EALREADY,
-	/* (for HCD)  */               -EALREADY
-};
-
-
-/*
- * The HCCA (Host Controller Communications Area) is a 256 byte
- * structure defined section 4.4.1 of the OHCI spec. The HC is
- * told the base address of it.  It must be 256-byte aligned.
- */
-struct ohci_hcca {
-#define NUM_INTS 32
-	__hc32	int_table [NUM_INTS];	/* periodic schedule */
-
-	/*
-	 * OHCI defines u16 frame_no, followed by u16 zero pad.
-	 * Since some processors can't do 16 bit bus accesses,
-	 * portable access must be a 32 bits wide.
-	 */
-	__hc32	frame_no;		/* current frame number */
-	__hc32	done_head;		/* info returned for an interrupt */
-	u8	reserved_for_hc [116];
-	u8	what [4];		/* spec only identifies 252 bytes :) */
-} __attribute__ ((aligned(256)));
-
-/*
- * This is the structure of the OHCI controller's memory mapped I/O region.
- * You must use readl() and writel() (in <asm/io.h>) to access these fields!!
- * Layout is in section 7 (and appendix B) of the spec.
- */
-struct ohci_regs {
-	/* control and status registers (section 7.1) */
-	__hc32	revision;
-	__hc32	control;
-	__hc32	cmdstatus;
-	__hc32	intrstatus;
-	__hc32	intrenable;
-	__hc32	intrdisable;
-
-	/* memory pointers (section 7.2) */
-	__hc32	hcca;
-	__hc32	ed_periodcurrent;
-	__hc32	ed_controlhead;
-	__hc32	ed_controlcurrent;
-	__hc32	ed_bulkhead;
-	__hc32	ed_bulkcurrent;
-	__hc32	donehead;
-
-	/* frame counters (section 7.3) */
-	__hc32	fminterval;
-	__hc32	fmremaining;
-	__hc32	fmnumber;
-	__hc32	periodicstart;
-	__hc32	lsthresh;
-
-	/* Root hub ports (section 7.4) */
-	struct	ohci_roothub_regs {
-		__hc32	a;
-		__hc32	b;
-		__hc32	status;
-#define MAX_ROOT_PORTS	15	/* maximum OHCI root hub ports (RH_A_NDP) */
-		__hc32	portstatus [MAX_ROOT_PORTS];
-	} roothub;
-
-	/* and optional "legacy support" registers (appendix B) at 0x0100 */
-
-} __attribute__ ((aligned(32)));
-
-
-/* OHCI CONTROL AND STATUS REGISTER MASKS */
-
-/*
- * HcControl (control) register masks
- */
-#define OHCI_CTRL_CBSR	(3 << 0)	/* control/bulk service ratio */
-#define OHCI_CTRL_PLE	(1 << 2)	/* periodic list enable */
-#define OHCI_CTRL_IE	(1 << 3)	/* isochronous enable */
-#define OHCI_CTRL_CLE	(1 << 4)	/* control list enable */
-#define OHCI_CTRL_BLE	(1 << 5)	/* bulk list enable */
-#define OHCI_CTRL_HCFS	(3 << 6)	/* host controller functional state */
-#define OHCI_CTRL_IR	(1 << 8)	/* interrupt routing */
-#define OHCI_CTRL_RWC	(1 << 9)	/* remote wakeup connected */
-#define OHCI_CTRL_RWE	(1 << 10)	/* remote wakeup enable */
-
-/* pre-shifted values for HCFS */
-#	define OHCI_USB_RESET	(0 << 6)
-#	define OHCI_USB_RESUME	(1 << 6)
-#	define OHCI_USB_OPER	(2 << 6)
-#	define OHCI_USB_SUSPEND	(3 << 6)
-
-/*
- * HcCommandStatus (cmdstatus) register masks
- */
-#define OHCI_HCR	(1 << 0)	/* host controller reset */
-#define OHCI_CLF	(1 << 1)	/* control list filled */
-#define OHCI_BLF	(1 << 2)	/* bulk list filled */
-#define OHCI_OCR	(1 << 3)	/* ownership change request */
-#define OHCI_SOC	(3 << 16)	/* scheduling overrun count */
-
-/*
- * masks used with interrupt registers:
- * HcInterruptStatus (intrstatus)
- * HcInterruptEnable (intrenable)
- * HcInterruptDisable (intrdisable)
- */
-#define OHCI_INTR_SO	(1 << 0)	/* scheduling overrun */
-#define OHCI_INTR_WDH	(1 << 1)	/* writeback of done_head */
-#define OHCI_INTR_SF	(1 << 2)	/* start frame */
-#define OHCI_INTR_RD	(1 << 3)	/* resume detect */
-#define OHCI_INTR_UE	(1 << 4)	/* unrecoverable error */
-#define OHCI_INTR_FNO	(1 << 5)	/* frame number overflow */
-#define OHCI_INTR_RHSC	(1 << 6)	/* root hub status change */
-#define OHCI_INTR_OC	(1 << 30)	/* ownership change */
-#define OHCI_INTR_MIE	(1 << 31)	/* master interrupt enable */
-
-
-/* OHCI ROOT HUB REGISTER MASKS */
-
-/* roothub.portstatus [i] bits */
-#define RH_PS_CCS            0x00000001		/* current connect status */
-#define RH_PS_PES            0x00000002		/* port enable status*/
-#define RH_PS_PSS            0x00000004		/* port suspend status */
-#define RH_PS_POCI           0x00000008		/* port over current indicator */
-#define RH_PS_PRS            0x00000010		/* port reset status */
-#define RH_PS_PPS            0x00000100		/* port power status */
-#define RH_PS_LSDA           0x00000200		/* low speed device attached */
-#define RH_PS_CSC            0x00010000		/* connect status change */
-#define RH_PS_PESC           0x00020000		/* port enable status change */
-#define RH_PS_PSSC           0x00040000		/* port suspend status change */
-#define RH_PS_OCIC           0x00080000		/* over current indicator change */
-#define RH_PS_PRSC           0x00100000		/* port reset status change */
-
-/* roothub.status bits */
-#define RH_HS_LPS	     0x00000001		/* local power status */
-#define RH_HS_OCI	     0x00000002		/* over current indicator */
-#define RH_HS_DRWE	     0x00008000		/* device remote wakeup enable */
-#define RH_HS_LPSC	     0x00010000		/* local power status change */
-#define RH_HS_OCIC	     0x00020000		/* over current indicator change */
-#define RH_HS_CRWE	     0x80000000		/* clear remote wakeup enable */
-
-/* roothub.b masks */
-#define RH_B_DR		0x0000ffff		/* device removable flags */
-#define RH_B_PPCM	0xffff0000		/* port power control mask */
-
-/* roothub.a masks */
-#define	RH_A_NDP	(0xff << 0)		/* number of downstream ports */
-#define	RH_A_PSM	(1 << 8)		/* power switching mode */
-#define	RH_A_NPS	(1 << 9)		/* no power switching */
-#define	RH_A_DT		(1 << 10)		/* device type (mbz) */
-#define	RH_A_OCPM	(1 << 11)		/* over current protection mode */
-#define	RH_A_NOCP	(1 << 12)		/* no over current protection */
-#define	RH_A_POTPGT	(0xff << 24)		/* power on to power good time */
-
-
-/* hcd-private per-urb state */
-typedef struct urb_priv {
-	struct ed		*ed;
-	u16			length;		// # tds in this request
-	u16			td_cnt;		// tds already serviced
-	struct list_head	pending;
-	struct td		*td [0];	// all TDs in this request
-
-} urb_priv_t;
-
-#define TD_HASH_SIZE    64    /* power'o'two */
-// sizeof (struct td) ~= 64 == 2^6 ...
-#define TD_HASH_FUNC(td_dma) ((td_dma ^ (td_dma >> 6)) % TD_HASH_SIZE)
-
-
-/*
- * This is the full ohci controller description
- *
- * Note how the "proper" USB information is just
- * a subset of what the full implementation needs. (Linus)
- */
-
-struct ohci_hcd {
-	spinlock_t		lock;
-
-	/*
-	 * I/O memory used to communicate with the HC (dma-consistent)
-	 */
-	struct ohci_regs __iomem *regs;
-
-	/*
-	 * main memory used to communicate with the HC (dma-consistent).
-	 * hcd adds to schedule for a live hc any time, but removals finish
-	 * only at the start of the next frame.
-	 */
-	struct ohci_hcca	*hcca;
-	dma_addr_t		hcca_dma;
-
-	struct ed		*ed_rm_list;		/* to be removed */
-
-	struct ed		*ed_bulktail;		/* last in bulk list */
-	struct ed		*ed_controltail;	/* last in ctrl list */
-	struct ed		*periodic [NUM_INTS];	/* shadow int_table */
-
-	/*
-	 * OTG controllers and transceivers need software interaction;
-	 * other external transceivers should be software-transparent
-	 */
-	struct otg_transceiver	*transceiver;
-
-	/*
-	 * memory management for queue data structures
-	 */
-	struct dma_pool		*td_cache;
-	struct dma_pool		*ed_cache;
-	struct td		*td_hash [TD_HASH_SIZE];
-	struct list_head	pending;
-
-	/*
-	 * driver state
-	 */
-	int			num_ports;
-	int			load [NUM_INTS];
-	u32			hc_control;	/* copy of hc control reg */
-	unsigned long		next_statechange;	/* suspend/resume */
-	u32			fminterval;		/* saved register */
-	unsigned		autostop:1;	/* rh auto stopping/stopped */
-
-	unsigned long		flags;		/* for HC bugs */
-#define	OHCI_QUIRK_AMD756	0x01			/* erratum #4 */
-#define	OHCI_QUIRK_SUPERIO	0x02			/* natsemi */
-#define	OHCI_QUIRK_INITRESET	0x04			/* SiS, OPTi, ... */
-#define	OHCI_QUIRK_BE_DESC	0x08			/* BE descriptors */
-#define	OHCI_QUIRK_BE_MMIO	0x10			/* BE registers */
-#define	OHCI_QUIRK_ZFMICRO	0x20			/* Compaq ZFMicro chipset*/
-#define	OHCI_QUIRK_NEC		0x40			/* lost interrupts */
-	// there are also chip quirks/bugs in init logic
-
-	struct work_struct	nec_work;	/* Worker for NEC quirk */
-};
-
-/* convert between an hcd pointer and the corresponding ohci_hcd */
-static inline struct ohci_hcd *hcd_to_ohci (struct usb_hcd *hcd)
-{
-	return (struct ohci_hcd *) (hcd->hcd_priv);
-}
-static inline struct usb_hcd *ohci_to_hcd (const struct ohci_hcd *ohci)
-{
-	return container_of ((void *) ohci, struct usb_hcd, hcd_priv);
-}
-
-/*-------------------------------------------------------------------------*/
-
-#ifndef DEBUG
-#define STUB_DEBUG_FILES
-#endif	/* DEBUG */
-
-#define ohci_dbg(ohci, fmt, args...) \
-	dev_dbg (ohci_to_hcd(ohci)->self.controller , fmt , ## args )
-#define ohci_err(ohci, fmt, args...) \
-	dev_err (ohci_to_hcd(ohci)->self.controller , fmt , ## args )
-#define ohci_info(ohci, fmt, args...) \
-	dev_info (ohci_to_hcd(ohci)->self.controller , fmt , ## args )
-#define ohci_warn(ohci, fmt, args...) \
-	dev_warn (ohci_to_hcd(ohci)->self.controller , fmt , ## args )
-
-#ifdef OHCI_VERBOSE_DEBUG
-#	define ohci_vdbg ohci_dbg
-#else
-#	define ohci_vdbg(ohci, fmt, args...) do { } while (0)
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * While most USB host controllers implement their registers and
- * in-memory communication descriptors in little-endian format,
- * a minority (notably the IBM STB04XXX and the Motorola MPC5200
- * processors) implement them in big endian format.
- *
- * In addition some more exotic implementations like the Toshiba
- * Spider (aka SCC) cell southbridge are "mixed" endian, that is,
- * they have a different endianness for registers vs. in-memory
- * descriptors.
- *
- * This attempts to support either format at compile time without a
- * runtime penalty, or both formats with the additional overhead
- * of checking a flag bit.
- *
- * That leads to some tricky Kconfig rules howevber. There are
- * different defaults based on some arch/ppc platforms, though
- * the basic rules are:
- *
- * Controller type              Kconfig options needed
- * ---------------              ----------------------
- * little endian                CONFIG_USB_OHCI_LITTLE_ENDIAN
- *
- * fully big endian             CONFIG_USB_OHCI_BIG_ENDIAN_DESC _and_
- *                              CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
- *
- * mixed endian                 CONFIG_USB_OHCI_LITTLE_ENDIAN _and_
- *                              CONFIG_USB_OHCI_BIG_ENDIAN_{MMIO,DESC}
- *
- * (If you have a mixed endian controller, you -must- also define
- * CONFIG_USB_OHCI_LITTLE_ENDIAN or things will not work when building
- * both your mixed endian and a fully big endian controller support in
- * the same kernel image).
- */
-
-#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_DESC
-#ifdef CONFIG_USB_OHCI_LITTLE_ENDIAN
-#define big_endian_desc(ohci)	(ohci->flags & OHCI_QUIRK_BE_DESC)
-#else
-#define big_endian_desc(ohci)	1		/* only big endian */
-#endif
-#else
-#define big_endian_desc(ohci)	0		/* only little endian */
-#endif
-
-#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
-#ifdef CONFIG_USB_OHCI_LITTLE_ENDIAN
-#define big_endian_mmio(ohci)	(ohci->flags & OHCI_QUIRK_BE_MMIO)
-#else
-#define big_endian_mmio(ohci)	1		/* only big endian */
-#endif
-#else
-#define big_endian_mmio(ohci)	0		/* only little endian */
-#endif
-
-/*
- * Big-endian read/write functions are arch-specific.
- * Other arches can be added if/when they're needed.
- *
- * REVISIT: arch/powerpc now has readl/writel_be, so the
- * definition below can die once the STB04xxx support is
- * finally ported over.
- */
-#if defined(CONFIG_PPC) && !defined(CONFIG_PPC_MERGE)
-#define readl_be(addr)		in_be32((__force unsigned *)addr)
-#define writel_be(val, addr)	out_be32((__force unsigned *)addr, val)
-#endif
-
-static inline unsigned int _ohci_readl (const struct ohci_hcd *ohci,
-					__hc32 __iomem * regs)
-{
-#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
-	return big_endian_mmio(ohci) ?
-		readl_be (regs) :
-		readl (regs);
-#else
-	return readl (regs);
-#endif
-}
-
-static inline void _ohci_writel (const struct ohci_hcd *ohci,
-				 const unsigned int val, __hc32 __iomem *regs)
-{
-#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
-	big_endian_mmio(ohci) ?
-		writel_be (val, regs) :
-		writel (val, regs);
-#else
-		writel (val, regs);
-#endif
-}
-
-#ifdef CONFIG_ARCH_LH7A404
-/* Marc Singer: at the time this code was written, the LH7A404
- * had a problem reading the USB host registers.  This
- * implementation of the ohci_readl function performs the read
- * twice as a work-around.
- */
-#define ohci_readl(o,r)		(_ohci_readl(o,r),_ohci_readl(o,r))
-#define ohci_writel(o,v,r)	_ohci_writel(o,v,r)
-#else
-#define ohci_readl(o,r)		_ohci_readl(o,r)
-#define ohci_writel(o,v,r)	_ohci_writel(o,v,r)
-#endif
-
-
-/*-------------------------------------------------------------------------*/
-
-/* cpu to ohci */
-static inline __hc16 cpu_to_hc16 (const struct ohci_hcd *ohci, const u16 x)
-{
-	return big_endian_desc(ohci) ?
-		(__force __hc16)cpu_to_be16(x) :
-		(__force __hc16)cpu_to_le16(x);
-}
-
-static inline __hc16 cpu_to_hc16p (const struct ohci_hcd *ohci, const u16 *x)
-{
-	return big_endian_desc(ohci) ?
-		cpu_to_be16p(x) :
-		cpu_to_le16p(x);
-}
-
-static inline __hc32 cpu_to_hc32 (const struct ohci_hcd *ohci, const u32 x)
-{
-	return big_endian_desc(ohci) ?
-		(__force __hc32)cpu_to_be32(x) :
-		(__force __hc32)cpu_to_le32(x);
-}
-
-static inline __hc32 cpu_to_hc32p (const struct ohci_hcd *ohci, const u32 *x)
-{
-	return big_endian_desc(ohci) ?
-		cpu_to_be32p(x) :
-		cpu_to_le32p(x);
-}
-
-/* ohci to cpu */
-static inline u16 hc16_to_cpu (const struct ohci_hcd *ohci, const __hc16 x)
-{
-	return big_endian_desc(ohci) ?
-		be16_to_cpu((__force __be16)x) :
-		le16_to_cpu((__force __le16)x);
-}
-
-static inline u16 hc16_to_cpup (const struct ohci_hcd *ohci, const __hc16 *x)
-{
-	return big_endian_desc(ohci) ?
-		be16_to_cpup((__force __be16 *)x) :
-		le16_to_cpup((__force __le16 *)x);
-}
-
-static inline u32 hc32_to_cpu (const struct ohci_hcd *ohci, const __hc32 x)
-{
-	return big_endian_desc(ohci) ?
-		be32_to_cpu((__force __be32)x) :
-		le32_to_cpu((__force __le32)x);
-}
-
-static inline u32 hc32_to_cpup (const struct ohci_hcd *ohci, const __hc32 *x)
-{
-	return big_endian_desc(ohci) ?
-		be32_to_cpup((__force __be32 *)x) :
-		le32_to_cpup((__force __le32 *)x);
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* HCCA frame number is 16 bits, but is accessed as 32 bits since not all
- * hardware handles 16 bit reads.  That creates a different confusion on
- * some big-endian SOC implementations.  Same thing happens with PSW access.
- *
- * FIXME: Deal with that as a runtime quirk when STB03xxx is ported over
- * to arch/powerpc
- */
-
-#ifdef CONFIG_STB03xxx
-#define OHCI_BE_FRAME_NO_SHIFT	16
-#else
-#define OHCI_BE_FRAME_NO_SHIFT	0
-#endif
-
-static inline u16 ohci_frame_no(const struct ohci_hcd *ohci)
-{
-	u32 tmp;
-	if (big_endian_desc(ohci)) {
-		tmp = be32_to_cpup((__force __be32 *)&ohci->hcca->frame_no);
-		tmp >>= OHCI_BE_FRAME_NO_SHIFT;
-	} else
-		tmp = le32_to_cpup((__force __le32 *)&ohci->hcca->frame_no);
-
-	return (u16)tmp;
-}
-
-static inline __hc16 *ohci_hwPSWp(const struct ohci_hcd *ohci,
-                                 const struct td *td, int index)
-{
-	return (__hc16 *)(big_endian_desc(ohci) ?
-			&td->hwPSW[index ^ 1] : &td->hwPSW[index]);
-}
-
-static inline u16 ohci_hwPSW(const struct ohci_hcd *ohci,
-                               const struct td *td, int index)
-{
-	return hc16_to_cpup(ohci, ohci_hwPSWp(ohci, td, index));
-}
-
-/*-------------------------------------------------------------------------*/
-
-static inline void disable (struct ohci_hcd *ohci)
-{
-	ohci_to_hcd(ohci)->state = HC_STATE_HALT;
-}
-
-#define	FI			0x2edf		/* 12000 bits per frame (-1) */
-#define	FSMP(fi)		(0x7fff & ((6 * ((fi) - 210)) / 7))
-#define	FIT			(1 << 31)
-#define LSTHRESH		0x628		/* lowspeed bit threshold */
-
-static inline void periodic_reinit (struct ohci_hcd *ohci)
-{
-	u32	fi = ohci->fminterval & 0x03fff;
-	u32	fit = ohci_readl(ohci, &ohci->regs->fminterval) & FIT;
-
-	ohci_writel (ohci, (fit ^ FIT) | ohci->fminterval,
-						&ohci->regs->fminterval);
-	ohci_writel (ohci, ((9 * fi) / 10) & 0x3fff,
-						&ohci->regs->periodicstart);
-}
-
-/* AMD-756 (D2 rev) reports corrupt register contents in some cases.
- * The erratum (#4) description is incorrect.  AMD's workaround waits
- * till some bits (mostly reserved) are clear; ok for all revs.
- */
-#define read_roothub(hc, register, mask) ({ \
-	u32 temp = ohci_readl (hc, &hc->regs->roothub.register); \
-	if (temp == -1) \
-		disable (hc); \
-	else if (hc->flags & OHCI_QUIRK_AMD756) \
-		while (temp & mask) \
-			temp = ohci_readl (hc, &hc->regs->roothub.register); \
-	temp; })
-
-static inline u32 roothub_a (struct ohci_hcd *hc)
-	{ return read_roothub (hc, a, 0xfc0fe000); }
-static inline u32 roothub_b (struct ohci_hcd *hc)
-	{ return ohci_readl (hc, &hc->regs->roothub.b); }
-static inline u32 roothub_status (struct ohci_hcd *hc)
-	{ return ohci_readl (hc, &hc->regs->roothub.status); }
-static inline u32 roothub_portstatus (struct ohci_hcd *hc, int i)
-	{ return read_roothub (hc, portstatus [i], 0xffe0fce0); }
diff -urN host/.svn/text-base/pci-quirks.c.svn-base host.new/.svn/text-base/pci-quirks.c.svn-base
--- host/.svn/text-base/pci-quirks.c.svn-base	2009-02-24 19:00:15.883945855 +0100
+++ host.new/.svn/text-base/pci-quirks.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,361 +0,0 @@
-/*
- * This file contains code to reset and initialize USB host controllers.
- * Some of it includes work-arounds for PCI hardware and BIOS quirks.
- * It may need to run early during booting -- before USB would normally
- * initialize -- to ensure that Linux doesn't use any legacy modes.
- *
- *  Copyright (c) 1999 Martin Mares <mj@ucw.cz>
- *  (and others)
- */
-
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/acpi.h>
-#include "pci-quirks.h"
-
-
-#define UHCI_USBLEGSUP		0xc0		/* legacy support */
-#define UHCI_USBCMD		0		/* command register */
-#define UHCI_USBINTR		4		/* interrupt register */
-#define UHCI_USBLEGSUP_RWC	0x8f00		/* the R/WC bits */
-#define UHCI_USBLEGSUP_RO	0x5040		/* R/O and reserved bits */
-#define UHCI_USBCMD_RUN		0x0001		/* RUN/STOP bit */
-#define UHCI_USBCMD_HCRESET	0x0002		/* Host Controller reset */
-#define UHCI_USBCMD_EGSM	0x0008		/* Global Suspend Mode */
-#define UHCI_USBCMD_CONFIGURE	0x0040		/* Config Flag */
-#define UHCI_USBINTR_RESUME	0x0002		/* Resume interrupt enable */
-
-#define OHCI_CONTROL		0x04
-#define OHCI_CMDSTATUS		0x08
-#define OHCI_INTRSTATUS		0x0c
-#define OHCI_INTRENABLE		0x10
-#define OHCI_INTRDISABLE	0x14
-#define OHCI_OCR		(1 << 3)	/* ownership change request */
-#define OHCI_CTRL_RWC		(1 << 9)	/* remote wakeup connected */
-#define OHCI_CTRL_IR		(1 << 8)	/* interrupt routing */
-#define OHCI_INTR_OC		(1 << 30)	/* ownership change */
-
-#define EHCI_HCC_PARAMS		0x08		/* extended capabilities */
-#define EHCI_USBCMD		0		/* command register */
-#define EHCI_USBCMD_RUN		(1 << 0)	/* RUN/STOP bit */
-#define EHCI_USBSTS		4		/* status register */
-#define EHCI_USBSTS_HALTED	(1 << 12)	/* HCHalted bit */
-#define EHCI_USBINTR		8		/* interrupt register */
-#define EHCI_CONFIGFLAG		0x40		/* configured flag register */
-#define EHCI_USBLEGSUP		0		/* legacy support register */
-#define EHCI_USBLEGSUP_BIOS	(1 << 16)	/* BIOS semaphore */
-#define EHCI_USBLEGSUP_OS	(1 << 24)	/* OS semaphore */
-#define EHCI_USBLEGCTLSTS	4		/* legacy control/status */
-#define EHCI_USBLEGCTLSTS_SOOE	(1 << 13)	/* SMI on ownership change */
-
-
-/*
- * Make sure the controller is completely inactive, unable to
- * generate interrupts or do DMA.
- */
-void uhci_reset_hc(struct pci_dev *pdev, unsigned long base)
-{
-	/* Turn off PIRQ enable and SMI enable.  (This also turns off the
-	 * BIOS's USB Legacy Support.)  Turn off all the R/WC bits too.
-	 */
-	pci_write_config_word(pdev, UHCI_USBLEGSUP, UHCI_USBLEGSUP_RWC);
-
-	/* Reset the HC - this will force us to get a
-	 * new notification of any already connected
-	 * ports due to the virtual disconnect that it
-	 * implies.
-	 */
-	outw(UHCI_USBCMD_HCRESET, base + UHCI_USBCMD);
-	mb();
-	udelay(5);
-	if (inw(base + UHCI_USBCMD) & UHCI_USBCMD_HCRESET)
-		dev_warn(&pdev->dev, "HCRESET not completed yet!\n");
-
-	/* Just to be safe, disable interrupt requests and
-	 * make sure the controller is stopped.
-	 */
-	outw(0, base + UHCI_USBINTR);
-	outw(0, base + UHCI_USBCMD);
-}
-EXPORT_SYMBOL_GPL(uhci_reset_hc);
-
-/*
- * Initialize a controller that was newly discovered or has just been
- * resumed.  In either case we can't be sure of its previous state.
- *
- * Returns: 1 if the controller was reset, 0 otherwise.
- */
-int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base)
-{
-	u16 legsup;
-	unsigned int cmd, intr;
-
-	/*
-	 * When restarting a suspended controller, we expect all the
-	 * settings to be the same as we left them:
-	 *
-	 *	PIRQ and SMI disabled, no R/W bits set in USBLEGSUP;
-	 *	Controller is stopped and configured with EGSM set;
-	 *	No interrupts enabled except possibly Resume Detect.
-	 *
-	 * If any of these conditions are violated we do a complete reset.
-	 */
-	pci_read_config_word(pdev, UHCI_USBLEGSUP, &legsup);
-	if (legsup & ~(UHCI_USBLEGSUP_RO | UHCI_USBLEGSUP_RWC)) {
-		dev_dbg(&pdev->dev, "%s: legsup = 0x%04x\n",
-				__FUNCTION__, legsup);
-		goto reset_needed;
-	}
-
-	cmd = inw(base + UHCI_USBCMD);
-	if ((cmd & UHCI_USBCMD_RUN) || !(cmd & UHCI_USBCMD_CONFIGURE) ||
-			!(cmd & UHCI_USBCMD_EGSM)) {
-		dev_dbg(&pdev->dev, "%s: cmd = 0x%04x\n",
-				__FUNCTION__, cmd);
-		goto reset_needed;
-	}
-
-	intr = inw(base + UHCI_USBINTR);
-	if (intr & (~UHCI_USBINTR_RESUME)) {
-		dev_dbg(&pdev->dev, "%s: intr = 0x%04x\n",
-				__FUNCTION__, intr);
-		goto reset_needed;
-	}
-	return 0;
-
-reset_needed:
-	dev_dbg(&pdev->dev, "Performing full reset\n");
-	uhci_reset_hc(pdev, base);
-	return 1;
-}
-EXPORT_SYMBOL_GPL(uhci_check_and_reset_hc);
-
-static inline int io_type_enabled(struct pci_dev *pdev, unsigned int mask)
-{
-	u16 cmd;
-	return !pci_read_config_word(pdev, PCI_COMMAND, &cmd) && (cmd & mask);
-}
-
-#define pio_enabled(dev) io_type_enabled(dev, PCI_COMMAND_IO)
-#define mmio_enabled(dev) io_type_enabled(dev, PCI_COMMAND_MEMORY)
-
-static void __devinit quirk_usb_handoff_uhci(struct pci_dev *pdev)
-{
-	unsigned long base = 0;
-	int i;
-
-	if (!pio_enabled(pdev))
-		return;
-
-	for (i = 0; i < PCI_ROM_RESOURCE; i++)
-		if ((pci_resource_flags(pdev, i) & IORESOURCE_IO)) {
-			base = pci_resource_start(pdev, i);
-			break;
-		}
-
-	if (base)
-		uhci_check_and_reset_hc(pdev, base);
-}
-
-static int __devinit mmio_resource_enabled(struct pci_dev *pdev, int idx)
-{
-	return pci_resource_start(pdev, idx) && mmio_enabled(pdev);
-}
-
-static void __devinit quirk_usb_handoff_ohci(struct pci_dev *pdev)
-{
-	void __iomem *base;
-
-	if (!mmio_resource_enabled(pdev, 0))
-		return;
-
-	base = ioremap_nocache(pci_resource_start(pdev, 0),
-				     pci_resource_len(pdev, 0));
-	if (base == NULL) return;
-
-/* On PA-RISC, PDC can leave IR set incorrectly; ignore it there. */
-#ifndef __hppa__
-{
-	u32 control = readl(base + OHCI_CONTROL);
-	if (control & OHCI_CTRL_IR) {
-		int wait_time = 500; /* arbitrary; 5 seconds */
-		writel(OHCI_INTR_OC, base + OHCI_INTRENABLE);
-		writel(OHCI_OCR, base + OHCI_CMDSTATUS);
-		while (wait_time > 0 &&
-				readl(base + OHCI_CONTROL) & OHCI_CTRL_IR) {
-			wait_time -= 10;
-			msleep(10);
-		}
-		if (wait_time <= 0)
-			printk(KERN_WARNING "%s %s: BIOS handoff "
-					"failed (BIOS bug ?) %08x\n",
-					pdev->dev.bus_id, "OHCI",
-					readl(base + OHCI_CONTROL));
-
-		/* reset controller, preserving RWC */
-		writel(control & OHCI_CTRL_RWC, base + OHCI_CONTROL);
-	}
-}
-#endif
-
-	/*
-	 * disable interrupts
-	 */
-	writel(~(u32)0, base + OHCI_INTRDISABLE);
-	writel(~(u32)0, base + OHCI_INTRSTATUS);
-
-	iounmap(base);
-}
-
-static void __devinit quirk_usb_disable_ehci(struct pci_dev *pdev)
-{
-	int wait_time, delta;
-	void __iomem *base, *op_reg_base;
-	u32	hcc_params, val;
-	u8	offset, cap_length;
-	int	count = 256/4;
-	int	tried_handoff = 0;
-
-	if (!mmio_resource_enabled(pdev, 0))
-		return;
-
-	base = ioremap_nocache(pci_resource_start(pdev, 0),
-				pci_resource_len(pdev, 0));
-	if (base == NULL) return;
-
-	cap_length = readb(base);
-	op_reg_base = base + cap_length;
-
-	/* EHCI 0.96 and later may have "extended capabilities"
-	 * spec section 5.1 explains the bios handoff, e.g. for
-	 * booting from USB disk or using a usb keyboard
-	 */
-	hcc_params = readl(base + EHCI_HCC_PARAMS);
-	offset = (hcc_params >> 8) & 0xff;
-	while (offset && count--) {
-		u32		cap;
-		int		msec;
-
-		pci_read_config_dword(pdev, offset, &cap);
-		switch (cap & 0xff) {
-		case 1:			/* BIOS/SMM/... handoff support */
-			if ((cap & EHCI_USBLEGSUP_BIOS)) {
-				pr_debug("%s %s: BIOS handoff\n",
-						pdev->dev.bus_id, "EHCI");
-
-#if 0
-/* aleksey_gorelov@phoenix.com reports that some systems need SMI forced on,
- * but that seems dubious in general (the BIOS left it off intentionally)
- * and is known to prevent some systems from booting.  so we won't do this
- * unless maybe we can determine when we're on a system that needs SMI forced.
- */
-				/* BIOS workaround (?): be sure the
-				 * pre-Linux code receives the SMI
-				 */
-				pci_read_config_dword(pdev,
-						offset + EHCI_USBLEGCTLSTS,
-						&val);
-				pci_write_config_dword(pdev,
-						offset + EHCI_USBLEGCTLSTS,
-						val | EHCI_USBLEGCTLSTS_SOOE);
-#endif
-
-				/* some systems get upset if this semaphore is
-				 * set for any other reason than forcing a BIOS
-				 * handoff..
-				 */
-				pci_write_config_byte(pdev, offset + 3, 1);
-			}
-
-			/* if boot firmware now owns EHCI, spin till
-			 * it hands it over.
-			 */
-			msec = 5000;
-			while ((cap & EHCI_USBLEGSUP_BIOS) && (msec > 0)) {
-				tried_handoff = 1;
-				msleep(10);
-				msec -= 10;
-				pci_read_config_dword(pdev, offset, &cap);
-			}
-
-			if (cap & EHCI_USBLEGSUP_BIOS) {
-				/* well, possibly buggy BIOS... try to shut
-				 * it down, and hope nothing goes too wrong
-				 */
-				printk(KERN_WARNING "%s %s: BIOS handoff "
-						"failed (BIOS bug ?) %08x\n",
-					pdev->dev.bus_id, "EHCI", cap);
-				pci_write_config_byte(pdev, offset + 2, 0);
-			}
-
-			/* just in case, always disable EHCI SMIs */
-			pci_write_config_dword(pdev,
-					offset + EHCI_USBLEGCTLSTS,
-					0);
-
-			/* If the BIOS ever owned the controller then we
-			 * can't expect any power sessions to remain intact.
-			 */
-			if (tried_handoff)
-				writel(0, op_reg_base + EHCI_CONFIGFLAG);
-			break;
-		case 0:			/* illegal reserved capability */
-			cap = 0;
-			/* FALLTHROUGH */
-		default:
-			printk(KERN_WARNING "%s %s: unrecognized "
-					"capability %02x\n",
-					pdev->dev.bus_id, "EHCI",
-					cap & 0xff);
-			break;
-		}
-		offset = (cap >> 8) & 0xff;
-	}
-	if (!count)
-		printk(KERN_DEBUG "%s %s: capability loop?\n",
-				pdev->dev.bus_id, "EHCI");
-
-	/*
-	 * halt EHCI & disable its interrupts in any case
-	 */
-	val = readl(op_reg_base + EHCI_USBSTS);
-	if ((val & EHCI_USBSTS_HALTED) == 0) {
-		val = readl(op_reg_base + EHCI_USBCMD);
-		val &= ~EHCI_USBCMD_RUN;
-		writel(val, op_reg_base + EHCI_USBCMD);
-
-		wait_time = 2000;
-		delta = 100;
-		do {
-			writel(0x3f, op_reg_base + EHCI_USBSTS);
-			udelay(delta);
-			wait_time -= delta;
-			val = readl(op_reg_base + EHCI_USBSTS);
-			if ((val == ~(u32)0) || (val & EHCI_USBSTS_HALTED)) {
-				break;
-			}
-		} while (wait_time > 0);
-	}
-	writel(0, op_reg_base + EHCI_USBINTR);
-	writel(0x3f, op_reg_base + EHCI_USBSTS);
-
-	iounmap(base);
-
-	return;
-}
-
-
-
-static void __devinit quirk_usb_early_handoff(struct pci_dev *pdev)
-{
-	if (pdev->class == PCI_CLASS_SERIAL_USB_UHCI)
-		quirk_usb_handoff_uhci(pdev);
-	else if (pdev->class == PCI_CLASS_SERIAL_USB_OHCI)
-		quirk_usb_handoff_ohci(pdev);
-	else if (pdev->class == PCI_CLASS_SERIAL_USB_EHCI)
-		quirk_usb_disable_ehci(pdev);
-}
-DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, quirk_usb_early_handoff);
diff -urN host/.svn/text-base/pci-quirks.h.svn-base host.new/.svn/text-base/pci-quirks.h.svn-base
--- host/.svn/text-base/pci-quirks.h.svn-base	2009-02-24 19:00:15.883945855 +0100
+++ host.new/.svn/text-base/pci-quirks.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,7 +0,0 @@
-#ifndef __LINUX_USB_PCI_QUIRKS_H
-#define __LINUX_USB_PCI_QUIRKS_H
-
-void uhci_reset_hc(struct pci_dev *pdev, unsigned long base);
-int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base);
-
-#endif  /*  __LINUX_USB_PCI_QUIRKS_H  */
diff -urN host/.svn/text-base/r8a66597-hcd.c.svn-base host.new/.svn/text-base/r8a66597-hcd.c.svn-base
--- host/.svn/text-base/r8a66597-hcd.c.svn-base	2009-02-24 19:00:15.911944432 +0100
+++ host.new/.svn/text-base/r8a66597-hcd.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,2240 +0,0 @@
-/*
- * R8A66597 HCD (Host Controller Driver)
- *
- * Copyright (C) 2006-2007 Renesas Solutions Corp.
- * Portions Copyright (C) 2004 Psion Teklogix (for NetBook PRO)
- * Portions Copyright (C) 2004-2005 David Brownell
- * Portions Copyright (C) 1999 Roman Weissgaerber
- *
- * Author : Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/smp_lock.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/timer.h>
-#include <linux/delay.h>
-#include <linux/list.h>
-#include <linux/interrupt.h>
-#include <linux/usb.h>
-#include <linux/platform_device.h>
-#include <linux/io.h>
-#include <linux/irq.h>
-
-#include "../core/hcd.h"
-#include "r8a66597.h"
-
-MODULE_DESCRIPTION("R8A66597 USB Host Controller Driver");
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Yoshihiro Shimoda");
-
-#define DRIVER_VERSION	"29 May 2007"
-
-static const char hcd_name[] = "r8a66597_hcd";
-
-/* module parameters */
-static unsigned short clock = XTAL12;
-module_param(clock, ushort, 0644);
-MODULE_PARM_DESC(clock, "input clock: 48MHz=32768, 24MHz=16384, 12MHz=0 "
-		"(default=0)");
-
-static unsigned short vif = LDRV;
-module_param(vif, ushort, 0644);
-MODULE_PARM_DESC(vif, "input VIF: 3.3V=32768, 1.5V=0(default=32768)");
-
-static unsigned short endian;
-module_param(endian, ushort, 0644);
-MODULE_PARM_DESC(endian, "data endian: big=256, little=0 (default=0)");
-
-static unsigned short irq_sense = INTL;
-module_param(irq_sense, ushort, 0644);
-MODULE_PARM_DESC(irq_sense, "IRQ sense: low level=32, falling edge=0 "
-		"(default=32)");
-
-static void packet_write(struct r8a66597 *r8a66597, u16 pipenum);
-static int r8a66597_get_frame(struct usb_hcd *hcd);
-
-/* this function must be called with interrupt disabled */
-static void enable_pipe_irq(struct r8a66597 *r8a66597, u16 pipenum,
-			    unsigned long reg)
-{
-	u16 tmp;
-
-	tmp = r8a66597_read(r8a66597, INTENB0);
-	r8a66597_bclr(r8a66597, BEMPE | NRDYE | BRDYE, INTENB0);
-	r8a66597_bset(r8a66597, 1 << pipenum, reg);
-	r8a66597_write(r8a66597, tmp, INTENB0);
-}
-
-/* this function must be called with interrupt disabled */
-static void disable_pipe_irq(struct r8a66597 *r8a66597, u16 pipenum,
-			     unsigned long reg)
-{
-	u16 tmp;
-
-	tmp = r8a66597_read(r8a66597, INTENB0);
-	r8a66597_bclr(r8a66597, BEMPE | NRDYE | BRDYE, INTENB0);
-	r8a66597_bclr(r8a66597, 1 << pipenum, reg);
-	r8a66597_write(r8a66597, tmp, INTENB0);
-}
-
-static void set_devadd_reg(struct r8a66597 *r8a66597, u8 r8a66597_address,
-			   u16 usbspd, u8 upphub, u8 hubport, int port)
-{
-	u16 val;
-	unsigned long devadd_reg = get_devadd_addr(r8a66597_address);
-
-	val = (upphub << 11) | (hubport << 8) | (usbspd << 6) | (port & 0x0001);
-	r8a66597_write(r8a66597, val, devadd_reg);
-}
-
-static int enable_controller(struct r8a66597 *r8a66597)
-{
-	u16 tmp;
-	int i = 0;
-
-	do {
-		r8a66597_write(r8a66597, USBE, SYSCFG0);
-		tmp = r8a66597_read(r8a66597, SYSCFG0);
-		if (i++ > 1000) {
-			err("register access fail.");
-			return -ENXIO;
-		}
-	} while ((tmp & USBE) != USBE);
-	r8a66597_bclr(r8a66597, USBE, SYSCFG0);
-	r8a66597_mdfy(r8a66597, clock, XTAL, SYSCFG0);
-
-	i = 0;
-	r8a66597_bset(r8a66597, XCKE, SYSCFG0);
-	do {
-		msleep(1);
-		tmp = r8a66597_read(r8a66597, SYSCFG0);
-		if (i++ > 500) {
-			err("register access fail.");
-			return -ENXIO;
-		}
-	} while ((tmp & SCKE) != SCKE);
-
-	r8a66597_bset(r8a66597, DCFM | DRPD, SYSCFG0);
-	r8a66597_bset(r8a66597, DRPD, SYSCFG1);
-
-	r8a66597_bset(r8a66597, vif & LDRV, PINCFG);
-	r8a66597_bset(r8a66597, HSE, SYSCFG0);
-	r8a66597_bset(r8a66597, HSE, SYSCFG1);
-	r8a66597_bset(r8a66597, USBE, SYSCFG0);
-
-	r8a66597_bset(r8a66597, BEMPE | NRDYE | BRDYE, INTENB0);
-	r8a66597_bset(r8a66597, irq_sense & INTL, SOFCFG);
-	r8a66597_bset(r8a66597, BRDY0, BRDYENB);
-	r8a66597_bset(r8a66597, BEMP0, BEMPENB);
-
-	r8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR, DMA0CFG);
-	r8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR, DMA1CFG);
-
-	r8a66597_bset(r8a66597, endian & BIGEND, CFIFOSEL);
-	r8a66597_bset(r8a66597, endian & BIGEND, D0FIFOSEL);
-	r8a66597_bset(r8a66597, endian & BIGEND, D1FIFOSEL);
-
-	r8a66597_bset(r8a66597, TRNENSEL, SOFCFG);
-
-	r8a66597_bset(r8a66597, SIGNE | SACKE, INTENB1);
-	r8a66597_bclr(r8a66597, DTCHE, INTENB1);
-	r8a66597_bset(r8a66597, ATTCHE, INTENB1);
-	r8a66597_bclr(r8a66597, DTCHE, INTENB2);
-	r8a66597_bset(r8a66597, ATTCHE, INTENB2);
-
-	return 0;
-}
-
-static void disable_controller(struct r8a66597 *r8a66597)
-{
-	u16 tmp;
-
-	r8a66597_write(r8a66597, 0, INTENB0);
-	r8a66597_write(r8a66597, 0, INTENB1);
-	r8a66597_write(r8a66597, 0, INTENB2);
-	r8a66597_write(r8a66597, 0, INTSTS0);
-	r8a66597_write(r8a66597, 0, INTSTS1);
-	r8a66597_write(r8a66597, 0, INTSTS2);
-
-	r8a66597_port_power(r8a66597, 0, 0);
-	r8a66597_port_power(r8a66597, 1, 0);
-
-	do {
-		tmp = r8a66597_read(r8a66597, SOFCFG) & EDGESTS;
-		udelay(640);
-	} while (tmp == EDGESTS);
-
-	r8a66597_bclr(r8a66597, DCFM | DRPD, SYSCFG0);
-	r8a66597_bclr(r8a66597, DRPD, SYSCFG1);
-	r8a66597_bclr(r8a66597, HSE, SYSCFG0);
-	r8a66597_bclr(r8a66597, HSE, SYSCFG1);
-
-	r8a66597_bclr(r8a66597, SCKE, SYSCFG0);
-	udelay(1);
-	r8a66597_bclr(r8a66597, PLLC, SYSCFG0);
-	r8a66597_bclr(r8a66597, XCKE, SYSCFG0);
-	r8a66597_bclr(r8a66597, USBE, SYSCFG0);
-}
-
-static int get_parent_r8a66597_address(struct r8a66597 *r8a66597,
-				       struct usb_device *udev)
-{
-	struct r8a66597_device *dev;
-
-	if (udev->parent && udev->parent->devnum != 1)
-		udev = udev->parent;
-
-	dev = dev_get_drvdata(&udev->dev);
-	if (dev)
-		return dev->address;
-	else
-		return 0;
-}
-
-static int is_child_device(char *devpath)
-{
-	return (devpath[2] ? 1 : 0);
-}
-
-static int is_hub_limit(char *devpath)
-{
-	return ((strlen(devpath) >= 4) ? 1 : 0);
-}
-
-static void get_port_number(char *devpath, u16 *root_port, u16 *hub_port)
-{
-	if (root_port) {
-		*root_port = (devpath[0] & 0x0F) - 1;
-		if (*root_port >= R8A66597_MAX_ROOT_HUB)
-			err("illegal root port number");
-	}
-	if (hub_port)
-		*hub_port = devpath[2] & 0x0F;
-}
-
-static u16 get_r8a66597_usb_speed(enum usb_device_speed speed)
-{
-	u16 usbspd = 0;
-
-	switch (speed) {
-	case USB_SPEED_LOW:
-		usbspd = LSMODE;
-		break;
-	case USB_SPEED_FULL:
-		usbspd = FSMODE;
-		break;
-	case USB_SPEED_HIGH:
-		usbspd = HSMODE;
-		break;
-	default:
-		err("unknown speed");
-		break;
-	}
-
-	return usbspd;
-}
-
-static void set_child_connect_map(struct r8a66597 *r8a66597, int address)
-{
-	int idx;
-
-	idx = address / 32;
-	r8a66597->child_connect_map[idx] |= 1 << (address % 32);
-}
-
-static void put_child_connect_map(struct r8a66597 *r8a66597, int address)
-{
-	int idx;
-
-	idx = address / 32;
-	r8a66597->child_connect_map[idx] &= ~(1 << (address % 32));
-}
-
-static void set_pipe_reg_addr(struct r8a66597_pipe *pipe, u8 dma_ch)
-{
-	u16 pipenum = pipe->info.pipenum;
-	unsigned long fifoaddr[] = {D0FIFO, D1FIFO, CFIFO};
-	unsigned long fifosel[] = {D0FIFOSEL, D1FIFOSEL, CFIFOSEL};
-	unsigned long fifoctr[] = {D0FIFOCTR, D1FIFOCTR, CFIFOCTR};
-
-	if (dma_ch > R8A66597_PIPE_NO_DMA)	/* dma fifo not use? */
-		dma_ch = R8A66597_PIPE_NO_DMA;
-
-	pipe->fifoaddr = fifoaddr[dma_ch];
-	pipe->fifosel = fifosel[dma_ch];
-	pipe->fifoctr = fifoctr[dma_ch];
-
-	if (pipenum == 0)
-		pipe->pipectr = DCPCTR;
-	else
-		pipe->pipectr = get_pipectr_addr(pipenum);
-
-	if (check_bulk_or_isoc(pipenum)) {
-		pipe->pipetre = get_pipetre_addr(pipenum);
-		pipe->pipetrn = get_pipetrn_addr(pipenum);
-	} else {
-		pipe->pipetre = 0;
-		pipe->pipetrn = 0;
-	}
-}
-
-static struct r8a66597_device *
-get_urb_to_r8a66597_dev(struct r8a66597 *r8a66597, struct urb *urb)
-{
-	if (usb_pipedevice(urb->pipe) == 0)
-		return &r8a66597->device0;
-
-	return dev_get_drvdata(&urb->dev->dev);
-}
-
-static int make_r8a66597_device(struct r8a66597 *r8a66597,
-				struct urb *urb, u8 addr)
-{
-	struct r8a66597_device *dev;
-	int usb_address = urb->setup_packet[2];	/* urb->pipe is address 0 */
-
-	dev = kzalloc(sizeof(struct r8a66597_device), GFP_ATOMIC);
-	if (dev == NULL)
-		return -ENOMEM;
-
-	dev_set_drvdata(&urb->dev->dev, dev);
-	dev->udev = urb->dev;
-	dev->address = addr;
-	dev->usb_address = usb_address;
-	dev->state = USB_STATE_ADDRESS;
-	dev->ep_in_toggle = 0;
-	dev->ep_out_toggle = 0;
-	INIT_LIST_HEAD(&dev->device_list);
-	list_add_tail(&dev->device_list, &r8a66597->child_device);
-
-	get_port_number(urb->dev->devpath, &dev->root_port, &dev->hub_port);
-	if (!is_child_device(urb->dev->devpath))
-		r8a66597->root_hub[dev->root_port].dev = dev;
-
-	set_devadd_reg(r8a66597, dev->address,
-		       get_r8a66597_usb_speed(urb->dev->speed),
-		       get_parent_r8a66597_address(r8a66597, urb->dev),
-		       dev->hub_port, dev->root_port);
-
-	return 0;
-}
-
-/* this function must be called with interrupt disabled */
-static u8 alloc_usb_address(struct r8a66597 *r8a66597, struct urb *urb)
-{
-	u8 addr;	/* R8A66597's address */
-	struct r8a66597_device *dev;
-
-	if (is_hub_limit(urb->dev->devpath)) {
-		err("Externel hub limit reached.");
-		return 0;
-	}
-
-	dev = get_urb_to_r8a66597_dev(r8a66597, urb);
-	if (dev && dev->state >= USB_STATE_ADDRESS)
-		return dev->address;
-
-	for (addr = 1; addr <= R8A66597_MAX_DEVICE; addr++) {
-		if (r8a66597->address_map & (1 << addr))
-			continue;
-
-		dbg("alloc_address: r8a66597_addr=%d", addr);
-		r8a66597->address_map |= 1 << addr;
-
-		if (make_r8a66597_device(r8a66597, urb, addr) < 0)
-			return 0;
-
-		return addr;
-	}
-
-	err("cannot communicate with a USB device more than 10.(%x)",
-	    r8a66597->address_map);
-
-	return 0;
-}
-
-/* this function must be called with interrupt disabled */
-static void free_usb_address(struct r8a66597 *r8a66597,
-			     struct r8a66597_device *dev)
-{
-	int port;
-
-	if (!dev)
-		return;
-
-	dbg("free_addr: addr=%d", dev->address);
-
-	dev->state = USB_STATE_DEFAULT;
-	r8a66597->address_map &= ~(1 << dev->address);
-	dev->address = 0;
-	dev_set_drvdata(&dev->udev->dev, NULL);
-	list_del(&dev->device_list);
-	kfree(dev);
-
-	for (port = 0; port < R8A66597_MAX_ROOT_HUB; port++) {
-		if (r8a66597->root_hub[port].dev == dev) {
-			r8a66597->root_hub[port].dev = NULL;
-			break;
-		}
-	}
-}
-
-static void r8a66597_reg_wait(struct r8a66597 *r8a66597, unsigned long reg,
-			      u16 mask, u16 loop)
-{
-	u16 tmp;
-	int i = 0;
-
-	do {
-		tmp = r8a66597_read(r8a66597, reg);
-		if (i++ > 1000000) {
-			err("register%lx, loop %x is timeout", reg, loop);
-			break;
-		}
-		ndelay(1);
-	} while ((tmp & mask) != loop);
-}
-
-/* this function must be called with interrupt disabled */
-static void pipe_start(struct r8a66597 *r8a66597, struct r8a66597_pipe *pipe)
-{
-	u16 tmp;
-
-	tmp = r8a66597_read(r8a66597, pipe->pipectr) & PID;
-	if ((pipe->info.pipenum != 0) & ((tmp & PID_STALL) != 0)) /* stall? */
-		r8a66597_mdfy(r8a66597, PID_NAK, PID, pipe->pipectr);
-	r8a66597_mdfy(r8a66597, PID_BUF, PID, pipe->pipectr);
-}
-
-/* this function must be called with interrupt disabled */
-static void pipe_stop(struct r8a66597 *r8a66597, struct r8a66597_pipe *pipe)
-{
-	u16 tmp;
-
-	tmp = r8a66597_read(r8a66597, pipe->pipectr) & PID;
-	if ((tmp & PID_STALL11) != PID_STALL11)	/* force stall? */
-		r8a66597_mdfy(r8a66597, PID_STALL, PID, pipe->pipectr);
-	r8a66597_mdfy(r8a66597, PID_NAK, PID, pipe->pipectr);
-	r8a66597_reg_wait(r8a66597, pipe->pipectr, PBUSY, 0);
-}
-
-/* this function must be called with interrupt disabled */
-static void clear_all_buffer(struct r8a66597 *r8a66597,
-			     struct r8a66597_pipe *pipe)
-{
-	u16 tmp;
-
-	if (!pipe || pipe->info.pipenum == 0)
-		return;
-
-	pipe_stop(r8a66597, pipe);
-	r8a66597_bset(r8a66597, ACLRM, pipe->pipectr);
-	tmp = r8a66597_read(r8a66597, pipe->pipectr);
-	tmp = r8a66597_read(r8a66597, pipe->pipectr);
-	tmp = r8a66597_read(r8a66597, pipe->pipectr);
-	r8a66597_bclr(r8a66597, ACLRM, pipe->pipectr);
-}
-
-/* this function must be called with interrupt disabled */
-static void r8a66597_pipe_toggle(struct r8a66597 *r8a66597,
-				 struct r8a66597_pipe *pipe, int toggle)
-{
-	if (toggle)
-		r8a66597_bset(r8a66597, SQSET, pipe->pipectr);
-	else
-		r8a66597_bset(r8a66597, SQCLR, pipe->pipectr);
-}
-
-/* this function must be called with interrupt disabled */
-static inline void cfifo_change(struct r8a66597 *r8a66597, u16 pipenum)
-{
-	r8a66597_mdfy(r8a66597, MBW | pipenum, MBW | CURPIPE, CFIFOSEL);
-	r8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, pipenum);
-}
-
-/* this function must be called with interrupt disabled */
-static inline void fifo_change_from_pipe(struct r8a66597 *r8a66597,
-					 struct r8a66597_pipe *pipe)
-{
-	cfifo_change(r8a66597, 0);
-	r8a66597_mdfy(r8a66597, MBW | 0, MBW | CURPIPE, D0FIFOSEL);
-	r8a66597_mdfy(r8a66597, MBW | 0, MBW | CURPIPE, D1FIFOSEL);
-
-	r8a66597_mdfy(r8a66597, MBW | pipe->info.pipenum, MBW | CURPIPE,
-		      pipe->fifosel);
-	r8a66597_reg_wait(r8a66597, pipe->fifosel, CURPIPE, pipe->info.pipenum);
-}
-
-static u16 r8a66597_get_pipenum(struct urb *urb, struct usb_host_endpoint *hep)
-{
-	struct r8a66597_pipe *pipe = hep->hcpriv;
-
-	if (usb_pipeendpoint(urb->pipe) == 0)
-		return 0;
-	else
-		return pipe->info.pipenum;
-}
-
-static u16 get_urb_to_r8a66597_addr(struct r8a66597 *r8a66597, struct urb *urb)
-{
-	struct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);
-
-	return (usb_pipedevice(urb->pipe) == 0) ? 0 : dev->address;
-}
-
-static unsigned short *get_toggle_pointer(struct r8a66597_device *dev,
-					  int urb_pipe)
-{
-	if (!dev)
-		return NULL;
-
-	return usb_pipein(urb_pipe) ? &dev->ep_in_toggle : &dev->ep_out_toggle;
-}
-
-/* this function must be called with interrupt disabled */
-static void pipe_toggle_set(struct r8a66597 *r8a66597,
-			    struct r8a66597_pipe *pipe,
-			    struct urb *urb, int set)
-{
-	struct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);
-	unsigned char endpoint = usb_pipeendpoint(urb->pipe);
-	unsigned short *toggle = get_toggle_pointer(dev, urb->pipe);
-
-	if (!toggle)
-		return;
-
-	if (set)
-		*toggle |= 1 << endpoint;
-	else
-		*toggle &= ~(1 << endpoint);
-}
-
-/* this function must be called with interrupt disabled */
-static void pipe_toggle_save(struct r8a66597 *r8a66597,
-			     struct r8a66597_pipe *pipe,
-			     struct urb *urb)
-{
-	if (r8a66597_read(r8a66597, pipe->pipectr) & SQMON)
-		pipe_toggle_set(r8a66597, pipe, urb, 1);
-	else
-		pipe_toggle_set(r8a66597, pipe, urb, 0);
-}
-
-/* this function must be called with interrupt disabled */
-static void pipe_toggle_restore(struct r8a66597 *r8a66597,
-				struct r8a66597_pipe *pipe,
-				struct urb *urb)
-{
-	struct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);
-	unsigned char endpoint = usb_pipeendpoint(urb->pipe);
-	unsigned short *toggle = get_toggle_pointer(dev, urb->pipe);
-
-	if (!toggle)
-		return;
-
-	r8a66597_pipe_toggle(r8a66597, pipe, *toggle & (1 << endpoint));
-}
-
-/* this function must be called with interrupt disabled */
-static void pipe_buffer_setting(struct r8a66597 *r8a66597,
-				struct r8a66597_pipe_info *info)
-{
-	u16 val = 0;
-
-	if (info->pipenum == 0)
-		return;
-
-	r8a66597_bset(r8a66597, ACLRM, get_pipectr_addr(info->pipenum));
-	r8a66597_bclr(r8a66597, ACLRM, get_pipectr_addr(info->pipenum));
-	r8a66597_write(r8a66597, info->pipenum, PIPESEL);
-	if (!info->dir_in)
-		val |= R8A66597_DIR;
-	if (info->type == R8A66597_BULK && info->dir_in)
-		val |= R8A66597_DBLB | R8A66597_SHTNAK;
-	val |= info->type | info->epnum;
-	r8a66597_write(r8a66597, val, PIPECFG);
-
-	r8a66597_write(r8a66597, (info->buf_bsize << 10) | (info->bufnum),
-		       PIPEBUF);
-	r8a66597_write(r8a66597, make_devsel(info->address) | info->maxpacket,
-		       PIPEMAXP);
-	if (info->interval)
-		info->interval--;
-	r8a66597_write(r8a66597, info->interval, PIPEPERI);
-}
-
-
-
-/* this function must be called with interrupt disabled */
-static void pipe_setting(struct r8a66597 *r8a66597, struct r8a66597_td *td)
-{
-	struct r8a66597_pipe_info *info;
-	struct urb *urb = td->urb;
-
-	if (td->pipenum > 0) {
-		info = &td->pipe->info;
-		cfifo_change(r8a66597, 0);
-		pipe_buffer_setting(r8a66597, info);
-
-		if (!usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe),
-				   usb_pipeout(urb->pipe)) &&
-		    !usb_pipecontrol(urb->pipe)) {
-			r8a66597_pipe_toggle(r8a66597, td->pipe, 0);
-			pipe_toggle_set(r8a66597, td->pipe, urb, 0);
-			clear_all_buffer(r8a66597, td->pipe);
-			usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
-				      usb_pipeout(urb->pipe), 1);
-		}
-		pipe_toggle_restore(r8a66597, td->pipe, urb);
-	}
-}
-
-/* this function must be called with interrupt disabled */
-static u16 get_empty_pipenum(struct r8a66597 *r8a66597,
-			     struct usb_endpoint_descriptor *ep)
-{
-	u16 array[R8A66597_MAX_NUM_PIPE], i = 0, min;
-
-	memset(array, 0, sizeof(array));
-	switch (ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
-	case USB_ENDPOINT_XFER_BULK:
-		if (ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
-			array[i++] = 4;
-		else {
-			array[i++] = 3;
-			array[i++] = 5;
-		}
-		break;
-	case USB_ENDPOINT_XFER_INT:
-		if (ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) {
-			array[i++] = 6;
-			array[i++] = 7;
-			array[i++] = 8;
-		} else
-			array[i++] = 9;
-		break;
-	case USB_ENDPOINT_XFER_ISOC:
-		if (ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
-			array[i++] = 2;
-		else
-			array[i++] = 1;
-		break;
-	default:
-		err("Illegal type");
-		return 0;
-	}
-
-	i = 1;
-	min = array[0];
-	while (array[i] != 0) {
-		if (r8a66597->pipe_cnt[min] > r8a66597->pipe_cnt[array[i]])
-			min = array[i];
-		i++;
-	}
-
-	return min;
-}
-
-static u16 get_r8a66597_type(__u8 type)
-{
-	u16 r8a66597_type;
-
-	switch (type) {
-	case USB_ENDPOINT_XFER_BULK:
-		r8a66597_type = R8A66597_BULK;
-		break;
-	case USB_ENDPOINT_XFER_INT:
-		r8a66597_type = R8A66597_INT;
-		break;
-	case USB_ENDPOINT_XFER_ISOC:
-		r8a66597_type = R8A66597_ISO;
-		break;
-	default:
-		err("Illegal type");
-		r8a66597_type = 0x0000;
-		break;
-	}
-
-	return r8a66597_type;
-}
-
-static u16 get_bufnum(u16 pipenum)
-{
-	u16 bufnum = 0;
-
-	if (pipenum == 0)
-		bufnum = 0;
-	else if (check_bulk_or_isoc(pipenum))
-		bufnum = 8 + (pipenum - 1) * R8A66597_BUF_BSIZE*2;
-	else if (check_interrupt(pipenum))
-		bufnum = 4 + (pipenum - 6);
-	else
-		err("Illegal pipenum (%d)", pipenum);
-
-	return bufnum;
-}
-
-static u16 get_buf_bsize(u16 pipenum)
-{
-	u16 buf_bsize = 0;
-
-	if (pipenum == 0)
-		buf_bsize = 3;
-	else if (check_bulk_or_isoc(pipenum))
-		buf_bsize = R8A66597_BUF_BSIZE - 1;
-	else if (check_interrupt(pipenum))
-		buf_bsize = 0;
-	else
-		err("Illegal pipenum (%d)", pipenum);
-
-	return buf_bsize;
-}
-
-/* this function must be called with interrupt disabled */
-static void enable_r8a66597_pipe_dma(struct r8a66597 *r8a66597,
-				     struct r8a66597_device *dev,
-				     struct r8a66597_pipe *pipe,
-				     struct urb *urb)
-{
-	int i;
-	struct r8a66597_pipe_info *info = &pipe->info;
-
-	if ((pipe->info.pipenum != 0) && (info->type != R8A66597_INT)) {
-		for (i = 0; i < R8A66597_MAX_DMA_CHANNEL; i++) {
-			if ((r8a66597->dma_map & (1 << i)) != 0)
-				continue;
-
-			info("address %d, EndpointAddress 0x%02x use DMA FIFO",
-			     usb_pipedevice(urb->pipe),
-			     info->dir_in ? USB_ENDPOINT_DIR_MASK + info->epnum
-					    : info->epnum);
-
-			r8a66597->dma_map |= 1 << i;
-			dev->dma_map |= 1 << i;
-			set_pipe_reg_addr(pipe, i);
-
-			cfifo_change(r8a66597, 0);
-			r8a66597_mdfy(r8a66597, MBW | pipe->info.pipenum,
-				      MBW | CURPIPE, pipe->fifosel);
-
-			r8a66597_reg_wait(r8a66597, pipe->fifosel, CURPIPE,
-					  pipe->info.pipenum);
-			r8a66597_bset(r8a66597, BCLR, pipe->fifoctr);
-			break;
-		}
-	}
-}
-
-/* this function must be called with interrupt disabled */
-static void enable_r8a66597_pipe(struct r8a66597 *r8a66597, struct urb *urb,
-				 struct usb_host_endpoint *hep,
-				 struct r8a66597_pipe_info *info)
-{
-	struct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);
-	struct r8a66597_pipe *pipe = hep->hcpriv;
-
-	dbg("enable_pipe:");
-
-	pipe->info = *info;
-	set_pipe_reg_addr(pipe, R8A66597_PIPE_NO_DMA);
-	r8a66597->pipe_cnt[pipe->info.pipenum]++;
-	dev->pipe_cnt[pipe->info.pipenum]++;
-
-	enable_r8a66597_pipe_dma(r8a66597, dev, pipe, urb);
-}
-
-/* this function must be called with interrupt disabled */
-static void force_dequeue(struct r8a66597 *r8a66597, u16 pipenum, u16 address)
-{
-	struct r8a66597_td *td, *next;
-	struct urb *urb;
-	struct list_head *list = &r8a66597->pipe_queue[pipenum];
-
-	if (list_empty(list))
-		return;
-
-	list_for_each_entry_safe(td, next, list, queue) {
-		if (!td)
-			continue;
-		if (td->address != address)
-			continue;
-
-		urb = td->urb;
-		list_del(&td->queue);
-		kfree(td);
-
-		if (urb) {
-			urb->status = -ENODEV;
-			urb->hcpriv = NULL;
-			spin_unlock(&r8a66597->lock);
-			usb_hcd_giveback_urb(r8a66597_to_hcd(r8a66597), urb);
-			spin_lock(&r8a66597->lock);
-		}
-		break;
-	}
-}
-
-/* this function must be called with interrupt disabled */
-static void disable_r8a66597_pipe_all(struct r8a66597 *r8a66597,
-				      struct r8a66597_device *dev)
-{
-	int check_ep0 = 0;
-	u16 pipenum;
-
-	if (!dev)
-		return;
-
-	for (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {
-		if (!dev->pipe_cnt[pipenum])
-			continue;
-
-		if (!check_ep0) {
-			check_ep0 = 1;
-			force_dequeue(r8a66597, 0, dev->address);
-		}
-
-		r8a66597->pipe_cnt[pipenum] -= dev->pipe_cnt[pipenum];
-		dev->pipe_cnt[pipenum] = 0;
-		force_dequeue(r8a66597, pipenum, dev->address);
-	}
-
-	dbg("disable_pipe");
-
-	r8a66597->dma_map &= ~(dev->dma_map);
-	dev->dma_map = 0;
-}
-
-/* this function must be called with interrupt disabled */
-static void init_pipe_info(struct r8a66597 *r8a66597, struct urb *urb,
-			   struct usb_host_endpoint *hep,
-			   struct usb_endpoint_descriptor *ep)
-{
-	struct r8a66597_pipe_info info;
-
-	info.pipenum = get_empty_pipenum(r8a66597, ep);
-	info.address = get_urb_to_r8a66597_addr(r8a66597, urb);
-	info.epnum = ep->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
-	info.maxpacket = ep->wMaxPacketSize;
-	info.type = get_r8a66597_type(ep->bmAttributes
-				      & USB_ENDPOINT_XFERTYPE_MASK);
-	info.bufnum = get_bufnum(info.pipenum);
-	info.buf_bsize = get_buf_bsize(info.pipenum);
-	info.interval = ep->bInterval;
-	if (ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
-		info.dir_in = 1;
-	else
-		info.dir_in = 0;
-
-	enable_r8a66597_pipe(r8a66597, urb, hep, &info);
-}
-
-static void init_pipe_config(struct r8a66597 *r8a66597, struct urb *urb)
-{
-	struct r8a66597_device *dev;
-
-	dev = get_urb_to_r8a66597_dev(r8a66597, urb);
-	dev->state = USB_STATE_CONFIGURED;
-}
-
-static void pipe_irq_enable(struct r8a66597 *r8a66597, struct urb *urb,
-			    u16 pipenum)
-{
-	if (pipenum == 0 && usb_pipeout(urb->pipe))
-		enable_irq_empty(r8a66597, pipenum);
-	else
-		enable_irq_ready(r8a66597, pipenum);
-
-	if (!usb_pipeisoc(urb->pipe))
-		enable_irq_nrdy(r8a66597, pipenum);
-}
-
-static void pipe_irq_disable(struct r8a66597 *r8a66597, u16 pipenum)
-{
-	disable_irq_ready(r8a66597, pipenum);
-	disable_irq_nrdy(r8a66597, pipenum);
-}
-
-/* this function must be called with interrupt disabled */
-static void r8a66597_usb_preconnect(struct r8a66597 *r8a66597, int port)
-{
-	r8a66597->root_hub[port].port |= (1 << USB_PORT_FEAT_CONNECTION)
-					 | (1 << USB_PORT_FEAT_C_CONNECTION);
-	r8a66597_write(r8a66597, ~DTCH, get_intsts_reg(port));
-	r8a66597_bset(r8a66597, DTCHE, get_intenb_reg(port));
-}
-
-/* this function must be called with interrupt disabled */
-static void r8a66597_usb_connect(struct r8a66597 *r8a66597, int port)
-{
-	u16 speed = get_rh_usb_speed(r8a66597, port);
-	struct r8a66597_root_hub *rh = &r8a66597->root_hub[port];
-
-	if (speed == HSMODE)
-		rh->port |= (1 << USB_PORT_FEAT_HIGHSPEED);
-	else if (speed == LSMODE)
-		rh->port |= (1 << USB_PORT_FEAT_LOWSPEED);
-
-	rh->port &= ~(1 << USB_PORT_FEAT_RESET);
-	rh->port |= 1 << USB_PORT_FEAT_ENABLE;
-}
-
-/* this function must be called with interrupt disabled */
-static void r8a66597_usb_disconnect(struct r8a66597 *r8a66597, int port)
-{
-	struct r8a66597_device *dev = r8a66597->root_hub[port].dev;
-
-	r8a66597->root_hub[port].port &= ~(1 << USB_PORT_FEAT_CONNECTION);
-	r8a66597->root_hub[port].port |= (1 << USB_PORT_FEAT_C_CONNECTION);
-
-	disable_r8a66597_pipe_all(r8a66597, dev);
-	free_usb_address(r8a66597, dev);
-
-	r8a66597_bset(r8a66597, ATTCHE, get_intenb_reg(port));
-}
-
-/* this function must be called with interrupt disabled */
-static void prepare_setup_packet(struct r8a66597 *r8a66597,
-				 struct r8a66597_td *td)
-{
-	int i;
-	u16 *p = (u16 *)td->urb->setup_packet;
-	unsigned long setup_addr = USBREQ;
-
-	r8a66597_write(r8a66597, make_devsel(td->address) | td->maxpacket,
-		       DCPMAXP);
-	r8a66597_write(r8a66597, ~(SIGN | SACK), INTSTS1);
-
-	for (i = 0; i < 4; i++) {
-		r8a66597_write(r8a66597, p[i], setup_addr);
-		setup_addr += 2;
-	}
-	r8a66597_write(r8a66597, SUREQ, DCPCTR);
-}
-
-/* this function must be called with interrupt disabled */
-static void prepare_packet_read(struct r8a66597 *r8a66597,
-				struct r8a66597_td *td)
-{
-	struct urb *urb = td->urb;
-
-	if (usb_pipecontrol(urb->pipe)) {
-		r8a66597_bclr(r8a66597, R8A66597_DIR, DCPCFG);
-		r8a66597_mdfy(r8a66597, 0, ISEL | CURPIPE, CFIFOSEL);
-		r8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, 0);
-		if (urb->actual_length == 0) {
-			r8a66597_pipe_toggle(r8a66597, td->pipe, 1);
-			r8a66597_write(r8a66597, BCLR, CFIFOCTR);
-		}
-		pipe_irq_disable(r8a66597, td->pipenum);
-		pipe_start(r8a66597, td->pipe);
-		pipe_irq_enable(r8a66597, urb, td->pipenum);
-	} else {
-		if (urb->actual_length == 0) {
-			pipe_irq_disable(r8a66597, td->pipenum);
-			pipe_setting(r8a66597, td);
-			pipe_stop(r8a66597, td->pipe);
-			r8a66597_write(r8a66597, ~(1 << td->pipenum), BRDYSTS);
-
-			if (td->pipe->pipetre) {
-				r8a66597_write(r8a66597, TRCLR,
-						td->pipe->pipetre);
-				r8a66597_write(r8a66597,
-						(urb->transfer_buffer_length
-						+ td->maxpacket - 1)
-						/ td->maxpacket,
-						td->pipe->pipetrn);
-				r8a66597_bset(r8a66597, TRENB,
-						td->pipe->pipetre);
-			}
-
-			pipe_start(r8a66597, td->pipe);
-			pipe_irq_enable(r8a66597, urb, td->pipenum);
-		}
-	}
-}
-
-/* this function must be called with interrupt disabled */
-static void prepare_packet_write(struct r8a66597 *r8a66597,
-				 struct r8a66597_td *td)
-{
-	u16 tmp;
-	struct urb *urb = td->urb;
-
-	if (usb_pipecontrol(urb->pipe)) {
-		pipe_stop(r8a66597, td->pipe);
-		r8a66597_bset(r8a66597, R8A66597_DIR, DCPCFG);
-		r8a66597_mdfy(r8a66597, ISEL, ISEL | CURPIPE, CFIFOSEL);
-		r8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, 0);
-		if (urb->actual_length == 0) {
-			r8a66597_pipe_toggle(r8a66597, td->pipe, 1);
-			r8a66597_write(r8a66597, BCLR, CFIFOCTR);
-		}
-	} else {
-		if (urb->actual_length == 0)
-			pipe_setting(r8a66597, td);
-		if (td->pipe->pipetre)
-			r8a66597_bclr(r8a66597, TRENB, td->pipe->pipetre);
-	}
-	r8a66597_write(r8a66597, ~(1 << td->pipenum), BRDYSTS);
-
-	fifo_change_from_pipe(r8a66597, td->pipe);
-	tmp = r8a66597_read(r8a66597, td->pipe->fifoctr);
-	if (unlikely((tmp & FRDY) == 0))
-		pipe_irq_enable(r8a66597, urb, td->pipenum);
-	else
-		packet_write(r8a66597, td->pipenum);
-	pipe_start(r8a66597, td->pipe);
-}
-
-/* this function must be called with interrupt disabled */
-static void prepare_status_packet(struct r8a66597 *r8a66597,
-				  struct r8a66597_td *td)
-{
-	struct urb *urb = td->urb;
-
-	r8a66597_pipe_toggle(r8a66597, td->pipe, 1);
-	pipe_stop(r8a66597, td->pipe);
-
-	if (urb->setup_packet[0] & USB_ENDPOINT_DIR_MASK) {
-		r8a66597_bset(r8a66597, R8A66597_DIR, DCPCFG);
-		r8a66597_mdfy(r8a66597, ISEL, ISEL | CURPIPE, CFIFOSEL);
-		r8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, 0);
-		r8a66597_write(r8a66597, ~BEMP0, BEMPSTS);
-		r8a66597_write(r8a66597, BCLR, CFIFOCTR);
-		r8a66597_write(r8a66597, BVAL, CFIFOCTR);
-		enable_irq_empty(r8a66597, 0);
-	} else {
-		r8a66597_bclr(r8a66597, R8A66597_DIR, DCPCFG);
-		r8a66597_mdfy(r8a66597, 0, ISEL | CURPIPE, CFIFOSEL);
-		r8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, 0);
-		r8a66597_write(r8a66597, BCLR, CFIFOCTR);
-		enable_irq_ready(r8a66597, 0);
-	}
-	enable_irq_nrdy(r8a66597, 0);
-	pipe_start(r8a66597, td->pipe);
-}
-
-/* this function must be called with interrupt disabled */
-static int start_transfer(struct r8a66597 *r8a66597, struct r8a66597_td *td)
-{
-	BUG_ON(!td);
-
-	switch (td->type) {
-	case USB_PID_SETUP:
-		if (td->urb->setup_packet[1] == USB_REQ_SET_ADDRESS) {
-			td->set_address = 1;
-			td->urb->setup_packet[2] = alloc_usb_address(r8a66597,
-								     td->urb);
-			if (td->urb->setup_packet[2] == 0)
-				return -EPIPE;
-		}
-		prepare_setup_packet(r8a66597, td);
-		break;
-	case USB_PID_IN:
-		prepare_packet_read(r8a66597, td);
-		break;
-	case USB_PID_OUT:
-		prepare_packet_write(r8a66597, td);
-		break;
-	case USB_PID_ACK:
-		prepare_status_packet(r8a66597, td);
-		break;
-	default:
-		err("invalid type.");
-		break;
-	}
-
-	return 0;
-}
-
-static int check_transfer_finish(struct r8a66597_td *td, struct urb *urb)
-{
-	if (usb_pipeisoc(urb->pipe)) {
-		if (urb->number_of_packets == td->iso_cnt)
-			return 1;
-	}
-
-	/* control or bulk or interrupt */
-	if ((urb->transfer_buffer_length <= urb->actual_length) ||
-	    (td->short_packet) || (td->zero_packet))
-		return 1;
-
-	return 0;
-}
-
-/* this function must be called with interrupt disabled */
-static void set_td_timer(struct r8a66597 *r8a66597, struct r8a66597_td *td)
-{
-	unsigned long time;
-
-	BUG_ON(!td);
-
-	if (!list_empty(&r8a66597->pipe_queue[td->pipenum]) &&
-	    !usb_pipecontrol(td->urb->pipe) && usb_pipein(td->urb->pipe)) {
-		r8a66597->timeout_map |= 1 << td->pipenum;
-		switch (usb_pipetype(td->urb->pipe)) {
-		case PIPE_INTERRUPT:
-		case PIPE_ISOCHRONOUS:
-			time = 30;
-			break;
-		default:
-			time = 300;
-			break;
-		}
-
-		mod_timer(&r8a66597->td_timer[td->pipenum],
-			  jiffies + msecs_to_jiffies(time));
-	}
-}
-
-/* this function must be called with interrupt disabled */
-static void done(struct r8a66597 *r8a66597, struct r8a66597_td *td,
-		 u16 pipenum, struct urb *urb)
-{
-	int restart = 0;
-	struct usb_hcd *hcd = r8a66597_to_hcd(r8a66597);
-
-	r8a66597->timeout_map &= ~(1 << pipenum);
-
-	if (likely(td)) {
-		if (td->set_address && urb->status != 0)
-			r8a66597->address_map &= ~(1 << urb->setup_packet[2]);
-
-		pipe_toggle_save(r8a66597, td->pipe, urb);
-		list_del(&td->queue);
-		kfree(td);
-	}
-
-	if (!list_empty(&r8a66597->pipe_queue[pipenum]))
-		restart = 1;
-
-	if (likely(urb)) {
-		if (usb_pipeisoc(urb->pipe))
-			urb->start_frame = r8a66597_get_frame(hcd);
-
-		urb->hcpriv = NULL;
-		spin_unlock(&r8a66597->lock);
-		usb_hcd_giveback_urb(hcd, urb);
-		spin_lock(&r8a66597->lock);
-	}
-
-	if (restart) {
-		td = r8a66597_get_td(r8a66597, pipenum);
-		if (unlikely(!td))
-			return;
-
-		start_transfer(r8a66597, td);
-		set_td_timer(r8a66597, td);
-	}
-}
-
-/* this function must be called with interrupt disabled */
-static void finish_request(struct r8a66597 *r8a66597, struct r8a66597_td *td,
-			   u16 pipenum, struct urb *urb)
-__releases(r8a66597->lock) __acquires(r8a66597->lock)
-{
-	done(r8a66597, td, pipenum, urb);
-}
-
-static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
-{
-	u16 tmp;
-	int rcv_len, bufsize, urb_len, size;
-	u16 *buf;
-	struct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);
-	struct urb *urb;
-	int finish = 0;
-
-	if (unlikely(!td))
-		return;
-	urb = td->urb;
-
-	fifo_change_from_pipe(r8a66597, td->pipe);
-	tmp = r8a66597_read(r8a66597, td->pipe->fifoctr);
-	if (unlikely((tmp & FRDY) == 0)) {
-		urb->status = -EPIPE;
-		pipe_stop(r8a66597, td->pipe);
-		pipe_irq_disable(r8a66597, pipenum);
-		err("in fifo not ready (%d)", pipenum);
-		finish_request(r8a66597, td, pipenum, td->urb);
-		return;
-	}
-
-	/* prepare parameters */
-	rcv_len = tmp & DTLN;
-	bufsize = td->maxpacket;
-	if (usb_pipeisoc(urb->pipe)) {
-		buf = (u16 *)(urb->transfer_buffer +
-				urb->iso_frame_desc[td->iso_cnt].offset);
-		urb_len = urb->iso_frame_desc[td->iso_cnt].length;
-	} else {
-		buf = (void *)urb->transfer_buffer + urb->actual_length;
-		urb_len = urb->transfer_buffer_length - urb->actual_length;
-	}
-	if (rcv_len < bufsize)
-		size = min(rcv_len, urb_len);
-	else
-		size = min(bufsize, urb_len);
-
-	/* update parameters */
-	urb->actual_length += size;
-	if (rcv_len == 0)
-		td->zero_packet = 1;
-	if ((size % td->maxpacket) > 0) {
-		td->short_packet = 1;
-		if (urb->transfer_buffer_length != urb->actual_length &&
-		    urb->transfer_flags & URB_SHORT_NOT_OK)
-			td->urb->status = -EREMOTEIO;
-	}
-	if (usb_pipeisoc(urb->pipe)) {
-		urb->iso_frame_desc[td->iso_cnt].actual_length = size;
-		urb->iso_frame_desc[td->iso_cnt].status = 0;
-		td->iso_cnt++;
-	}
-
-	/* check transfer finish */
-	if (check_transfer_finish(td, urb)) {
-		pipe_stop(r8a66597, td->pipe);
-		pipe_irq_disable(r8a66597, pipenum);
-		finish = 1;
-	}
-
-	/* read fifo */
-	if (urb->transfer_buffer) {
-		if (size == 0)
-			r8a66597_write(r8a66597, BCLR, td->pipe->fifoctr);
-		else
-			r8a66597_read_fifo(r8a66597, td->pipe->fifoaddr,
-					   buf, size);
-	}
-
-	if (finish && pipenum != 0) {
-		if (td->urb->status == -EINPROGRESS)
-			td->urb->status = 0;
-		finish_request(r8a66597, td, pipenum, urb);
-	}
-}
-
-static void packet_write(struct r8a66597 *r8a66597, u16 pipenum)
-{
-	u16 tmp;
-	int bufsize, size;
-	u16 *buf;
-	struct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);
-	struct urb *urb;
-
-	if (unlikely(!td))
-		return;
-	urb = td->urb;
-
-	fifo_change_from_pipe(r8a66597, td->pipe);
-	tmp = r8a66597_read(r8a66597, td->pipe->fifoctr);
-	if (unlikely((tmp & FRDY) == 0)) {
-		urb->status = -EPIPE;
-		pipe_stop(r8a66597, td->pipe);
-		pipe_irq_disable(r8a66597, pipenum);
-		err("out write fifo not ready. (%d)", pipenum);
-		finish_request(r8a66597, td, pipenum, td->urb);
-		return;
-	}
-
-	/* prepare parameters */
-	bufsize = td->maxpacket;
-	if (usb_pipeisoc(urb->pipe)) {
-		buf = (u16 *)(urb->transfer_buffer +
-				urb->iso_frame_desc[td->iso_cnt].offset);
-		size = min(bufsize,
-			   (int)urb->iso_frame_desc[td->iso_cnt].length);
-	} else {
-		buf = (u16 *)(urb->transfer_buffer + urb->actual_length);
-		size = min((int)bufsize,
-			   urb->transfer_buffer_length - urb->actual_length);
-	}
-
-	/* write fifo */
-	if (pipenum > 0)
-		r8a66597_write(r8a66597, ~(1 << pipenum), BEMPSTS);
-	if (urb->transfer_buffer) {
-		r8a66597_write_fifo(r8a66597, td->pipe->fifoaddr, buf, size);
-		if (!usb_pipebulk(urb->pipe) || td->maxpacket != size)
-			r8a66597_write(r8a66597, BVAL, td->pipe->fifoctr);
-	}
-
-	/* update parameters */
-	urb->actual_length += size;
-	if (usb_pipeisoc(urb->pipe)) {
-		urb->iso_frame_desc[td->iso_cnt].actual_length = size;
-		urb->iso_frame_desc[td->iso_cnt].status = 0;
-		td->iso_cnt++;
-	}
-
-	/* check transfer finish */
-	if (check_transfer_finish(td, urb)) {
-		disable_irq_ready(r8a66597, pipenum);
-		enable_irq_empty(r8a66597, pipenum);
-		if (!usb_pipeisoc(urb->pipe))
-			enable_irq_nrdy(r8a66597, pipenum);
-	} else
-		pipe_irq_enable(r8a66597, urb, pipenum);
-}
-
-
-static void check_next_phase(struct r8a66597 *r8a66597)
-{
-	struct r8a66597_td *td = r8a66597_get_td(r8a66597, 0);
-	struct urb *urb;
-	u8 finish = 0;
-
-	if (unlikely(!td))
-		return;
-	urb = td->urb;
-
-	switch (td->type) {
-	case USB_PID_IN:
-	case USB_PID_OUT:
-		if (urb->status != -EINPROGRESS) {
-			finish = 1;
-			break;
-		}
-		if (check_transfer_finish(td, urb))
-			td->type = USB_PID_ACK;
-		break;
-	case USB_PID_SETUP:
-		if (urb->status != -EINPROGRESS)
-			finish = 1;
-		else if (urb->transfer_buffer_length == urb->actual_length) {
-			td->type = USB_PID_ACK;
-			urb->status = 0;
-		} else if (usb_pipeout(urb->pipe))
-			td->type = USB_PID_OUT;
-		else
-			td->type = USB_PID_IN;
-		break;
-	case USB_PID_ACK:
-		finish = 1;
-		if (urb->status == -EINPROGRESS)
-			urb->status = 0;
-		break;
-	}
-
-	if (finish)
-		finish_request(r8a66597, td, 0, urb);
-	else
-		start_transfer(r8a66597, td);
-}
-
-static void set_urb_error(struct r8a66597 *r8a66597, u16 pipenum)
-{
-	struct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);
-
-	if (td && td->urb) {
-		u16 pid = r8a66597_read(r8a66597, td->pipe->pipectr) & PID;
-
-		if (pid == PID_NAK)
-			td->urb->status = -ECONNRESET;
-		else
-			td->urb->status = -EPIPE;
-	}
-}
-
-static void irq_pipe_ready(struct r8a66597 *r8a66597)
-{
-	u16 check;
-	u16 pipenum;
-	u16 mask;
-	struct r8a66597_td *td;
-
-	mask = r8a66597_read(r8a66597, BRDYSTS)
-	       & r8a66597_read(r8a66597, BRDYENB);
-	r8a66597_write(r8a66597, ~mask, BRDYSTS);
-	if (mask & BRDY0) {
-		td = r8a66597_get_td(r8a66597, 0);
-		if (td && td->type == USB_PID_IN)
-			packet_read(r8a66597, 0);
-		else
-			pipe_irq_disable(r8a66597, 0);
-		check_next_phase(r8a66597);
-	}
-
-	for (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {
-		check = 1 << pipenum;
-		if (mask & check) {
-			td = r8a66597_get_td(r8a66597, pipenum);
-			if (unlikely(!td))
-				continue;
-
-			if (td->type == USB_PID_IN)
-				packet_read(r8a66597, pipenum);
-			else if (td->type == USB_PID_OUT)
-				packet_write(r8a66597, pipenum);
-		}
-	}
-}
-
-static void irq_pipe_empty(struct r8a66597 *r8a66597)
-{
-	u16 tmp;
-	u16 check;
-	u16 pipenum;
-	u16 mask;
-	struct r8a66597_td *td;
-
-	mask = r8a66597_read(r8a66597, BEMPSTS)
-	       & r8a66597_read(r8a66597, BEMPENB);
-	r8a66597_write(r8a66597, ~mask, BEMPSTS);
-	if (mask & BEMP0) {
-		cfifo_change(r8a66597, 0);
-		td = r8a66597_get_td(r8a66597, 0);
-		if (td && td->type != USB_PID_OUT)
-			disable_irq_empty(r8a66597, 0);
-		check_next_phase(r8a66597);
-	}
-
-	for (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {
-		check = 1 << pipenum;
-		if (mask &  check) {
-			struct r8a66597_td *td;
-			td = r8a66597_get_td(r8a66597, pipenum);
-			if (unlikely(!td))
-				continue;
-
-			tmp = r8a66597_read(r8a66597, td->pipe->pipectr);
-			if ((tmp & INBUFM) == 0) {
-				disable_irq_empty(r8a66597, pipenum);
-				pipe_irq_disable(r8a66597, pipenum);
-				if (td->urb->status == -EINPROGRESS)
-					td->urb->status = 0;
-				finish_request(r8a66597, td, pipenum, td->urb);
-			}
-		}
-	}
-}
-
-static void irq_pipe_nrdy(struct r8a66597 *r8a66597)
-{
-	u16 check;
-	u16 pipenum;
-	u16 mask;
-
-	mask = r8a66597_read(r8a66597, NRDYSTS)
-	       & r8a66597_read(r8a66597, NRDYENB);
-	r8a66597_write(r8a66597, ~mask, NRDYSTS);
-	if (mask & NRDY0) {
-		cfifo_change(r8a66597, 0);
-		set_urb_error(r8a66597, 0);
-		pipe_irq_disable(r8a66597, 0);
-		check_next_phase(r8a66597);
-	}
-
-	for (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {
-		check = 1 << pipenum;
-		if (mask & check) {
-			struct r8a66597_td *td;
-			td = r8a66597_get_td(r8a66597, pipenum);
-			if (unlikely(!td))
-				continue;
-
-			set_urb_error(r8a66597, pipenum);
-			pipe_irq_disable(r8a66597, pipenum);
-			pipe_stop(r8a66597, td->pipe);
-			finish_request(r8a66597, td, pipenum, td->urb);
-		}
-	}
-}
-
-static void start_root_hub_sampling(struct r8a66597 *r8a66597, int port)
-{
-	struct r8a66597_root_hub *rh = &r8a66597->root_hub[port];
-
-	rh->old_syssts = r8a66597_read(r8a66597, get_syssts_reg(port)) & LNST;
-	rh->scount = R8A66597_MAX_SAMPLING;
-	mod_timer(&r8a66597->rh_timer, jiffies + msecs_to_jiffies(50));
-}
-
-static irqreturn_t r8a66597_irq(struct usb_hcd *hcd)
-{
-	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
-	u16 intsts0, intsts1, intsts2;
-	u16 intenb0, intenb1, intenb2;
-	u16 mask0, mask1, mask2;
-
-	spin_lock(&r8a66597->lock);
-
-	intsts0 = r8a66597_read(r8a66597, INTSTS0);
-	intsts1 = r8a66597_read(r8a66597, INTSTS1);
-	intsts2 = r8a66597_read(r8a66597, INTSTS2);
-	intenb0 = r8a66597_read(r8a66597, INTENB0);
-	intenb1 = r8a66597_read(r8a66597, INTENB1);
-	intenb2 = r8a66597_read(r8a66597, INTENB2);
-
-	mask2 = intsts2 & intenb2;
-	mask1 = intsts1 & intenb1;
-	mask0 = intsts0 & intenb0 & (BEMP | NRDY | BRDY);
-	if (mask2) {
-		if (mask2 & ATTCH) {
-			r8a66597_write(r8a66597, ~ATTCH, INTSTS2);
-			r8a66597_bclr(r8a66597, ATTCHE, INTENB2);
-
-			/* start usb bus sampling */
-			start_root_hub_sampling(r8a66597, 1);
-		}
-		if (mask2 & DTCH) {
-			r8a66597_write(r8a66597, ~DTCH, INTSTS2);
-			r8a66597_bclr(r8a66597, DTCHE, INTENB2);
-			r8a66597_usb_disconnect(r8a66597, 1);
-		}
-	}
-
-	if (mask1) {
-		if (mask1 & ATTCH) {
-			r8a66597_write(r8a66597, ~ATTCH, INTSTS1);
-			r8a66597_bclr(r8a66597, ATTCHE, INTENB1);
-
-			/* start usb bus sampling */
-			start_root_hub_sampling(r8a66597, 0);
-		}
-		if (mask1 & DTCH) {
-			r8a66597_write(r8a66597, ~DTCH, INTSTS1);
-			r8a66597_bclr(r8a66597, DTCHE, INTENB1);
-			r8a66597_usb_disconnect(r8a66597, 0);
-		}
-		if (mask1 & SIGN) {
-			r8a66597_write(r8a66597, ~SIGN, INTSTS1);
-			set_urb_error(r8a66597, 0);
-			check_next_phase(r8a66597);
-		}
-		if (mask1 & SACK) {
-			r8a66597_write(r8a66597, ~SACK, INTSTS1);
-			check_next_phase(r8a66597);
-		}
-	}
-	if (mask0) {
-		if (mask0 & BRDY)
-			irq_pipe_ready(r8a66597);
-		if (mask0 & BEMP)
-			irq_pipe_empty(r8a66597);
-		if (mask0 & NRDY)
-			irq_pipe_nrdy(r8a66597);
-	}
-
-	spin_unlock(&r8a66597->lock);
-	return IRQ_HANDLED;
-}
-
-/* this function must be called with interrupt disabled */
-static void r8a66597_root_hub_control(struct r8a66597 *r8a66597, int port)
-{
-	u16 tmp;
-	struct r8a66597_root_hub *rh = &r8a66597->root_hub[port];
-
-	if (rh->port & (1 << USB_PORT_FEAT_RESET)) {
-		unsigned long dvstctr_reg = get_dvstctr_reg(port);
-
-		tmp = r8a66597_read(r8a66597, dvstctr_reg);
-		if ((tmp & USBRST) == USBRST) {
-			r8a66597_mdfy(r8a66597, UACT, USBRST | UACT,
-				      dvstctr_reg);
-			mod_timer(&r8a66597->rh_timer,
-				  jiffies + msecs_to_jiffies(50));
-		} else
-			r8a66597_usb_connect(r8a66597, port);
-	}
-
-	if (rh->scount > 0) {
-		tmp = r8a66597_read(r8a66597, get_syssts_reg(port)) & LNST;
-		if (tmp == rh->old_syssts) {
-			rh->scount--;
-			if (rh->scount == 0) {
-				if (tmp == FS_JSTS) {
-					r8a66597_bset(r8a66597, HSE,
-						      get_syscfg_reg(port));
-					r8a66597_usb_preconnect(r8a66597, port);
-				} else if (tmp == LS_JSTS) {
-					r8a66597_bclr(r8a66597, HSE,
-						      get_syscfg_reg(port));
-					r8a66597_usb_preconnect(r8a66597, port);
-				} else if (tmp == SE0)
-					r8a66597_bset(r8a66597, ATTCHE,
-						      get_intenb_reg(port));
-			} else {
-				mod_timer(&r8a66597->rh_timer,
-					  jiffies + msecs_to_jiffies(50));
-			}
-		} else {
-			rh->scount = R8A66597_MAX_SAMPLING;
-			rh->old_syssts = tmp;
-			mod_timer(&r8a66597->rh_timer,
-				  jiffies + msecs_to_jiffies(50));
-		}
-	}
-}
-
-static void r8a66597_td_timer(unsigned long _r8a66597)
-{
-	struct r8a66597 *r8a66597 = (struct r8a66597 *)_r8a66597;
-	unsigned long flags;
-	u16 pipenum;
-	struct r8a66597_td *td, *new_td = NULL;
-	struct r8a66597_pipe *pipe;
-
-	spin_lock_irqsave(&r8a66597->lock, flags);
-	for (pipenum = 0; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {
-		if (!(r8a66597->timeout_map & (1 << pipenum)))
-			continue;
-		if (timer_pending(&r8a66597->td_timer[pipenum]))
-			continue;
-
-		td = r8a66597_get_td(r8a66597, pipenum);
-		if (!td) {
-			r8a66597->timeout_map &= ~(1 << pipenum);
-			continue;
-		}
-
-		if (td->urb->actual_length) {
-			set_td_timer(r8a66597, td);
-			break;
-		}
-
-		pipe = td->pipe;
-		pipe_stop(r8a66597, pipe);
-
-		new_td = td;
-		do {
-			list_move_tail(&new_td->queue,
-				       &r8a66597->pipe_queue[pipenum]);
-			new_td = r8a66597_get_td(r8a66597, pipenum);
-			if (!new_td) {
-				new_td = td;
-				break;
-			}
-		} while (td != new_td && td->address == new_td->address);
-
-		start_transfer(r8a66597, new_td);
-
-		if (td == new_td)
-			r8a66597->timeout_map &= ~(1 << pipenum);
-		else
-			set_td_timer(r8a66597, new_td);
-		break;
-	}
-	spin_unlock_irqrestore(&r8a66597->lock, flags);
-}
-
-static void r8a66597_timer(unsigned long _r8a66597)
-{
-	struct r8a66597 *r8a66597 = (struct r8a66597 *)_r8a66597;
-	unsigned long flags;
-
-	spin_lock_irqsave(&r8a66597->lock, flags);
-
-	r8a66597_root_hub_control(r8a66597, 0);
-	r8a66597_root_hub_control(r8a66597, 1);
-
-	spin_unlock_irqrestore(&r8a66597->lock, flags);
-}
-
-static int check_pipe_config(struct r8a66597 *r8a66597, struct urb *urb)
-{
-	struct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);
-
-	if (dev && dev->address && dev->state != USB_STATE_CONFIGURED &&
-	    (urb->dev->state == USB_STATE_CONFIGURED))
-		return 1;
-	else
-		return 0;
-}
-
-static int r8a66597_start(struct usb_hcd *hcd)
-{
-	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
-
-	hcd->state = HC_STATE_RUNNING;
-	return enable_controller(r8a66597);
-}
-
-static void r8a66597_stop(struct usb_hcd *hcd)
-{
-	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
-
-	disable_controller(r8a66597);
-}
-
-static void set_address_zero(struct r8a66597 *r8a66597, struct urb *urb)
-{
-	unsigned int usb_address = usb_pipedevice(urb->pipe);
-	u16 root_port, hub_port;
-
-	if (usb_address == 0) {
-		get_port_number(urb->dev->devpath,
-				&root_port, &hub_port);
-		set_devadd_reg(r8a66597, 0,
-			       get_r8a66597_usb_speed(urb->dev->speed),
-			       get_parent_r8a66597_address(r8a66597, urb->dev),
-			       hub_port, root_port);
-	}
-}
-
-static struct r8a66597_td *r8a66597_make_td(struct r8a66597 *r8a66597,
-					    struct urb *urb,
-					    struct usb_host_endpoint *hep)
-{
-	struct r8a66597_td *td;
-	u16 pipenum;
-
-	td = kzalloc(sizeof(struct r8a66597_td), GFP_ATOMIC);
-	if (td == NULL)
-		return NULL;
-
-	pipenum = r8a66597_get_pipenum(urb, hep);
-	td->pipenum = pipenum;
-	td->pipe = hep->hcpriv;
-	td->urb = urb;
-	td->address = get_urb_to_r8a66597_addr(r8a66597, urb);
-	td->maxpacket = usb_maxpacket(urb->dev, urb->pipe,
-				      !usb_pipein(urb->pipe));
-	if (usb_pipecontrol(urb->pipe))
-		td->type = USB_PID_SETUP;
-	else if (usb_pipein(urb->pipe))
-		td->type = USB_PID_IN;
-	else
-		td->type = USB_PID_OUT;
-	INIT_LIST_HEAD(&td->queue);
-
-	return td;
-}
-
-static int r8a66597_urb_enqueue(struct usb_hcd *hcd,
-				struct usb_host_endpoint *hep,
-				struct urb *urb,
-				gfp_t mem_flags)
-{
-	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
-	struct r8a66597_td *td = NULL;
-	int ret = 0, request = 0;
-	unsigned long flags;
-
-	spin_lock_irqsave(&r8a66597->lock, flags);
-	if (!get_urb_to_r8a66597_dev(r8a66597, urb)) {
-		ret = -ENODEV;
-		goto error;
-	}
-
-	if (!hep->hcpriv) {
-		hep->hcpriv = kzalloc(sizeof(struct r8a66597_pipe),
-				GFP_ATOMIC);
-		if (!hep->hcpriv) {
-			ret = -ENOMEM;
-			goto error;
-		}
-		set_pipe_reg_addr(hep->hcpriv, R8A66597_PIPE_NO_DMA);
-		if (usb_pipeendpoint(urb->pipe))
-			init_pipe_info(r8a66597, urb, hep, &hep->desc);
-	}
-
-	if (unlikely(check_pipe_config(r8a66597, urb)))
-		init_pipe_config(r8a66597, urb);
-
-	set_address_zero(r8a66597, urb);
-	td = r8a66597_make_td(r8a66597, urb, hep);
-	if (td == NULL) {
-		ret = -ENOMEM;
-		goto error;
-	}
-	if (list_empty(&r8a66597->pipe_queue[td->pipenum]))
-		request = 1;
-	list_add_tail(&td->queue, &r8a66597->pipe_queue[td->pipenum]);
-
-	spin_lock(&urb->lock);
-	if (urb->status != -EINPROGRESS) {
-		spin_unlock(&urb->lock);
-		ret = -EPIPE;
-		goto error;
-	}
-	urb->hcpriv = td;
-	spin_unlock(&urb->lock);
-
-	if (request) {
-		ret = start_transfer(r8a66597, td);
-		if (ret < 0) {
-			list_del(&td->queue);
-			kfree(td);
-		}
-	} else
-		set_td_timer(r8a66597, td);
-
-error:
-	spin_unlock_irqrestore(&r8a66597->lock, flags);
-	return ret;
-}
-
-static int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
-{
-	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
-	struct r8a66597_td *td;
-	unsigned long flags;
-
-	spin_lock_irqsave(&r8a66597->lock, flags);
-	if (urb->hcpriv) {
-		td = urb->hcpriv;
-		pipe_stop(r8a66597, td->pipe);
-		pipe_irq_disable(r8a66597, td->pipenum);
-		disable_irq_empty(r8a66597, td->pipenum);
-		done(r8a66597, td, td->pipenum, urb);
-	}
-	spin_unlock_irqrestore(&r8a66597->lock, flags);
-	return 0;
-}
-
-static void r8a66597_endpoint_disable(struct usb_hcd *hcd,
-				      struct usb_host_endpoint *hep)
-{
-	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
-	struct r8a66597_pipe *pipe = (struct r8a66597_pipe *)hep->hcpriv;
-	struct r8a66597_td *td;
-	struct urb *urb = NULL;
-	u16 pipenum;
-	unsigned long flags;
-
-	if (pipe == NULL)
-		return;
-	pipenum = pipe->info.pipenum;
-
-	if (pipenum == 0) {
-		kfree(hep->hcpriv);
-		hep->hcpriv = NULL;
-		return;
-	}
-
-	spin_lock_irqsave(&r8a66597->lock, flags);
-	pipe_stop(r8a66597, pipe);
-	pipe_irq_disable(r8a66597, pipenum);
-	disable_irq_empty(r8a66597, pipenum);
-	td = r8a66597_get_td(r8a66597, pipenum);
-	if (td)
-		urb = td->urb;
-	done(r8a66597, td, pipenum, urb);
-	kfree(hep->hcpriv);
-	hep->hcpriv = NULL;
-	spin_unlock_irqrestore(&r8a66597->lock, flags);
-}
-
-static int r8a66597_get_frame(struct usb_hcd *hcd)
-{
-	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
-	return r8a66597_read(r8a66597, FRMNUM) & 0x03FF;
-}
-
-static void collect_usb_address_map(struct usb_device *udev, unsigned long *map)
-{
-	int chix;
-
-	if (udev->state == USB_STATE_CONFIGURED &&
-	    udev->parent && udev->parent->devnum > 1 &&
-	    udev->parent->descriptor.bDeviceClass == USB_CLASS_HUB)
-		map[udev->devnum/32] |= (1 << (udev->devnum % 32));
-
-	for (chix = 0; chix < udev->maxchild; chix++) {
-		struct usb_device *childdev = udev->children[chix];
-
-		if (childdev)
-			collect_usb_address_map(childdev, map);
-	}
-}
-
-/* this function must be called with interrupt disabled */
-static struct r8a66597_device *get_r8a66597_device(struct r8a66597 *r8a66597,
-						   int addr)
-{
-	struct r8a66597_device *dev;
-	struct list_head *list = &r8a66597->child_device;
-
-	list_for_each_entry(dev, list, device_list) {
-		if (!dev)
-			continue;
-		if (dev->usb_address != addr)
-			continue;
-
-		return dev;
-	}
-
-	err("get_r8a66597_device fail.(%d)\n", addr);
-	return NULL;
-}
-
-static void update_usb_address_map(struct r8a66597 *r8a66597,
-				   struct usb_device *root_hub,
-				   unsigned long *map)
-{
-	int i, j, addr;
-	unsigned long diff;
-	unsigned long flags;
-
-	for (i = 0; i < 4; i++) {
-		diff = r8a66597->child_connect_map[i] ^ map[i];
-		if (!diff)
-			continue;
-
-		for (j = 0; j < 32; j++) {
-			if (!(diff & (1 << j)))
-				continue;
-
-			addr = i * 32 + j;
-			if (map[i] & (1 << j))
-				set_child_connect_map(r8a66597, addr);
-			else {
-				struct r8a66597_device *dev;
-
-				spin_lock_irqsave(&r8a66597->lock, flags);
-				dev = get_r8a66597_device(r8a66597, addr);
-				disable_r8a66597_pipe_all(r8a66597, dev);
-				free_usb_address(r8a66597, dev);
-				put_child_connect_map(r8a66597, addr);
-				spin_unlock_irqrestore(&r8a66597->lock, flags);
-			}
-		}
-	}
-}
-
-static void r8a66597_check_detect_child(struct r8a66597 *r8a66597,
-					struct usb_hcd *hcd)
-{
-	struct usb_bus *bus;
-	unsigned long now_map[4];
-
-	memset(now_map, 0, sizeof(now_map));
-
-	list_for_each_entry(bus, &usb_bus_list, bus_list) {
-		if (!bus->root_hub)
-			continue;
-
-		if (bus->busnum != hcd->self.busnum)
-			continue;
-
-		collect_usb_address_map(bus->root_hub, now_map);
-		update_usb_address_map(r8a66597, bus->root_hub, now_map);
-	}
-}
-
-static int r8a66597_hub_status_data(struct usb_hcd *hcd, char *buf)
-{
-	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
-	unsigned long flags;
-	int i;
-
-	r8a66597_check_detect_child(r8a66597, hcd);
-
-	spin_lock_irqsave(&r8a66597->lock, flags);
-
-	*buf = 0;	/* initialize (no change) */
-
-	for (i = 0; i < R8A66597_MAX_ROOT_HUB; i++) {
-		if (r8a66597->root_hub[i].port & 0xffff0000)
-			*buf |= 1 << (i + 1);
-	}
-
-	spin_unlock_irqrestore(&r8a66597->lock, flags);
-
-	return (*buf != 0);
-}
-
-static void r8a66597_hub_descriptor(struct r8a66597 *r8a66597,
-				    struct usb_hub_descriptor *desc)
-{
-	desc->bDescriptorType = 0x29;
-	desc->bHubContrCurrent = 0;
-	desc->bNbrPorts = R8A66597_MAX_ROOT_HUB;
-	desc->bDescLength = 9;
-	desc->bPwrOn2PwrGood = 0;
-	desc->wHubCharacteristics = cpu_to_le16(0x0011);
-	desc->bitmap[0] = ((1 << R8A66597_MAX_ROOT_HUB) - 1) << 1;
-	desc->bitmap[1] = ~0;
-}
-
-static int r8a66597_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
-				u16 wIndex, char *buf, u16 wLength)
-{
-	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
-	int ret;
-	int port = (wIndex & 0x00FF) - 1;
-	struct r8a66597_root_hub *rh = &r8a66597->root_hub[port];
-	unsigned long flags;
-
-	ret = 0;
-
-	spin_lock_irqsave(&r8a66597->lock, flags);
-	switch (typeReq) {
-	case ClearHubFeature:
-	case SetHubFeature:
-		switch (wValue) {
-		case C_HUB_OVER_CURRENT:
-		case C_HUB_LOCAL_POWER:
-			break;
-		default:
-			goto error;
-		}
-		break;
-	case ClearPortFeature:
-		if (wIndex > R8A66597_MAX_ROOT_HUB)
-			goto error;
-		if (wLength != 0)
-			goto error;
-
-		switch (wValue) {
-		case USB_PORT_FEAT_ENABLE:
-			rh->port &= (1 << USB_PORT_FEAT_POWER);
-			break;
-		case USB_PORT_FEAT_SUSPEND:
-			break;
-		case USB_PORT_FEAT_POWER:
-			r8a66597_port_power(r8a66597, port, 0);
-			break;
-		case USB_PORT_FEAT_C_ENABLE:
-		case USB_PORT_FEAT_C_SUSPEND:
-		case USB_PORT_FEAT_C_CONNECTION:
-		case USB_PORT_FEAT_C_OVER_CURRENT:
-		case USB_PORT_FEAT_C_RESET:
-			break;
-		default:
-			goto error;
-		}
-		rh->port &= ~(1 << wValue);
-		break;
-	case GetHubDescriptor:
-		r8a66597_hub_descriptor(r8a66597,
-					(struct usb_hub_descriptor *)buf);
-		break;
-	case GetHubStatus:
-		*buf = 0x00;
-		break;
-	case GetPortStatus:
-		if (wIndex > R8A66597_MAX_ROOT_HUB)
-			goto error;
-		*(u32 *)buf = rh->port;
-		break;
-	case SetPortFeature:
-		if (wIndex > R8A66597_MAX_ROOT_HUB)
-			goto error;
-		if (wLength != 0)
-			goto error;
-
-		switch (wValue) {
-		case USB_PORT_FEAT_SUSPEND:
-			break;
-		case USB_PORT_FEAT_POWER:
-			r8a66597_port_power(r8a66597, port, 1);
-			rh->port |= (1 << USB_PORT_FEAT_POWER);
-			break;
-		case USB_PORT_FEAT_RESET: {
-			struct r8a66597_device *dev = rh->dev;
-
-			rh->port |= (1 << USB_PORT_FEAT_RESET);
-
-			disable_r8a66597_pipe_all(r8a66597, dev);
-			free_usb_address(r8a66597, dev);
-
-			r8a66597_mdfy(r8a66597, USBRST, USBRST | UACT,
-				      get_dvstctr_reg(port));
-			mod_timer(&r8a66597->rh_timer,
-				  jiffies + msecs_to_jiffies(50));
-			}
-			break;
-		default:
-			goto error;
-		}
-		rh->port |= 1 << wValue;
-		break;
-	default:
-error:
-		ret = -EPIPE;
-		break;
-	}
-
-	spin_unlock_irqrestore(&r8a66597->lock, flags);
-	return ret;
-}
-
-static struct hc_driver r8a66597_hc_driver = {
-	.description =		hcd_name,
-	.hcd_priv_size =	sizeof(struct r8a66597),
-	.irq =			r8a66597_irq,
-
-	/*
-	 * generic hardware linkage
-	 */
-	.flags =		HCD_USB2,
-
-	.start =		r8a66597_start,
-	.stop =			r8a66597_stop,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		r8a66597_urb_enqueue,
-	.urb_dequeue =		r8a66597_urb_dequeue,
-	.endpoint_disable =	r8a66597_endpoint_disable,
-
-	/*
-	 * periodic schedule support
-	 */
-	.get_frame_number =	r8a66597_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	r8a66597_hub_status_data,
-	.hub_control =		r8a66597_hub_control,
-};
-
-#if defined(CONFIG_PM)
-static int r8a66597_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	pdev->dev.power.power_state = state;
-	return 0;
-}
-
-static int r8a66597_resume(struct platform_device *pdev)
-{
-	pdev->dev.power.power_state = PMSG_ON;
-	return 0;
-}
-#else	/* if defined(CONFIG_PM) */
-#define r8a66597_suspend	NULL
-#define r8a66597_resume		NULL
-#endif
-
-static int __init_or_module r8a66597_remove(struct platform_device *pdev)
-{
-	struct r8a66597		*r8a66597 = dev_get_drvdata(&pdev->dev);
-	struct usb_hcd		*hcd = r8a66597_to_hcd(r8a66597);
-
-	del_timer_sync(&r8a66597->rh_timer);
-	iounmap((void *)r8a66597->reg);
-	usb_remove_hcd(hcd);
-	usb_put_hcd(hcd);
-	return 0;
-}
-
-#define resource_len(r) (((r)->end - (r)->start) + 1)
-static int __init r8a66597_probe(struct platform_device *pdev)
-{
-	struct resource *res = NULL;
-	int irq = -1;
-	void __iomem *reg = NULL;
-	struct usb_hcd *hcd = NULL;
-	struct r8a66597 *r8a66597;
-	int ret = 0;
-	int i;
-
-	if (pdev->dev.dma_mask) {
-		ret = -EINVAL;
-		err("dma not support");
-		goto clean_up;
-	}
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-					   (char *)hcd_name);
-	if (!res) {
-		ret = -ENODEV;
-		err("platform_get_resource_byname error.");
-		goto clean_up;
-	}
-
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		ret = -ENODEV;
-		err("platform_get_irq error.");
-		goto clean_up;
-	}
-
-	reg = ioremap(res->start, resource_len(res));
-	if (reg == NULL) {
-		ret = -ENOMEM;
-		err("ioremap error.");
-		goto clean_up;
-	}
-
-	/* initialize hcd */
-	hcd = usb_create_hcd(&r8a66597_hc_driver, &pdev->dev, (char *)hcd_name);
-	if (!hcd) {
-		ret = -ENOMEM;
-		err("Failed to create hcd");
-		goto clean_up;
-	}
-	r8a66597 = hcd_to_r8a66597(hcd);
-	memset(r8a66597, 0, sizeof(struct r8a66597));
-	dev_set_drvdata(&pdev->dev, r8a66597);
-
-	spin_lock_init(&r8a66597->lock);
-	init_timer(&r8a66597->rh_timer);
-	r8a66597->rh_timer.function = r8a66597_timer;
-	r8a66597->rh_timer.data = (unsigned long)r8a66597;
-	r8a66597->reg = (unsigned long)reg;
-
-	for (i = 0; i < R8A66597_MAX_NUM_PIPE; i++) {
-		INIT_LIST_HEAD(&r8a66597->pipe_queue[i]);
-		init_timer(&r8a66597->td_timer[i]);
-		r8a66597->td_timer[i].function = r8a66597_td_timer;
-		r8a66597->td_timer[i].data = (unsigned long)r8a66597;
-	}
-	INIT_LIST_HEAD(&r8a66597->child_device);
-
-	hcd->rsrc_start = res->start;
-	ret = usb_add_hcd(hcd, irq, 0);
-	if (ret != 0) {
-		err("Failed to add hcd");
-		goto clean_up;
-	}
-
-	return 0;
-
-clean_up:
-	if (reg)
-		iounmap(reg);
-
-	return ret;
-}
-
-static struct platform_driver r8a66597_driver = {
-	.probe =	r8a66597_probe,
-	.remove =	r8a66597_remove,
-	.suspend =	r8a66597_suspend,
-	.resume =	r8a66597_resume,
-	.driver		= {
-		.name = (char *) hcd_name,
-	},
-};
-
-static int __init r8a66597_init(void)
-{
-	if (usb_disabled())
-		return -ENODEV;
-
-	info("driver %s, %s", hcd_name, DRIVER_VERSION);
-	return platform_driver_register(&r8a66597_driver);
-}
-module_init(r8a66597_init);
-
-static void __exit r8a66597_cleanup(void)
-{
-	platform_driver_unregister(&r8a66597_driver);
-}
-module_exit(r8a66597_cleanup);
-
diff -urN host/.svn/text-base/r8a66597.h.svn-base host.new/.svn/text-base/r8a66597.h.svn-base
--- host/.svn/text-base/r8a66597.h.svn-base	2009-02-24 19:00:15.919944025 +0100
+++ host.new/.svn/text-base/r8a66597.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,631 +0,0 @@
-/*
- * R8A66597 HCD (Host Controller Driver)
- *
- * Copyright (C) 2006-2007 Renesas Solutions Corp.
- * Portions Copyright (C) 2004 Psion Teklogix (for NetBook PRO)
- * Portions Copyright (C) 2004-2005 David Brownell
- * Portions Copyright (C) 1999 Roman Weissgaerber
- *
- * Author : Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-#ifndef __R8A66597_H__
-#define __R8A66597_H__
-
-#define SYSCFG0		0x00
-#define SYSCFG1		0x02
-#define SYSSTS0		0x04
-#define SYSSTS1		0x06
-#define DVSTCTR0	0x08
-#define DVSTCTR1	0x0A
-#define TESTMODE	0x0C
-#define PINCFG		0x0E
-#define DMA0CFG		0x10
-#define DMA1CFG		0x12
-#define CFIFO		0x14
-#define D0FIFO		0x18
-#define D1FIFO		0x1C
-#define CFIFOSEL	0x20
-#define CFIFOCTR	0x22
-#define CFIFOSIE	0x24
-#define D0FIFOSEL	0x28
-#define D0FIFOCTR	0x2A
-#define D1FIFOSEL	0x2C
-#define D1FIFOCTR	0x2E
-#define INTENB0		0x30
-#define INTENB1		0x32
-#define INTENB2		0x34
-#define BRDYENB		0x36
-#define NRDYENB		0x38
-#define BEMPENB		0x3A
-#define SOFCFG		0x3C
-#define INTSTS0		0x40
-#define INTSTS1		0x42
-#define INTSTS2		0x44
-#define BRDYSTS		0x46
-#define NRDYSTS		0x48
-#define BEMPSTS		0x4A
-#define FRMNUM		0x4C
-#define UFRMNUM		0x4E
-#define USBADDR		0x50
-#define USBREQ		0x54
-#define USBVAL		0x56
-#define USBINDX		0x58
-#define USBLENG		0x5A
-#define DCPCFG		0x5C
-#define DCPMAXP		0x5E
-#define DCPCTR		0x60
-#define PIPESEL		0x64
-#define PIPECFG		0x68
-#define PIPEBUF		0x6A
-#define PIPEMAXP	0x6C
-#define PIPEPERI	0x6E
-#define PIPE1CTR	0x70
-#define PIPE2CTR	0x72
-#define PIPE3CTR	0x74
-#define PIPE4CTR	0x76
-#define PIPE5CTR	0x78
-#define PIPE6CTR	0x7A
-#define PIPE7CTR	0x7C
-#define PIPE8CTR	0x7E
-#define PIPE9CTR	0x80
-#define PIPE1TRE	0x90
-#define PIPE1TRN	0x92
-#define PIPE2TRE	0x94
-#define PIPE2TRN	0x96
-#define PIPE3TRE	0x98
-#define PIPE3TRN	0x9A
-#define PIPE4TRE	0x9C
-#define	PIPE4TRN	0x9E
-#define	PIPE5TRE	0xA0
-#define	PIPE5TRN	0xA2
-#define DEVADD0		0xD0
-#define DEVADD1		0xD2
-#define DEVADD2		0xD4
-#define DEVADD3		0xD6
-#define DEVADD4		0xD8
-#define DEVADD5		0xDA
-#define DEVADD6		0xDC
-#define DEVADD7		0xDE
-#define DEVADD8		0xE0
-#define DEVADD9		0xE2
-#define DEVADDA		0xE4
-
-/* System Configuration Control Register */
-#define	XTAL		0xC000	/* b15-14: Crystal selection */
-#define	  XTAL48	 0x8000	  /* 48MHz */
-#define	  XTAL24	 0x4000	  /* 24MHz */
-#define	  XTAL12	 0x0000	  /* 12MHz */
-#define	XCKE		0x2000	/* b13: External clock enable */
-#define	PLLC		0x0800	/* b11: PLL control */
-#define	SCKE		0x0400	/* b10: USB clock enable */
-#define	PCSDIS		0x0200	/* b9: not CS wakeup */
-#define	LPSME		0x0100	/* b8: Low power sleep mode */
-#define	HSE		0x0080	/* b7: Hi-speed enable */
-#define	DCFM		0x0040	/* b6: Controller function select  */
-#define	DRPD		0x0020	/* b5: D+/- pull down control */
-#define	DPRPU		0x0010	/* b4: D+ pull up control */
-#define	USBE		0x0001	/* b0: USB module operation enable */
-
-/* System Configuration Status Register */
-#define	OVCBIT		0x8000	/* b15-14: Over-current bit */
-#define	OVCMON		0xC000	/* b15-14: Over-current monitor */
-#define	SOFEA		0x0020	/* b5: SOF monitor */
-#define	IDMON		0x0004	/* b3: ID-pin monitor */
-#define	LNST		0x0003	/* b1-0: D+, D- line status */
-#define	  SE1		 0x0003	  /* SE1 */
-#define	  FS_KSTS	 0x0002	  /* Full-Speed K State */
-#define	  FS_JSTS	 0x0001	  /* Full-Speed J State */
-#define	  LS_JSTS	 0x0002	  /* Low-Speed J State */
-#define	  LS_KSTS	 0x0001	  /* Low-Speed K State */
-#define	  SE0		 0x0000	  /* SE0 */
-
-/* Device State Control Register */
-#define	EXTLP0		0x0400	/* b10: External port */
-#define	VBOUT		0x0200	/* b9: VBUS output */
-#define	WKUP		0x0100	/* b8: Remote wakeup */
-#define	RWUPE		0x0080	/* b7: Remote wakeup sense */
-#define	USBRST		0x0040	/* b6: USB reset enable */
-#define	RESUME		0x0020	/* b5: Resume enable */
-#define	UACT		0x0010	/* b4: USB bus enable */
-#define	RHST		0x0007	/* b1-0: Reset handshake status */
-#define	  HSPROC	 0x0004	  /* HS handshake is processing */
-#define	  HSMODE	 0x0003	  /* Hi-Speed mode */
-#define	  FSMODE	 0x0002	  /* Full-Speed mode */
-#define	  LSMODE	 0x0001	  /* Low-Speed mode */
-#define	  UNDECID	 0x0000	  /* Undecided */
-
-/* Test Mode Register */
-#define	UTST			0x000F	/* b3-0: Test select */
-#define	  H_TST_PACKET		 0x000C	  /* HOST TEST Packet */
-#define	  H_TST_SE0_NAK		 0x000B	  /* HOST TEST SE0 NAK */
-#define	  H_TST_K		 0x000A	  /* HOST TEST K */
-#define	  H_TST_J		 0x0009	  /* HOST TEST J */
-#define	  H_TST_NORMAL		 0x0000	  /* HOST Normal Mode */
-#define	  P_TST_PACKET		 0x0004	  /* PERI TEST Packet */
-#define	  P_TST_SE0_NAK		 0x0003	  /* PERI TEST SE0 NAK */
-#define	  P_TST_K		 0x0002	  /* PERI TEST K */
-#define	  P_TST_J		 0x0001	  /* PERI TEST J */
-#define	  P_TST_NORMAL		 0x0000	  /* PERI Normal Mode */
-
-/* Data Pin Configuration Register */
-#define	LDRV			0x8000	/* b15: Drive Current Adjust */
-#define	  VIF1			  0x0000		/* VIF = 1.8V */
-#define	  VIF3			  0x8000		/* VIF = 3.3V */
-#define	INTA			0x0001	/* b1: USB INT-pin active */
-
-/* DMAx Pin Configuration Register */
-#define	DREQA			0x4000	/* b14: Dreq active select */
-#define	BURST			0x2000	/* b13: Burst mode */
-#define	DACKA			0x0400	/* b10: Dack active select */
-#define	DFORM			0x0380	/* b9-7: DMA mode select */
-#define	  CPU_ADR_RD_WR		 0x0000	  /* Address + RD/WR mode (CPU bus) */
-#define	  CPU_DACK_RD_WR	 0x0100	  /* DACK + RD/WR mode (CPU bus) */
-#define	  CPU_DACK_ONLY		 0x0180	  /* DACK only mode (CPU bus) */
-#define	  SPLIT_DACK_ONLY	 0x0200	  /* DACK only mode (SPLIT bus) */
-#define	DENDA			0x0040	/* b6: Dend active select */
-#define	PKTM			0x0020	/* b5: Packet mode */
-#define	DENDE			0x0010	/* b4: Dend enable */
-#define	OBUS			0x0004	/* b2: OUTbus mode */
-
-/* CFIFO/DxFIFO Port Select Register */
-#define	RCNT		0x8000	/* b15: Read count mode */
-#define	REW		0x4000	/* b14: Buffer rewind */
-#define	DCLRM		0x2000	/* b13: DMA buffer clear mode */
-#define	DREQE		0x1000	/* b12: DREQ output enable */
-#define	MBW		0x0400	/* b10: Maximum bit width for FIFO access */
-#define	  MBW_8		 0x0000	  /*  8bit */
-#define	  MBW_16	 0x0400	  /* 16bit */
-#define	BIGEND		0x0100	/* b8: Big endian mode */
-#define	  BYTE_LITTLE	 0x0000		/* little dendian */
-#define	  BYTE_BIG	 0x0100		/* big endifan */
-#define	ISEL		0x0020	/* b5: DCP FIFO port direction select */
-#define	CURPIPE		0x000F	/* b2-0: PIPE select */
-
-/* CFIFO/DxFIFO Port Control Register */
-#define	BVAL		0x8000	/* b15: Buffer valid flag */
-#define	BCLR		0x4000	/* b14: Buffer clear */
-#define	FRDY		0x2000	/* b13: FIFO ready */
-#define	DTLN		0x0FFF	/* b11-0: FIFO received data length */
-
-/* Interrupt Enable Register 0 */
-#define	VBSE	0x8000	/* b15: VBUS interrupt */
-#define	RSME	0x4000	/* b14: Resume interrupt */
-#define	SOFE	0x2000	/* b13: Frame update interrupt */
-#define	DVSE	0x1000	/* b12: Device state transition interrupt */
-#define	CTRE	0x0800	/* b11: Control transfer stage transition interrupt */
-#define	BEMPE	0x0400	/* b10: Buffer empty interrupt */
-#define	NRDYE	0x0200	/* b9: Buffer not ready interrupt */
-#define	BRDYE	0x0100	/* b8: Buffer ready interrupt */
-
-/* Interrupt Enable Register 1 */
-#define	OVRCRE		0x8000	/* b15: Over-current interrupt */
-#define	BCHGE		0x4000	/* b14: USB us chenge interrupt */
-#define	DTCHE		0x1000	/* b12: Detach sense interrupt */
-#define	ATTCHE		0x0800	/* b11: Attach sense interrupt */
-#define	EOFERRE		0x0040	/* b6: EOF error interrupt */
-#define	SIGNE		0x0020	/* b5: SETUP IGNORE interrupt */
-#define	SACKE		0x0010	/* b4: SETUP ACK interrupt */
-
-/* BRDY Interrupt Enable/Status Register */
-#define	BRDY9		0x0200	/* b9: PIPE9 */
-#define	BRDY8		0x0100	/* b8: PIPE8 */
-#define	BRDY7		0x0080	/* b7: PIPE7 */
-#define	BRDY6		0x0040	/* b6: PIPE6 */
-#define	BRDY5		0x0020	/* b5: PIPE5 */
-#define	BRDY4		0x0010	/* b4: PIPE4 */
-#define	BRDY3		0x0008	/* b3: PIPE3 */
-#define	BRDY2		0x0004	/* b2: PIPE2 */
-#define	BRDY1		0x0002	/* b1: PIPE1 */
-#define	BRDY0		0x0001	/* b1: PIPE0 */
-
-/* NRDY Interrupt Enable/Status Register */
-#define	NRDY9		0x0200	/* b9: PIPE9 */
-#define	NRDY8		0x0100	/* b8: PIPE8 */
-#define	NRDY7		0x0080	/* b7: PIPE7 */
-#define	NRDY6		0x0040	/* b6: PIPE6 */
-#define	NRDY5		0x0020	/* b5: PIPE5 */
-#define	NRDY4		0x0010	/* b4: PIPE4 */
-#define	NRDY3		0x0008	/* b3: PIPE3 */
-#define	NRDY2		0x0004	/* b2: PIPE2 */
-#define	NRDY1		0x0002	/* b1: PIPE1 */
-#define	NRDY0		0x0001	/* b1: PIPE0 */
-
-/* BEMP Interrupt Enable/Status Register */
-#define	BEMP9		0x0200	/* b9: PIPE9 */
-#define	BEMP8		0x0100	/* b8: PIPE8 */
-#define	BEMP7		0x0080	/* b7: PIPE7 */
-#define	BEMP6		0x0040	/* b6: PIPE6 */
-#define	BEMP5		0x0020	/* b5: PIPE5 */
-#define	BEMP4		0x0010	/* b4: PIPE4 */
-#define	BEMP3		0x0008	/* b3: PIPE3 */
-#define	BEMP2		0x0004	/* b2: PIPE2 */
-#define	BEMP1		0x0002	/* b1: PIPE1 */
-#define	BEMP0		0x0001	/* b0: PIPE0 */
-
-/* SOF Pin Configuration Register */
-#define	TRNENSEL	0x0100	/* b8: Select transaction enable period */
-#define	BRDYM		0x0040	/* b6: BRDY clear timing */
-#define	INTL		0x0020	/* b5: Interrupt sense select */
-#define	EDGESTS		0x0010	/* b4:  */
-#define	SOFMODE		0x000C	/* b3-2: SOF pin select */
-#define	  SOF_125US	 0x0008	  /* SOF OUT 125us Frame Signal */
-#define	  SOF_1MS	 0x0004	  /* SOF OUT 1ms Frame Signal */
-#define	  SOF_DISABLE	 0x0000	  /* SOF OUT Disable */
-
-/* Interrupt Status Register 0 */
-#define	VBINT	0x8000	/* b15: VBUS interrupt */
-#define	RESM	0x4000	/* b14: Resume interrupt */
-#define	SOFR	0x2000	/* b13: SOF frame update interrupt */
-#define	DVST	0x1000	/* b12: Device state transition interrupt */
-#define	CTRT	0x0800	/* b11: Control transfer stage transition interrupt */
-#define	BEMP	0x0400	/* b10: Buffer empty interrupt */
-#define	NRDY	0x0200	/* b9: Buffer not ready interrupt */
-#define	BRDY	0x0100	/* b8: Buffer ready interrupt */
-#define	VBSTS	0x0080	/* b7: VBUS input port */
-#define	DVSQ	0x0070	/* b6-4: Device state */
-#define	  DS_SPD_CNFG	 0x0070	  /* Suspend Configured */
-#define	  DS_SPD_ADDR	 0x0060	  /* Suspend Address */
-#define	  DS_SPD_DFLT	 0x0050	  /* Suspend Default */
-#define	  DS_SPD_POWR	 0x0040	  /* Suspend Powered */
-#define	  DS_SUSP	 0x0040	  /* Suspend */
-#define	  DS_CNFG	 0x0030	  /* Configured */
-#define	  DS_ADDS	 0x0020	  /* Address */
-#define	  DS_DFLT	 0x0010	  /* Default */
-#define	  DS_POWR	 0x0000	  /* Powered */
-#define	DVSQS		0x0030	/* b5-4: Device state */
-#define	VALID		0x0008	/* b3: Setup packet detected flag */
-#define	CTSQ		0x0007	/* b2-0: Control transfer stage */
-#define	  CS_SQER	 0x0006	  /* Sequence error */
-#define	  CS_WRND	 0x0005	  /* Control write nodata status stage */
-#define	  CS_WRSS	 0x0004	  /* Control write status stage */
-#define	  CS_WRDS	 0x0003	  /* Control write data stage */
-#define	  CS_RDSS	 0x0002	  /* Control read status stage */
-#define	  CS_RDDS	 0x0001	  /* Control read data stage */
-#define	  CS_IDST	 0x0000	  /* Idle or setup stage */
-
-/* Interrupt Status Register 1 */
-#define	OVRCR		0x8000	/* b15: Over-current interrupt */
-#define	BCHG		0x4000	/* b14: USB bus chenge interrupt */
-#define	DTCH		0x1000	/* b12: Detach sense interrupt */
-#define	ATTCH		0x0800	/* b11: Attach sense interrupt */
-#define	EOFERR		0x0040	/* b6: EOF-error interrupt */
-#define	SIGN		0x0020	/* b5: Setup ignore interrupt */
-#define	SACK		0x0010	/* b4: Setup acknowledge interrupt */
-
-/* Frame Number Register */
-#define	OVRN		0x8000	/* b15: Overrun error */
-#define	CRCE		0x4000	/* b14: Received data error */
-#define	FRNM		0x07FF	/* b10-0: Frame number */
-
-/* Micro Frame Number Register */
-#define	UFRNM		0x0007	/* b2-0: Micro frame number */
-
-/* Default Control Pipe Maxpacket Size Register */
-/* Pipe Maxpacket Size Register */
-#define	DEVSEL	0xF000	/* b15-14: Device address select */
-#define	MAXP	0x007F	/* b6-0: Maxpacket size of default control pipe */
-
-/* Default Control Pipe Control Register */
-#define	BSTS		0x8000	/* b15: Buffer status */
-#define	SUREQ		0x4000	/* b14: Send USB request  */
-#define	CSCLR		0x2000	/* b13: complete-split status clear */
-#define	CSSTS		0x1000	/* b12: complete-split status */
-#define	SUREQCLR	0x0800	/* b11: stop setup request */
-#define	SQCLR		0x0100	/* b8: Sequence toggle bit clear */
-#define	SQSET		0x0080	/* b7: Sequence toggle bit set */
-#define	SQMON		0x0040	/* b6: Sequence toggle bit monitor */
-#define	PBUSY		0x0020	/* b5: pipe busy */
-#define	PINGE		0x0010	/* b4: ping enable */
-#define	CCPL		0x0004	/* b2: Enable control transfer complete */
-#define	PID		0x0003	/* b1-0: Response PID */
-#define	  PID_STALL11	 0x0003	  /* STALL */
-#define	  PID_STALL	 0x0002	  /* STALL */
-#define	  PID_BUF	 0x0001	  /* BUF */
-#define	  PID_NAK	 0x0000	  /* NAK */
-
-/* Pipe Window Select Register */
-#define	PIPENM		0x0007	/* b2-0: Pipe select */
-
-/* Pipe Configuration Register */
-#define	R8A66597_TYP	0xC000	/* b15-14: Transfer type */
-#define	  R8A66597_ISO	 0xC000		  /* Isochronous */
-#define	  R8A66597_INT	 0x8000		  /* Interrupt */
-#define	  R8A66597_BULK	 0x4000		  /* Bulk */
-#define	R8A66597_BFRE	0x0400	/* b10: Buffer ready interrupt mode select */
-#define	R8A66597_DBLB	0x0200	/* b9: Double buffer mode select */
-#define	R8A66597_CNTMD	0x0100	/* b8: Continuous transfer mode select */
-#define	R8A66597_SHTNAK	0x0080	/* b7: Transfer end NAK */
-#define	R8A66597_DIR	0x0010	/* b4: Transfer direction select */
-#define	R8A66597_EPNUM	0x000F	/* b3-0: Eendpoint number select */
-
-/* Pipe Buffer Configuration Register */
-#define	BUFSIZE		0x7C00	/* b14-10: Pipe buffer size */
-#define	BUFNMB		0x007F	/* b6-0: Pipe buffer number */
-#define	PIPE0BUF	256
-#define	PIPExBUF	64
-
-/* Pipe Maxpacket Size Register */
-#define	MXPS		0x07FF	/* b10-0: Maxpacket size */
-
-/* Pipe Cycle Configuration Register */
-#define	IFIS	0x1000	/* b12: Isochronous in-buffer flush mode select */
-#define	IITV	0x0007	/* b2-0: Isochronous interval */
-
-/* Pipex Control Register */
-#define	BSTS	0x8000	/* b15: Buffer status */
-#define	INBUFM	0x4000	/* b14: IN buffer monitor (Only for PIPE1 to 5) */
-#define	CSCLR	0x2000	/* b13: complete-split status clear */
-#define	CSSTS	0x1000	/* b12: complete-split status */
-#define	ATREPM	0x0400	/* b10: Auto repeat mode */
-#define	ACLRM	0x0200	/* b9: Out buffer auto clear mode */
-#define	SQCLR	0x0100	/* b8: Sequence toggle bit clear */
-#define	SQSET	0x0080	/* b7: Sequence toggle bit set */
-#define	SQMON	0x0040	/* b6: Sequence toggle bit monitor */
-#define	PBUSY	0x0020	/* b5: pipe busy */
-#define	PID	0x0003	/* b1-0: Response PID */
-
-/* PIPExTRE */
-#define	TRENB		0x0200	/* b9: Transaction counter enable */
-#define	TRCLR		0x0100	/* b8: Transaction counter clear */
-
-/* PIPExTRN */
-#define	TRNCNT		0xFFFF	/* b15-0: Transaction counter */
-
-/* DEVADDx */
-#define	UPPHUB		0x7800
-#define	HUBPORT		0x0700
-#define	USBSPD		0x00C0
-#define	RTPORT		0x0001
-
-#define R8A66597_MAX_NUM_PIPE		10
-#define R8A66597_BUF_BSIZE		8
-#define R8A66597_MAX_DEVICE		10
-#define R8A66597_MAX_ROOT_HUB		2
-#define R8A66597_MAX_SAMPLING		10
-#define R8A66597_MAX_DMA_CHANNEL	2
-#define R8A66597_PIPE_NO_DMA		R8A66597_MAX_DMA_CHANNEL
-#define check_bulk_or_isoc(pipenum)	((pipenum >= 1 && pipenum <= 5))
-#define check_interrupt(pipenum)	((pipenum >= 6 && pipenum <= 9))
-#define make_devsel(addr)		(addr << 12)
-
-struct r8a66597_pipe_info {
-	u16 pipenum;
-	u16 address;	/* R8A66597 HCD usb addres */
-	u16 epnum;
-	u16 maxpacket;
-	u16 type;
-	u16 bufnum;
-	u16 buf_bsize;
-	u16 interval;
-	u16 dir_in;
-};
-
-struct r8a66597_pipe {
-	struct r8a66597_pipe_info info;
-
-	unsigned long fifoaddr;
-	unsigned long fifosel;
-	unsigned long fifoctr;
-	unsigned long pipectr;
-	unsigned long pipetre;
-	unsigned long pipetrn;
-};
-
-struct r8a66597_td {
-	struct r8a66597_pipe *pipe;
-	struct urb *urb;
-	struct list_head queue;
-
-	u16 type;
-	u16 pipenum;
-	int iso_cnt;
-
-	u16 address;		/* R8A66597's USB address */
-	u16 maxpacket;
-
-	unsigned zero_packet:1;
-	unsigned short_packet:1;
-	unsigned set_address:1;
-};
-
-struct r8a66597_device {
-	u16	address;	/* R8A66597's USB address */
-	u16	hub_port;
-	u16	root_port;
-
-	unsigned short ep_in_toggle;
-	unsigned short ep_out_toggle;
-	unsigned char pipe_cnt[R8A66597_MAX_NUM_PIPE];
-	unsigned char dma_map;
-
-	enum usb_device_state state;
-
-	struct usb_device *udev;
-	int usb_address;
-	struct list_head device_list;
-};
-
-struct r8a66597_root_hub {
-	u32 port;
-	u16 old_syssts;
-	int scount;
-
-	struct r8a66597_device	*dev;
-};
-
-struct r8a66597 {
-	spinlock_t lock;
-	unsigned long reg;
-
-	struct r8a66597_device		device0;
-	struct r8a66597_root_hub	root_hub[R8A66597_MAX_ROOT_HUB];
-	struct list_head		pipe_queue[R8A66597_MAX_NUM_PIPE];
-
-	struct timer_list rh_timer;
-	struct timer_list td_timer[R8A66597_MAX_NUM_PIPE];
-
-	unsigned short address_map;
-	unsigned short timeout_map;
-	unsigned char pipe_cnt[R8A66597_MAX_NUM_PIPE];
-	unsigned char dma_map;
-
-	struct list_head child_device;
-	unsigned long child_connect_map[4];
-};
-
-static inline struct r8a66597 *hcd_to_r8a66597(struct usb_hcd *hcd)
-{
-	return (struct r8a66597 *)(hcd->hcd_priv);
-}
-
-static inline struct usb_hcd *r8a66597_to_hcd(struct r8a66597 *r8a66597)
-{
-	return container_of((void *)r8a66597, struct usb_hcd, hcd_priv);
-}
-
-static inline struct r8a66597_td *r8a66597_get_td(struct r8a66597 *r8a66597,
-						  u16 pipenum)
-{
-	if (unlikely(list_empty(&r8a66597->pipe_queue[pipenum])))
-		return NULL;
-
-	return list_entry(r8a66597->pipe_queue[pipenum].next,
-			  struct r8a66597_td, queue);
-}
-
-static inline struct urb *r8a66597_get_urb(struct r8a66597 *r8a66597,
-					   u16 pipenum)
-{
-	struct r8a66597_td *td;
-
-	td = r8a66597_get_td(r8a66597, pipenum);
-	return (td ? td->urb : NULL);
-}
-
-static inline u16 r8a66597_read(struct r8a66597 *r8a66597, unsigned long offset)
-{
-	return inw(r8a66597->reg + offset);
-}
-
-static inline void r8a66597_read_fifo(struct r8a66597 *r8a66597,
-				      unsigned long offset, u16 *buf,
-				      int len)
-{
-	len = (len + 1) / 2;
-	insw(r8a66597->reg + offset, buf, len);
-}
-
-static inline void r8a66597_write(struct r8a66597 *r8a66597, u16 val,
-				  unsigned long offset)
-{
-	outw(val, r8a66597->reg + offset);
-}
-
-static inline void r8a66597_write_fifo(struct r8a66597 *r8a66597,
-				       unsigned long offset, u16 *buf,
-				       int len)
-{
-	unsigned long fifoaddr = r8a66597->reg + offset;
-	int odd = len & 0x0001;
-
-	len = len / 2;
-	outsw(fifoaddr, buf, len);
-	if (unlikely(odd)) {
-		buf = &buf[len];
-		outb((unsigned char)*buf, fifoaddr);
-	}
-}
-
-static inline void r8a66597_mdfy(struct r8a66597 *r8a66597,
-				 u16 val, u16 pat, unsigned long offset)
-{
-	u16 tmp;
-	tmp = r8a66597_read(r8a66597, offset);
-	tmp = tmp & (~pat);
-	tmp = tmp | val;
-	r8a66597_write(r8a66597, tmp, offset);
-}
-
-#define r8a66597_bclr(r8a66597, val, offset)	\
-			r8a66597_mdfy(r8a66597, 0, val, offset)
-#define r8a66597_bset(r8a66597, val, offset)	\
-			r8a66597_mdfy(r8a66597, val, 0, offset)
-
-static inline unsigned long get_syscfg_reg(int port)
-{
-	return port == 0 ? SYSCFG0 : SYSCFG1;
-}
-
-static inline unsigned long get_syssts_reg(int port)
-{
-	return port == 0 ? SYSSTS0 : SYSSTS1;
-}
-
-static inline unsigned long get_dvstctr_reg(int port)
-{
-	return port == 0 ? DVSTCTR0 : DVSTCTR1;
-}
-
-static inline unsigned long get_intenb_reg(int port)
-{
-	return port == 0 ? INTENB1 : INTENB2;
-}
-
-static inline unsigned long get_intsts_reg(int port)
-{
-	return port == 0 ? INTSTS1 : INTSTS2;
-}
-
-static inline u16 get_rh_usb_speed(struct r8a66597 *r8a66597, int port)
-{
-	unsigned long dvstctr_reg = get_dvstctr_reg(port);
-
-	return r8a66597_read(r8a66597, dvstctr_reg) & RHST;
-}
-
-static inline void r8a66597_port_power(struct r8a66597 *r8a66597, int port,
-				       int power)
-{
-	unsigned long dvstctr_reg = get_dvstctr_reg(port);
-
-	if (power)
-		r8a66597_bset(r8a66597, VBOUT, dvstctr_reg);
-	else
-		r8a66597_bclr(r8a66597, VBOUT, dvstctr_reg);
-}
-
-#define get_pipectr_addr(pipenum)	(PIPE1CTR + (pipenum - 1) * 2)
-#define get_pipetre_addr(pipenum)	(PIPE1TRE + (pipenum - 1) * 4)
-#define get_pipetrn_addr(pipenum)	(PIPE1TRN + (pipenum - 1) * 4)
-#define get_devadd_addr(address)	(DEVADD0 + address * 2)
-
-#define enable_irq_ready(r8a66597, pipenum)	\
-	enable_pipe_irq(r8a66597, pipenum, BRDYENB)
-#define disable_irq_ready(r8a66597, pipenum)	\
-	disable_pipe_irq(r8a66597, pipenum, BRDYENB)
-#define enable_irq_empty(r8a66597, pipenum)	\
-	enable_pipe_irq(r8a66597, pipenum, BEMPENB)
-#define disable_irq_empty(r8a66597, pipenum)	\
-	disable_pipe_irq(r8a66597, pipenum, BEMPENB)
-#define enable_irq_nrdy(r8a66597, pipenum)	\
-	enable_pipe_irq(r8a66597, pipenum, NRDYENB)
-#define disable_irq_nrdy(r8a66597, pipenum)	\
-	disable_pipe_irq(r8a66597, pipenum, NRDYENB)
-
-#endif	/* __R8A66597_H__ */
-
diff -urN host/.svn/text-base/sl811-hcd.c.svn-base host.new/.svn/text-base/sl811-hcd.c.svn-base
--- host/.svn/text-base/sl811-hcd.c.svn-base	2009-02-24 19:00:15.939943009 +0100
+++ host.new/.svn/text-base/sl811-hcd.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,1857 +0,0 @@
-/*
- * SL811HS HCD (Host Controller Driver) for USB.
- *
- * Copyright (C) 2004 Psion Teklogix (for NetBook PRO)
- * Copyright (C) 2004-2005 David Brownell
- *
- * Periodic scheduling is based on Roman's OHCI code
- * 	Copyright (C) 1999 Roman Weissgaerber
- *
- * The SL811HS controller handles host side USB (like the SL11H, but with
- * another register set and SOF generation) as well as peripheral side USB
- * (like the SL811S).  This driver version doesn't implement the Gadget API
- * for the peripheral role; or OTG (that'd need much external circuitry).
- *
- * For documentation, see the SL811HS spec and the "SL811HS Embedded Host"
- * document (providing significant pieces missing from that spec); plus
- * the SL811S spec if you want peripheral side info.
- */
-
-/*
- * Status:  Passed basic stress testing, works with hubs, mice, keyboards,
- * and usb-storage.
- *
- * TODO:
- * - usb suspend/resume triggered by sl811 (with USB_SUSPEND)
- * - various issues noted in the code
- * - performance work; use both register banks; ...
- * - use urb->iso_frame_desc[] with ISO transfers
- */
-
-#undef	VERBOSE
-#undef	PACKET_TRACE
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/ioport.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/timer.h>
-#include <linux/list.h>
-#include <linux/interrupt.h>
-#include <linux/usb.h>
-#include <linux/usb/sl811.h>
-#include <linux/platform_device.h>
-
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/system.h>
-#include <asm/byteorder.h>
-
-#include "../core/hcd.h"
-#include "sl811.h"
-
-
-MODULE_DESCRIPTION("SL811HS USB Host Controller Driver");
-MODULE_LICENSE("GPL");
-
-#define DRIVER_VERSION	"19 May 2005"
-
-
-#ifndef DEBUG
-#	define	STUB_DEBUG_FILE
-#endif
-
-/* for now, use only one transfer register bank */
-#undef	USE_B
-
-/* this doesn't understand urb->iso_frame_desc[], but if you had a driver
- * that just queued one ISO frame per URB then iso transfers "should" work
- * using the normal urb status fields.
- */
-#define	DISABLE_ISO
-
-// #define	QUIRK2
-#define	QUIRK3
-
-static const char hcd_name[] = "sl811-hcd";
-
-/*-------------------------------------------------------------------------*/
-
-static void port_power(struct sl811 *sl811, int is_on)
-{
-	struct usb_hcd	*hcd = sl811_to_hcd(sl811);
-
-	/* hub is inactive unless the port is powered */
-	if (is_on) {
-		if (sl811->port1 & (1 << USB_PORT_FEAT_POWER))
-			return;
-
-		sl811->port1 = (1 << USB_PORT_FEAT_POWER);
-		sl811->irq_enable = SL11H_INTMASK_INSRMV;
-		hcd->self.controller->power.power_state = PMSG_ON;
-	} else {
-		sl811->port1 = 0;
-		sl811->irq_enable = 0;
-		hcd->state = HC_STATE_HALT;
-		hcd->self.controller->power.power_state = PMSG_SUSPEND;
-	}
-	sl811->ctrl1 = 0;
-	sl811_write(sl811, SL11H_IRQ_ENABLE, 0);
-	sl811_write(sl811, SL11H_IRQ_STATUS, ~0);
-
-	if (sl811->board && sl811->board->port_power) {
-		/* switch VBUS, at 500mA unless hub power budget gets set */
-		DBG("power %s\n", is_on ? "on" : "off");
-		sl811->board->port_power(hcd->self.controller, is_on);
-	}
-
-	/* reset as thoroughly as we can */
-	if (sl811->board && sl811->board->reset)
-		sl811->board->reset(hcd->self.controller);
-	else {
-		sl811_write(sl811, SL11H_CTLREG1, SL11H_CTL1MASK_SE0);
-		mdelay(20);
-	}
-
-	sl811_write(sl811, SL11H_IRQ_ENABLE, 0);
-	sl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);
-	sl811_write(sl811, SL811HS_CTLREG2, SL811HS_CTL2_INIT);
-	sl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);
-
-	// if !is_on, put into lowpower mode now
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* This is a PIO-only HCD.  Queueing appends URBs to the endpoint's queue,
- * and may start I/O.  Endpoint queues are scanned during completion irq
- * handlers (one per packet: ACK, NAK, faults, etc) and urb cancellation.
- *
- * Using an external DMA engine to copy a packet at a time could work,
- * though setup/teardown costs may be too big to make it worthwhile.
- */
-
-/* SETUP starts a new control request.  Devices are not allowed to
- * STALL or NAK these; they must cancel any pending control requests.
- */
-static void setup_packet(
-	struct sl811		*sl811,
-	struct sl811h_ep	*ep,
-	struct urb		*urb,
-	u8			bank,
-	u8			control
-)
-{
-	u8			addr;
-	u8			len;
-	void __iomem		*data_reg;
-
-	addr = SL811HS_PACKET_BUF(bank == 0);
-	len = sizeof(struct usb_ctrlrequest);
-	data_reg = sl811->data_reg;
-	sl811_write_buf(sl811, addr, urb->setup_packet, len);
-
-	/* autoincrementing */
-	sl811_write(sl811, bank + SL11H_BUFADDRREG, addr);
-	writeb(len, data_reg);
-	writeb(SL_SETUP /* | ep->epnum */, data_reg);
-	writeb(usb_pipedevice(urb->pipe), data_reg);
-
-	/* always OUT/data0 */ ;
-	sl811_write(sl811, bank + SL11H_HOSTCTLREG,
-			control | SL11H_HCTLMASK_OUT);
-	ep->length = 0;
-	PACKET("SETUP qh%p\n", ep);
-}
-
-/* STATUS finishes control requests, often after IN or OUT data packets */
-static void status_packet(
-	struct sl811		*sl811,
-	struct sl811h_ep	*ep,
-	struct urb		*urb,
-	u8			bank,
-	u8			control
-)
-{
-	int			do_out;
-	void __iomem		*data_reg;
-
-	do_out = urb->transfer_buffer_length && usb_pipein(urb->pipe);
-	data_reg = sl811->data_reg;
-
-	/* autoincrementing */
-	sl811_write(sl811, bank + SL11H_BUFADDRREG, 0);
-	writeb(0, data_reg);
-	writeb((do_out ? SL_OUT : SL_IN) /* | ep->epnum */, data_reg);
-	writeb(usb_pipedevice(urb->pipe), data_reg);
-
-	/* always data1; sometimes IN */
-	control |= SL11H_HCTLMASK_TOGGLE;
-	if (do_out)
-		control |= SL11H_HCTLMASK_OUT;
-	sl811_write(sl811, bank + SL11H_HOSTCTLREG, control);
-	ep->length = 0;
-	PACKET("STATUS%s/%s qh%p\n", ep->nak_count ? "/retry" : "",
-			do_out ? "out" : "in", ep);
-}
-
-/* IN packets can be used with any type of endpoint. here we just
- * start the transfer, data from the peripheral may arrive later.
- * urb->iso_frame_desc is currently ignored here...
- */
-static void in_packet(
-	struct sl811		*sl811,
-	struct sl811h_ep	*ep,
-	struct urb		*urb,
-	u8			bank,
-	u8			control
-)
-{
-	u8			addr;
-	u8			len;
-	void __iomem		*data_reg;
-
-	/* avoid losing data on overflow */
-	len = ep->maxpacket;
-	addr = SL811HS_PACKET_BUF(bank == 0);
-	if (!(control & SL11H_HCTLMASK_ISOCH)
-			&& usb_gettoggle(urb->dev, ep->epnum, 0))
-		control |= SL11H_HCTLMASK_TOGGLE;
-	data_reg = sl811->data_reg;
-
-	/* autoincrementing */
-	sl811_write(sl811, bank + SL11H_BUFADDRREG, addr);
-	writeb(len, data_reg);
-	writeb(SL_IN | ep->epnum, data_reg);
-	writeb(usb_pipedevice(urb->pipe), data_reg);
-
-	sl811_write(sl811, bank + SL11H_HOSTCTLREG, control);
-	ep->length = min((int)len,
-			urb->transfer_buffer_length - urb->actual_length);
-	PACKET("IN%s/%d qh%p len%d\n", ep->nak_count ? "/retry" : "",
-			!!usb_gettoggle(urb->dev, ep->epnum, 0), ep, len);
-}
-
-/* OUT packets can be used with any type of endpoint.
- * urb->iso_frame_desc is currently ignored here...
- */
-static void out_packet(
-	struct sl811		*sl811,
-	struct sl811h_ep	*ep,
-	struct urb		*urb,
-	u8			bank,
-	u8			control
-)
-{
-	void			*buf;
-	u8			addr;
-	u8			len;
-	void __iomem		*data_reg;
-
-	buf = urb->transfer_buffer + urb->actual_length;
-	prefetch(buf);
-
-	len = min((int)ep->maxpacket,
-			urb->transfer_buffer_length - urb->actual_length);
-
-	if (!(control & SL11H_HCTLMASK_ISOCH)
-			&& usb_gettoggle(urb->dev, ep->epnum, 1))
-		control |= SL11H_HCTLMASK_TOGGLE;
-	addr = SL811HS_PACKET_BUF(bank == 0);
-	data_reg = sl811->data_reg;
-
-	sl811_write_buf(sl811, addr, buf, len);
-
-	/* autoincrementing */
-	sl811_write(sl811, bank + SL11H_BUFADDRREG, addr);
-	writeb(len, data_reg);
-	writeb(SL_OUT | ep->epnum, data_reg);
-	writeb(usb_pipedevice(urb->pipe), data_reg);
-
-	sl811_write(sl811, bank + SL11H_HOSTCTLREG,
-			control | SL11H_HCTLMASK_OUT);
-	ep->length = len;
-	PACKET("OUT%s/%d qh%p len%d\n", ep->nak_count ? "/retry" : "",
-			!!usb_gettoggle(urb->dev, ep->epnum, 1), ep, len);
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* caller updates on-chip enables later */
-
-static inline void sofirq_on(struct sl811 *sl811)
-{
-	if (sl811->irq_enable & SL11H_INTMASK_SOFINTR)
-		return;
-	VDBG("sof irq on\n");
-	sl811->irq_enable |= SL11H_INTMASK_SOFINTR;
-}
-
-static inline void sofirq_off(struct sl811 *sl811)
-{
-	if (!(sl811->irq_enable & SL11H_INTMASK_SOFINTR))
-		return;
-	VDBG("sof irq off\n");
-	sl811->irq_enable &= ~SL11H_INTMASK_SOFINTR;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* pick the next endpoint for a transaction, and issue it.
- * frames start with periodic transfers (after whatever is pending
- * from the previous frame), and the rest of the time is async
- * transfers, scheduled round-robin.
- */
-static struct sl811h_ep	*start(struct sl811 *sl811, u8 bank)
-{
-	struct sl811h_ep	*ep;
-	struct urb		*urb;
-	int			fclock;
-	u8			control;
-
-	/* use endpoint at schedule head */
-	if (sl811->next_periodic) {
-		ep = sl811->next_periodic;
-		sl811->next_periodic = ep->next;
-	} else {
-		if (sl811->next_async)
-			ep = sl811->next_async;
-		else if (!list_empty(&sl811->async))
-			ep = container_of(sl811->async.next,
-					struct sl811h_ep, schedule);
-		else {
-			/* could set up the first fullspeed periodic
-			 * transfer for the next frame ...
-			 */
-			return NULL;
-		}
-
-#ifdef USE_B
-		if ((bank && sl811->active_b == ep) || sl811->active_a == ep)
-			return NULL;
-#endif
-
-		if (ep->schedule.next == &sl811->async)
-			sl811->next_async = NULL;
-		else
-			sl811->next_async = container_of(ep->schedule.next,
-					struct sl811h_ep, schedule);
-	}
-
-	if (unlikely(list_empty(&ep->hep->urb_list))) {
-		DBG("empty %p queue?\n", ep);
-		return NULL;
-	}
-
-	urb = container_of(ep->hep->urb_list.next, struct urb, urb_list);
-	control = ep->defctrl;
-
-	/* if this frame doesn't have enough time left to transfer this
-	 * packet, wait till the next frame.  too-simple algorithm...
-	 */
-	fclock = sl811_read(sl811, SL11H_SOFTMRREG) << 6;
-	fclock -= 100;		/* setup takes not much time */
-	if (urb->dev->speed == USB_SPEED_LOW) {
-		if (control & SL11H_HCTLMASK_PREAMBLE) {
-			/* also note erratum 1: some hubs won't work */
-			fclock -= 800;
-		}
-		fclock -= ep->maxpacket << 8;
-
-		/* erratum 2: AFTERSOF only works for fullspeed */
-		if (fclock < 0) {
-			if (ep->period)
-				sl811->stat_overrun++;
-			sofirq_on(sl811);
-			return NULL;
-		}
-	} else {
-		fclock -= 12000 / 19;	/* 19 64byte packets/msec */
-		if (fclock < 0) {
-			if (ep->period)
-				sl811->stat_overrun++;
-			control |= SL11H_HCTLMASK_AFTERSOF;
-
-		/* throttle bulk/control irq noise */
-		} else if (ep->nak_count)
-			control |= SL11H_HCTLMASK_AFTERSOF;
-	}
-
-
-	switch (ep->nextpid) {
-	case USB_PID_IN:
-		in_packet(sl811, ep, urb, bank, control);
-		break;
-	case USB_PID_OUT:
-		out_packet(sl811, ep, urb, bank, control);
-		break;
-	case USB_PID_SETUP:
-		setup_packet(sl811, ep, urb, bank, control);
-		break;
-	case USB_PID_ACK:		/* for control status */
-		status_packet(sl811, ep, urb, bank, control);
-		break;
-	default:
-		DBG("bad ep%p pid %02x\n", ep, ep->nextpid);
-		ep = NULL;
-	}
-	return ep;
-}
-
-#define MIN_JIFFIES	((msecs_to_jiffies(2) > 1) ? msecs_to_jiffies(2) : 2)
-
-static inline void start_transfer(struct sl811 *sl811)
-{
-	if (sl811->port1 & (1 << USB_PORT_FEAT_SUSPEND))
-		return;
-	if (sl811->active_a == NULL) {
-		sl811->active_a = start(sl811, SL811_EP_A(SL811_HOST_BUF));
-		if (sl811->active_a != NULL)
-			sl811->jiffies_a = jiffies + MIN_JIFFIES;
-	}
-#ifdef USE_B
-	if (sl811->active_b == NULL) {
-		sl811->active_b = start(sl811, SL811_EP_B(SL811_HOST_BUF));
-		if (sl811->active_b != NULL)
-			sl811->jiffies_b = jiffies + MIN_JIFFIES;
-	}
-#endif
-}
-
-static void finish_request(
-	struct sl811		*sl811,
-	struct sl811h_ep	*ep,
-	struct urb		*urb,
-	int			status
-) __releases(sl811->lock) __acquires(sl811->lock)
-{
-	unsigned		i;
-
-	if (usb_pipecontrol(urb->pipe))
-		ep->nextpid = USB_PID_SETUP;
-
-	spin_lock(&urb->lock);
-	if (urb->status == -EINPROGRESS)
-		urb->status = status;
-	urb->hcpriv = NULL;
-	spin_unlock(&urb->lock);
-
-	spin_unlock(&sl811->lock);
-	usb_hcd_giveback_urb(sl811_to_hcd(sl811), urb);
-	spin_lock(&sl811->lock);
-
-	/* leave active endpoints in the schedule */
-	if (!list_empty(&ep->hep->urb_list))
-		return;
-
-	/* async deschedule? */
-	if (!list_empty(&ep->schedule)) {
-		list_del_init(&ep->schedule);
-		if (ep == sl811->next_async)
-			sl811->next_async = NULL;
-		return;
-	}
-
-	/* periodic deschedule */
-	DBG("deschedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);
-	for (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {
-		struct sl811h_ep	*temp;
-		struct sl811h_ep	**prev = &sl811->periodic[i];
-
-		while (*prev && ((temp = *prev) != ep))
-			prev = &temp->next;
-		if (*prev)
-			*prev = ep->next;
-		sl811->load[i] -= ep->load;
-	}
-	ep->branch = PERIODIC_SIZE;
-	sl811->periodic_count--;
-	sl811_to_hcd(sl811)->self.bandwidth_allocated
-		-= ep->load / ep->period;
-	if (ep == sl811->next_periodic)
-		sl811->next_periodic = ep->next;
-
-	/* we might turn SOFs back on again for the async schedule */
-	if (sl811->periodic_count == 0)
-		sofirq_off(sl811);
-}
-
-static void
-done(struct sl811 *sl811, struct sl811h_ep *ep, u8 bank)
-{
-	u8			status;
-	struct urb		*urb;
-	int			urbstat = -EINPROGRESS;
-
-	if (unlikely(!ep))
-		return;
-
-	status = sl811_read(sl811, bank + SL11H_PKTSTATREG);
-
-	urb = container_of(ep->hep->urb_list.next, struct urb, urb_list);
-
-	/* we can safely ignore NAKs */
-	if (status & SL11H_STATMASK_NAK) {
-		// PACKET("...NAK_%02x qh%p\n", bank, ep);
-		if (!ep->period)
-			ep->nak_count++;
-		ep->error_count = 0;
-
-	/* ACK advances transfer, toggle, and maybe queue */
-	} else if (status & SL11H_STATMASK_ACK) {
-		struct usb_device	*udev = urb->dev;
-		int			len;
-		unsigned char		*buf;
-
-		/* urb->iso_frame_desc is currently ignored here... */
-
-		ep->nak_count = ep->error_count = 0;
-		switch (ep->nextpid) {
-		case USB_PID_OUT:
-			// PACKET("...ACK/out_%02x qh%p\n", bank, ep);
-			urb->actual_length += ep->length;
-			usb_dotoggle(udev, ep->epnum, 1);
-			if (urb->actual_length
-					== urb->transfer_buffer_length) {
-				if (usb_pipecontrol(urb->pipe))
-					ep->nextpid = USB_PID_ACK;
-
-				/* some bulk protocols terminate OUT transfers
-				 * by a short packet, using ZLPs not padding.
-				 */
-				else if (ep->length < ep->maxpacket
-						|| !(urb->transfer_flags
-							& URB_ZERO_PACKET))
-					urbstat = 0;
-			}
-			break;
-		case USB_PID_IN:
-			// PACKET("...ACK/in_%02x qh%p\n", bank, ep);
-			buf = urb->transfer_buffer + urb->actual_length;
-			prefetchw(buf);
-			len = ep->maxpacket - sl811_read(sl811,
-						bank + SL11H_XFERCNTREG);
-			if (len > ep->length) {
-				len = ep->length;
-				urb->status = -EOVERFLOW;
-			}
-			urb->actual_length += len;
-			sl811_read_buf(sl811, SL811HS_PACKET_BUF(bank == 0),
-					buf, len);
-			usb_dotoggle(udev, ep->epnum, 0);
-			if (urb->actual_length == urb->transfer_buffer_length)
-				urbstat = 0;
-			else if (len < ep->maxpacket) {
-				if (urb->transfer_flags & URB_SHORT_NOT_OK)
-					urbstat = -EREMOTEIO;
-				else
-					urbstat = 0;
-			}
-			if (usb_pipecontrol(urb->pipe)
-					&& (urbstat == -EREMOTEIO
-						|| urbstat == 0)) {
-
-				/* NOTE if the status stage STALLs (why?),
-				 * this reports the wrong urb status.
-				 */
-				spin_lock(&urb->lock);
-				if (urb->status == -EINPROGRESS)
-					urb->status = urbstat;
-				spin_unlock(&urb->lock);
-
-				urb = NULL;
-				ep->nextpid = USB_PID_ACK;
-			}
-			break;
-		case USB_PID_SETUP:
-			// PACKET("...ACK/setup_%02x qh%p\n", bank, ep);
-			if (urb->transfer_buffer_length == urb->actual_length)
-				ep->nextpid = USB_PID_ACK;
-			else if (usb_pipeout(urb->pipe)) {
-				usb_settoggle(udev, 0, 1, 1);
-				ep->nextpid = USB_PID_OUT;
-			} else {
-				usb_settoggle(udev, 0, 0, 1);
-				ep->nextpid = USB_PID_IN;
-			}
-			break;
-		case USB_PID_ACK:
-			// PACKET("...ACK/status_%02x qh%p\n", bank, ep);
-			urbstat = 0;
-			break;
-		}
-
-	/* STALL stops all transfers */
-	} else if (status & SL11H_STATMASK_STALL) {
-		PACKET("...STALL_%02x qh%p\n", bank, ep);
-		ep->nak_count = ep->error_count = 0;
-		urbstat = -EPIPE;
-
-	/* error? retry, until "3 strikes" */
-	} else if (++ep->error_count >= 3) {
-		if (status & SL11H_STATMASK_TMOUT)
-			urbstat = -ETIME;
-		else if (status & SL11H_STATMASK_OVF)
-			urbstat = -EOVERFLOW;
-		else
-			urbstat = -EPROTO;
-		ep->error_count = 0;
-		PACKET("...3STRIKES_%02x %02x qh%p stat %d\n",
-				bank, status, ep, urbstat);
-	}
-
-	if (urb && (urbstat != -EINPROGRESS || urb->status != -EINPROGRESS))
-		finish_request(sl811, ep, urb, urbstat);
-}
-
-static inline u8 checkdone(struct sl811 *sl811)
-{
-	u8	ctl;
-	u8	irqstat = 0;
-
-	if (sl811->active_a && time_before_eq(sl811->jiffies_a, jiffies)) {
-		ctl = sl811_read(sl811, SL811_EP_A(SL11H_HOSTCTLREG));
-		if (ctl & SL11H_HCTLMASK_ARM)
-			sl811_write(sl811, SL811_EP_A(SL11H_HOSTCTLREG), 0);
-		DBG("%s DONE_A: ctrl %02x sts %02x\n",
-			(ctl & SL11H_HCTLMASK_ARM) ? "timeout" : "lost",
-			ctl,
-			sl811_read(sl811, SL811_EP_A(SL11H_PKTSTATREG)));
-		irqstat |= SL11H_INTMASK_DONE_A;
-	}
-#ifdef	USE_B
-	if (sl811->active_b && time_before_eq(sl811->jiffies_b, jiffies)) {
-		ctl = sl811_read(sl811, SL811_EP_B(SL11H_HOSTCTLREG));
-		if (ctl & SL11H_HCTLMASK_ARM)
-			sl811_write(sl811, SL811_EP_B(SL11H_HOSTCTLREG), 0);
-		DBG("%s DONE_B: ctrl %02x sts %02x\n",
-			(ctl & SL11H_HCTLMASK_ARM) ? "timeout" : "lost",
-			ctl,
-			sl811_read(sl811, SL811_EP_B(SL11H_PKTSTATREG)));
-		irqstat |= SL11H_INTMASK_DONE_A;
-	}
-#endif
-	return irqstat;
-}
-
-static irqreturn_t sl811h_irq(struct usb_hcd *hcd)
-{
-	struct sl811	*sl811 = hcd_to_sl811(hcd);
-	u8		irqstat;
-	irqreturn_t	ret = IRQ_NONE;
-	unsigned	retries = 5;
-
-	spin_lock(&sl811->lock);
-
-retry:
-	irqstat = sl811_read(sl811, SL11H_IRQ_STATUS) & ~SL11H_INTMASK_DP;
-	if (irqstat) {
-		sl811_write(sl811, SL11H_IRQ_STATUS, irqstat);
-		irqstat &= sl811->irq_enable;
-	}
-
-#ifdef	QUIRK2
-	/* this may no longer be necessary ... */
-	if (irqstat == 0) {
-		irqstat = checkdone(sl811);
-		if (irqstat)
-			sl811->stat_lost++;
-	}
-#endif
-
-	/* USB packets, not necessarily handled in the order they're
-	 * issued ... that's fine if they're different endpoints.
-	 */
-	if (irqstat & SL11H_INTMASK_DONE_A) {
-		done(sl811, sl811->active_a, SL811_EP_A(SL811_HOST_BUF));
-		sl811->active_a = NULL;
-		sl811->stat_a++;
-	}
-#ifdef USE_B
-	if (irqstat & SL11H_INTMASK_DONE_B) {
-		done(sl811, sl811->active_b, SL811_EP_B(SL811_HOST_BUF));
-		sl811->active_b = NULL;
-		sl811->stat_b++;
-	}
-#endif
-	if (irqstat & SL11H_INTMASK_SOFINTR) {
-		unsigned index;
-
-		index = sl811->frame++ % (PERIODIC_SIZE - 1);
-		sl811->stat_sof++;
-
-		/* be graceful about almost-inevitable periodic schedule
-		 * overruns:  continue the previous frame's transfers iff
-		 * this one has nothing scheduled.
-		 */
-		if (sl811->next_periodic) {
-			// ERR("overrun to slot %d\n", index);
-			sl811->stat_overrun++;
-		}
-		if (sl811->periodic[index])
-			sl811->next_periodic = sl811->periodic[index];
-	}
-
-	/* khubd manages debouncing and wakeup */
-	if (irqstat & SL11H_INTMASK_INSRMV) {
-		sl811->stat_insrmv++;
-
-		/* most stats are reset for each VBUS session */
-		sl811->stat_wake = 0;
-		sl811->stat_sof = 0;
-		sl811->stat_a = 0;
-		sl811->stat_b = 0;
-		sl811->stat_lost = 0;
-
-		sl811->ctrl1 = 0;
-		sl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);
-
-		sl811->irq_enable = SL11H_INTMASK_INSRMV;
-		sl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);
-
-		/* usbcore nukes other pending transactions on disconnect */
-		if (sl811->active_a) {
-			sl811_write(sl811, SL811_EP_A(SL11H_HOSTCTLREG), 0);
-			finish_request(sl811, sl811->active_a,
-				container_of(sl811->active_a
-						->hep->urb_list.next,
-					struct urb, urb_list),
-				-ESHUTDOWN);
-			sl811->active_a = NULL;
-		}
-#ifdef	USE_B
-		if (sl811->active_b) {
-			sl811_write(sl811, SL811_EP_B(SL11H_HOSTCTLREG), 0);
-			finish_request(sl811, sl811->active_b,
-				container_of(sl811->active_b
-						->hep->urb_list.next,
-					struct urb, urb_list),
-				NULL, -ESHUTDOWN);
-			sl811->active_b = NULL;
-		}
-#endif
-
-		/* port status seems weird until after reset, so
-		 * force the reset and make khubd clean up later.
-		 */
-		sl811->port1 |= (1 << USB_PORT_FEAT_C_CONNECTION)
-				| (1 << USB_PORT_FEAT_CONNECTION);
-
-	} else if (irqstat & SL11H_INTMASK_RD) {
-		if (sl811->port1 & (1 << USB_PORT_FEAT_SUSPEND)) {
-			DBG("wakeup\n");
-			sl811->port1 |= 1 << USB_PORT_FEAT_C_SUSPEND;
-			sl811->stat_wake++;
-		} else
-			irqstat &= ~SL11H_INTMASK_RD;
-	}
-
-	if (irqstat) {
-		if (sl811->port1 & (1 << USB_PORT_FEAT_ENABLE))
-			start_transfer(sl811);
-		ret = IRQ_HANDLED;
-		if (retries--)
-			goto retry;
-	}
-
-	if (sl811->periodic_count == 0 && list_empty(&sl811->async))
-		sofirq_off(sl811);
-	sl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);
-
-	spin_unlock(&sl811->lock);
-
-	return ret;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* usb 1.1 says max 90% of a frame is available for periodic transfers.
- * this driver doesn't promise that much since it's got to handle an
- * IRQ per packet; irq handling latencies also use up that time.
- *
- * NOTE:  the periodic schedule is a sparse tree, with the load for
- * each branch minimized.  see fig 3.5 in the OHCI spec for example.
- */
-#define	MAX_PERIODIC_LOAD	500	/* out of 1000 usec */
-
-static int balance(struct sl811 *sl811, u16 period, u16 load)
-{
-	int	i, branch = -ENOSPC;
-
-	/* search for the least loaded schedule branch of that period
-	 * which has enough bandwidth left unreserved.
-	 */
-	for (i = 0; i < period ; i++) {
-		if (branch < 0 || sl811->load[branch] > sl811->load[i]) {
-			int	j;
-
-			for (j = i; j < PERIODIC_SIZE; j += period) {
-				if ((sl811->load[j] + load)
-						> MAX_PERIODIC_LOAD)
-					break;
-			}
-			if (j < PERIODIC_SIZE)
-				continue;
-			branch = i;
-		}
-	}
-	return branch;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static int sl811h_urb_enqueue(
-	struct usb_hcd		*hcd,
-	struct usb_host_endpoint *hep,
-	struct urb		*urb,
-	gfp_t			mem_flags
-) {
-	struct sl811		*sl811 = hcd_to_sl811(hcd);
-	struct usb_device	*udev = urb->dev;
-	unsigned int		pipe = urb->pipe;
-	int			is_out = !usb_pipein(pipe);
-	int			type = usb_pipetype(pipe);
-	int			epnum = usb_pipeendpoint(pipe);
-	struct sl811h_ep	*ep = NULL;
-	unsigned long		flags;
-	int			i;
-	int			retval = 0;
-
-#ifdef	DISABLE_ISO
-	if (type == PIPE_ISOCHRONOUS)
-		return -ENOSPC;
-#endif
-
-	/* avoid all allocations within spinlocks */
-	if (!hep->hcpriv)
-		ep = kzalloc(sizeof *ep, mem_flags);
-
-	spin_lock_irqsave(&sl811->lock, flags);
-
-	/* don't submit to a dead or disabled port */
-	if (!(sl811->port1 & (1 << USB_PORT_FEAT_ENABLE))
-			|| !HC_IS_RUNNING(hcd->state)) {
-		retval = -ENODEV;
-		kfree(ep);
-		goto fail;
-	}
-
-	if (hep->hcpriv) {
-		kfree(ep);
-		ep = hep->hcpriv;
-	} else if (!ep) {
-		retval = -ENOMEM;
-		goto fail;
-
-	} else {
-		INIT_LIST_HEAD(&ep->schedule);
-		ep->udev = udev;
-		ep->epnum = epnum;
-		ep->maxpacket = usb_maxpacket(udev, urb->pipe, is_out);
-		ep->defctrl = SL11H_HCTLMASK_ARM | SL11H_HCTLMASK_ENABLE;
-		usb_settoggle(udev, epnum, is_out, 0);
-
-		if (type == PIPE_CONTROL)
-			ep->nextpid = USB_PID_SETUP;
-		else if (is_out)
-			ep->nextpid = USB_PID_OUT;
-		else
-			ep->nextpid = USB_PID_IN;
-
-		if (ep->maxpacket > H_MAXPACKET) {
-			/* iso packets up to 240 bytes could work... */
-			DBG("dev %d ep%d maxpacket %d\n",
-				udev->devnum, epnum, ep->maxpacket);
-			retval = -EINVAL;
-			goto fail;
-		}
-
-		if (udev->speed == USB_SPEED_LOW) {
-			/* send preamble for external hub? */
-			if (!(sl811->ctrl1 & SL11H_CTL1MASK_LSPD))
-				ep->defctrl |= SL11H_HCTLMASK_PREAMBLE;
-		}
-		switch (type) {
-		case PIPE_ISOCHRONOUS:
-		case PIPE_INTERRUPT:
-			if (urb->interval > PERIODIC_SIZE)
-				urb->interval = PERIODIC_SIZE;
-			ep->period = urb->interval;
-			ep->branch = PERIODIC_SIZE;
-			if (type == PIPE_ISOCHRONOUS)
-				ep->defctrl |= SL11H_HCTLMASK_ISOCH;
-			ep->load = usb_calc_bus_time(udev->speed, !is_out,
-				(type == PIPE_ISOCHRONOUS),
-				usb_maxpacket(udev, pipe, is_out))
-					/ 1000;
-			break;
-		}
-
-		ep->hep = hep;
-		hep->hcpriv = ep;
-	}
-
-	/* maybe put endpoint into schedule */
-	switch (type) {
-	case PIPE_CONTROL:
-	case PIPE_BULK:
-		if (list_empty(&ep->schedule))
-			list_add_tail(&ep->schedule, &sl811->async);
-		break;
-	case PIPE_ISOCHRONOUS:
-	case PIPE_INTERRUPT:
-		urb->interval = ep->period;
-		if (ep->branch < PERIODIC_SIZE) {
-			/* NOTE:  the phase is correct here, but the value
-			 * needs offsetting by the transfer queue depth.
-			 * All current drivers ignore start_frame, so this
-			 * is unlikely to ever matter...
-			 */
-			urb->start_frame = (sl811->frame & (PERIODIC_SIZE - 1))
-						+ ep->branch;
-			break;
-		}
-
-		retval = balance(sl811, ep->period, ep->load);
-		if (retval < 0)
-			goto fail;
-		ep->branch = retval;
-		retval = 0;
-		urb->start_frame = (sl811->frame & (PERIODIC_SIZE - 1))
-					+ ep->branch;
-
-		/* sort each schedule branch by period (slow before fast)
-		 * to share the faster parts of the tree without needing
-		 * dummy/placeholder nodes
-		 */
-		DBG("schedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);
-		for (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {
-			struct sl811h_ep	**prev = &sl811->periodic[i];
-			struct sl811h_ep	*here = *prev;
-
-			while (here && ep != here) {
-				if (ep->period > here->period)
-					break;
-				prev = &here->next;
-				here = *prev;
-			}
-			if (ep != here) {
-				ep->next = here;
-				*prev = ep;
-			}
-			sl811->load[i] += ep->load;
-		}
-		sl811->periodic_count++;
-		hcd->self.bandwidth_allocated += ep->load / ep->period;
-		sofirq_on(sl811);
-	}
-
-	/* in case of unlink-during-submit */
-	spin_lock(&urb->lock);
-	if (urb->status != -EINPROGRESS) {
-		spin_unlock(&urb->lock);
-		finish_request(sl811, ep, urb, 0);
-		retval = 0;
-		goto fail;
-	}
-	urb->hcpriv = hep;
-	spin_unlock(&urb->lock);
-
-	start_transfer(sl811);
-	sl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);
-fail:
-	spin_unlock_irqrestore(&sl811->lock, flags);
-	return retval;
-}
-
-static int sl811h_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
-{
-	struct sl811		*sl811 = hcd_to_sl811(hcd);
-	struct usb_host_endpoint *hep;
-	unsigned long		flags;
-	struct sl811h_ep	*ep;
-	int			retval = 0;
-
-	spin_lock_irqsave(&sl811->lock, flags);
-	hep = urb->hcpriv;
-	if (!hep)
-		goto fail;
-
-	ep = hep->hcpriv;
-	if (ep) {
-		/* finish right away if this urb can't be active ...
-		 * note that some drivers wrongly expect delays
-		 */
-		if (ep->hep->urb_list.next != &urb->urb_list) {
-			/* not front of queue?  never active */
-
-		/* for active transfers, we expect an IRQ */
-		} else if (sl811->active_a == ep) {
-			if (time_before_eq(sl811->jiffies_a, jiffies)) {
-				/* happens a lot with lowspeed?? */
-				DBG("giveup on DONE_A: ctrl %02x sts %02x\n",
-					sl811_read(sl811,
-						SL811_EP_A(SL11H_HOSTCTLREG)),
-					sl811_read(sl811,
-						SL811_EP_A(SL11H_PKTSTATREG)));
-				sl811_write(sl811, SL811_EP_A(SL11H_HOSTCTLREG),
-						0);
-				sl811->active_a = NULL;
-			} else
-				urb = NULL;
-#ifdef	USE_B
-		} else if (sl811->active_b == ep) {
-			if (time_before_eq(sl811->jiffies_a, jiffies)) {
-				/* happens a lot with lowspeed?? */
-				DBG("giveup on DONE_B: ctrl %02x sts %02x\n",
-					sl811_read(sl811,
-						SL811_EP_B(SL11H_HOSTCTLREG)),
-					sl811_read(sl811,
-						SL811_EP_B(SL11H_PKTSTATREG)));
-				sl811_write(sl811, SL811_EP_B(SL11H_HOSTCTLREG),
-						0);
-				sl811->active_b = NULL;
-			} else
-				urb = NULL;
-#endif
-		} else {
-			/* front of queue for inactive endpoint */
-		}
-
-		if (urb)
-			finish_request(sl811, ep, urb, 0);
-		else
-			VDBG("dequeue, urb %p active %s; wait4irq\n", urb,
-				(sl811->active_a == ep) ? "A" : "B");
-	} else
-fail:
-		retval = -EINVAL;
-	spin_unlock_irqrestore(&sl811->lock, flags);
-	return retval;
-}
-
-static void
-sl811h_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *hep)
-{
-	struct sl811h_ep	*ep = hep->hcpriv;
-
-	if (!ep)
-		return;
-
-	/* assume we'd just wait for the irq */
-	if (!list_empty(&hep->urb_list))
-		msleep(3);
-	if (!list_empty(&hep->urb_list))
-		WARN("ep %p not empty?\n", ep);
-
-	kfree(ep);
-	hep->hcpriv = NULL;
-}
-
-static int
-sl811h_get_frame(struct usb_hcd *hcd)
-{
-	struct sl811 *sl811 = hcd_to_sl811(hcd);
-
-	/* wrong except while periodic transfers are scheduled;
-	 * never matches the on-the-wire frame;
-	 * subject to overruns.
-	 */
-	return sl811->frame;
-}
-
-
-/*-------------------------------------------------------------------------*/
-
-/* the virtual root hub timer IRQ checks for hub status */
-static int
-sl811h_hub_status_data(struct usb_hcd *hcd, char *buf)
-{
-	struct sl811 *sl811 = hcd_to_sl811(hcd);
-#ifdef	QUIRK3
-	unsigned long flags;
-
-	/* non-SMP HACK: use root hub timer as i/o watchdog
-	 * this seems essential when SOF IRQs aren't in use...
-	 */
-	local_irq_save(flags);
-	if (!timer_pending(&sl811->timer)) {
-		if (sl811h_irq( /* ~0, */ hcd) != IRQ_NONE)
-			sl811->stat_lost++;
-	}
-	local_irq_restore(flags);
-#endif
-
-	if (!(sl811->port1 & (0xffff << 16)))
-		return 0;
-
-	/* tell khubd port 1 changed */
-	*buf = (1 << 1);
-	return 1;
-}
-
-static void
-sl811h_hub_descriptor (
-	struct sl811			*sl811,
-	struct usb_hub_descriptor	*desc
-) {
-	u16		temp = 0;
-
-	desc->bDescriptorType = 0x29;
-	desc->bHubContrCurrent = 0;
-
-	desc->bNbrPorts = 1;
-	desc->bDescLength = 9;
-
-	/* per-port power switching (gang of one!), or none */
-	desc->bPwrOn2PwrGood = 0;
-	if (sl811->board && sl811->board->port_power) {
-		desc->bPwrOn2PwrGood = sl811->board->potpg;
-		if (!desc->bPwrOn2PwrGood)
-			desc->bPwrOn2PwrGood = 10;
-		temp = 0x0001;
-	} else
-		temp = 0x0002;
-
-	/* no overcurrent errors detection/handling */
-	temp |= 0x0010;
-
-	desc->wHubCharacteristics = (__force __u16)cpu_to_le16(temp);
-
-	/* two bitmaps:  ports removable, and legacy PortPwrCtrlMask */
-	desc->bitmap[0] = 0 << 1;
-	desc->bitmap[1] = ~0;
-}
-
-static void
-sl811h_timer(unsigned long _sl811)
-{
-	struct sl811 	*sl811 = (void *) _sl811;
-	unsigned long	flags;
-	u8		irqstat;
-	u8		signaling = sl811->ctrl1 & SL11H_CTL1MASK_FORCE;
-	const u32	mask = (1 << USB_PORT_FEAT_CONNECTION)
-				| (1 << USB_PORT_FEAT_ENABLE)
-				| (1 << USB_PORT_FEAT_LOWSPEED);
-
-	spin_lock_irqsave(&sl811->lock, flags);
-
-	/* stop special signaling */
-	sl811->ctrl1 &= ~SL11H_CTL1MASK_FORCE;
-	sl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);
-	udelay(3);
-
-	irqstat = sl811_read(sl811, SL11H_IRQ_STATUS);
-
-	switch (signaling) {
-	case SL11H_CTL1MASK_SE0:
-		DBG("end reset\n");
-		sl811->port1 = (1 << USB_PORT_FEAT_C_RESET)
-				| (1 << USB_PORT_FEAT_POWER);
-		sl811->ctrl1 = 0;
-		/* don't wrongly ack RD */
-		if (irqstat & SL11H_INTMASK_INSRMV)
-			irqstat &= ~SL11H_INTMASK_RD;
-		break;
-	case SL11H_CTL1MASK_K:
-		DBG("end resume\n");
-		sl811->port1 &= ~(1 << USB_PORT_FEAT_SUSPEND);
-		break;
-	default:
-		DBG("odd timer signaling: %02x\n", signaling);
-		break;
-	}
-	sl811_write(sl811, SL11H_IRQ_STATUS, irqstat);
-
-	if (irqstat & SL11H_INTMASK_RD) {
-		/* usbcore nukes all pending transactions on disconnect */
-		if (sl811->port1 & (1 << USB_PORT_FEAT_CONNECTION))
-			sl811->port1 |= (1 << USB_PORT_FEAT_C_CONNECTION)
-					| (1 << USB_PORT_FEAT_C_ENABLE);
-		sl811->port1 &= ~mask;
-		sl811->irq_enable = SL11H_INTMASK_INSRMV;
-	} else {
-		sl811->port1 |= mask;
-		if (irqstat & SL11H_INTMASK_DP)
-			sl811->port1 &= ~(1 << USB_PORT_FEAT_LOWSPEED);
-		sl811->irq_enable = SL11H_INTMASK_INSRMV | SL11H_INTMASK_RD;
-	}
-
-	if (sl811->port1 & (1 << USB_PORT_FEAT_CONNECTION)) {
-		u8	ctrl2 = SL811HS_CTL2_INIT;
-
-		sl811->irq_enable |= SL11H_INTMASK_DONE_A;
-#ifdef USE_B
-		sl811->irq_enable |= SL11H_INTMASK_DONE_B;
-#endif
-		if (sl811->port1 & (1 << USB_PORT_FEAT_LOWSPEED)) {
-			sl811->ctrl1 |= SL11H_CTL1MASK_LSPD;
-			ctrl2 |= SL811HS_CTL2MASK_DSWAP;
-		}
-
-		/* start SOFs flowing, kickstarting with A registers */
-		sl811->ctrl1 |= SL11H_CTL1MASK_SOF_ENA;
-		sl811_write(sl811, SL11H_SOFLOWREG, 0xe0);
-		sl811_write(sl811, SL811HS_CTLREG2, ctrl2);
-
-		/* autoincrementing */
-		sl811_write(sl811, SL811_EP_A(SL11H_BUFLNTHREG), 0);
-		writeb(SL_SOF, sl811->data_reg);
-		writeb(0, sl811->data_reg);
-		sl811_write(sl811, SL811_EP_A(SL11H_HOSTCTLREG),
-				SL11H_HCTLMASK_ARM);
-
-		/* khubd provides debounce delay */
-	} else {
-		sl811->ctrl1 = 0;
-	}
-	sl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);
-
-	/* reenable irqs */
-	sl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);
-	spin_unlock_irqrestore(&sl811->lock, flags);
-}
-
-static int
-sl811h_hub_control(
-	struct usb_hcd	*hcd,
-	u16		typeReq,
-	u16		wValue,
-	u16		wIndex,
-	char		*buf,
-	u16		wLength
-) {
-	struct sl811	*sl811 = hcd_to_sl811(hcd);
-	int		retval = 0;
-	unsigned long	flags;
-
-	spin_lock_irqsave(&sl811->lock, flags);
-
-	switch (typeReq) {
-	case ClearHubFeature:
-	case SetHubFeature:
-		switch (wValue) {
-		case C_HUB_OVER_CURRENT:
-		case C_HUB_LOCAL_POWER:
-			break;
-		default:
-			goto error;
-		}
-		break;
-	case ClearPortFeature:
-		if (wIndex != 1 || wLength != 0)
-			goto error;
-
-		switch (wValue) {
-		case USB_PORT_FEAT_ENABLE:
-			sl811->port1 &= (1 << USB_PORT_FEAT_POWER);
-			sl811->ctrl1 = 0;
-			sl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);
-			sl811->irq_enable = SL11H_INTMASK_INSRMV;
-			sl811_write(sl811, SL11H_IRQ_ENABLE,
-						sl811->irq_enable);
-			break;
-		case USB_PORT_FEAT_SUSPEND:
-			if (!(sl811->port1 & (1 << USB_PORT_FEAT_SUSPEND)))
-				break;
-
-			/* 20 msec of resume/K signaling, other irqs blocked */
-			DBG("start resume...\n");
-			sl811->irq_enable = 0;
-			sl811_write(sl811, SL11H_IRQ_ENABLE,
-						sl811->irq_enable);
-			sl811->ctrl1 |= SL11H_CTL1MASK_K;
-			sl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);
-
-			mod_timer(&sl811->timer, jiffies
-					+ msecs_to_jiffies(20));
-			break;
-		case USB_PORT_FEAT_POWER:
-			port_power(sl811, 0);
-			break;
-		case USB_PORT_FEAT_C_ENABLE:
-		case USB_PORT_FEAT_C_SUSPEND:
-		case USB_PORT_FEAT_C_CONNECTION:
-		case USB_PORT_FEAT_C_OVER_CURRENT:
-		case USB_PORT_FEAT_C_RESET:
-			break;
-		default:
-			goto error;
-		}
-		sl811->port1 &= ~(1 << wValue);
-		break;
-	case GetHubDescriptor:
-		sl811h_hub_descriptor(sl811, (struct usb_hub_descriptor *) buf);
-		break;
-	case GetHubStatus:
-		*(__le32 *) buf = cpu_to_le32(0);
-		break;
-	case GetPortStatus:
-		if (wIndex != 1)
-			goto error;
-		*(__le32 *) buf = cpu_to_le32(sl811->port1);
-
-#ifndef	VERBOSE
-	if (*(u16*)(buf+2))	/* only if wPortChange is interesting */
-#endif
-		DBG("GetPortStatus %08x\n", sl811->port1);
-		break;
-	case SetPortFeature:
-		if (wIndex != 1 || wLength != 0)
-			goto error;
-		switch (wValue) {
-		case USB_PORT_FEAT_SUSPEND:
-			if (sl811->port1 & (1 << USB_PORT_FEAT_RESET))
-				goto error;
-			if (!(sl811->port1 & (1 << USB_PORT_FEAT_ENABLE)))
-				goto error;
-
-			DBG("suspend...\n");
-			sl811->ctrl1 &= ~SL11H_CTL1MASK_SOF_ENA;
-			sl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);
-			break;
-		case USB_PORT_FEAT_POWER:
-			port_power(sl811, 1);
-			break;
-		case USB_PORT_FEAT_RESET:
-			if (sl811->port1 & (1 << USB_PORT_FEAT_SUSPEND))
-				goto error;
-			if (!(sl811->port1 & (1 << USB_PORT_FEAT_POWER)))
-				break;
-
-			/* 50 msec of reset/SE0 signaling, irqs blocked */
-			sl811->irq_enable = 0;
-			sl811_write(sl811, SL11H_IRQ_ENABLE,
-						sl811->irq_enable);
-			sl811->ctrl1 = SL11H_CTL1MASK_SE0;
-			sl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);
-			sl811->port1 |= (1 << USB_PORT_FEAT_RESET);
-			mod_timer(&sl811->timer, jiffies
-					+ msecs_to_jiffies(50));
-			break;
-		default:
-			goto error;
-		}
-		sl811->port1 |= 1 << wValue;
-		break;
-
-	default:
-error:
-		/* "protocol stall" on error */
-		retval = -EPIPE;
-	}
-
-	spin_unlock_irqrestore(&sl811->lock, flags);
-	return retval;
-}
-
-#ifdef	CONFIG_PM
-
-static int
-sl811h_bus_suspend(struct usb_hcd *hcd)
-{
-	// SOFs off
-	DBG("%s\n", __FUNCTION__);
-	return 0;
-}
-
-static int
-sl811h_bus_resume(struct usb_hcd *hcd)
-{
-	// SOFs on
-	DBG("%s\n", __FUNCTION__);
-	return 0;
-}
-
-#else
-
-#define	sl811h_bus_suspend	NULL
-#define	sl811h_bus_resume	NULL
-
-#endif
-
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef STUB_DEBUG_FILE
-
-static inline void create_debug_file(struct sl811 *sl811) { }
-static inline void remove_debug_file(struct sl811 *sl811) { }
-
-#else
-
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-
-static void dump_irq(struct seq_file *s, char *label, u8 mask)
-{
-	seq_printf(s, "%s %02x%s%s%s%s%s%s\n", label, mask,
-		(mask & SL11H_INTMASK_DONE_A) ? " done_a" : "",
-		(mask & SL11H_INTMASK_DONE_B) ? " done_b" : "",
-		(mask & SL11H_INTMASK_SOFINTR) ? " sof" : "",
-		(mask & SL11H_INTMASK_INSRMV) ? " ins/rmv" : "",
-		(mask & SL11H_INTMASK_RD) ? " rd" : "",
-		(mask & SL11H_INTMASK_DP) ? " dp" : "");
-}
-
-static int proc_sl811h_show(struct seq_file *s, void *unused)
-{
-	struct sl811		*sl811 = s->private;
-	struct sl811h_ep	*ep;
-	unsigned		i;
-
-	seq_printf(s, "%s\n%s version %s\nportstatus[1] = %08x\n",
-		sl811_to_hcd(sl811)->product_desc,
-		hcd_name, DRIVER_VERSION,
-		sl811->port1);
-
-	seq_printf(s, "insert/remove: %ld\n", sl811->stat_insrmv);
-	seq_printf(s, "current session:  done_a %ld done_b %ld "
-			"wake %ld sof %ld overrun %ld lost %ld\n\n",
-		sl811->stat_a, sl811->stat_b,
-		sl811->stat_wake, sl811->stat_sof,
-		sl811->stat_overrun, sl811->stat_lost);
-
-	spin_lock_irq(&sl811->lock);
-
-	if (sl811->ctrl1 & SL11H_CTL1MASK_SUSPEND)
-		seq_printf(s, "(suspended)\n\n");
-	else {
-		u8	t = sl811_read(sl811, SL11H_CTLREG1);
-
-		seq_printf(s, "ctrl1 %02x%s%s%s%s\n", t,
-			(t & SL11H_CTL1MASK_SOF_ENA) ? " sofgen" : "",
-			({char *s; switch (t & SL11H_CTL1MASK_FORCE) {
-			case SL11H_CTL1MASK_NORMAL: s = ""; break;
-			case SL11H_CTL1MASK_SE0: s = " se0/reset"; break;
-			case SL11H_CTL1MASK_K: s = " k/resume"; break;
-			default: s = "j"; break;
-			}; s; }),
-			(t & SL11H_CTL1MASK_LSPD) ? " lowspeed" : "",
-			(t & SL11H_CTL1MASK_SUSPEND) ? " suspend" : "");
-
-		dump_irq(s, "irq_enable",
-				sl811_read(sl811, SL11H_IRQ_ENABLE));
-		dump_irq(s, "irq_status",
-				sl811_read(sl811, SL11H_IRQ_STATUS));
-		seq_printf(s, "frame clocks remaining:  %d\n",
-				sl811_read(sl811, SL11H_SOFTMRREG) << 6);
-	}
-
-	seq_printf(s, "A: qh%p ctl %02x sts %02x\n", sl811->active_a,
-		sl811_read(sl811, SL811_EP_A(SL11H_HOSTCTLREG)),
-		sl811_read(sl811, SL811_EP_A(SL11H_PKTSTATREG)));
-	seq_printf(s, "B: qh%p ctl %02x sts %02x\n", sl811->active_b,
-		sl811_read(sl811, SL811_EP_B(SL11H_HOSTCTLREG)),
-		sl811_read(sl811, SL811_EP_B(SL11H_PKTSTATREG)));
-	seq_printf(s, "\n");
-	list_for_each_entry (ep, &sl811->async, schedule) {
-		struct urb		*urb;
-
-		seq_printf(s, "%s%sqh%p, ep%d%s, maxpacket %d"
-					" nak %d err %d\n",
-			(ep == sl811->active_a) ? "(A) " : "",
-			(ep == sl811->active_b) ? "(B) " : "",
-			ep, ep->epnum,
-			({ char *s; switch (ep->nextpid) {
-			case USB_PID_IN: s = "in"; break;
-			case USB_PID_OUT: s = "out"; break;
-			case USB_PID_SETUP: s = "setup"; break;
-			case USB_PID_ACK: s = "status"; break;
-			default: s = "?"; break;
-			}; s;}),
-			ep->maxpacket,
-			ep->nak_count, ep->error_count);
-		list_for_each_entry (urb, &ep->hep->urb_list, urb_list) {
-			seq_printf(s, "  urb%p, %d/%d\n", urb,
-				urb->actual_length,
-				urb->transfer_buffer_length);
-		}
-	}
-	if (!list_empty(&sl811->async))
-		seq_printf(s, "\n");
-
-	seq_printf(s, "periodic size= %d\n", PERIODIC_SIZE);
-
-	for (i = 0; i < PERIODIC_SIZE; i++) {
-		ep = sl811->periodic[i];
-		if (!ep)
-			continue;
-		seq_printf(s, "%2d [%3d]:\n", i, sl811->load[i]);
-
-		/* DUMB: prints shared entries multiple times */
-		do {
-			seq_printf(s,
-				"   %s%sqh%d/%p (%sdev%d ep%d%s max %d) "
-					"err %d\n",
-				(ep == sl811->active_a) ? "(A) " : "",
-				(ep == sl811->active_b) ? "(B) " : "",
-				ep->period, ep,
-				(ep->udev->speed == USB_SPEED_FULL)
-					? "" : "ls ",
-				ep->udev->devnum, ep->epnum,
-				(ep->epnum == 0) ? ""
-					: ((ep->nextpid == USB_PID_IN)
-						? "in"
-						: "out"),
-				ep->maxpacket, ep->error_count);
-			ep = ep->next;
-		} while (ep);
-	}
-
-	spin_unlock_irq(&sl811->lock);
-	seq_printf(s, "\n");
-
-	return 0;
-}
-
-static int proc_sl811h_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, proc_sl811h_show, PDE(inode)->data);
-}
-
-static const struct file_operations proc_ops = {
-	.open		= proc_sl811h_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-/* expect just one sl811 per system */
-static const char proc_filename[] = "driver/sl811h";
-
-static void create_debug_file(struct sl811 *sl811)
-{
-	struct proc_dir_entry *pde;
-
-	pde = create_proc_entry(proc_filename, 0, NULL);
-	if (pde == NULL)
-		return;
-
-	pde->proc_fops = &proc_ops;
-	pde->data = sl811;
-	sl811->pde = pde;
-}
-
-static void remove_debug_file(struct sl811 *sl811)
-{
-	if (sl811->pde)
-		remove_proc_entry(proc_filename, NULL);
-}
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-static void
-sl811h_stop(struct usb_hcd *hcd)
-{
-	struct sl811	*sl811 = hcd_to_sl811(hcd);
-	unsigned long	flags;
-
-	del_timer_sync(&hcd->rh_timer);
-
-	spin_lock_irqsave(&sl811->lock, flags);
-	port_power(sl811, 0);
-	spin_unlock_irqrestore(&sl811->lock, flags);
-}
-
-static int
-sl811h_start(struct usb_hcd *hcd)
-{
-	struct sl811		*sl811 = hcd_to_sl811(hcd);
-
-	/* chip has been reset, VBUS power is off */
-	hcd->state = HC_STATE_RUNNING;
-
-	if (sl811->board) {
-		if (!device_can_wakeup(hcd->self.controller))
-			device_init_wakeup(hcd->self.controller,
-				sl811->board->can_wakeup);
-		hcd->power_budget = sl811->board->power * 2;
-	}
-
-	/* enable power and interupts */
-	port_power(sl811, 1);
-
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static struct hc_driver sl811h_hc_driver = {
-	.description =		hcd_name,
-	.hcd_priv_size =	sizeof(struct sl811),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq =			sl811h_irq,
-	.flags =		HCD_USB11 | HCD_MEMORY,
-
-	/* Basic lifecycle operations */
-	.start =		sl811h_start,
-	.stop =			sl811h_stop,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue =		sl811h_urb_enqueue,
-	.urb_dequeue =		sl811h_urb_dequeue,
-	.endpoint_disable =	sl811h_endpoint_disable,
-
-	/*
-	 * periodic schedule support
-	 */
-	.get_frame_number =	sl811h_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data =	sl811h_hub_status_data,
-	.hub_control =		sl811h_hub_control,
-	.bus_suspend =		sl811h_bus_suspend,
-	.bus_resume =		sl811h_bus_resume,
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int __devexit
-sl811h_remove(struct platform_device *dev)
-{
-	struct usb_hcd		*hcd = platform_get_drvdata(dev);
-	struct sl811		*sl811 = hcd_to_sl811(hcd);
-	struct resource		*res;
-
-	remove_debug_file(sl811);
-	usb_remove_hcd(hcd);
-
-	/* some platforms may use IORESOURCE_IO */
-	res = platform_get_resource(dev, IORESOURCE_MEM, 1);
-	if (res)
-		iounmap(sl811->data_reg);
-
-	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
-	if (res)
-		iounmap(sl811->addr_reg);
-
-	usb_put_hcd(hcd);
-	return 0;
-}
-
-static int __devinit
-sl811h_probe(struct platform_device *dev)
-{
-	struct usb_hcd		*hcd;
-	struct sl811		*sl811;
-	struct resource		*addr, *data;
-	int			irq;
-	void __iomem		*addr_reg;
-	void __iomem		*data_reg;
-	int			retval;
-	u8			tmp, ioaddr = 0;
-
-	/* basic sanity checks first.  board-specific init logic should
-	 * have initialized these three resources and probably board
-	 * specific platform_data.  we don't probe for IRQs, and do only
-	 * minimal sanity checking.
-	 */
-	irq = platform_get_irq(dev, 0);
-	if (dev->num_resources < 3 || irq < 0)
-		return -ENODEV;
-
-	/* refuse to confuse usbcore */
-	if (dev->dev.dma_mask) {
-		DBG("no we won't dma\n");
-		return -EINVAL;
-	}
-
-	/* the chip may be wired for either kind of addressing */
-	addr = platform_get_resource(dev, IORESOURCE_MEM, 0);
-	data = platform_get_resource(dev, IORESOURCE_MEM, 1);
-	retval = -EBUSY;
-	if (!addr || !data) {
-		addr = platform_get_resource(dev, IORESOURCE_IO, 0);
-		data = platform_get_resource(dev, IORESOURCE_IO, 1);
-		if (!addr || !data)
-			return -ENODEV;
-		ioaddr = 1;
-		/*
-		 * NOTE: 64-bit resource->start is getting truncated
-		 * to avoid compiler warning, assuming that ->start
-		 * is always 32-bit for this case
-		 */
-		addr_reg = (void __iomem *) (unsigned long) addr->start;
-		data_reg = (void __iomem *) (unsigned long) data->start;
-	} else {
-		addr_reg = ioremap(addr->start, 1);
-		if (addr_reg == NULL) {
-			retval = -ENOMEM;
-			goto err2;
-		}
-
-		data_reg = ioremap(data->start, 1);
-		if (data_reg == NULL) {
-			retval = -ENOMEM;
-			goto err4;
-		}
-	}
-
-	/* allocate and initialize hcd */
-	hcd = usb_create_hcd(&sl811h_hc_driver, &dev->dev, dev->dev.bus_id);
-	if (!hcd) {
-		retval = -ENOMEM;
-		goto err5;
-	}
-	hcd->rsrc_start = addr->start;
-	sl811 = hcd_to_sl811(hcd);
-
-	spin_lock_init(&sl811->lock);
-	INIT_LIST_HEAD(&sl811->async);
-	sl811->board = dev->dev.platform_data;
-	init_timer(&sl811->timer);
-	sl811->timer.function = sl811h_timer;
-	sl811->timer.data = (unsigned long) sl811;
-	sl811->addr_reg = addr_reg;
-	sl811->data_reg = data_reg;
-
-	spin_lock_irq(&sl811->lock);
-	port_power(sl811, 0);
-	spin_unlock_irq(&sl811->lock);
-	msleep(200);
-
-	tmp = sl811_read(sl811, SL11H_HWREVREG);
-	switch (tmp >> 4) {
-	case 1:
-		hcd->product_desc = "SL811HS v1.2";
-		break;
-	case 2:
-		hcd->product_desc = "SL811HS v1.5";
-		break;
-	default:
-		/* reject case 0, SL11S is less functional */
-		DBG("chiprev %02x\n", tmp);
-		retval = -ENXIO;
-		goto err6;
-	}
-
-	/* The chip's IRQ is level triggered, active high.  A requirement
-	 * for platform device setup is to cope with things like signal
-	 * inverters (e.g. CF is active low) or working only with edge
-	 * triggers (e.g. most ARM CPUs).  Initial driver stress testing
-	 * was on a system with single edge triggering, so most sorts of
-	 * triggering arrangement should work.
-	 */
-	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
-	if (retval != 0)
-		goto err6;
-
-	create_debug_file(sl811);
-	return retval;
-
- err6:
-	usb_put_hcd(hcd);
- err5:
-	if (!ioaddr)
-		iounmap(data_reg);
- err4:
-	if (!ioaddr)
-		iounmap(addr_reg);
- err2:
-	DBG("init error, %d\n", retval);
-	return retval;
-}
-
-#ifdef	CONFIG_PM
-
-/* for this device there's no useful distinction between the controller
- * and its root hub, except that the root hub only gets direct PM calls
- * when CONFIG_USB_SUSPEND is enabled.
- */
-
-static int
-sl811h_suspend(struct platform_device *dev, pm_message_t state)
-{
-	struct usb_hcd	*hcd = platform_get_drvdata(dev);
-	struct sl811	*sl811 = hcd_to_sl811(hcd);
-	int		retval = 0;
-
-	switch (state.event) {
-	case PM_EVENT_FREEZE:
-		retval = sl811h_bus_suspend(hcd);
-		break;
-	case PM_EVENT_SUSPEND:
-	case PM_EVENT_PRETHAW:		/* explicitly discard hw state */
-		port_power(sl811, 0);
-		break;
-	}
-	if (retval == 0)
-		dev->dev.power.power_state = state;
-	return retval;
-}
-
-static int
-sl811h_resume(struct platform_device *dev)
-{
-	struct usb_hcd	*hcd = platform_get_drvdata(dev);
-	struct sl811	*sl811 = hcd_to_sl811(hcd);
-
-	/* with no "check to see if VBUS is still powered" board hook,
-	 * let's assume it'd only be powered to enable remote wakeup.
-	 */
-	if (dev->dev.power.power_state.event == PM_EVENT_SUSPEND
-			|| !device_can_wakeup(&hcd->self.root_hub->dev)) {
-		sl811->port1 = 0;
-		port_power(sl811, 1);
-		usb_root_hub_lost_power(hcd->self.root_hub);
-		return 0;
-	}
-
-	dev->dev.power.power_state = PMSG_ON;
-	return sl811h_bus_resume(hcd);
-}
-
-#else
-
-#define	sl811h_suspend	NULL
-#define	sl811h_resume	NULL
-
-#endif
-
-
-/* this driver is exported so sl811_cs can depend on it */
-struct platform_driver sl811h_driver = {
-	.probe =	sl811h_probe,
-	.remove =	__devexit_p(sl811h_remove),
-
-	.suspend =	sl811h_suspend,
-	.resume =	sl811h_resume,
-	.driver = {
-		.name =	(char *) hcd_name,
-		.owner = THIS_MODULE,
-	},
-};
-EXPORT_SYMBOL(sl811h_driver);
-
-/*-------------------------------------------------------------------------*/
-
-static int __init sl811h_init(void)
-{
-	if (usb_disabled())
-		return -ENODEV;
-
-	INFO("driver %s, %s\n", hcd_name, DRIVER_VERSION);
-	return platform_driver_register(&sl811h_driver);
-}
-module_init(sl811h_init);
-
-static void __exit sl811h_cleanup(void)
-{
-	platform_driver_unregister(&sl811h_driver);
-}
-module_exit(sl811h_cleanup);
diff -urN host/.svn/text-base/sl811.h.svn-base host.new/.svn/text-base/sl811.h.svn-base
--- host/.svn/text-base/sl811.h.svn-base	2009-02-24 19:00:15.943942806 +0100
+++ host.new/.svn/text-base/sl811.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,266 +0,0 @@
-/*
- * SL811HS register declarations and HCD data structures
- *
- * Copyright (C) 2004 Psion Teklogix
- * Copyright (C) 2004 David Brownell
- * Copyright (C) 2001 Cypress Semiconductor Inc. 
- */
-
-/*
- * SL811HS has transfer registers, and control registers.  In host/master
- * mode one set of registers is used; in peripheral/slave mode, another.
- *  - SL11H only has some "A" transfer registers from 0x00-0x04
- *  - SL811HS also has "B" registers from 0x08-0x0c
- *  - SL811S (or HS in slave mode) has four A+B sets, at 00, 10, 20, 30
- */
-
-#define SL811_EP_A(base)	((base) + 0)
-#define SL811_EP_B(base)	((base) + 8)
-
-#define SL811_HOST_BUF		0x00
-#define SL811_PERIPH_EP0	0x00
-#define SL811_PERIPH_EP1	0x10
-#define SL811_PERIPH_EP2	0x20
-#define SL811_PERIPH_EP3	0x30
-
-
-/* TRANSFER REGISTERS:  host and peripheral sides are similar
- * except for the control models (master vs slave).
- */
-#define SL11H_HOSTCTLREG	0
-#	define SL11H_HCTLMASK_ARM	0x01
-#	define SL11H_HCTLMASK_ENABLE	0x02
-#	define SL11H_HCTLMASK_IN	0x00
-#	define SL11H_HCTLMASK_OUT	0x04
-#	define SL11H_HCTLMASK_ISOCH	0x10
-#	define SL11H_HCTLMASK_AFTERSOF	0x20
-#	define SL11H_HCTLMASK_TOGGLE	0x40
-#	define SL11H_HCTLMASK_PREAMBLE	0x80
-#define SL11H_BUFADDRREG	1
-#define SL11H_BUFLNTHREG	2
-#define SL11H_PKTSTATREG	3	/* read */
-#	define SL11H_STATMASK_ACK	0x01
-#	define SL11H_STATMASK_ERROR	0x02
-#	define SL11H_STATMASK_TMOUT	0x04
-#	define SL11H_STATMASK_SEQ	0x08
-#	define SL11H_STATMASK_SETUP	0x10
-#	define SL11H_STATMASK_OVF	0x20
-#	define SL11H_STATMASK_NAK	0x40
-#	define SL11H_STATMASK_STALL	0x80
-#define SL11H_PIDEPREG		3	/* write */
-#	define	SL_SETUP	0xd0
-#	define	SL_IN		0x90
-#	define	SL_OUT		0x10
-#	define	SL_SOF		0x50
-#	define	SL_PREAMBLE	0xc0
-#	define	SL_NAK		0xa0
-#	define	SL_STALL	0xe0
-#	define	SL_DATA0	0x30
-#	define	SL_DATA1	0xb0
-#define SL11H_XFERCNTREG	4	/* read */
-#define SL11H_DEVADDRREG	4	/* write */
-
-
-/* CONTROL REGISTERS:  host and peripheral are very different.
- */
-#define SL11H_CTLREG1		5
-#	define SL11H_CTL1MASK_SOF_ENA	0x01
-#	define SL11H_CTL1MASK_FORCE	0x18
-#		define SL11H_CTL1MASK_NORMAL	0x00
-#		define SL11H_CTL1MASK_SE0	0x08	/* reset */
-#		define SL11H_CTL1MASK_J		0x10
-#		define SL11H_CTL1MASK_K		0x18	/* resume */
-#	define SL11H_CTL1MASK_LSPD	0x20
-#	define SL11H_CTL1MASK_SUSPEND	0x40
-#define SL11H_IRQ_ENABLE	6
-#	define SL11H_INTMASK_DONE_A	0x01
-#	define SL11H_INTMASK_DONE_B	0x02
-#	define SL11H_INTMASK_SOFINTR	0x10
-#	define SL11H_INTMASK_INSRMV	0x20	/* to/from SE0 */
-#	define SL11H_INTMASK_RD		0x40
-#	define SL11H_INTMASK_DP		0x80	/* only in INTSTATREG */
-#define SL11S_ADDRESS		7
-
-/* 0x08-0x0c are for the B buffer (not in SL11) */
-
-#define SL11H_IRQ_STATUS	0x0D	/* write to ack */
-#define SL11H_HWREVREG		0x0E	/* read */
-#	define SL11H_HWRMASK_HWREV	0xF0
-#define SL11H_SOFLOWREG		0x0E	/* write */
-#define SL11H_SOFTMRREG		0x0F	/* read */
-
-/* a write to this register enables SL811HS features.
- * HOST flag presumably overrides the chip input signal?
- */
-#define SL811HS_CTLREG2		0x0F
-#	define SL811HS_CTL2MASK_SOF_MASK	0x3F
-#	define SL811HS_CTL2MASK_DSWAP		0x40
-#	define SL811HS_CTL2MASK_HOST		0x80
-
-#define SL811HS_CTL2_INIT	(SL811HS_CTL2MASK_HOST | 0x2e)
-
-
-/* DATA BUFFERS: registers from 0x10..0xff are for data buffers;
- * that's 240 bytes, which we'll split evenly between A and B sides.
- * Only ISO can use more than 64 bytes per packet.
- * (The SL11S has 0x40..0xff for buffers.)
- */
-#define H_MAXPACKET	120		/* bytes in A or B fifos */
-
-#define SL11H_DATA_START	0x10
-#define	SL811HS_PACKET_BUF(is_a)	((is_a) \
-		? SL11H_DATA_START \
-		: (SL11H_DATA_START + H_MAXPACKET))
-
-/*-------------------------------------------------------------------------*/
-
-#define	LOG2_PERIODIC_SIZE	5	/* arbitrary; this matches OHCI */
-#define	PERIODIC_SIZE		(1 << LOG2_PERIODIC_SIZE)
-
-struct sl811 {
-	spinlock_t		lock;
-	void __iomem		*addr_reg;
-	void __iomem		*data_reg;
-	struct sl811_platform_data	*board;
-	struct proc_dir_entry	*pde;
-
-	unsigned long		stat_insrmv;
-	unsigned long		stat_wake;
-	unsigned long		stat_sof;
-	unsigned long		stat_a;
-	unsigned long		stat_b;
-	unsigned long		stat_lost;
-	unsigned long		stat_overrun;
-
-	/* sw model */
-	struct timer_list	timer;
-	struct sl811h_ep	*next_periodic;
-	struct sl811h_ep	*next_async;
-
-	struct sl811h_ep	*active_a;
-	unsigned long		jiffies_a;
-	struct sl811h_ep	*active_b;
-	unsigned long		jiffies_b;
-
-	u32			port1;
-	u8			ctrl1, ctrl2, irq_enable;
-	u16			frame;
-
-	/* async schedule: control, bulk */
-	struct list_head	async;
-
-	/* periodic schedule: interrupt, iso */
-	u16			load[PERIODIC_SIZE];
-	struct sl811h_ep	*periodic[PERIODIC_SIZE];
-	unsigned		periodic_count;
-};
-
-static inline struct sl811 *hcd_to_sl811(struct usb_hcd *hcd)
-{
-	return (struct sl811 *) (hcd->hcd_priv);
-}
-
-static inline struct usb_hcd *sl811_to_hcd(struct sl811 *sl811)
-{
-	return container_of((void *) sl811, struct usb_hcd, hcd_priv);
-}
-
-struct sl811h_ep {
-	struct usb_host_endpoint *hep;
-	struct usb_device	*udev;
-
-	u8			defctrl;
-	u8			maxpacket;
-	u8			epnum;
-	u8			nextpid;
-
-	u16			error_count;
-	u16			nak_count;
-	u16			length;		/* of current packet */
-
-	/* periodic schedule */
-	u16			period;
-	u16			branch;
-	u16			load;
-	struct sl811h_ep	*next;
-
-	/* async schedule */
-	struct list_head	schedule;
-};
-
-/*-------------------------------------------------------------------------*/
-
-/* These register utilities should work for the SL811S register API too
- * NOTE:  caller must hold sl811->lock.
- */
-
-static inline u8 sl811_read(struct sl811 *sl811, int reg)
-{
-	writeb(reg, sl811->addr_reg);
-	return readb(sl811->data_reg);
-}
-
-static inline void sl811_write(struct sl811 *sl811, int reg, u8 val)
-{
-	writeb(reg, sl811->addr_reg);
-	writeb(val, sl811->data_reg);
-}
-
-static inline void
-sl811_write_buf(struct sl811 *sl811, int addr, const void *buf, size_t count)
-{
-	const u8	*data;
-	void __iomem	*data_reg;
-
-	if (!count)
-		return;
-	writeb(addr, sl811->addr_reg);
-
-	data = buf;
-	data_reg = sl811->data_reg;
-	do {
-		writeb(*data++, data_reg);
-	} while (--count);
-}
-
-static inline void
-sl811_read_buf(struct sl811 *sl811, int addr, void *buf, size_t count)
-{
-	u8 		*data;
-	void __iomem	*data_reg;
-
-	if (!count)
-		return;
-	writeb(addr, sl811->addr_reg);
-
-	data = buf;
-	data_reg = sl811->data_reg;
-	do {
-		*data++ = readb(data_reg);
-	} while (--count);
-}
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef DEBUG
-#define DBG(stuff...)		printk(KERN_DEBUG "sl811: " stuff)
-#else
-#define DBG(stuff...)		do{}while(0)
-#endif
-
-#ifdef VERBOSE
-#    define VDBG		DBG
-#else
-#    define VDBG(stuff...)	do{}while(0)
-#endif
-
-#ifdef PACKET_TRACE
-#    define PACKET		VDBG
-#else
-#    define PACKET(stuff...)	do{}while(0)
-#endif
-
-#define ERR(stuff...)		printk(KERN_ERR "sl811: " stuff)
-#define WARN(stuff...)		printk(KERN_WARNING "sl811: " stuff)
-#define INFO(stuff...)		printk(KERN_INFO "sl811: " stuff)
-
diff -urN host/.svn/text-base/sl811_cs.c.svn-base host.new/.svn/text-base/sl811_cs.c.svn-base
--- host/.svn/text-base/sl811_cs.c.svn-base	2009-02-24 19:00:15.947942602 +0100
+++ host.new/.svn/text-base/sl811_cs.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,326 +0,0 @@
-/*
- * PCMCIA driver for SL811HS (as found in REX-CFU1U)
- * Filename: sl811_cs.c
- * Author:   Yukio Yamamoto
- *
- *  Port to sl811-hcd and 2.6.x by
- *    Botond Botyanszki <boti@rocketmail.com>
- *    Simon Pickering
- *
- *  Last update: 2005-05-12
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/ptrace.h>
-#include <linux/slab.h>
-#include <linux/string.h>
-#include <linux/timer.h>
-#include <linux/ioport.h>
-#include <linux/platform_device.h>
-
-#include <pcmcia/cs_types.h>
-#include <pcmcia/cs.h>
-#include <pcmcia/cistpl.h>
-#include <pcmcia/cisreg.h>
-#include <pcmcia/ds.h>
-
-#include <linux/usb/sl811.h>
-
-MODULE_AUTHOR("Botond Botyanszki");
-MODULE_DESCRIPTION("REX-CFU1U PCMCIA driver for 2.6");
-MODULE_LICENSE("GPL");
-
-
-/*====================================================================*/
-/* MACROS                                                             */
-/*====================================================================*/
-
-#if defined(DEBUG) || defined(PCMCIA_DEBUG)
-
-static int pc_debug = 0;
-module_param(pc_debug, int, 0644);
-
-#define DBG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG "sl811_cs: " args)
-
-#else
-#define DBG(n, args...) do{}while(0)
-#endif	/* no debugging */
-
-#define INFO(args...) printk(KERN_INFO "sl811_cs: " args)
-
-#define INT_MODULE_PARM(n, v) static int n = v; module_param(n, int, 0444)
-
-#define CS_CHECK(fn, ret) \
-	do { \
-		last_fn = (fn); \
-		if ((last_ret = (ret)) != 0) \
-			goto cs_failed; \
-	} while (0)
-
-/*====================================================================*/
-/* VARIABLES                                                          */
-/*====================================================================*/
-
-static const char driver_name[DEV_NAME_LEN]  = "sl811_cs";
-
-typedef struct local_info_t {
-	struct pcmcia_device	*p_dev;
-	dev_node_t		node;
-} local_info_t;
-
-static void sl811_cs_release(struct pcmcia_device * link);
-
-/*====================================================================*/
-
-static void release_platform_dev(struct device * dev)
-{
-	DBG(0, "sl811_cs platform_dev release\n");
-	dev->parent = NULL;
-}
-
-static struct sl811_platform_data platform_data = {
-	.potpg		= 100,
-	.power		= 50,		/* == 100mA */
-	// .reset	= ... FIXME:  invoke CF reset on the card
-};
-
-static struct resource resources[] = {
-	[0] = {
-		.flags	= IORESOURCE_IRQ,
-	},
-	[1] = {
-		// .name   = "address",
-		.flags	= IORESOURCE_IO,
-	},
-	[2] = {
-		// .name   = "data",
-		.flags	= IORESOURCE_IO,
-	},
-};
-
-extern struct platform_driver sl811h_driver;
-
-static struct platform_device platform_dev = {
-	.id			= -1,
-	.dev = {
-		.platform_data = &platform_data,
-		.release       = release_platform_dev,
-	},
-	.resource		= resources,
-	.num_resources		= ARRAY_SIZE(resources),
-};
-
-static int sl811_hc_init(struct device *parent, ioaddr_t base_addr, int irq)
-{
-	if (platform_dev.dev.parent)
-		return -EBUSY;
-	platform_dev.dev.parent = parent;
-
-	/* finish seting up the platform device */
-	resources[0].start = irq;
-
-	resources[1].start = base_addr;
-	resources[1].end = base_addr;
-
-	resources[2].start = base_addr + 1;
-	resources[2].end   = base_addr + 1;
-
-	/* The driver core will probe for us.  We know sl811-hcd has been
-	 * initialized already because of the link order dependency created
-	 * by referencing "sl811h_driver".
-	 */
-	platform_dev.name = sl811h_driver.driver.name;
-	return platform_device_register(&platform_dev);
-}
-
-/*====================================================================*/
-
-static void sl811_cs_detach(struct pcmcia_device *link)
-{
-	DBG(0, "sl811_cs_detach(0x%p)\n", link);
-
-	sl811_cs_release(link);
-
-	/* This points to the parent local_info_t struct */
-	kfree(link->priv);
-}
-
-static void sl811_cs_release(struct pcmcia_device * link)
-{
-	DBG(0, "sl811_cs_release(0x%p)\n", link);
-
-	pcmcia_disable_device(link);
-	platform_device_unregister(&platform_dev);
-}
-
-static int sl811_cs_config(struct pcmcia_device *link)
-{
-	struct device		*parent = &handle_to_dev(link);
-	local_info_t		*dev = link->priv;
-	tuple_t			tuple;
-	cisparse_t		parse;
-	int			last_fn, last_ret;
-	u_char			buf[64];
-	config_info_t		conf;
-	cistpl_cftable_entry_t	dflt = { 0 };
-
-	DBG(0, "sl811_cs_config(0x%p)\n", link);
-
-	/* Look up the current Vcc */
-	CS_CHECK(GetConfigurationInfo,
-			pcmcia_get_configuration_info(link, &conf));
-
-	tuple.Attributes = 0;
-	tuple.TupleData = buf;
-	tuple.TupleDataMax = sizeof(buf);
-	tuple.TupleOffset = 0;
-	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
-	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
-	while (1) {
-		cistpl_cftable_entry_t	*cfg = &(parse.cftable_entry);
-
-		if (pcmcia_get_tuple_data(link, &tuple) != 0
-				|| pcmcia_parse_tuple(link, &tuple, &parse)
-						!= 0)
-			goto next_entry;
-
-		if (cfg->flags & CISTPL_CFTABLE_DEFAULT) {
-			dflt = *cfg;
-		}
-
-		if (cfg->index == 0)
-			goto next_entry;
-
-		link->conf.ConfigIndex = cfg->index;
-
-		/* Use power settings for Vcc and Vpp if present */
-		/*  Note that the CIS values need to be rescaled */
-		if (cfg->vcc.present & (1<<CISTPL_POWER_VNOM)) {
-			if (cfg->vcc.param[CISTPL_POWER_VNOM]/10000
-					!= conf.Vcc)
-				goto next_entry;
-		} else if (dflt.vcc.present & (1<<CISTPL_POWER_VNOM)) {
-			if (dflt.vcc.param[CISTPL_POWER_VNOM]/10000
-					!= conf.Vcc)
-				goto next_entry;
-		}
-
-		if (cfg->vpp1.present & (1<<CISTPL_POWER_VNOM))
-			link->conf.Vpp =
-				cfg->vpp1.param[CISTPL_POWER_VNOM]/10000;
-		else if (dflt.vpp1.present & (1<<CISTPL_POWER_VNOM))
-			link->conf.Vpp =
-				dflt.vpp1.param[CISTPL_POWER_VNOM]/10000;
-
-		/* we need an interrupt */
-		if (cfg->irq.IRQInfo1 || dflt.irq.IRQInfo1)
-			link->conf.Attributes |= CONF_ENABLE_IRQ;
-
-		/* IO window settings */
-		link->io.NumPorts1 = link->io.NumPorts2 = 0;
-		if ((cfg->io.nwin > 0) || (dflt.io.nwin > 0)) {
-			cistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt.io;
-
-			link->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
-			link->io.IOAddrLines = io->flags & CISTPL_IO_LINES_MASK;
-			link->io.BasePort1 = io->win[0].base;
-			link->io.NumPorts1 = io->win[0].len;
-
-			if (pcmcia_request_io(link, &link->io) != 0)
-				goto next_entry;
-		}
-		break;
-
-next_entry:
-		pcmcia_disable_device(link);
-		last_ret = pcmcia_get_next_tuple(link, &tuple);
-	}
-
-	/* require an IRQ and two registers */
-	if (!link->io.NumPorts1 || link->io.NumPorts1 < 2)
-		goto cs_failed;
-	if (link->conf.Attributes & CONF_ENABLE_IRQ)
-		CS_CHECK(RequestIRQ,
-			pcmcia_request_irq(link, &link->irq));
-	else
-		goto cs_failed;
-
-	CS_CHECK(RequestConfiguration,
-		pcmcia_request_configuration(link, &link->conf));
-
-	sprintf(dev->node.dev_name, driver_name);
-	dev->node.major = dev->node.minor = 0;
-	link->dev_node = &dev->node;
-
-	printk(KERN_INFO "%s: index 0x%02x: ",
-	       dev->node.dev_name, link->conf.ConfigIndex);
-	if (link->conf.Vpp)
-		printk(", Vpp %d.%d", link->conf.Vpp/10, link->conf.Vpp%10);
-	printk(", irq %d", link->irq.AssignedIRQ);
-	printk(", io 0x%04x-0x%04x", link->io.BasePort1,
-	       link->io.BasePort1+link->io.NumPorts1-1);
-	printk("\n");
-
-	if (sl811_hc_init(parent, link->io.BasePort1, link->irq.AssignedIRQ)
-			< 0) {
-cs_failed:
-		printk("sl811_cs_config failed\n");
-		cs_error(link, last_fn, last_ret);
-		sl811_cs_release(link);
-		return  -ENODEV;
-	}
-	return 0;
-}
-
-static int sl811_cs_probe(struct pcmcia_device *link)
-{
-	local_info_t *local;
-
-	local = kzalloc(sizeof(local_info_t), GFP_KERNEL);
-	if (!local)
-		return -ENOMEM;
-	local->p_dev = link;
-	link->priv = local;
-
-	/* Initialize */
-	link->irq.Attributes = IRQ_TYPE_EXCLUSIVE;
-	link->irq.IRQInfo1 = IRQ_INFO2_VALID|IRQ_LEVEL_ID;
-	link->irq.Handler = NULL;
-
-	link->conf.Attributes = 0;
-	link->conf.IntType = INT_MEMORY_AND_IO;
-
-	return sl811_cs_config(link);
-}
-
-static struct pcmcia_device_id sl811_ids[] = {
-	PCMCIA_DEVICE_MANF_CARD(0xc015, 0x0001), /* RATOC USB HOST CF+ Card */
-	PCMCIA_DEVICE_NULL,
-};
-MODULE_DEVICE_TABLE(pcmcia, sl811_ids);
-
-static struct pcmcia_driver sl811_cs_driver = {
-	.owner		= THIS_MODULE,
-	.drv		= {
-		.name	= (char *)driver_name,
-	},
-	.probe		= sl811_cs_probe,
-	.remove		= sl811_cs_detach,
-	.id_table	= sl811_ids,
-};
-
-/*====================================================================*/
-
-static int __init init_sl811_cs(void)
-{
-	return pcmcia_register_driver(&sl811_cs_driver);
-}
-module_init(init_sl811_cs);
-
-static void __exit exit_sl811_cs(void)
-{
-	pcmcia_unregister_driver(&sl811_cs_driver);
-}
-module_exit(exit_sl811_cs);
diff -urN host/.svn/text-base/u132-hcd.c.svn-base host.new/.svn/text-base/u132-hcd.c.svn-base
--- host/.svn/text-base/u132-hcd.c.svn-base	2009-02-24 19:00:15.995940163 +0100
+++ host.new/.svn/text-base/u132-hcd.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,3253 +0,0 @@
-/*
-* Host Controller Driver for the Elan Digital Systems U132 adapter
-*
-* Copyright(C) 2006 Elan Digital Systems Limited
-* http://www.elandigitalsystems.com
-*
-* Author and Maintainer - Tony Olech - Elan Digital Systems
-* tony.olech@elandigitalsystems.com
-*
-* This program is free software;you can redistribute it and/or
-* modify it under the terms of the GNU General Public License as
-* published by the Free Software Foundation, version 2.
-*
-*
-* This driver was written by Tony Olech(tony.olech@elandigitalsystems.com)
-* based on various USB host drivers in the 2.6.15 linux kernel
-* with constant reference to the 3rd Edition of Linux Device Drivers
-* published by O'Reilly
-*
-* The U132 adapter is a USB to CardBus adapter specifically designed
-* for PC cards that contain an OHCI host controller. Typical PC cards
-* are the Orange Mobile 3G Option GlobeTrotter Fusion card.
-*
-* The U132 adapter will *NOT *work with PC cards that do not contain
-* an OHCI controller. A simple way to test whether a PC card has an
-* OHCI controller as an interface is to insert the PC card directly
-* into a laptop(or desktop) with a CardBus slot and if "lspci" shows
-* a new USB controller and "lsusb -v" shows a new OHCI Host Controller
-* then there is a good chance that the U132 adapter will support the
-* PC card.(you also need the specific client driver for the PC card)
-*
-* Please inform the Author and Maintainer about any PC cards that
-* contain OHCI Host Controller and work when directly connected to
-* an embedded CardBus slot but do not work when they are connected
-* via an ELAN U132 adapter.
-*
-*/
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/delay.h>
-#include <linux/ioport.h>
-#include <linux/pci_ids.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/timer.h>
-#include <linux/list.h>
-#include <linux/interrupt.h>
-#include <linux/usb.h>
-#include <linux/workqueue.h>
-#include <linux/platform_device.h>
-#include <linux/pci_ids.h>
-#include <linux/mutex.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/system.h>
-#include <asm/byteorder.h>
-#include "../core/hcd.h"
-
-	/* FIXME ohci.h is ONLY for internal use by the OHCI driver.
-	 * If you're going to try stuff like this, you need to split
-	 * out shareable stuff (register declarations?) into its own
-	 * file, maybe name <linux/usb/ohci.h>
-	 */
-
-#include "ohci.h"
-#define OHCI_CONTROL_INIT OHCI_CTRL_CBSR
-#define OHCI_INTR_INIT (OHCI_INTR_MIE | OHCI_INTR_UE | OHCI_INTR_RD | \
-        OHCI_INTR_WDH)
-MODULE_AUTHOR("Tony Olech - Elan Digital Systems Limited");
-MODULE_DESCRIPTION("U132 USB Host Controller Driver");
-MODULE_LICENSE("GPL");
-#define INT_MODULE_PARM(n, v) static int n = v;module_param(n, int, 0444)
-INT_MODULE_PARM(testing, 0);
-/* Some boards misreport power switching/overcurrent*/
-static int distrust_firmware = 1;
-module_param(distrust_firmware, bool, 0);
-MODULE_PARM_DESC(distrust_firmware, "true to distrust firmware power/overcurren"
-        "t setup");
-static DECLARE_WAIT_QUEUE_HEAD(u132_hcd_wait);
-/*
-* u132_module_lock exists to protect access to global variables
-*
-*/
-static struct mutex u132_module_lock;
-static int u132_exiting = 0;
-static int u132_instances = 0;
-static struct list_head u132_static_list;
-/*
-* end of the global variables protected by u132_module_lock
-*/
-static struct workqueue_struct *workqueue;
-#define MAX_U132_PORTS 7
-#define MAX_U132_ADDRS 128
-#define MAX_U132_UDEVS 4
-#define MAX_U132_ENDPS 100
-#define MAX_U132_RINGS 4
-static const char *cc_to_text[16] = {
-        "No Error ",
-        "CRC Error ",
-        "Bit Stuff ",
-        "Data Togg ",
-        "Stall ",
-        "DevNotResp ",
-        "PIDCheck ",
-        "UnExpPID ",
-        "DataOver ",
-        "DataUnder ",
-        "(for hw) ",
-        "(for hw) ",
-        "BufferOver ",
-        "BuffUnder ",
-        "(for HCD) ",
-        "(for HCD) "
-};
-struct u132_port {
-        struct u132 *u132;
-        int reset;
-        int enable;
-        int power;
-        int Status;
-};
-struct u132_addr {
-        u8 address;
-};
-struct u132_udev {
-        struct kref kref;
-        struct usb_device *usb_device;
-        u8 enumeration;
-        u8 udev_number;
-        u8 usb_addr;
-        u8 portnumber;
-        u8 endp_number_in[16];
-        u8 endp_number_out[16];
-};
-#define ENDP_QUEUE_SHIFT 3
-#define ENDP_QUEUE_SIZE (1<<ENDP_QUEUE_SHIFT)
-#define ENDP_QUEUE_MASK (ENDP_QUEUE_SIZE-1)
-struct u132_urbq {
-        struct list_head urb_more;
-        struct urb *urb;
-};
-struct u132_spin {
-        spinlock_t slock;
-};
-struct u132_endp {
-        struct kref kref;
-        u8 udev_number;
-        u8 endp_number;
-        u8 usb_addr;
-        u8 usb_endp;
-        struct u132 *u132;
-        struct list_head endp_ring;
-        struct u132_ring *ring;
-        unsigned toggle_bits:2;
-        unsigned active:1;
-        unsigned delayed:1;
-        unsigned input:1;
-        unsigned output:1;
-        unsigned pipetype:2;
-        unsigned dequeueing:1;
-        unsigned edset_flush:1;
-        unsigned spare_bits:14;
-        unsigned long jiffies;
-        struct usb_host_endpoint *hep;
-        struct u132_spin queue_lock;
-        u16 queue_size;
-        u16 queue_last;
-        u16 queue_next;
-        struct urb *urb_list[ENDP_QUEUE_SIZE];
-        struct list_head urb_more;
-        struct delayed_work scheduler;
-};
-struct u132_ring {
-        unsigned in_use:1;
-        unsigned length:7;
-        u8 number;
-        struct u132 *u132;
-        struct u132_endp *curr_endp;
-        struct delayed_work scheduler;
-};
-struct u132 {
-        struct kref kref;
-        struct list_head u132_list;
-        struct semaphore sw_lock;
-        struct semaphore scheduler_lock;
-        struct u132_platform_data *board;
-        struct platform_device *platform_dev;
-        struct u132_ring ring[MAX_U132_RINGS];
-        int sequence_num;
-        int going;
-        int power;
-        int reset;
-        int num_ports;
-        u32 hc_control;
-        u32 hc_fminterval;
-        u32 hc_roothub_status;
-        u32 hc_roothub_a;
-        u32 hc_roothub_portstatus[MAX_ROOT_PORTS];
-        int flags;
-        unsigned long next_statechange;
-        struct delayed_work monitor;
-        int num_endpoints;
-        struct u132_addr addr[MAX_U132_ADDRS];
-        struct u132_udev udev[MAX_U132_UDEVS];
-        struct u132_port port[MAX_U132_PORTS];
-        struct u132_endp *endp[MAX_U132_ENDPS];
-};
-
-/*
-* these cannot be inlines because we need the structure offset!!
-* Does anyone have a better way?????
-*/
-#define ftdi_read_pcimem(pdev, member, data) usb_ftdi_elan_read_pcimem(pdev, \
-        offsetof(struct ohci_regs, member), 0, data);
-#define ftdi_write_pcimem(pdev, member, data) usb_ftdi_elan_write_pcimem(pdev, \
-        offsetof(struct ohci_regs, member), 0, data);
-#define u132_read_pcimem(u132, member, data) \
-        usb_ftdi_elan_read_pcimem(u132->platform_dev, offsetof(struct \
-        ohci_regs, member), 0, data);
-#define u132_write_pcimem(u132, member, data) \
-        usb_ftdi_elan_write_pcimem(u132->platform_dev, offsetof(struct \
-        ohci_regs, member), 0, data);
-static inline struct u132 *udev_to_u132(struct u132_udev *udev)
-{
-        u8 udev_number = udev->udev_number;
-        return container_of(udev, struct u132, udev[udev_number]);
-}
-
-static inline struct u132 *hcd_to_u132(struct usb_hcd *hcd)
-{
-        return (struct u132 *)(hcd->hcd_priv);
-}
-
-static inline struct usb_hcd *u132_to_hcd(struct u132 *u132)
-{
-        return container_of((void *)u132, struct usb_hcd, hcd_priv);
-}
-
-static inline void u132_disable(struct u132 *u132)
-{
-        u132_to_hcd(u132)->state = HC_STATE_HALT;
-}
-
-
-#define kref_to_u132(d) container_of(d, struct u132, kref)
-#define kref_to_u132_endp(d) container_of(d, struct u132_endp, kref)
-#define kref_to_u132_udev(d) container_of(d, struct u132_udev, kref)
-#include "../misc/usb_u132.h"
-static const char hcd_name[] = "u132_hcd";
-#define PORT_C_MASK ((USB_PORT_STAT_C_CONNECTION | USB_PORT_STAT_C_ENABLE | \
-        USB_PORT_STAT_C_SUSPEND | USB_PORT_STAT_C_OVERCURRENT | \
-        USB_PORT_STAT_C_RESET) << 16)
-static void u132_hcd_delete(struct kref *kref)
-{
-        struct u132 *u132 = kref_to_u132(kref);
-        struct platform_device *pdev = u132->platform_dev;
-        struct usb_hcd *hcd = u132_to_hcd(u132);
-        u132->going += 1;
-        mutex_lock(&u132_module_lock);
-        list_del_init(&u132->u132_list);
-        u132_instances -= 1;
-        mutex_unlock(&u132_module_lock);
-        dev_warn(&u132->platform_dev->dev, "FREEING the hcd=%p and thus the u13"
-                "2=%p going=%d pdev=%p\n", hcd, u132, u132->going, pdev);
-        usb_put_hcd(hcd);
-}
-
-static inline void u132_u132_put_kref(struct u132 *u132)
-{
-        kref_put(&u132->kref, u132_hcd_delete);
-}
-
-static inline void u132_u132_init_kref(struct u132 *u132)
-{
-        kref_init(&u132->kref);
-}
-
-static void u132_udev_delete(struct kref *kref)
-{
-        struct u132_udev *udev = kref_to_u132_udev(kref);
-        udev->udev_number = 0;
-        udev->usb_device = NULL;
-        udev->usb_addr = 0;
-        udev->enumeration = 0;
-}
-
-static inline void u132_udev_put_kref(struct u132 *u132, struct u132_udev *udev)
-{
-        kref_put(&udev->kref, u132_udev_delete);
-}
-
-static inline void u132_udev_get_kref(struct u132 *u132, struct u132_udev *udev)
-{
-        kref_get(&udev->kref);
-}
-
-static inline void u132_udev_init_kref(struct u132 *u132,
-        struct u132_udev *udev)
-{
-        kref_init(&udev->kref);
-}
-
-static inline void u132_ring_put_kref(struct u132 *u132, struct u132_ring *ring)
-{
-        kref_put(&u132->kref, u132_hcd_delete);
-}
-
-static void u132_ring_requeue_work(struct u132 *u132, struct u132_ring *ring,
-        unsigned int delta)
-{
-        if (delta > 0) {
-                if (queue_delayed_work(workqueue, &ring->scheduler, delta))
-                        return;
-        } else if (queue_delayed_work(workqueue, &ring->scheduler, 0))
-                return;
-        kref_put(&u132->kref, u132_hcd_delete);
-        return;
-}
-
-static void u132_ring_queue_work(struct u132 *u132, struct u132_ring *ring,
-        unsigned int delta)
-{
-        kref_get(&u132->kref);
-        u132_ring_requeue_work(u132, ring, delta);
-        return;
-}
-
-static void u132_ring_cancel_work(struct u132 *u132, struct u132_ring *ring)
-{
-        if (cancel_delayed_work(&ring->scheduler)) {
-                kref_put(&u132->kref, u132_hcd_delete);
-        }
-}
-
-static void u132_endp_delete(struct kref *kref)
-{
-        struct u132_endp *endp = kref_to_u132_endp(kref);
-        struct u132 *u132 = endp->u132;
-        u8 usb_addr = endp->usb_addr;
-        u8 usb_endp = endp->usb_endp;
-        u8 address = u132->addr[usb_addr].address;
-        struct u132_udev *udev = &u132->udev[address];
-        u8 endp_number = endp->endp_number;
-        struct usb_host_endpoint *hep = endp->hep;
-        struct u132_ring *ring = endp->ring;
-        struct list_head *head = &endp->endp_ring;
-        ring->length -= 1;
-        if (endp == ring->curr_endp) {
-                if (list_empty(head)) {
-                        ring->curr_endp = NULL;
-                        list_del(head);
-                } else {
-                        struct u132_endp *next_endp = list_entry(head->next,
-                                struct u132_endp, endp_ring);
-                        ring->curr_endp = next_endp;
-                        list_del(head);
-        }} else
-                list_del(head);
-        if (endp->input) {
-                udev->endp_number_in[usb_endp] = 0;
-                u132_udev_put_kref(u132, udev);
-        }
-        if (endp->output) {
-                udev->endp_number_out[usb_endp] = 0;
-                u132_udev_put_kref(u132, udev);
-        }
-        u132->endp[endp_number - 1] = NULL;
-        hep->hcpriv = NULL;
-        kfree(endp);
-        u132_u132_put_kref(u132);
-}
-
-static inline void u132_endp_put_kref(struct u132 *u132, struct u132_endp *endp)
-{
-        kref_put(&endp->kref, u132_endp_delete);
-}
-
-static inline void u132_endp_get_kref(struct u132 *u132, struct u132_endp *endp)
-{
-        kref_get(&endp->kref);
-}
-
-static inline void u132_endp_init_kref(struct u132 *u132,
-        struct u132_endp *endp)
-{
-        kref_init(&endp->kref);
-        kref_get(&u132->kref);
-}
-
-static void u132_endp_queue_work(struct u132 *u132, struct u132_endp *endp,
-        unsigned int delta)
-{
-	if (queue_delayed_work(workqueue, &endp->scheduler, delta))
-		kref_get(&endp->kref);
-}
-
-static void u132_endp_cancel_work(struct u132 *u132, struct u132_endp *endp)
-{
-        if (cancel_delayed_work(&endp->scheduler))
-                kref_put(&endp->kref, u132_endp_delete);
-}
-
-static inline void u132_monitor_put_kref(struct u132 *u132)
-{
-        kref_put(&u132->kref, u132_hcd_delete);
-}
-
-static void u132_monitor_queue_work(struct u132 *u132, unsigned int delta)
-{
-	if (queue_delayed_work(workqueue, &u132->monitor, delta))
-		kref_get(&u132->kref);
-}
-
-static void u132_monitor_requeue_work(struct u132 *u132, unsigned int delta)
-{
-	if (!queue_delayed_work(workqueue, &u132->monitor, delta))
-		kref_put(&u132->kref, u132_hcd_delete);
-}
-
-static void u132_monitor_cancel_work(struct u132 *u132)
-{
-        if (cancel_delayed_work(&u132->monitor))
-                kref_put(&u132->kref, u132_hcd_delete);
-}
-
-static int read_roothub_info(struct u132 *u132)
-{
-        u32 revision;
-        int retval;
-        retval = u132_read_pcimem(u132, revision, &revision);
-        if (retval) {
-                dev_err(&u132->platform_dev->dev, "error %d accessing device co"
-                        "ntrol\n", retval);
-                return retval;
-        } else if ((revision & 0xFF) == 0x10) {
-        } else if ((revision & 0xFF) == 0x11) {
-        } else {
-                dev_err(&u132->platform_dev->dev, "device revision is not valid"
-                        " %08X\n", revision);
-                return -ENODEV;
-        }
-        retval = u132_read_pcimem(u132, control, &u132->hc_control);
-        if (retval) {
-                dev_err(&u132->platform_dev->dev, "error %d accessing device co"
-                        "ntrol\n", retval);
-                return retval;
-        }
-        retval = u132_read_pcimem(u132, roothub.status,
-                &u132->hc_roothub_status);
-        if (retval) {
-                dev_err(&u132->platform_dev->dev, "error %d accessing device re"
-                        "g roothub.status\n", retval);
-                return retval;
-        }
-        retval = u132_read_pcimem(u132, roothub.a, &u132->hc_roothub_a);
-        if (retval) {
-                dev_err(&u132->platform_dev->dev, "error %d accessing device re"
-                        "g roothub.a\n", retval);
-                return retval;
-        }
-        {
-                int I = u132->num_ports;
-                int i = 0;
-                while (I-- > 0) {
-                        retval = u132_read_pcimem(u132, roothub.portstatus[i],
-                                &u132->hc_roothub_portstatus[i]);
-                        if (retval) {
-                                dev_err(&u132->platform_dev->dev, "error %d acc"
-                                        "essing device roothub.portstatus[%d]\n"
-                                        , retval, i);
-                                return retval;
-                        } else
-                                i += 1;
-                }
-        }
-        return 0;
-}
-
-static void u132_hcd_monitor_work(struct work_struct *work)
-{
-        struct u132 *u132 = container_of(work, struct u132, monitor.work);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                u132_monitor_put_kref(u132);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                u132_monitor_put_kref(u132);
-                return;
-        } else {
-                int retval;
-                down(&u132->sw_lock);
-                retval = read_roothub_info(u132);
-                if (retval) {
-                        struct usb_hcd *hcd = u132_to_hcd(u132);
-                        u132_disable(u132);
-                        u132->going = 1;
-                        up(&u132->sw_lock);
-                        usb_hc_died(hcd);
-                        ftdi_elan_gone_away(u132->platform_dev);
-                        u132_monitor_put_kref(u132);
-                        return;
-                } else {
-                        u132_monitor_requeue_work(u132, 500);
-                        up(&u132->sw_lock);
-                        return;
-                }
-        }
-}
-
-static void u132_hcd_giveback_urb(struct u132 *u132, struct u132_endp *endp,
-        struct urb *urb, int status)
-{
-        struct u132_ring *ring;
-        unsigned long irqs;
-        struct usb_hcd *hcd = u132_to_hcd(u132);
-        urb->error_count = 0;
-        urb->status = status;
-        urb->hcpriv = NULL;
-        spin_lock_irqsave(&endp->queue_lock.slock, irqs);
-        endp->queue_next += 1;
-        if (ENDP_QUEUE_SIZE > --endp->queue_size) {
-                endp->active = 0;
-                spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-        } else {
-                struct list_head *next = endp->urb_more.next;
-                struct u132_urbq *urbq = list_entry(next, struct u132_urbq,
-                        urb_more);
-                list_del(next);
-                endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] =
-                        urbq->urb;
-                endp->active = 0;
-                spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                kfree(urbq);
-        } down(&u132->scheduler_lock);
-        ring = endp->ring;
-        ring->in_use = 0;
-        u132_ring_cancel_work(u132, ring);
-        u132_ring_queue_work(u132, ring, 0);
-        up(&u132->scheduler_lock);
-        u132_endp_put_kref(u132, endp);
-        usb_hcd_giveback_urb(hcd, urb);
-        return;
-}
-
-static void u132_hcd_forget_urb(struct u132 *u132, struct u132_endp *endp,
-        struct urb *urb, int status)
-{
-        u132_endp_put_kref(u132, endp);
-}
-
-static void u132_hcd_abandon_urb(struct u132 *u132, struct u132_endp *endp,
-        struct urb *urb, int status)
-{
-        unsigned long irqs;
-        struct usb_hcd *hcd = u132_to_hcd(u132);
-        urb->error_count = 0;
-        urb->status = status;
-        urb->hcpriv = NULL;
-        spin_lock_irqsave(&endp->queue_lock.slock, irqs);
-        endp->queue_next += 1;
-        if (ENDP_QUEUE_SIZE > --endp->queue_size) {
-                endp->active = 0;
-                spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-        } else {
-                struct list_head *next = endp->urb_more.next;
-                struct u132_urbq *urbq = list_entry(next, struct u132_urbq,
-                        urb_more);
-                list_del(next);
-                endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] =
-                        urbq->urb;
-                endp->active = 0;
-                spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                kfree(urbq);
-        } usb_hcd_giveback_urb(hcd, urb);
-        return;
-}
-
-static inline int edset_input(struct u132 *u132, struct u132_ring *ring,
-        struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
-        void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
-        int toggle_bits, int error_count, int condition_code, int repeat_number,
-         int halted, int skipped, int actual, int non_null))
-{
-        return usb_ftdi_elan_edset_input(u132->platform_dev, ring->number, endp,
-                 urb, address, endp->usb_endp, toggle_bits, callback);
-}
-
-static inline int edset_setup(struct u132 *u132, struct u132_ring *ring,
-        struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
-        void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
-        int toggle_bits, int error_count, int condition_code, int repeat_number,
-         int halted, int skipped, int actual, int non_null))
-{
-        return usb_ftdi_elan_edset_setup(u132->platform_dev, ring->number, endp,
-                 urb, address, endp->usb_endp, toggle_bits, callback);
-}
-
-static inline int edset_single(struct u132 *u132, struct u132_ring *ring,
-        struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
-        void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
-        int toggle_bits, int error_count, int condition_code, int repeat_number,
-         int halted, int skipped, int actual, int non_null))
-{
-        return usb_ftdi_elan_edset_single(u132->platform_dev, ring->number,
-                endp, urb, address, endp->usb_endp, toggle_bits, callback);
-}
-
-static inline int edset_output(struct u132 *u132, struct u132_ring *ring,
-        struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
-        void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
-        int toggle_bits, int error_count, int condition_code, int repeat_number,
-         int halted, int skipped, int actual, int non_null))
-{
-        return usb_ftdi_elan_edset_output(u132->platform_dev, ring->number,
-                endp, urb, address, endp->usb_endp, toggle_bits, callback);
-}
-
-
-/*
-* must not LOCK sw_lock
-*
-*/
-static void u132_hcd_interrupt_recv(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
-{
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        struct u132_udev *udev = &u132->udev[address];
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                struct u132_ring *ring = endp->ring;
-                u8 *u = urb->transfer_buffer + urb->actual_length;
-                u8 *b = buf;
-                int L = len;
-                while (L-- > 0) {
-                        *u++ = *b++;
-                }
-                urb->actual_length += len;
-                if ((condition_code == TD_CC_NOERROR) &&
-                        (urb->transfer_buffer_length > urb->actual_length)) {
-                        endp->toggle_bits = toggle_bits;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0,
-                                1 & toggle_bits);
-                        if (urb->actual_length > 0) {
-                                int retval;
-                                up(&u132->scheduler_lock);
-                                retval = edset_single(u132, ring, endp, urb,
-                                        address, endp->toggle_bits,
-                                        u132_hcd_interrupt_recv);
-                                if (retval == 0) {
-                                } else
-                                        u132_hcd_giveback_urb(u132, endp, urb,
-                                                retval);
-                        } else {
-                                ring->in_use = 0;
-                                endp->active = 0;
-                                endp->jiffies = jiffies +
-                                        msecs_to_jiffies(urb->interval);
-                                u132_ring_cancel_work(u132, ring);
-                                u132_ring_queue_work(u132, ring, 0);
-                                up(&u132->scheduler_lock);
-                                u132_endp_put_kref(u132, endp);
-                        }
-                        return;
-                } else if ((condition_code == TD_DATAUNDERRUN) &&
-                        ((urb->transfer_flags & URB_SHORT_NOT_OK) == 0)) {
-                        endp->toggle_bits = toggle_bits;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0,
-                                1 & toggle_bits);
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb, 0);
-                        return;
-                } else {
-                        if (condition_code == TD_CC_NOERROR) {
-                                endp->toggle_bits = toggle_bits;
-                                usb_settoggle(udev->usb_device, endp->usb_endp,
-                                        0, 1 & toggle_bits);
-                        } else if (condition_code == TD_CC_STALL) {
-                                endp->toggle_bits = 0x2;
-                                usb_settoggle(udev->usb_device, endp->usb_endp,
-                                        0, 0);
-                        } else {
-                                endp->toggle_bits = 0x2;
-                                usb_settoggle(udev->usb_device, endp->usb_endp,
-                                        0, 0);
-                                dev_err(&u132->platform_dev->dev, "urb=%p givin"
-                                        "g back INTERRUPT %s\n", urb,
-                                        cc_to_text[condition_code]);
-                        }
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb,
-                                cc_to_error[condition_code]);
-                        return;
-                }
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
-}
-
-static void u132_hcd_bulk_output_sent(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
-{
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                struct u132_ring *ring = endp->ring;
-                urb->actual_length += len;
-                endp->toggle_bits = toggle_bits;
-                if (urb->transfer_buffer_length > urb->actual_length) {
-                        int retval;
-                        up(&u132->scheduler_lock);
-                        retval = edset_output(u132, ring, endp, urb, address,
-                                endp->toggle_bits, u132_hcd_bulk_output_sent);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                } else {
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb, 0);
-                        return;
-                }
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
-}
-
-static void u132_hcd_bulk_input_recv(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
-{
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        struct u132_udev *udev = &u132->udev[address];
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                struct u132_ring *ring = endp->ring;
-                u8 *u = urb->transfer_buffer + urb->actual_length;
-                u8 *b = buf;
-                int L = len;
-                while (L-- > 0) {
-                        *u++ = *b++;
-                }
-                urb->actual_length += len;
-                if ((condition_code == TD_CC_NOERROR) &&
-                        (urb->transfer_buffer_length > urb->actual_length)) {
-                        int retval;
-                        endp->toggle_bits = toggle_bits;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0,
-                                1 & toggle_bits);
-                        up(&u132->scheduler_lock);
-                        retval = usb_ftdi_elan_edset_input(u132->platform_dev,
-                                ring->number, endp, urb, address,
-                                endp->usb_endp, endp->toggle_bits,
-                                u132_hcd_bulk_input_recv);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                } else if (condition_code == TD_CC_NOERROR) {
-                        endp->toggle_bits = toggle_bits;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0,
-                                1 & toggle_bits);
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb,
-                                cc_to_error[condition_code]);
-                        return;
-                } else if ((condition_code == TD_DATAUNDERRUN) &&
-                        ((urb->transfer_flags & URB_SHORT_NOT_OK) == 0)) {
-                        endp->toggle_bits = toggle_bits;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0,
-                                1 & toggle_bits);
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb, 0);
-                        return;
-                } else if (condition_code == TD_DATAUNDERRUN) {
-                        endp->toggle_bits = toggle_bits;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0,
-                                1 & toggle_bits);
-                        dev_warn(&u132->platform_dev->dev, "urb=%p(SHORT NOT OK"
-                                ") giving back BULK IN %s\n", urb,
-                                cc_to_text[condition_code]);
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb, 0);
-                        return;
-                } else if (condition_code == TD_CC_STALL) {
-                        endp->toggle_bits = 0x2;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0, 0);
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb,
-                                cc_to_error[condition_code]);
-                        return;
-                } else {
-                        endp->toggle_bits = 0x2;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0, 0);
-                        dev_err(&u132->platform_dev->dev, "urb=%p giving back B"
-                                "ULK IN code=%d %s\n", urb, condition_code,
-                                cc_to_text[condition_code]);
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb,
-                                cc_to_error[condition_code]);
-                        return;
-                }
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
-}
-
-static void u132_hcd_configure_empty_sent(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
-{
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, 0);
-                return;
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
-}
-
-static void u132_hcd_configure_input_recv(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
-{
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                struct u132_ring *ring = endp->ring;
-                u8 *u = urb->transfer_buffer;
-                u8 *b = buf;
-                int L = len;
-                while (L-- > 0) {
-                        *u++ = *b++;
-                }
-                urb->actual_length = len;
-                if ((condition_code == TD_CC_NOERROR) || ((condition_code ==
-                        TD_DATAUNDERRUN) && ((urb->transfer_flags &
-                        URB_SHORT_NOT_OK) == 0))) {
-                        int retval;
-                        up(&u132->scheduler_lock);
-                        retval = usb_ftdi_elan_edset_empty(u132->platform_dev,
-                                ring->number, endp, urb, address,
-                                endp->usb_endp, 0x3,
-                                u132_hcd_configure_empty_sent);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                } else if (condition_code == TD_CC_STALL) {
-                        up(&u132->scheduler_lock);
-                        dev_warn(&u132->platform_dev->dev, "giving back SETUP I"
-                                "NPUT STALL urb %p\n", urb);
-                        u132_hcd_giveback_urb(u132, endp, urb,
-                                cc_to_error[condition_code]);
-                        return;
-                } else {
-                        up(&u132->scheduler_lock);
-                        dev_err(&u132->platform_dev->dev, "giving back SETUP IN"
-                                "PUT %s urb %p\n", cc_to_text[condition_code],
-                                urb);
-                        u132_hcd_giveback_urb(u132, endp, urb,
-                                cc_to_error[condition_code]);
-                        return;
-                }
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
-}
-
-static void u132_hcd_configure_empty_recv(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
-{
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, 0);
-                return;
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
-}
-
-static void u132_hcd_configure_setup_sent(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
-{
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                if (usb_pipein(urb->pipe)) {
-                        int retval;
-                        struct u132_ring *ring = endp->ring;
-                        up(&u132->scheduler_lock);
-                        retval = usb_ftdi_elan_edset_input(u132->platform_dev,
-                                ring->number, endp, urb, address,
-                                endp->usb_endp, 0,
-                                u132_hcd_configure_input_recv);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                } else {
-                        int retval;
-                        struct u132_ring *ring = endp->ring;
-                        up(&u132->scheduler_lock);
-                        retval = usb_ftdi_elan_edset_input(u132->platform_dev,
-                                ring->number, endp, urb, address,
-                                endp->usb_endp, 0,
-                                u132_hcd_configure_empty_recv);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                }
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
-}
-
-static void u132_hcd_enumeration_empty_recv(void *data, struct urb *urb,
-        u8 *buf, int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
-{
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        struct u132_udev *udev = &u132->udev[address];
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                u132->addr[0].address = 0;
-                endp->usb_addr = udev->usb_addr;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, 0);
-                return;
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
-}
-
-static void u132_hcd_enumeration_address_sent(void *data, struct urb *urb,
-        u8 *buf, int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
-{
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                int retval;
-                struct u132_ring *ring = endp->ring;
-                up(&u132->scheduler_lock);
-                retval = usb_ftdi_elan_edset_input(u132->platform_dev,
-                        ring->number, endp, urb, 0, endp->usb_endp, 0,
-                        u132_hcd_enumeration_empty_recv);
-                if (retval == 0) {
-                } else
-                        u132_hcd_giveback_urb(u132, endp, urb, retval);
-                return;
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
-}
-
-static void u132_hcd_initial_empty_sent(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
-{
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, 0);
-                return;
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
-}
-
-static void u132_hcd_initial_input_recv(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
-{
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                int retval;
-                struct u132_ring *ring = endp->ring;
-                u8 *u = urb->transfer_buffer;
-                u8 *b = buf;
-                int L = len;
-                while (L-- > 0) {
-                        *u++ = *b++;
-                }
-                urb->actual_length = len;
-                up(&u132->scheduler_lock);
-                retval = usb_ftdi_elan_edset_empty(u132->platform_dev,
-                        ring->number, endp, urb, address, endp->usb_endp, 0x3,
-                        u132_hcd_initial_empty_sent);
-                if (retval == 0) {
-                } else
-                        u132_hcd_giveback_urb(u132, endp, urb, retval);
-                return;
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
-}
-
-static void u132_hcd_initial_setup_sent(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
-{
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                int retval;
-                struct u132_ring *ring = endp->ring;
-                up(&u132->scheduler_lock);
-                retval = usb_ftdi_elan_edset_input(u132->platform_dev,
-                        ring->number, endp, urb, address, endp->usb_endp, 0,
-                        u132_hcd_initial_input_recv);
-                if (retval == 0) {
-                } else
-                        u132_hcd_giveback_urb(u132, endp, urb, retval);
-                return;
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
-}
-
-/*
-* this work function is only executed from the work queue
-*
-*/
-static void u132_hcd_ring_work_scheduler(struct work_struct *work)
-{
-        struct u132_ring *ring =
-		container_of(work, struct u132_ring, scheduler.work);
-        struct u132 *u132 = ring->u132;
-        down(&u132->scheduler_lock);
-        if (ring->in_use) {
-                up(&u132->scheduler_lock);
-                u132_ring_put_kref(u132, ring);
-                return;
-        } else if (ring->curr_endp) {
-                struct u132_endp *last_endp = ring->curr_endp;
-                struct list_head *scan;
-                struct list_head *head = &last_endp->endp_ring;
-                unsigned long wakeup = 0;
-                list_for_each(scan, head) {
-                        struct u132_endp *endp = list_entry(scan,
-                                struct u132_endp, endp_ring);
-                        if (endp->queue_next == endp->queue_last) {
-                        } else if ((endp->delayed == 0)
-                                || time_after_eq(jiffies, endp->jiffies)) {
-                                ring->curr_endp = endp;
-                                u132_endp_cancel_work(u132, last_endp);
-                                u132_endp_queue_work(u132, last_endp, 0);
-                                up(&u132->scheduler_lock);
-                                u132_ring_put_kref(u132, ring);
-                                return;
-                        } else {
-                                unsigned long delta = endp->jiffies - jiffies;
-                                if (delta > wakeup)
-                                        wakeup = delta;
-                        }
-                }
-                if (last_endp->queue_next == last_endp->queue_last) {
-                } else if ((last_endp->delayed == 0) || time_after_eq(jiffies,
-                        last_endp->jiffies)) {
-                        u132_endp_cancel_work(u132, last_endp);
-                        u132_endp_queue_work(u132, last_endp, 0);
-                        up(&u132->scheduler_lock);
-                        u132_ring_put_kref(u132, ring);
-                        return;
-                } else {
-                        unsigned long delta = last_endp->jiffies - jiffies;
-                        if (delta > wakeup)
-                                wakeup = delta;
-                }
-                if (wakeup > 0) {
-                        u132_ring_requeue_work(u132, ring, wakeup);
-                        up(&u132->scheduler_lock);
-                        return;
-                } else {
-                        up(&u132->scheduler_lock);
-                        u132_ring_put_kref(u132, ring);
-                        return;
-                }
-        } else {
-                up(&u132->scheduler_lock);
-                u132_ring_put_kref(u132, ring);
-                return;
-        }
-}
-
-static void u132_hcd_endp_work_scheduler(struct work_struct *work)
-{
-        struct u132_ring *ring;
-        struct u132_endp *endp =
-		container_of(work, struct u132_endp, scheduler.work);
-        struct u132 *u132 = endp->u132;
-        down(&u132->scheduler_lock);
-        ring = endp->ring;
-        if (endp->edset_flush) {
-                endp->edset_flush = 0;
-                if (endp->dequeueing)
-                        usb_ftdi_elan_edset_flush(u132->platform_dev,
-                                ring->number, endp);
-                up(&u132->scheduler_lock);
-                u132_endp_put_kref(u132, endp);
-                return;
-        } else if (endp->active) {
-                up(&u132->scheduler_lock);
-                u132_endp_put_kref(u132, endp);
-                return;
-        } else if (ring->in_use) {
-                up(&u132->scheduler_lock);
-                u132_endp_put_kref(u132, endp);
-                return;
-        } else if (endp->queue_next == endp->queue_last) {
-                up(&u132->scheduler_lock);
-                u132_endp_put_kref(u132, endp);
-                return;
-        } else if (endp->pipetype == PIPE_INTERRUPT) {
-                u8 address = u132->addr[endp->usb_addr].address;
-                if (ring->in_use) {
-                        up(&u132->scheduler_lock);
-                        u132_endp_put_kref(u132, endp);
-                        return;
-                } else {
-                        int retval;
-                        struct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &
-                                endp->queue_next];
-                        endp->active = 1;
-                        ring->curr_endp = endp;
-                        ring->in_use = 1;
-                        up(&u132->scheduler_lock);
-                        retval = edset_single(u132, ring, endp, urb, address,
-                                endp->toggle_bits, u132_hcd_interrupt_recv);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                }
-        } else if (endp->pipetype == PIPE_CONTROL) {
-                u8 address = u132->addr[endp->usb_addr].address;
-                if (ring->in_use) {
-                        up(&u132->scheduler_lock);
-                        u132_endp_put_kref(u132, endp);
-                        return;
-                } else if (address == 0) {
-                        int retval;
-                        struct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &
-                                endp->queue_next];
-                        endp->active = 1;
-                        ring->curr_endp = endp;
-                        ring->in_use = 1;
-                        up(&u132->scheduler_lock);
-                        retval = edset_setup(u132, ring, endp, urb, address,
-                                0x2, u132_hcd_initial_setup_sent);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                } else if (endp->usb_addr == 0) {
-                        int retval;
-                        struct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &
-                                endp->queue_next];
-                        endp->active = 1;
-                        ring->curr_endp = endp;
-                        ring->in_use = 1;
-                        up(&u132->scheduler_lock);
-                        retval = edset_setup(u132, ring, endp, urb, 0, 0x2,
-                                u132_hcd_enumeration_address_sent);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                } else {
-                        int retval;
-                        u8 address = u132->addr[endp->usb_addr].address;
-                        struct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &
-                                endp->queue_next];
-                        endp->active = 1;
-                        ring->curr_endp = endp;
-                        ring->in_use = 1;
-                        up(&u132->scheduler_lock);
-                        retval = edset_setup(u132, ring, endp, urb, address,
-                                0x2, u132_hcd_configure_setup_sent);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                }
-        } else {
-                if (endp->input) {
-                        u8 address = u132->addr[endp->usb_addr].address;
-                        if (ring->in_use) {
-                                up(&u132->scheduler_lock);
-                                u132_endp_put_kref(u132, endp);
-                                return;
-                        } else {
-                                int retval;
-                                struct urb *urb = endp->urb_list[
-                                        ENDP_QUEUE_MASK & endp->queue_next];
-                                endp->active = 1;
-                                ring->curr_endp = endp;
-                                ring->in_use = 1;
-                                up(&u132->scheduler_lock);
-                                retval = edset_input(u132, ring, endp, urb,
-                                        address, endp->toggle_bits,
-                                        u132_hcd_bulk_input_recv);
-                                if (retval == 0) {
-                                } else
-                                        u132_hcd_giveback_urb(u132, endp, urb,
-                                                retval);
-                                return;
-                        }
-                } else {        /* output pipe */
-                        u8 address = u132->addr[endp->usb_addr].address;
-                        if (ring->in_use) {
-                                up(&u132->scheduler_lock);
-                                u132_endp_put_kref(u132, endp);
-                                return;
-                        } else {
-                                int retval;
-                                struct urb *urb = endp->urb_list[
-                                        ENDP_QUEUE_MASK & endp->queue_next];
-                                endp->active = 1;
-                                ring->curr_endp = endp;
-                                ring->in_use = 1;
-                                up(&u132->scheduler_lock);
-                                retval = edset_output(u132, ring, endp, urb,
-                                        address, endp->toggle_bits,
-                                        u132_hcd_bulk_output_sent);
-                                if (retval == 0) {
-                                } else
-                                        u132_hcd_giveback_urb(u132, endp, urb,
-                                                retval);
-                                return;
-                        }
-                }
-        }
-}
-#ifdef CONFIG_PM
-
-static void port_power(struct u132 *u132, int pn, int is_on)
-{
-        u132->port[pn].power = is_on;
-}
-
-#endif
-
-static void u132_power(struct u132 *u132, int is_on)
-{
-        struct usb_hcd *hcd = u132_to_hcd(u132)
-                ;        /* hub is inactive unless the port is powered */
-        if (is_on) {
-                if (u132->power)
-                        return;
-                u132->power = 1;
-                hcd->self.controller->power.power_state = PMSG_ON;
-        } else {
-                u132->power = 0;
-                hcd->state = HC_STATE_HALT;
-                hcd->self.controller->power.power_state = PMSG_SUSPEND;
-        }
-}
-
-static int u132_periodic_reinit(struct u132 *u132)
-{
-        int retval;
-        u32 fi = u132->hc_fminterval & 0x03fff;
-        u32 fit;
-        u32 fminterval;
-        retval = u132_read_pcimem(u132, fminterval, &fminterval);
-        if (retval)
-                return retval;
-        fit = fminterval & FIT;
-        retval = u132_write_pcimem(u132, fminterval,
-                (fit ^ FIT) | u132->hc_fminterval);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, periodicstart,
-                ((9 *fi) / 10) & 0x3fff);
-        if (retval)
-                return retval;
-        return 0;
-}
-
-static char *hcfs2string(int state)
-{
-        switch (state) {
-        case OHCI_USB_RESET:
-                return "reset";
-        case OHCI_USB_RESUME:
-                return "resume";
-        case OHCI_USB_OPER:
-                return "operational";
-        case OHCI_USB_SUSPEND:
-                return "suspend";
-        }
-        return "?";
-}
-
-static int u132_init(struct u132 *u132)
-{
-        int retval;
-        u32 control;
-        u132_disable(u132);
-        u132->next_statechange = jiffies;
-        retval = u132_write_pcimem(u132, intrdisable, OHCI_INTR_MIE);
-        if (retval)
-                return retval;
-        retval = u132_read_pcimem(u132, control, &control);
-        if (retval)
-                return retval;
-        if (u132->num_ports == 0) {
-                u32 rh_a = -1;
-                retval = u132_read_pcimem(u132, roothub.a, &rh_a);
-                if (retval)
-                        return retval;
-                u132->num_ports = rh_a & RH_A_NDP;
-                retval = read_roothub_info(u132);
-                if (retval)
-                        return retval;
-        }
-        if (u132->num_ports > MAX_U132_PORTS) {
-                return -EINVAL;
-        }
-        return 0;
-}
-
-
-/* Start an OHCI controller, set the BUS operational
-* resets USB and controller
-* enable interrupts
-*/
-static int u132_run(struct u132 *u132)
-{
-        int retval;
-        u32 control;
-        u32 status;
-        u32 fminterval;
-        u32 periodicstart;
-        u32 cmdstatus;
-        u32 roothub_a;
-        int mask = OHCI_INTR_INIT;
-        int first = u132->hc_fminterval == 0;
-        int sleep_time = 0;
-        int reset_timeout = 30;        /* ... allow extra time */
-        u132_disable(u132);
-        if (first) {
-                u32 temp;
-                retval = u132_read_pcimem(u132, fminterval, &temp);
-                if (retval)
-                        return retval;
-                u132->hc_fminterval = temp & 0x3fff;
-                if (u132->hc_fminterval != FI) {
-                }
-                u132->hc_fminterval |= FSMP(u132->hc_fminterval) << 16;
-        }
-        retval = u132_read_pcimem(u132, control, &u132->hc_control);
-        if (retval)
-                return retval;
-        dev_info(&u132->platform_dev->dev, "resetting from state '%s', control "
-                "= %08X\n", hcfs2string(u132->hc_control & OHCI_CTRL_HCFS),
-                u132->hc_control);
-        switch (u132->hc_control & OHCI_CTRL_HCFS) {
-        case OHCI_USB_OPER:
-                sleep_time = 0;
-                break;
-        case OHCI_USB_SUSPEND:
-        case OHCI_USB_RESUME:
-                u132->hc_control &= OHCI_CTRL_RWC;
-                u132->hc_control |= OHCI_USB_RESUME;
-                sleep_time = 10;
-                break;
-        default:
-                u132->hc_control &= OHCI_CTRL_RWC;
-                u132->hc_control |= OHCI_USB_RESET;
-                sleep_time = 50;
-                break;
-        }
-        retval = u132_write_pcimem(u132, control, u132->hc_control);
-        if (retval)
-                return retval;
-        retval = u132_read_pcimem(u132, control, &control);
-        if (retval)
-                return retval;
-        msleep(sleep_time);
-        retval = u132_read_pcimem(u132, roothub.a, &roothub_a);
-        if (retval)
-                return retval;
-        if (!(roothub_a & RH_A_NPS)) {
-                int temp;        /* power down each port */
-                for (temp = 0; temp < u132->num_ports; temp++) {
-                        retval = u132_write_pcimem(u132,
-                                roothub.portstatus[temp], RH_PS_LSDA);
-                        if (retval)
-                                return retval;
-                }
-        }
-        retval = u132_read_pcimem(u132, control, &control);
-        if (retval)
-                return retval;
-      retry:retval = u132_read_pcimem(u132, cmdstatus, &status);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, cmdstatus, OHCI_HCR);
-        if (retval)
-                return retval;
-      extra:{
-                retval = u132_read_pcimem(u132, cmdstatus, &status);
-                if (retval)
-                        return retval;
-                if (0 != (status & OHCI_HCR)) {
-                        if (--reset_timeout == 0) {
-                                dev_err(&u132->platform_dev->dev, "USB HC reset"
-                                        " timed out!\n");
-                                return -ENODEV;
-                        } else {
-                                msleep(5);
-                                goto extra;
-                        }
-                }
-        }
-        if (u132->flags & OHCI_QUIRK_INITRESET) {
-                retval = u132_write_pcimem(u132, control, u132->hc_control);
-                if (retval)
-                        return retval;
-                retval = u132_read_pcimem(u132, control, &control);
-                if (retval)
-                        return retval;
-        }
-        retval = u132_write_pcimem(u132, ed_controlhead, 0x00000000);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, ed_bulkhead, 0x11000000);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, hcca, 0x00000000);
-        if (retval)
-                return retval;
-        retval = u132_periodic_reinit(u132);
-        if (retval)
-                return retval;
-        retval = u132_read_pcimem(u132, fminterval, &fminterval);
-        if (retval)
-                return retval;
-        retval = u132_read_pcimem(u132, periodicstart, &periodicstart);
-        if (retval)
-                return retval;
-        if (0 == (fminterval & 0x3fff0000) || 0 == periodicstart) {
-                if (!(u132->flags & OHCI_QUIRK_INITRESET)) {
-                        u132->flags |= OHCI_QUIRK_INITRESET;
-                        goto retry;
-                } else
-                        dev_err(&u132->platform_dev->dev, "init err(%08x %04x)"
-                                "\n", fminterval, periodicstart);
-        }                        /* start controller operations */
-        u132->hc_control &= OHCI_CTRL_RWC;
-        u132->hc_control |= OHCI_CONTROL_INIT | OHCI_CTRL_BLE | OHCI_USB_OPER;
-        retval = u132_write_pcimem(u132, control, u132->hc_control);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, cmdstatus, OHCI_BLF);
-        if (retval)
-                return retval;
-        retval = u132_read_pcimem(u132, cmdstatus, &cmdstatus);
-        if (retval)
-                return retval;
-        retval = u132_read_pcimem(u132, control, &control);
-        if (retval)
-                return retval;
-        u132_to_hcd(u132)->state = HC_STATE_RUNNING;
-        retval = u132_write_pcimem(u132, roothub.status, RH_HS_DRWE);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, intrstatus, mask);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, intrdisable,
-                OHCI_INTR_MIE | OHCI_INTR_OC | OHCI_INTR_RHSC | OHCI_INTR_FNO |
-                OHCI_INTR_UE | OHCI_INTR_RD | OHCI_INTR_SF | OHCI_INTR_WDH |
-                OHCI_INTR_SO);
-        if (retval)
-                return retval;        /* handle root hub init quirks ... */
-        retval = u132_read_pcimem(u132, roothub.a, &roothub_a);
-        if (retval)
-                return retval;
-        roothub_a &= ~(RH_A_PSM | RH_A_OCPM);
-        if (u132->flags & OHCI_QUIRK_SUPERIO) {
-                roothub_a |= RH_A_NOCP;
-                roothub_a &= ~(RH_A_POTPGT | RH_A_NPS);
-                retval = u132_write_pcimem(u132, roothub.a, roothub_a);
-                if (retval)
-                        return retval;
-        } else if ((u132->flags & OHCI_QUIRK_AMD756) || distrust_firmware) {
-                roothub_a |= RH_A_NPS;
-                retval = u132_write_pcimem(u132, roothub.a, roothub_a);
-                if (retval)
-                        return retval;
-        }
-        retval = u132_write_pcimem(u132, roothub.status, RH_HS_LPSC);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, roothub.b,
-                (roothub_a & RH_A_NPS) ? 0 : RH_B_PPCM);
-        if (retval)
-                return retval;
-        retval = u132_read_pcimem(u132, control, &control);
-        if (retval)
-                return retval;
-        mdelay((roothub_a >> 23) & 0x1fe);
-        u132_to_hcd(u132)->state = HC_STATE_RUNNING;
-        return 0;
-}
-
-static void u132_hcd_stop(struct usb_hcd *hcd)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "u132 device %p(hcd=%p) has b"
-                        "een removed %d\n", u132, hcd, u132->going);
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device hcd=%p is being remov"
-                        "ed\n", hcd);
-        } else {
-                down(&u132->sw_lock);
-                msleep(100);
-                u132_power(u132, 0);
-                up(&u132->sw_lock);
-        }
-}
-
-static int u132_hcd_start(struct usb_hcd *hcd)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else if (hcd->self.controller) {
-                int retval;
-                struct platform_device *pdev =
-                        to_platform_device(hcd->self.controller);
-                u16 vendor = ((struct u132_platform_data *)
-                        (pdev->dev.platform_data))->vendor;
-                u16 device = ((struct u132_platform_data *)
-                        (pdev->dev.platform_data))->device;
-                down(&u132->sw_lock);
-                msleep(10);
-                if (vendor == PCI_VENDOR_ID_AMD && device == 0x740c) {
-                        u132->flags = OHCI_QUIRK_AMD756;
-                } else if (vendor == PCI_VENDOR_ID_OPTI && device == 0xc861) {
-                        dev_err(&u132->platform_dev->dev, "WARNING: OPTi workar"
-                                "ounds unavailable\n");
-                } else if (vendor == PCI_VENDOR_ID_COMPAQ && device == 0xa0f8)
-                        u132->flags |= OHCI_QUIRK_ZFMICRO;
-                retval = u132_run(u132);
-                if (retval) {
-                        u132_disable(u132);
-                        u132->going = 1;
-                }
-                msleep(100);
-                up(&u132->sw_lock);
-                return retval;
-        } else {
-                dev_err(&u132->platform_dev->dev, "platform_device missing\n");
-                return -ENODEV;
-        }
-}
-
-static int u132_hcd_reset(struct usb_hcd *hcd)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else {
-                int retval;
-                down(&u132->sw_lock);
-                retval = u132_init(u132);
-                if (retval) {
-                        u132_disable(u132);
-                        u132->going = 1;
-                }
-                up(&u132->sw_lock);
-                return retval;
-        }
-}
-
-static int create_endpoint_and_queue_int(struct u132 *u132,
-        struct u132_udev *udev, struct usb_host_endpoint *hep, struct urb *urb,
-        struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp, u8 address,
-        gfp_t mem_flags)
-{
-        struct u132_ring *ring;
-        unsigned long irqs;
-        u8 endp_number = ++u132->num_endpoints;
-        struct u132_endp *endp = hep->hcpriv = u132->endp[endp_number - 1] =
-                kmalloc(sizeof(struct u132_endp), mem_flags);
-        if (!endp) {
-                return -ENOMEM;
-        }
-        INIT_DELAYED_WORK(&endp->scheduler, u132_hcd_endp_work_scheduler);
-        spin_lock_init(&endp->queue_lock.slock);
-        INIT_LIST_HEAD(&endp->urb_more);
-        ring = endp->ring = &u132->ring[0];
-        if (ring->curr_endp) {
-                list_add_tail(&endp->endp_ring, &ring->curr_endp->endp_ring);
-        } else {
-                INIT_LIST_HEAD(&endp->endp_ring);
-                ring->curr_endp = endp;
-        }
-        ring->length += 1;
-        endp->dequeueing = 0;
-        endp->edset_flush = 0;
-        endp->active = 0;
-        endp->delayed = 0;
-        endp->endp_number = endp_number;
-        endp->u132 = u132;
-        endp->hep = hep;
-        endp->pipetype = usb_pipetype(urb->pipe);
-        u132_endp_init_kref(u132, endp);
-        if (usb_pipein(urb->pipe)) {
-                endp->toggle_bits = 0x2;
-                usb_settoggle(udev->usb_device, usb_endp, 0, 0);
-                endp->input = 1;
-                endp->output = 0;
-                udev->endp_number_in[usb_endp] = endp_number;
-                u132_udev_get_kref(u132, udev);
-        } else {
-                endp->toggle_bits = 0x2;
-                usb_settoggle(udev->usb_device, usb_endp, 1, 0);
-                endp->input = 0;
-                endp->output = 1;
-                udev->endp_number_out[usb_endp] = endp_number;
-                u132_udev_get_kref(u132, udev);
-        }
-        urb->hcpriv = u132;
-        spin_lock_irqsave(&endp->queue_lock.slock, irqs);
-        endp->delayed = 1;
-        endp->jiffies = jiffies + msecs_to_jiffies(urb->interval);
-        endp->udev_number = address;
-        endp->usb_addr = usb_addr;
-        endp->usb_endp = usb_endp;
-        endp->queue_size = 1;
-        endp->queue_last = 0;
-        endp->queue_next = 0;
-        endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
-        spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-        u132_endp_queue_work(u132, endp, msecs_to_jiffies(urb->interval));
-        return 0;
-}
-
-static int queue_int_on_old_endpoint(struct u132 *u132, struct u132_udev *udev,
-        struct usb_host_endpoint *hep, struct urb *urb,
-        struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
-        u8 usb_endp, u8 address)
-{
-        urb->hcpriv = u132;
-        endp->delayed = 1;
-        endp->jiffies = jiffies + msecs_to_jiffies(urb->interval);
-        if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
-                endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
-        } else {
-                struct u132_urbq *urbq = kmalloc(sizeof(struct u132_urbq),
-                        GFP_ATOMIC);
-                if (urbq == NULL) {
-                        endp->queue_size -= 1;
-                        return -ENOMEM;
-                } else {
-                        list_add_tail(&urbq->urb_more, &endp->urb_more);
-                        urbq->urb = urb;
-                }
-        }
-        return 0;
-}
-
-static int create_endpoint_and_queue_bulk(struct u132 *u132,
-        struct u132_udev *udev, struct usb_host_endpoint *hep, struct urb *urb,
-        struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp, u8 address,
-        gfp_t mem_flags)
-{
-        int ring_number;
-        struct u132_ring *ring;
-        unsigned long irqs;
-        u8 endp_number = ++u132->num_endpoints;
-        struct u132_endp *endp = hep->hcpriv = u132->endp[endp_number - 1] =
-                kmalloc(sizeof(struct u132_endp), mem_flags);
-        if (!endp) {
-                return -ENOMEM;
-        }
-        INIT_DELAYED_WORK(&endp->scheduler, u132_hcd_endp_work_scheduler);
-        spin_lock_init(&endp->queue_lock.slock);
-        INIT_LIST_HEAD(&endp->urb_more);
-        endp->dequeueing = 0;
-        endp->edset_flush = 0;
-        endp->active = 0;
-        endp->delayed = 0;
-        endp->endp_number = endp_number;
-        endp->u132 = u132;
-        endp->hep = hep;
-        endp->pipetype = usb_pipetype(urb->pipe);
-        u132_endp_init_kref(u132, endp);
-        if (usb_pipein(urb->pipe)) {
-                endp->toggle_bits = 0x2;
-                usb_settoggle(udev->usb_device, usb_endp, 0, 0);
-                ring_number = 3;
-                endp->input = 1;
-                endp->output = 0;
-                udev->endp_number_in[usb_endp] = endp_number;
-                u132_udev_get_kref(u132, udev);
-        } else {
-                endp->toggle_bits = 0x2;
-                usb_settoggle(udev->usb_device, usb_endp, 1, 0);
-                ring_number = 2;
-                endp->input = 0;
-                endp->output = 1;
-                udev->endp_number_out[usb_endp] = endp_number;
-                u132_udev_get_kref(u132, udev);
-        }
-        ring = endp->ring = &u132->ring[ring_number - 1];
-        if (ring->curr_endp) {
-                list_add_tail(&endp->endp_ring, &ring->curr_endp->endp_ring);
-        } else {
-                INIT_LIST_HEAD(&endp->endp_ring);
-                ring->curr_endp = endp;
-        }
-        ring->length += 1;
-        urb->hcpriv = u132;
-        spin_lock_irqsave(&endp->queue_lock.slock, irqs);
-        endp->udev_number = address;
-        endp->usb_addr = usb_addr;
-        endp->usb_endp = usb_endp;
-        endp->queue_size = 1;
-        endp->queue_last = 0;
-        endp->queue_next = 0;
-        endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
-        spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-        u132_endp_queue_work(u132, endp, 0);
-        return 0;
-}
-
-static int queue_bulk_on_old_endpoint(struct u132 *u132, struct u132_udev *udev,
-         struct usb_host_endpoint *hep, struct urb *urb,
-        struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
-        u8 usb_endp, u8 address)
-{
-        urb->hcpriv = u132;
-        if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
-                endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
-        } else {
-                struct u132_urbq *urbq = kmalloc(sizeof(struct u132_urbq),
-                        GFP_ATOMIC);
-                if (urbq == NULL) {
-                        endp->queue_size -= 1;
-                        return -ENOMEM;
-                } else {
-                        list_add_tail(&urbq->urb_more, &endp->urb_more);
-                        urbq->urb = urb;
-                }
-        }
-        return 0;
-}
-
-static int create_endpoint_and_queue_control(struct u132 *u132,
-        struct usb_host_endpoint *hep, struct urb *urb,
-        struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp,
-        gfp_t mem_flags)
-{
-        struct u132_ring *ring;
-        u8 endp_number = ++u132->num_endpoints;
-        struct u132_endp *endp = hep->hcpriv = u132->endp[endp_number - 1] =
-                kmalloc(sizeof(struct u132_endp), mem_flags);
-        if (!endp) {
-                return -ENOMEM;
-        }
-        INIT_DELAYED_WORK(&endp->scheduler, u132_hcd_endp_work_scheduler);
-        spin_lock_init(&endp->queue_lock.slock);
-        INIT_LIST_HEAD(&endp->urb_more);
-        ring = endp->ring = &u132->ring[0];
-        if (ring->curr_endp) {
-                list_add_tail(&endp->endp_ring, &ring->curr_endp->endp_ring);
-        } else {
-                INIT_LIST_HEAD(&endp->endp_ring);
-                ring->curr_endp = endp;
-        }
-        ring->length += 1;
-        endp->dequeueing = 0;
-        endp->edset_flush = 0;
-        endp->active = 0;
-        endp->delayed = 0;
-        endp->endp_number = endp_number;
-        endp->u132 = u132;
-        endp->hep = hep;
-        u132_endp_init_kref(u132, endp);
-        u132_endp_get_kref(u132, endp);
-        if (usb_addr == 0) {
-                unsigned long irqs;
-                u8 address = u132->addr[usb_addr].address;
-                struct u132_udev *udev = &u132->udev[address];
-                endp->udev_number = address;
-                endp->usb_addr = usb_addr;
-                endp->usb_endp = usb_endp;
-                endp->input = 1;
-                endp->output = 1;
-                endp->pipetype = usb_pipetype(urb->pipe);
-                u132_udev_init_kref(u132, udev);
-                u132_udev_get_kref(u132, udev);
-                udev->endp_number_in[usb_endp] = endp_number;
-                udev->endp_number_out[usb_endp] = endp_number;
-                urb->hcpriv = u132;
-                spin_lock_irqsave(&endp->queue_lock.slock, irqs);
-                endp->queue_size = 1;
-                endp->queue_last = 0;
-                endp->queue_next = 0;
-                endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
-                spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                u132_endp_queue_work(u132, endp, 0);
-                return 0;
-        } else {                /*(usb_addr > 0) */
-                unsigned long irqs;
-                u8 address = u132->addr[usb_addr].address;
-                struct u132_udev *udev = &u132->udev[address];
-                endp->udev_number = address;
-                endp->usb_addr = usb_addr;
-                endp->usb_endp = usb_endp;
-                endp->input = 1;
-                endp->output = 1;
-                endp->pipetype = usb_pipetype(urb->pipe);
-                u132_udev_get_kref(u132, udev);
-                udev->enumeration = 2;
-                udev->endp_number_in[usb_endp] = endp_number;
-                udev->endp_number_out[usb_endp] = endp_number;
-                urb->hcpriv = u132;
-                spin_lock_irqsave(&endp->queue_lock.slock, irqs);
-                endp->queue_size = 1;
-                endp->queue_last = 0;
-                endp->queue_next = 0;
-                endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
-                spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                u132_endp_queue_work(u132, endp, 0);
-                return 0;
-        }
-}
-
-static int queue_control_on_old_endpoint(struct u132 *u132,
-        struct usb_host_endpoint *hep, struct urb *urb,
-        struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
-        u8 usb_endp)
-{
-        if (usb_addr == 0) {
-                if (usb_pipein(urb->pipe)) {
-                        urb->hcpriv = u132;
-                        if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
-                                endp->urb_list[ENDP_QUEUE_MASK &
-                                        endp->queue_last++] = urb;
-                        } else {
-                                struct u132_urbq *urbq =
-                                        kmalloc(sizeof(struct u132_urbq),
-                                        GFP_ATOMIC);
-                                if (urbq == NULL) {
-                                        endp->queue_size -= 1;
-                                        return -ENOMEM;
-                                } else {
-                                        list_add_tail(&urbq->urb_more,
-                                                &endp->urb_more);
-                                        urbq->urb = urb;
-                                }
-                        }
-                        return 0;
-                } else {        /* usb_pipeout(urb->pipe) */
-                        struct u132_addr *addr = &u132->addr[usb_dev->devnum];
-                        int I = MAX_U132_UDEVS;
-                        int i = 0;
-                        while (--I > 0) {
-                                struct u132_udev *udev = &u132->udev[++i];
-                                if (udev->usb_device) {
-                                        continue;
-                                } else {
-                                        udev->enumeration = 1;
-                                        u132->addr[0].address = i;
-                                        endp->udev_number = i;
-                                        udev->udev_number = i;
-                                        udev->usb_addr = usb_dev->devnum;
-                                        u132_udev_init_kref(u132, udev);
-                                        udev->endp_number_in[usb_endp] =
-                                                endp->endp_number;
-                                        u132_udev_get_kref(u132, udev);
-                                        udev->endp_number_out[usb_endp] =
-                                                endp->endp_number;
-                                        udev->usb_device = usb_dev;
-                                        ((u8 *) (urb->setup_packet))[2] =
-                                                addr->address = i;
-                                        u132_udev_get_kref(u132, udev);
-                                        break;
-                                }
-                        }
-                        if (I == 0) {
-                                dev_err(&u132->platform_dev->dev, "run out of d"
-                                        "evice space\n");
-                                return -EINVAL;
-                        }
-                        urb->hcpriv = u132;
-                        if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
-                                endp->urb_list[ENDP_QUEUE_MASK &
-                                        endp->queue_last++] = urb;
-                        } else {
-                                struct u132_urbq *urbq =
-                                        kmalloc(sizeof(struct u132_urbq),
-                                        GFP_ATOMIC);
-                                if (urbq == NULL) {
-                                        endp->queue_size -= 1;
-                                        return -ENOMEM;
-                                } else {
-                                        list_add_tail(&urbq->urb_more,
-                                                &endp->urb_more);
-                                        urbq->urb = urb;
-                                }
-                        }
-                        return 0;
-                }
-        } else {                /*(usb_addr > 0) */
-                u8 address = u132->addr[usb_addr].address;
-                struct u132_udev *udev = &u132->udev[address];
-                urb->hcpriv = u132;
-                if (udev->enumeration == 2) {
-                } else
-                        udev->enumeration = 2;
-                if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
-                        endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] =
-                                urb;
-                } else {
-                        struct u132_urbq *urbq =
-                                kmalloc(sizeof(struct u132_urbq), GFP_ATOMIC);
-                        if (urbq == NULL) {
-                                endp->queue_size -= 1;
-                                return -ENOMEM;
-                        } else {
-                                list_add_tail(&urbq->urb_more, &endp->urb_more);
-                                urbq->urb = urb;
-                        }
-                }
-                return 0;
-        }
-}
-
-static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
-        struct urb *urb, gfp_t mem_flags)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (irqs_disabled()) {
-                if (__GFP_WAIT & mem_flags) {
-                        printk(KERN_ERR "invalid context for function that migh"
-                                "t sleep\n");
-                        return -EINVAL;
-                }
-        }
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                return -ESHUTDOWN;
-        } else {
-                u8 usb_addr = usb_pipedevice(urb->pipe);
-                u8 usb_endp = usb_pipeendpoint(urb->pipe);
-                struct usb_device *usb_dev = urb->dev;
-                if (usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {
-                        u8 address = u132->addr[usb_addr].address;
-                        struct u132_udev *udev = &u132->udev[address];
-                        struct u132_endp *endp = hep->hcpriv;
-                        urb->actual_length = 0;
-                        if (endp) {
-                                unsigned long irqs;
-                                int retval;
-                                spin_lock_irqsave(&endp->queue_lock.slock,
-                                        irqs);
-                                retval = queue_int_on_old_endpoint(u132, udev,
-                                        hep, urb, usb_dev, endp, usb_addr,
-                                        usb_endp, address);
-                                spin_unlock_irqrestore(&endp->queue_lock.slock,
-                                        irqs);
-                                if (retval) {
-                                        return retval;
-                                } else {
-                                        u132_endp_queue_work(u132, endp,
-                                                msecs_to_jiffies(urb->interval))
-                                                ;
-                                        return 0;
-                                }
-                        } else if (u132->num_endpoints == MAX_U132_ENDPS) {
-                                return -EINVAL;
-                        } else {        /*(endp == NULL) */
-                                return create_endpoint_and_queue_int(u132, udev,
-                                         hep, urb, usb_dev, usb_addr, usb_endp,
-                                        address, mem_flags);
-                        }
-                } else if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
-                        dev_err(&u132->platform_dev->dev, "the hardware does no"
-                                "t support PIPE_ISOCHRONOUS\n");
-                        return -EINVAL;
-                } else if (usb_pipetype(urb->pipe) == PIPE_BULK) {
-                        u8 address = u132->addr[usb_addr].address;
-                        struct u132_udev *udev = &u132->udev[address];
-                        struct u132_endp *endp = hep->hcpriv;
-                        urb->actual_length = 0;
-                        if (endp) {
-                                unsigned long irqs;
-                                int retval;
-                                spin_lock_irqsave(&endp->queue_lock.slock,
-                                        irqs);
-                                retval = queue_bulk_on_old_endpoint(u132, udev,
-                                        hep, urb, usb_dev, endp, usb_addr,
-                                        usb_endp, address);
-                                spin_unlock_irqrestore(&endp->queue_lock.slock,
-                                        irqs);
-                                if (retval) {
-                                        return retval;
-                                } else {
-                                        u132_endp_queue_work(u132, endp, 0);
-                                        return 0;
-                                }
-                        } else if (u132->num_endpoints == MAX_U132_ENDPS) {
-                                return -EINVAL;
-                        } else
-                                return create_endpoint_and_queue_bulk(u132,
-                                        udev, hep, urb, usb_dev, usb_addr,
-                                        usb_endp, address, mem_flags);
-                } else {
-                        struct u132_endp *endp = hep->hcpriv;
-                        u16 urb_size = 8;
-                        u8 *b = urb->setup_packet;
-                        int i = 0;
-                        char data[30 *3 + 4];
-                        char *d = data;
-                        int m = (sizeof(data) - 1) / 3;
-                        int l = 0;
-                        data[0] = 0;
-                        while (urb_size-- > 0) {
-                                if (i > m) {
-                                } else if (i++ < m) {
-                                        int w = sprintf(d, " %02X", *b++);
-                                        d += w;
-                                        l += w;
-                                } else
-                                        d += sprintf(d, " ..");
-                        }
-                        if (endp) {
-                                unsigned long irqs;
-                                int retval;
-                                spin_lock_irqsave(&endp->queue_lock.slock,
-                                        irqs);
-                                retval = queue_control_on_old_endpoint(u132,
-                                        hep, urb, usb_dev, endp, usb_addr,
-                                        usb_endp);
-                                spin_unlock_irqrestore(&endp->queue_lock.slock,
-                                        irqs);
-                                if (retval) {
-                                        return retval;
-                                } else {
-                                        u132_endp_queue_work(u132, endp, 0);
-                                        return 0;
-                                }
-                        } else if (u132->num_endpoints == MAX_U132_ENDPS) {
-                                return -EINVAL;
-                        } else
-                                return create_endpoint_and_queue_control(u132,
-                                        hep, urb, usb_dev, usb_addr, usb_endp,
-                                        mem_flags);
-                }
-        }
-}
-
-static int dequeue_from_overflow_chain(struct u132 *u132,
-        struct u132_endp *endp, struct urb *urb)
-{
-        struct list_head *scan;
-        struct list_head *head = &endp->urb_more;
-        list_for_each(scan, head) {
-                struct u132_urbq *urbq = list_entry(scan, struct u132_urbq,
-                        urb_more);
-                if (urbq->urb == urb) {
-                        struct usb_hcd *hcd = u132_to_hcd(u132);
-                        list_del(scan);
-                        endp->queue_size -= 1;
-                        urb->error_count = 0;
-                        urb->hcpriv = NULL;
-                        usb_hcd_giveback_urb(hcd, urb);
-                        return 0;
-                } else
-                        continue;
-        }
-        dev_err(&u132->platform_dev->dev, "urb=%p not found in endp[%d]=%p ring"
-                "[%d] %c%c usb_endp=%d usb_addr=%d size=%d next=%04X last=%04X"
-                "\n", urb, endp->endp_number, endp, endp->ring->number,
-                endp->input ? 'I' : ' ', endp->output ? 'O' : ' ',
-                endp->usb_endp, endp->usb_addr, endp->queue_size,
-                endp->queue_next, endp->queue_last);
-        return -EINVAL;
-}
-
-static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
-        struct urb *urb)
-{
-        unsigned long irqs;
-        spin_lock_irqsave(&endp->queue_lock.slock, irqs);
-        if (endp->queue_size == 0) {
-                dev_err(&u132->platform_dev->dev, "urb=%p not found in endp[%d]"
-                        "=%p ring[%d] %c%c usb_endp=%d usb_addr=%d\n", urb,
-                        endp->endp_number, endp, endp->ring->number,
-                        endp->input ? 'I' : ' ', endp->output ? 'O' : ' ',
-                        endp->usb_endp, endp->usb_addr);
-                spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                return -EINVAL;
-        }
-        if (urb == endp->urb_list[ENDP_QUEUE_MASK & endp->queue_next]) {
-                if (endp->active) {
-                        endp->dequeueing = 1;
-                        endp->edset_flush = 1;
-                        u132_endp_queue_work(u132, endp, 0);
-                        spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                        urb->hcpriv = NULL;
-                        return 0;
-                } else {
-                        spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                        u132_hcd_abandon_urb(u132, endp, urb, urb->status);
-                        return 0;
-                }
-        } else {
-                u16 queue_list = 0;
-                u16 queue_size = endp->queue_size;
-                u16 queue_scan = endp->queue_next;
-                struct urb **urb_slot = NULL;
-                while (++queue_list < ENDP_QUEUE_SIZE && --queue_size > 0) {
-                        if (urb == endp->urb_list[ENDP_QUEUE_MASK &
-                                ++queue_scan]) {
-                                urb_slot = &endp->urb_list[ENDP_QUEUE_MASK &
-                                        queue_scan];
-                                break;
-                        } else
-                                continue;
-                }
-                while (++queue_list < ENDP_QUEUE_SIZE && --queue_size > 0) {
-                        *urb_slot = endp->urb_list[ENDP_QUEUE_MASK &
-                                ++queue_scan];
-                        urb_slot = &endp->urb_list[ENDP_QUEUE_MASK &
-                                queue_scan];
-                }
-                if (urb_slot) {
-                        struct usb_hcd *hcd = u132_to_hcd(u132);
-                        endp->queue_size -= 1;
-                        if (list_empty(&endp->urb_more)) {
-                                spin_unlock_irqrestore(&endp->queue_lock.slock,
-                                        irqs);
-                        } else {
-                                struct list_head *next = endp->urb_more.next;
-                                struct u132_urbq *urbq = list_entry(next,
-                                        struct u132_urbq, urb_more);
-                                list_del(next);
-                                *urb_slot = urbq->urb;
-                                spin_unlock_irqrestore(&endp->queue_lock.slock,
-                                        irqs);
-                                kfree(urbq);
-                        } urb->error_count = 0;
-                        urb->hcpriv = NULL;
-                        usb_hcd_giveback_urb(hcd, urb);
-                        return 0;
-                } else if (list_empty(&endp->urb_more)) {
-                        dev_err(&u132->platform_dev->dev, "urb=%p not found in "
-                                "endp[%d]=%p ring[%d] %c%c usb_endp=%d usb_addr"
-                                "=%d size=%d next=%04X last=%04X\n", urb,
-                                endp->endp_number, endp, endp->ring->number,
-                                endp->input ? 'I' : ' ',
-                                endp->output ? 'O' : ' ', endp->usb_endp,
-                                endp->usb_addr, endp->queue_size,
-                                endp->queue_next, endp->queue_last);
-                        spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                        return -EINVAL;
-                } else {
-                        int retval = dequeue_from_overflow_chain(u132, endp,
-                                urb);
-                        spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                        return retval;
-                }
-        }
-}
-
-static int u132_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 2) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else {
-                u8 usb_addr = usb_pipedevice(urb->pipe);
-                u8 usb_endp = usb_pipeendpoint(urb->pipe);
-                u8 address = u132->addr[usb_addr].address;
-                struct u132_udev *udev = &u132->udev[address];
-                if (usb_pipein(urb->pipe)) {
-                        u8 endp_number = udev->endp_number_in[usb_endp];
-                        struct u132_endp *endp = u132->endp[endp_number - 1];
-                        return u132_endp_urb_dequeue(u132, endp, urb);
-                } else {
-                        u8 endp_number = udev->endp_number_out[usb_endp];
-                        struct u132_endp *endp = u132->endp[endp_number - 1];
-                        return u132_endp_urb_dequeue(u132, endp, urb);
-                }
-        }
-}
-
-static void u132_endpoint_disable(struct usb_hcd *hcd,
-        struct usb_host_endpoint *hep)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 2) {
-                dev_err(&u132->platform_dev->dev, "u132 device %p(hcd=%p hep=%p"
-                        ") has been removed %d\n", u132, hcd, hep,
-                        u132->going);
-        } else {
-                struct u132_endp *endp = hep->hcpriv;
-                if (endp)
-                        u132_endp_put_kref(u132, endp);
-        }
-}
-
-static int u132_get_frame(struct usb_hcd *hcd)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else {
-                int frame = 0;
-                dev_err(&u132->platform_dev->dev, "TODO: u132_get_frame\n");
-                msleep(100);
-                return frame;
-        }
-}
-
-static int u132_roothub_descriptor(struct u132 *u132,
-        struct usb_hub_descriptor *desc)
-{
-        int retval;
-        u16 temp;
-        u32 rh_a = -1;
-        u32 rh_b = -1;
-        retval = u132_read_pcimem(u132, roothub.a, &rh_a);
-        if (retval)
-                return retval;
-        desc->bDescriptorType = 0x29;
-        desc->bPwrOn2PwrGood = (rh_a & RH_A_POTPGT) >> 24;
-        desc->bHubContrCurrent = 0;
-        desc->bNbrPorts = u132->num_ports;
-        temp = 1 + (u132->num_ports / 8);
-        desc->bDescLength = 7 + 2 *temp;
-        temp = 0;
-        if (rh_a & RH_A_NPS)
-                temp |= 0x0002;
-        if (rh_a & RH_A_PSM)
-                temp |= 0x0001;
-        if (rh_a & RH_A_NOCP) {
-                temp |= 0x0010;
-        } else if (rh_a & RH_A_OCPM)
-                temp |= 0x0008;
-        desc->wHubCharacteristics = cpu_to_le16(temp);
-        retval = u132_read_pcimem(u132, roothub.b, &rh_b);
-        if (retval)
-                return retval;
-        memset(desc->bitmap, 0xff, sizeof(desc->bitmap));
-        desc->bitmap[0] = rh_b & RH_B_DR;
-        if (u132->num_ports > 7) {
-                desc->bitmap[1] = (rh_b & RH_B_DR) >> 8;
-                desc->bitmap[2] = 0xff;
-        } else
-                desc->bitmap[1] = 0xff;
-        return 0;
-}
-
-static int u132_roothub_status(struct u132 *u132, __le32 *desc)
-{
-        u32 rh_status = -1;
-        int ret_status = u132_read_pcimem(u132, roothub.status, &rh_status);
-        *desc = cpu_to_le32(rh_status);
-        return ret_status;
-}
-
-static int u132_roothub_portstatus(struct u132 *u132, __le32 *desc, u16 wIndex)
-{
-        if (wIndex == 0 || wIndex > u132->num_ports) {
-                return -EINVAL;
-        } else {
-                int port = wIndex - 1;
-                u32 rh_portstatus = -1;
-                int ret_portstatus = u132_read_pcimem(u132,
-                        roothub.portstatus[port], &rh_portstatus);
-                *desc = cpu_to_le32(rh_portstatus);
-                if (*(u16 *) (desc + 2)) {
-                        dev_info(&u132->platform_dev->dev, "Port %d Status Chan"
-                                "ge = %08X\n", port, *desc);
-                }
-                return ret_portstatus;
-        }
-}
-
-
-/* this timer value might be vendor-specific ... */
-#define PORT_RESET_HW_MSEC 10
-#define PORT_RESET_MSEC 10
-/* wrap-aware logic morphed from <linux/jiffies.h> */
-#define tick_before(t1, t2) ((s16)(((s16)(t1))-((s16)(t2))) < 0)
-static int u132_roothub_portreset(struct u132 *u132, int port_index)
-{
-        int retval;
-        u32 fmnumber;
-        u16 now;
-        u16 reset_done;
-        retval = u132_read_pcimem(u132, fmnumber, &fmnumber);
-        if (retval)
-                return retval;
-        now = fmnumber;
-        reset_done = now + PORT_RESET_MSEC;
-        do {
-                u32 portstat;
-                do {
-                        retval = u132_read_pcimem(u132,
-                                roothub.portstatus[port_index], &portstat);
-                        if (retval)
-                                return retval;
-                        if (RH_PS_PRS & portstat) {
-                                continue;
-                        } else
-                                break;
-                } while (tick_before(now, reset_done));
-                if (RH_PS_PRS & portstat)
-                        return -ENODEV;
-                if (RH_PS_CCS & portstat) {
-                        if (RH_PS_PRSC & portstat) {
-                                retval = u132_write_pcimem(u132,
-                                        roothub.portstatus[port_index],
-                                        RH_PS_PRSC);
-                                if (retval)
-                                        return retval;
-                        }
-                } else
-                        break;        /* start the next reset,
-                                sleep till it's probably done */
-                retval = u132_write_pcimem(u132, roothub.portstatus[port_index],
-                         RH_PS_PRS);
-                if (retval)
-                        return retval;
-                msleep(PORT_RESET_HW_MSEC);
-                retval = u132_read_pcimem(u132, fmnumber, &fmnumber);
-                if (retval)
-                        return retval;
-                now = fmnumber;
-        } while (tick_before(now, reset_done));
-        return 0;
-}
-
-static int u132_roothub_setportfeature(struct u132 *u132, u16 wValue,
-        u16 wIndex)
-{
-        if (wIndex == 0 || wIndex > u132->num_ports) {
-                return -EINVAL;
-        } else {
-                int retval;
-                int port_index = wIndex - 1;
-                struct u132_port *port = &u132->port[port_index];
-                port->Status &= ~(1 << wValue);
-                switch (wValue) {
-                case USB_PORT_FEAT_SUSPEND:
-                        retval = u132_write_pcimem(u132,
-                                roothub.portstatus[port_index], RH_PS_PSS);
-                        if (retval)
-                                return retval;
-                        return 0;
-                case USB_PORT_FEAT_POWER:
-                        retval = u132_write_pcimem(u132,
-                                roothub.portstatus[port_index], RH_PS_PPS);
-                        if (retval)
-                                return retval;
-                        return 0;
-                case USB_PORT_FEAT_RESET:
-                        retval = u132_roothub_portreset(u132, port_index);
-                        if (retval)
-                                return retval;
-                        return 0;
-                default:
-                        return -EPIPE;
-                }
-        }
-}
-
-static int u132_roothub_clearportfeature(struct u132 *u132, u16 wValue,
-        u16 wIndex)
-{
-        if (wIndex == 0 || wIndex > u132->num_ports) {
-                return -EINVAL;
-        } else {
-                int port_index = wIndex - 1;
-                u32 temp;
-                int retval;
-                struct u132_port *port = &u132->port[port_index];
-                port->Status &= ~(1 << wValue);
-                switch (wValue) {
-                case USB_PORT_FEAT_ENABLE:
-                        temp = RH_PS_CCS;
-                        break;
-                case USB_PORT_FEAT_C_ENABLE:
-                        temp = RH_PS_PESC;
-                        break;
-                case USB_PORT_FEAT_SUSPEND:
-                        temp = RH_PS_POCI;
-                        if ((u132->hc_control & OHCI_CTRL_HCFS)
-                                != OHCI_USB_OPER) {
-                                dev_err(&u132->platform_dev->dev, "TODO resume_"
-                                        "root_hub\n");
-                        }
-                        break;
-                case USB_PORT_FEAT_C_SUSPEND:
-                        temp = RH_PS_PSSC;
-                        break;
-                case USB_PORT_FEAT_POWER:
-                        temp = RH_PS_LSDA;
-                        break;
-                case USB_PORT_FEAT_C_CONNECTION:
-                        temp = RH_PS_CSC;
-                        break;
-                case USB_PORT_FEAT_C_OVER_CURRENT:
-                        temp = RH_PS_OCIC;
-                        break;
-                case USB_PORT_FEAT_C_RESET:
-                        temp = RH_PS_PRSC;
-                        break;
-                default:
-                        return -EPIPE;
-                }
-                retval = u132_write_pcimem(u132, roothub.portstatus[port_index],
-                         temp);
-                if (retval)
-                        return retval;
-                return 0;
-        }
-}
-
-
-/* the virtual root hub timer IRQ checks for hub status*/
-static int u132_hub_status_data(struct usb_hcd *hcd, char *buf)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device hcd=%p has been remov"
-                        "ed %d\n", hcd, u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device hcd=%p is being remov"
-                        "ed\n", hcd);
-                return -ESHUTDOWN;
-        } else {
-                int i, changed = 0, length = 1;
-                if (u132->flags & OHCI_QUIRK_AMD756) {
-                        if ((u132->hc_roothub_a & RH_A_NDP) > MAX_ROOT_PORTS) {
-                                dev_err(&u132->platform_dev->dev, "bogus NDP, r"
-                                        "ereads as NDP=%d\n",
-                                        u132->hc_roothub_a & RH_A_NDP);
-                                goto done;
-                        }
-                }
-                if (u132->hc_roothub_status & (RH_HS_LPSC | RH_HS_OCIC)) {
-                        buf[0] = changed = 1;
-                } else
-                        buf[0] = 0;
-                if (u132->num_ports > 7) {
-                        buf[1] = 0;
-                        length++;
-                }
-                for (i = 0; i < u132->num_ports; i++) {
-                        if (u132->hc_roothub_portstatus[i] & (RH_PS_CSC |
-                                RH_PS_PESC | RH_PS_PSSC | RH_PS_OCIC |
-                                RH_PS_PRSC)) {
-                                changed = 1;
-                                if (i < 7) {
-                                        buf[0] |= 1 << (i + 1);
-                                } else
-                                        buf[1] |= 1 << (i - 7);
-                                continue;
-                        }
-                        if (!(u132->hc_roothub_portstatus[i] & RH_PS_CCS)) {
-                                continue;
-                        }
-                        if ((u132->hc_roothub_portstatus[i] & RH_PS_PSS)) {
-                                continue;
-                        }
-                }
-              done:return changed ? length : 0;
-        }
-}
-
-static int u132_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
-        u16 wIndex, char *buf, u16 wLength)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else {
-                int retval = 0;
-                down(&u132->sw_lock);
-                switch (typeReq) {
-                case ClearHubFeature:
-                        switch (wValue) {
-                        case C_HUB_OVER_CURRENT:
-                        case C_HUB_LOCAL_POWER:
-                                break;
-                        default:
-                                goto stall;
-                        }
-                        break;
-                case SetHubFeature:
-                        switch (wValue) {
-                        case C_HUB_OVER_CURRENT:
-                        case C_HUB_LOCAL_POWER:
-                                break;
-                        default:
-                                goto stall;
-                        }
-                        break;
-                case ClearPortFeature:{
-                                retval = u132_roothub_clearportfeature(u132,
-                                        wValue, wIndex);
-                                if (retval)
-                                        goto error;
-                                break;
-                        }
-                case GetHubDescriptor:{
-                                retval = u132_roothub_descriptor(u132,
-                                        (struct usb_hub_descriptor *)buf);
-                                if (retval)
-                                        goto error;
-                                break;
-                        }
-                case GetHubStatus:{
-                                retval = u132_roothub_status(u132,
-                                        (__le32 *) buf);
-                                if (retval)
-                                        goto error;
-                                break;
-                        }
-                case GetPortStatus:{
-                                retval = u132_roothub_portstatus(u132,
-                                        (__le32 *) buf, wIndex);
-                                if (retval)
-                                        goto error;
-                                break;
-                        }
-                case SetPortFeature:{
-                                retval = u132_roothub_setportfeature(u132,
-                                        wValue, wIndex);
-                                if (retval)
-                                        goto error;
-                                break;
-                        }
-                default:
-                        goto stall;
-                      error:u132_disable(u132);
-                        u132->going = 1;
-                        break;
-                      stall:retval = -EPIPE;
-                        break;
-                }
-                up(&u132->sw_lock);
-                return retval;
-        }
-}
-
-static int u132_start_port_reset(struct usb_hcd *hcd, unsigned port_num)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else
-                return 0;
-}
-
-static void u132_hub_irq_enable(struct usb_hcd *hcd)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-        } else if (u132->going > 0)
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-}
-
-
-#ifdef CONFIG_PM
-static int u132_hcd_suspend(struct usb_hcd *hcd, pm_message_t message)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else
-                return 0;
-}
-
-static int u132_hcd_resume(struct usb_hcd *hcd)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else
-                return 0;
-}
-
-static int u132_bus_suspend(struct usb_hcd *hcd)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else
-                return 0;
-}
-
-static int u132_bus_resume(struct usb_hcd *hcd)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else
-                return 0;
-}
-
-#else
-#define u132_hcd_suspend NULL
-#define u132_hcd_resume NULL
-#define u132_bus_suspend NULL
-#define u132_bus_resume NULL
-#endif
-static struct hc_driver u132_hc_driver = {
-        .description = hcd_name,
-        .hcd_priv_size = sizeof(struct u132),
-        .irq = NULL,
-        .flags = HCD_USB11 | HCD_MEMORY,
-        .reset = u132_hcd_reset,
-        .start = u132_hcd_start,
-        .suspend = u132_hcd_suspend,
-        .resume = u132_hcd_resume,
-        .stop = u132_hcd_stop,
-        .urb_enqueue = u132_urb_enqueue,
-        .urb_dequeue = u132_urb_dequeue,
-        .endpoint_disable = u132_endpoint_disable,
-        .get_frame_number = u132_get_frame,
-        .hub_status_data = u132_hub_status_data,
-        .hub_control = u132_hub_control,
-        .bus_suspend = u132_bus_suspend,
-        .bus_resume = u132_bus_resume,
-        .start_port_reset = u132_start_port_reset,
-        .hub_irq_enable = u132_hub_irq_enable,
-};
-
-/*
-* This function may be called by the USB core whilst the "usb_all_devices_rwsem"
-* is held for writing, thus this module must not call usb_remove_hcd()
-* synchronously - but instead should immediately stop activity to the
-* device and asynchronously call usb_remove_hcd()
-*/
-static int __devexit u132_remove(struct platform_device *pdev)
-{
-        struct usb_hcd *hcd = platform_get_drvdata(pdev);
-        if (hcd) {
-                struct u132 *u132 = hcd_to_u132(hcd);
-                if (u132->going++ > 1) {
-                        dev_err(&u132->platform_dev->dev, "already being remove"
-				"d\n");
-                        return -ENODEV;
-                } else {
-                        int rings = MAX_U132_RINGS;
-                        int endps = MAX_U132_ENDPS;
-                        dev_err(&u132->platform_dev->dev, "removing device u132"
-				".%d\n", u132->sequence_num);
-                        msleep(100);
-                        down(&u132->sw_lock);
-                        u132_monitor_cancel_work(u132);
-                        while (rings-- > 0) {
-                                struct u132_ring *ring = &u132->ring[rings];
-                                u132_ring_cancel_work(u132, ring);
-                        } while (endps-- > 0) {
-                                struct u132_endp *endp = u132->endp[endps];
-                                if (endp)
-                                        u132_endp_cancel_work(u132, endp);
-                        }
-                        u132->going += 1;
-                        printk(KERN_INFO "removing device u132.%d\n",
-                                u132->sequence_num);
-                        up(&u132->sw_lock);
-                        usb_remove_hcd(hcd);
-                        u132_u132_put_kref(u132);
-                        return 0;
-                }
-        } else
-                return 0;
-}
-
-static void u132_initialise(struct u132 *u132, struct platform_device *pdev)
-{
-        int rings = MAX_U132_RINGS;
-        int ports = MAX_U132_PORTS;
-        int addrs = MAX_U132_ADDRS;
-        int udevs = MAX_U132_UDEVS;
-        int endps = MAX_U132_ENDPS;
-        u132->board = pdev->dev.platform_data;
-        u132->platform_dev = pdev;
-        u132->power = 0;
-        u132->reset = 0;
-        init_MUTEX(&u132->sw_lock);
-        init_MUTEX(&u132->scheduler_lock);
-        while (rings-- > 0) {
-                struct u132_ring *ring = &u132->ring[rings];
-                ring->u132 = u132;
-                ring->number = rings + 1;
-                ring->length = 0;
-                ring->curr_endp = NULL;
-                INIT_DELAYED_WORK(&ring->scheduler,
-				  u132_hcd_ring_work_scheduler);
-        } down(&u132->sw_lock);
-        INIT_DELAYED_WORK(&u132->monitor, u132_hcd_monitor_work);
-        while (ports-- > 0) {
-                struct u132_port *port = &u132->port[ports];
-                port->u132 = u132;
-                port->reset = 0;
-                port->enable = 0;
-                port->power = 0;
-                port->Status = 0;
-        } while (addrs-- > 0) {
-                struct u132_addr *addr = &u132->addr[addrs];
-                addr->address = 0;
-        } while (udevs-- > 0) {
-                struct u132_udev *udev = &u132->udev[udevs];
-                int i = ARRAY_SIZE(udev->endp_number_in);
-                int o = ARRAY_SIZE(udev->endp_number_out);
-                udev->usb_device = NULL;
-                udev->udev_number = 0;
-                udev->usb_addr = 0;
-                udev->portnumber = 0;
-                while (i-- > 0) {
-                        udev->endp_number_in[i] = 0;
-                }
-                while (o-- > 0) {
-                        udev->endp_number_out[o] = 0;
-                }
-        }
-        while (endps-- > 0) {
-                u132->endp[endps] = NULL;
-        }
-        up(&u132->sw_lock);
-        return;
-}
-
-static int __devinit u132_probe(struct platform_device *pdev)
-{
-        struct usb_hcd *hcd;
-        int retval;
-        u32 control;
-        u32 rh_a = -1;
-        u32 num_ports;
-        msleep(100);
-        if (u132_exiting > 0) {
-                return -ENODEV;
-        }
-        retval = ftdi_write_pcimem(pdev, intrdisable, OHCI_INTR_MIE);
-        if (retval)
-                return retval;
-        retval = ftdi_read_pcimem(pdev, control, &control);
-        if (retval)
-                return retval;
-        retval = ftdi_read_pcimem(pdev, roothub.a, &rh_a);
-        if (retval)
-                return retval;
-        num_ports = rh_a & RH_A_NDP;        /* refuse to confuse usbcore */
-        if (pdev->dev.dma_mask) {
-                return -EINVAL;
-        }
-        hcd = usb_create_hcd(&u132_hc_driver, &pdev->dev, pdev->dev.bus_id);
-        if (!hcd) {
-                printk(KERN_ERR "failed to create the usb hcd struct for U132\n"
-                        );
-                ftdi_elan_gone_away(pdev);
-                return -ENOMEM;
-        } else {
-                int retval = 0;
-                struct u132 *u132 = hcd_to_u132(hcd);
-                hcd->rsrc_start = 0;
-                mutex_lock(&u132_module_lock);
-                list_add_tail(&u132->u132_list, &u132_static_list);
-                u132->sequence_num = ++u132_instances;
-                mutex_unlock(&u132_module_lock);
-                u132_u132_init_kref(u132);
-                u132_initialise(u132, pdev);
-                hcd->product_desc = "ELAN U132 Host Controller";
-                retval = usb_add_hcd(hcd, 0, 0);
-                if (retval != 0) {
-                        dev_err(&u132->platform_dev->dev, "init error %d\n",
-                                retval);
-                        u132_u132_put_kref(u132);
-                        return retval;
-                } else {
-                        u132_monitor_queue_work(u132, 100);
-                        return 0;
-                }
-        }
-}
-
-
-#ifdef CONFIG_PM
-/* for this device there's no useful distinction between the controller
-* and its root hub, except that the root hub only gets direct PM calls
-* when CONFIG_USB_SUSPEND is enabled.
-*/
-static int u132_suspend(struct platform_device *pdev, pm_message_t state)
-{
-        struct usb_hcd *hcd = platform_get_drvdata(pdev);
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else {
-                int retval = 0;
-                if (state.event == PM_EVENT_FREEZE) {
-                        retval = u132_bus_suspend(hcd);
-                } else if (state.event == PM_EVENT_SUSPEND) {
-                        int ports = MAX_U132_PORTS;
-                        while (ports-- > 0) {
-                                port_power(u132, ports, 0);
-                        }
-                }
-                if (retval == 0)
-                        pdev->dev.power.power_state = state;
-                return retval;
-        }
-}
-
-static int u132_resume(struct platform_device *pdev)
-{
-        struct usb_hcd *hcd = platform_get_drvdata(pdev);
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else {
-                int retval = 0;
-                if (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {
-                        int ports = MAX_U132_PORTS;
-                        while (ports-- > 0) {
-                                port_power(u132, ports, 1);
-                        }
-                        retval = 0;
-                } else {
-                        pdev->dev.power.power_state = PMSG_ON;
-                        retval = u132_bus_resume(hcd);
-                }
-                return retval;
-        }
-}
-
-#else
-#define u132_suspend NULL
-#define u132_resume NULL
-#endif
-/*
-* this driver is loaded explicitly by ftdi_u132
-*
-* the platform_driver struct is static because it is per type of module
-*/
-static struct platform_driver u132_platform_driver = {
-        .probe = u132_probe,
-        .remove = __devexit_p(u132_remove),
-        .suspend = u132_suspend,
-        .resume = u132_resume,
-        .driver = {
-                   .name = (char *)hcd_name,
-                   .owner = THIS_MODULE,
-                   },
-};
-static int __init u132_hcd_init(void)
-{
-        int retval;
-        INIT_LIST_HEAD(&u132_static_list);
-        u132_instances = 0;
-        u132_exiting = 0;
-        mutex_init(&u132_module_lock);
-        if (usb_disabled())
-                return -ENODEV;
-        printk(KERN_INFO "driver %s built at %s on %s\n", hcd_name, __TIME__,
-                __DATE__);
-        workqueue = create_singlethread_workqueue("u132");
-        retval = platform_driver_register(&u132_platform_driver);
-        return retval;
-}
-
-
-module_init(u132_hcd_init);
-static void __exit u132_hcd_exit(void)
-{
-        struct u132 *u132;
-        struct u132 *temp;
-        mutex_lock(&u132_module_lock);
-        u132_exiting += 1;
-        mutex_unlock(&u132_module_lock);
-        list_for_each_entry_safe(u132, temp, &u132_static_list, u132_list) {
-                platform_device_unregister(u132->platform_dev);
-        } platform_driver_unregister(&u132_platform_driver);
-        printk(KERN_INFO "u132-hcd driver deregistered\n");
-        wait_event(u132_hcd_wait, u132_instances == 0);
-        flush_workqueue(workqueue);
-        destroy_workqueue(workqueue);
-}
-
-
-module_exit(u132_hcd_exit);
-MODULE_LICENSE("GPL");
diff -urN host/.svn/text-base/uhci-debug.c.svn-base host.new/.svn/text-base/uhci-debug.c.svn-base
--- host/.svn/text-base/uhci-debug.c.svn-base	2009-02-24 19:00:15.999939960 +0100
+++ host.new/.svn/text-base/uhci-debug.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,592 +0,0 @@
-/*
- * UHCI-specific debugging code. Invaluable when something
- * goes wrong, but don't get in my face.
- *
- * Kernel visible pointers are surrounded in []s and bus
- * visible pointers are surrounded in ()s
- *
- * (C) Copyright 1999 Linus Torvalds
- * (C) Copyright 1999-2001 Johannes Erdfelt
- */
-
-#include <linux/kernel.h>
-#include <linux/debugfs.h>
-#include <linux/smp_lock.h>
-#include <asm/io.h>
-
-#include "uhci-hcd.h"
-
-#define uhci_debug_operations (* (const struct file_operations *) NULL)
-static struct dentry *uhci_debugfs_root;
-
-#ifdef DEBUG
-
-/* Handle REALLY large printks so we don't overflow buffers */
-static void lprintk(char *buf)
-{
-	char *p;
-
-	/* Just write one line at a time */
-	while (buf) {
-		p = strchr(buf, '\n');
-		if (p)
-			*p = 0;
-		printk(KERN_DEBUG "%s\n", buf);
-		buf = p;
-		if (buf)
-			buf++;
-	}
-}
-
-static int uhci_show_td(struct uhci_td *td, char *buf, int len, int space)
-{
-	char *out = buf;
-	char *spid;
-	u32 status, token;
-
-	/* Try to make sure there's enough memory */
-	if (len < 160)
-		return 0;
-
-	status = td_status(td);
-	out += sprintf(out, "%*s[%p] link (%08x) ", space, "", td, le32_to_cpu(td->link));
-	out += sprintf(out, "e%d %s%s%s%s%s%s%s%s%s%sLength=%x ",
-		((status >> 27) & 3),
-		(status & TD_CTRL_SPD) ?      "SPD " : "",
-		(status & TD_CTRL_LS) ?       "LS " : "",
-		(status & TD_CTRL_IOC) ?      "IOC " : "",
-		(status & TD_CTRL_ACTIVE) ?   "Active " : "",
-		(status & TD_CTRL_STALLED) ?  "Stalled " : "",
-		(status & TD_CTRL_DBUFERR) ?  "DataBufErr " : "",
-		(status & TD_CTRL_BABBLE) ?   "Babble " : "",
-		(status & TD_CTRL_NAK) ?      "NAK " : "",
-		(status & TD_CTRL_CRCTIMEO) ? "CRC/Timeo " : "",
-		(status & TD_CTRL_BITSTUFF) ? "BitStuff " : "",
-		status & 0x7ff);
-
-	token = td_token(td);
-	switch (uhci_packetid(token)) {
-		case USB_PID_SETUP:
-			spid = "SETUP";
-			break;
-		case USB_PID_OUT:
-			spid = "OUT";
-			break;
-		case USB_PID_IN:
-			spid = "IN";
-			break;
-		default:
-			spid = "?";
-			break;
-	}
-
-	out += sprintf(out, "MaxLen=%x DT%d EndPt=%x Dev=%x, PID=%x(%s) ",
-		token >> 21,
-		((token >> 19) & 1),
-		(token >> 15) & 15,
-		(token >> 8) & 127,
-		(token & 0xff),
-		spid);
-	out += sprintf(out, "(buf=%08x)\n", le32_to_cpu(td->buffer));
-
-	return out - buf;
-}
-
-static int uhci_show_urbp(struct urb_priv *urbp, char *buf, int len, int space)
-{
-	char *out = buf;
-	struct uhci_td *td;
-	int i, nactive, ninactive;
-	char *ptype;
-
-	if (len < 200)
-		return 0;
-
-	out += sprintf(out, "urb_priv [%p] ", urbp);
-	out += sprintf(out, "urb [%p] ", urbp->urb);
-	out += sprintf(out, "qh [%p] ", urbp->qh);
-	out += sprintf(out, "Dev=%d ", usb_pipedevice(urbp->urb->pipe));
-	out += sprintf(out, "EP=%x(%s) ", usb_pipeendpoint(urbp->urb->pipe),
-			(usb_pipein(urbp->urb->pipe) ? "IN" : "OUT"));
-
-	switch (usb_pipetype(urbp->urb->pipe)) {
-	case PIPE_ISOCHRONOUS: ptype = "ISO"; break;
-	case PIPE_INTERRUPT: ptype = "INT"; break;
-	case PIPE_BULK: ptype = "BLK"; break;
-	default:
-	case PIPE_CONTROL: ptype = "CTL"; break;
-	}
-
-	out += sprintf(out, "%s%s", ptype, (urbp->fsbr ? " FSBR" : ""));
-	out += sprintf(out, " Actlen=%d", urbp->urb->actual_length);
-
-	if (urbp->urb->status != -EINPROGRESS)
-		out += sprintf(out, " Status=%d", urbp->urb->status);
-	out += sprintf(out, "\n");
-
-	i = nactive = ninactive = 0;
-	list_for_each_entry(td, &urbp->td_list, list) {
-		if (urbp->qh->type != USB_ENDPOINT_XFER_ISOC &&
-				(++i <= 10 || debug > 2)) {
-			out += sprintf(out, "%*s%d: ", space + 2, "", i);
-			out += uhci_show_td(td, out, len - (out - buf), 0);
-		} else {
-			if (td_status(td) & TD_CTRL_ACTIVE)
-				++nactive;
-			else
-				++ninactive;
-		}
-	}
-	if (nactive + ninactive > 0)
-		out += sprintf(out, "%*s[skipped %d inactive and %d active "
-				"TDs]\n",
-				space, "", ninactive, nactive);
-
-	return out - buf;
-}
-
-static int uhci_show_qh(struct uhci_hcd *uhci,
-		struct uhci_qh *qh, char *buf, int len, int space)
-{
-	char *out = buf;
-	int i, nurbs;
-	__le32 element = qh_element(qh);
-	char *qtype;
-
-	/* Try to make sure there's enough memory */
-	if (len < 80 * 7)
-		return 0;
-
-	switch (qh->type) {
-	case USB_ENDPOINT_XFER_ISOC: qtype = "ISO"; break;
-	case USB_ENDPOINT_XFER_INT: qtype = "INT"; break;
-	case USB_ENDPOINT_XFER_BULK: qtype = "BLK"; break;
-	case USB_ENDPOINT_XFER_CONTROL: qtype = "CTL"; break;
-	default: qtype = "Skel" ; break;
-	}
-
-	out += sprintf(out, "%*s[%p] %s QH link (%08x) element (%08x)\n",
-			space, "", qh, qtype,
-			le32_to_cpu(qh->link), le32_to_cpu(element));
-	if (qh->type == USB_ENDPOINT_XFER_ISOC)
-		out += sprintf(out, "%*s    period %d phase %d load %d us, "
-				"frame %x desc [%p]\n",
-				space, "", qh->period, qh->phase, qh->load,
-				qh->iso_frame, qh->iso_packet_desc);
-	else if (qh->type == USB_ENDPOINT_XFER_INT)
-		out += sprintf(out, "%*s    period %d phase %d load %d us\n",
-				space, "", qh->period, qh->phase, qh->load);
-
-	if (element & UHCI_PTR_QH)
-		out += sprintf(out, "%*s  Element points to QH (bug?)\n", space, "");
-
-	if (element & UHCI_PTR_DEPTH)
-		out += sprintf(out, "%*s  Depth traverse\n", space, "");
-
-	if (element & cpu_to_le32(8))
-		out += sprintf(out, "%*s  Bit 3 set (bug?)\n", space, "");
-
-	if (!(element & ~(UHCI_PTR_QH | UHCI_PTR_DEPTH)))
-		out += sprintf(out, "%*s  Element is NULL (bug?)\n", space, "");
-
-	if (list_empty(&qh->queue)) {
-		out += sprintf(out, "%*s  queue is empty\n", space, "");
-		if (qh == uhci->skel_async_qh)
-			out += uhci_show_td(uhci->term_td, out,
-					len - (out - buf), 0);
-	} else {
-		struct urb_priv *urbp = list_entry(qh->queue.next,
-				struct urb_priv, node);
-		struct uhci_td *td = list_entry(urbp->td_list.next,
-				struct uhci_td, list);
-
-		if (element != LINK_TO_TD(td))
-			out += sprintf(out, "%*s Element != First TD\n",
-					space, "");
-		i = nurbs = 0;
-		list_for_each_entry(urbp, &qh->queue, node) {
-			if (++i <= 10)
-				out += uhci_show_urbp(urbp, out,
-						len - (out - buf), space + 2);
-			else
-				++nurbs;
-		}
-		if (nurbs > 0)
-			out += sprintf(out, "%*s Skipped %d URBs\n",
-					space, "", nurbs);
-	}
-
-	if (qh->dummy_td) {
-		out += sprintf(out, "%*s  Dummy TD\n", space, "");
-		out += uhci_show_td(qh->dummy_td, out, len - (out - buf), 0);
-	}
-
-	return out - buf;
-}
-
-static int uhci_show_sc(int port, unsigned short status, char *buf, int len)
-{
-	char *out = buf;
-
-	/* Try to make sure there's enough memory */
-	if (len < 160)
-		return 0;
-
-	out += sprintf(out, "  stat%d     =     %04x  %s%s%s%s%s%s%s%s%s%s\n",
-		port,
-		status,
-		(status & USBPORTSC_SUSP) ?	" Suspend" : "",
-		(status & USBPORTSC_OCC) ?	" OverCurrentChange" : "",
-		(status & USBPORTSC_OC) ?	" OverCurrent" : "",
-		(status & USBPORTSC_PR) ?	" Reset" : "",
-		(status & USBPORTSC_LSDA) ?	" LowSpeed" : "",
-		(status & USBPORTSC_RD) ?	" ResumeDetect" : "",
-		(status & USBPORTSC_PEC) ?	" EnableChange" : "",
-		(status & USBPORTSC_PE) ?	" Enabled" : "",
-		(status & USBPORTSC_CSC) ?	" ConnectChange" : "",
-		(status & USBPORTSC_CCS) ?	" Connected" : "");
-
-	return out - buf;
-}
-
-static int uhci_show_root_hub_state(struct uhci_hcd *uhci, char *buf, int len)
-{
-	char *out = buf;
-	char *rh_state;
-
-	/* Try to make sure there's enough memory */
-	if (len < 60)
-		return 0;
-
-	switch (uhci->rh_state) {
-	    case UHCI_RH_RESET:
-		rh_state = "reset";		break;
-	    case UHCI_RH_SUSPENDED:
-		rh_state = "suspended";		break;
-	    case UHCI_RH_AUTO_STOPPED:
-		rh_state = "auto-stopped";	break;
-	    case UHCI_RH_RESUMING:
-		rh_state = "resuming";		break;
-	    case UHCI_RH_SUSPENDING:
-		rh_state = "suspending";	break;
-	    case UHCI_RH_RUNNING:
-		rh_state = "running";		break;
-	    case UHCI_RH_RUNNING_NODEVS:
-		rh_state = "running, no devs";	break;
-	    default:
-		rh_state = "?";			break;
-	}
-	out += sprintf(out, "Root-hub state: %s   FSBR: %d\n",
-			rh_state, uhci->fsbr_is_on);
-	return out - buf;
-}
-
-static int uhci_show_status(struct uhci_hcd *uhci, char *buf, int len)
-{
-	char *out = buf;
-	unsigned long io_addr = uhci->io_addr;
-	unsigned short usbcmd, usbstat, usbint, usbfrnum;
-	unsigned int flbaseadd;
-	unsigned char sof;
-	unsigned short portsc1, portsc2;
-
-	/* Try to make sure there's enough memory */
-	if (len < 80 * 9)
-		return 0;
-
-	usbcmd    = inw(io_addr + 0);
-	usbstat   = inw(io_addr + 2);
-	usbint    = inw(io_addr + 4);
-	usbfrnum  = inw(io_addr + 6);
-	flbaseadd = inl(io_addr + 8);
-	sof       = inb(io_addr + 12);
-	portsc1   = inw(io_addr + 16);
-	portsc2   = inw(io_addr + 18);
-
-	out += sprintf(out, "  usbcmd    =     %04x   %s%s%s%s%s%s%s%s\n",
-		usbcmd,
-		(usbcmd & USBCMD_MAXP) ?    "Maxp64 " : "Maxp32 ",
-		(usbcmd & USBCMD_CF) ?      "CF " : "",
-		(usbcmd & USBCMD_SWDBG) ?   "SWDBG " : "",
-		(usbcmd & USBCMD_FGR) ?     "FGR " : "",
-		(usbcmd & USBCMD_EGSM) ?    "EGSM " : "",
-		(usbcmd & USBCMD_GRESET) ?  "GRESET " : "",
-		(usbcmd & USBCMD_HCRESET) ? "HCRESET " : "",
-		(usbcmd & USBCMD_RS) ?      "RS " : "");
-
-	out += sprintf(out, "  usbstat   =     %04x   %s%s%s%s%s%s\n",
-		usbstat,
-		(usbstat & USBSTS_HCH) ?    "HCHalted " : "",
-		(usbstat & USBSTS_HCPE) ?   "HostControllerProcessError " : "",
-		(usbstat & USBSTS_HSE) ?    "HostSystemError " : "",
-		(usbstat & USBSTS_RD) ?     "ResumeDetect " : "",
-		(usbstat & USBSTS_ERROR) ?  "USBError " : "",
-		(usbstat & USBSTS_USBINT) ? "USBINT " : "");
-
-	out += sprintf(out, "  usbint    =     %04x\n", usbint);
-	out += sprintf(out, "  usbfrnum  =   (%d)%03x\n", (usbfrnum >> 10) & 1,
-		0xfff & (4*(unsigned int)usbfrnum));
-	out += sprintf(out, "  flbaseadd = %08x\n", flbaseadd);
-	out += sprintf(out, "  sof       =       %02x\n", sof);
-	out += uhci_show_sc(1, portsc1, out, len - (out - buf));
-	out += uhci_show_sc(2, portsc2, out, len - (out - buf));
-	out += sprintf(out, "Most recent frame: %x (%d)   "
-			"Last ISO frame: %x (%d)\n",
-			uhci->frame_number, uhci->frame_number & 1023,
-			uhci->last_iso_frame, uhci->last_iso_frame & 1023);
-
-	return out - buf;
-}
-
-static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
-{
-	char *out = buf;
-	int i, j;
-	struct uhci_qh *qh;
-	struct uhci_td *td;
-	struct list_head *tmp, *head;
-	int nframes, nerrs;
-	__le32 link;
-	__le32 fsbr_link;
-
-	static const char * const qh_names[] = {
-		"unlink", "iso", "int128", "int64", "int32", "int16",
-		"int8", "int4", "int2", "async", "term"
-	};
-
-	out += uhci_show_root_hub_state(uhci, out, len - (out - buf));
-	out += sprintf(out, "HC status\n");
-	out += uhci_show_status(uhci, out, len - (out - buf));
-
-	out += sprintf(out, "Periodic load table\n");
-	for (i = 0; i < MAX_PHASE; ++i) {
-		out += sprintf(out, "\t%d", uhci->load[i]);
-		if (i % 8 == 7)
-			*out++ = '\n';
-	}
-	out += sprintf(out, "Total: %d, #INT: %d, #ISO: %d\n",
-			uhci->total_load,
-			uhci_to_hcd(uhci)->self.bandwidth_int_reqs,
-			uhci_to_hcd(uhci)->self.bandwidth_isoc_reqs);
-	if (debug <= 1)
-		return out - buf;
-
-	out += sprintf(out, "Frame List\n");
-	nframes = 10;
-	nerrs = 0;
-	for (i = 0; i < UHCI_NUMFRAMES; ++i) {
-		__le32 qh_dma;
-
-		j = 0;
-		td = uhci->frame_cpu[i];
-		link = uhci->frame[i];
-		if (!td)
-			goto check_link;
-
-		if (nframes > 0) {
-			out += sprintf(out, "- Frame %d -> (%08x)\n",
-					i, le32_to_cpu(link));
-			j = 1;
-		}
-
-		head = &td->fl_list;
-		tmp = head;
-		do {
-			td = list_entry(tmp, struct uhci_td, fl_list);
-			tmp = tmp->next;
-			if (link != LINK_TO_TD(td)) {
-				if (nframes > 0)
-					out += sprintf(out, "    link does "
-						"not match list entry!\n");
-				else
-					++nerrs;
-			}
-			if (nframes > 0)
-				out += uhci_show_td(td, out,
-						len - (out - buf), 4);
-			link = td->link;
-		} while (tmp != head);
-
-check_link:
-		qh_dma = uhci_frame_skel_link(uhci, i);
-		if (link != qh_dma) {
-			if (nframes > 0) {
-				if (!j) {
-					out += sprintf(out,
-						"- Frame %d -> (%08x)\n",
-						i, le32_to_cpu(link));
-					j = 1;
-				}
-				out += sprintf(out, "   link does not match "
-					"QH (%08x)!\n", le32_to_cpu(qh_dma));
-			} else
-				++nerrs;
-		}
-		nframes -= j;
-	}
-	if (nerrs > 0)
-		out += sprintf(out, "Skipped %d bad links\n", nerrs);
-
-	out += sprintf(out, "Skeleton QHs\n");
-
-	fsbr_link = 0;
-	for (i = 0; i < UHCI_NUM_SKELQH; ++i) {
-		int cnt = 0;
-
-		qh = uhci->skelqh[i];
-		out += sprintf(out, "- skel_%s_qh\n", qh_names[i]); \
-		out += uhci_show_qh(uhci, qh, out, len - (out - buf), 4);
-
-		/* Last QH is the Terminating QH, it's different */
-		if (i == SKEL_TERM) {
-			if (qh_element(qh) != LINK_TO_TD(uhci->term_td))
-				out += sprintf(out, "    skel_term_qh element is not set to term_td!\n");
-			link = fsbr_link;
-			if (!link)
-				link = LINK_TO_QH(uhci->skel_term_qh);
-			goto check_qh_link;
-		}
-
-		head = &qh->node;
-		tmp = head->next;
-
-		while (tmp != head) {
-			qh = list_entry(tmp, struct uhci_qh, node);
-			tmp = tmp->next;
-			if (++cnt <= 10)
-				out += uhci_show_qh(uhci, qh, out,
-						len - (out - buf), 4);
-			if (!fsbr_link && qh->skel >= SKEL_FSBR)
-				fsbr_link = LINK_TO_QH(qh);
-		}
-		if ((cnt -= 10) > 0)
-			out += sprintf(out, "    Skipped %d QHs\n", cnt);
-
-		link = UHCI_PTR_TERM;
-		if (i <= SKEL_ISO)
-			;
-		else if (i < SKEL_ASYNC)
-			link = LINK_TO_QH(uhci->skel_async_qh);
-		else if (!uhci->fsbr_is_on)
-			;
-		else
-			link = LINK_TO_QH(uhci->skel_term_qh);
-check_qh_link:
-		if (qh->link != link)
-			out += sprintf(out, "    last QH not linked to next skeleton!\n");
-	}
-
-	return out - buf;
-}
-
-#ifdef CONFIG_DEBUG_FS
-
-#define MAX_OUTPUT	(64 * 1024)
-
-struct uhci_debug {
-	int size;
-	char *data;
-};
-
-static int uhci_debug_open(struct inode *inode, struct file *file)
-{
-	struct uhci_hcd *uhci = inode->i_private;
-	struct uhci_debug *up;
-	int ret = -ENOMEM;
-	unsigned long flags;
-
-	lock_kernel();
-	up = kmalloc(sizeof(*up), GFP_KERNEL);
-	if (!up)
-		goto out;
-
-	up->data = kmalloc(MAX_OUTPUT, GFP_KERNEL);
-	if (!up->data) {
-		kfree(up);
-		goto out;
-	}
-
-	up->size = 0;
-	spin_lock_irqsave(&uhci->lock, flags);
-	if (uhci->is_initialized)
-		up->size = uhci_sprint_schedule(uhci, up->data, MAX_OUTPUT);
-	spin_unlock_irqrestore(&uhci->lock, flags);
-
-	file->private_data = up;
-
-	ret = 0;
-out:
-	unlock_kernel();
-	return ret;
-}
-
-static loff_t uhci_debug_lseek(struct file *file, loff_t off, int whence)
-{
-	struct uhci_debug *up;
-	loff_t new = -1;
-
-	lock_kernel();
-	up = file->private_data;
-
-	switch (whence) {
-	case 0:
-		new = off;
-		break;
-	case 1:
-		new = file->f_pos + off;
-		break;
-	}
-	if (new < 0 || new > up->size) {
-		unlock_kernel();
-		return -EINVAL;
-	}
-	unlock_kernel();
-	return (file->f_pos = new);
-}
-
-static ssize_t uhci_debug_read(struct file *file, char __user *buf,
-				size_t nbytes, loff_t *ppos)
-{
-	struct uhci_debug *up = file->private_data;
-	return simple_read_from_buffer(buf, nbytes, ppos, up->data, up->size);
-}
-
-static int uhci_debug_release(struct inode *inode, struct file *file)
-{
-	struct uhci_debug *up = file->private_data;
-
-	kfree(up->data);
-	kfree(up);
-
-	return 0;
-}
-
-#undef uhci_debug_operations
-static const struct file_operations uhci_debug_operations = {
-	.owner =	THIS_MODULE,
-	.open =		uhci_debug_open,
-	.llseek =	uhci_debug_lseek,
-	.read =		uhci_debug_read,
-	.release =	uhci_debug_release,
-};
-
-#endif	/* CONFIG_DEBUG_FS */
-
-#else	/* DEBUG */
-
-static inline void lprintk(char *buf)
-{}
-
-static inline int uhci_show_qh(struct uhci_hcd *uhci,
-		struct uhci_qh *qh, char *buf, int len, int space)
-{
-	return 0;
-}
-
-static inline int uhci_sprint_schedule(struct uhci_hcd *uhci,
-		char *buf, int len)
-{
-	return 0;
-}
-
-#endif
diff -urN host/.svn/text-base/uhci-hcd.c.svn-base host.new/.svn/text-base/uhci-hcd.c.svn-base
--- host/.svn/text-base/uhci-hcd.c.svn-base	2009-02-24 19:00:16.015939146 +0100
+++ host.new/.svn/text-base/uhci-hcd.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,973 +0,0 @@
-/*
- * Universal Host Controller Interface driver for USB.
- *
- * Maintainer: Alan Stern <stern@rowland.harvard.edu>
- *
- * (C) Copyright 1999 Linus Torvalds
- * (C) Copyright 1999-2002 Johannes Erdfelt, johannes@erdfelt.com
- * (C) Copyright 1999 Randy Dunlap
- * (C) Copyright 1999 Georg Acher, acher@in.tum.de
- * (C) Copyright 1999 Deti Fliegl, deti@fliegl.de
- * (C) Copyright 1999 Thomas Sailer, sailer@ife.ee.ethz.ch
- * (C) Copyright 1999 Roman Weissgaerber, weissg@vienna.at
- * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface
- *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).
- * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)
- * (C) Copyright 2004-2007 Alan Stern, stern@rowland.harvard.edu
- *
- * Intel documents this fairly well, and as far as I know there
- * are no royalties or anything like that, but even so there are
- * people who decided that they want to do the same thing in a
- * completely different way.
- *
- */
-
-#include <linux/module.h>
-#include <linux/pci.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/ioport.h>
-#include <linux/slab.h>
-#include <linux/errno.h>
-#include <linux/unistd.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#include <linux/debugfs.h>
-#include <linux/pm.h>
-#include <linux/dmapool.h>
-#include <linux/dma-mapping.h>
-#include <linux/usb.h>
-#include <linux/bitops.h>
-#include <linux/dmi.h>
-
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/system.h>
-
-#include "../core/hcd.h"
-#include "uhci-hcd.h"
-#include "pci-quirks.h"
-
-/*
- * Version Information
- */
-#define DRIVER_VERSION "v3.0"
-#define DRIVER_AUTHOR "Linus 'Frodo Rabbit' Torvalds, Johannes Erdfelt, \
-Randy Dunlap, Georg Acher, Deti Fliegl, Thomas Sailer, Roman Weissgaerber, \
-Alan Stern"
-#define DRIVER_DESC "USB Universal Host Controller Interface driver"
-
-/* for flakey hardware, ignore overcurrent indicators */
-static int ignore_oc=1;
-module_param(ignore_oc, bool, S_IRUGO);
-MODULE_PARM_DESC(ignore_oc, "ignore hardware overcurrent indications");
-
-/*
- * debug = 0, no debugging messages
- * debug = 1, dump failed URBs except for stalls
- * debug = 2, dump all failed URBs (including stalls)
- *            show all queues in /debug/uhci/[pci_addr]
- * debug = 3, show all TDs in URBs when dumping
- */
-#ifdef DEBUG
-#define DEBUG_CONFIGURED	1
-static int debug = 1;
-module_param(debug, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(debug, "Debug level");
-
-#else
-#define DEBUG_CONFIGURED	0
-#define debug			0
-#endif
-
-static char *errbuf;
-#define ERRBUF_LEN    (32 * 1024)
-
-static struct kmem_cache *uhci_up_cachep;	/* urb_priv */
-
-static void suspend_rh(struct uhci_hcd *uhci, enum uhci_rh_state new_state);
-static void wakeup_rh(struct uhci_hcd *uhci);
-static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
-
-/*
- * Calculate the link pointer DMA value for the first Skeleton QH in a frame.
- */
-static __le32 uhci_frame_skel_link(struct uhci_hcd *uhci, int frame)
-{
-	int skelnum;
-
-	/*
-	 * The interrupt queues will be interleaved as evenly as possible.
-	 * There's not much to be done about period-1 interrupts; they have
-	 * to occur in every frame.  But we can schedule period-2 interrupts
-	 * in odd-numbered frames, period-4 interrupts in frames congruent
-	 * to 2 (mod 4), and so on.  This way each frame only has two
-	 * interrupt QHs, which will help spread out bandwidth utilization.
-	 *
-	 * ffs (Find First bit Set) does exactly what we need:
-	 * 1,3,5,...  => ffs = 0 => use period-2 QH = skelqh[8],
-	 * 2,6,10,... => ffs = 1 => use period-4 QH = skelqh[7], etc.
-	 * ffs >= 7 => not on any high-period queue, so use
-	 *	period-1 QH = skelqh[9].
-	 * Add in UHCI_NUMFRAMES to insure at least one bit is set.
-	 */
-	skelnum = 8 - (int) __ffs(frame | UHCI_NUMFRAMES);
-	if (skelnum <= 1)
-		skelnum = 9;
-	return LINK_TO_QH(uhci->skelqh[skelnum]);
-}
-
-#include "uhci-debug.c"
-#include "uhci-q.c"
-#include "uhci-hub.c"
-
-/*
- * Finish up a host controller reset and update the recorded state.
- */
-static void finish_reset(struct uhci_hcd *uhci)
-{
-	int port;
-
-	/* HCRESET doesn't affect the Suspend, Reset, and Resume Detect
-	 * bits in the port status and control registers.
-	 * We have to clear them by hand.
-	 */
-	for (port = 0; port < uhci->rh_numports; ++port)
-		outw(0, uhci->io_addr + USBPORTSC1 + (port * 2));
-
-	uhci->port_c_suspend = uhci->resuming_ports = 0;
-	uhci->rh_state = UHCI_RH_RESET;
-	uhci->is_stopped = UHCI_IS_STOPPED;
-	uhci_to_hcd(uhci)->state = HC_STATE_HALT;
-	uhci_to_hcd(uhci)->poll_rh = 0;
-
-	uhci->dead = 0;		/* Full reset resurrects the controller */
-}
-
-/*
- * Last rites for a defunct/nonfunctional controller
- * or one we don't want to use any more.
- */
-static void uhci_hc_died(struct uhci_hcd *uhci)
-{
-	uhci_get_current_frame_number(uhci);
-	uhci_reset_hc(to_pci_dev(uhci_dev(uhci)), uhci->io_addr);
-	finish_reset(uhci);
-	uhci->dead = 1;
-
-	/* The current frame may already be partway finished */
-	++uhci->frame_number;
-}
-
-/*
- * Initialize a controller that was newly discovered or has lost power
- * or otherwise been reset while it was suspended.  In none of these cases
- * can we be sure of its previous state.
- */
-static void check_and_reset_hc(struct uhci_hcd *uhci)
-{
-	if (uhci_check_and_reset_hc(to_pci_dev(uhci_dev(uhci)), uhci->io_addr))
-		finish_reset(uhci);
-}
-
-/*
- * Store the basic register settings needed by the controller.
- */
-static void configure_hc(struct uhci_hcd *uhci)
-{
-	/* Set the frame length to the default: 1 ms exactly */
-	outb(USBSOF_DEFAULT, uhci->io_addr + USBSOF);
-
-	/* Store the frame list base address */
-	outl(uhci->frame_dma_handle, uhci->io_addr + USBFLBASEADD);
-
-	/* Set the current frame number */
-	outw(uhci->frame_number & UHCI_MAX_SOF_NUMBER,
-			uhci->io_addr + USBFRNUM);
-
-	/* Mark controller as not halted before we enable interrupts */
-	uhci_to_hcd(uhci)->state = HC_STATE_SUSPENDED;
-	mb();
-
-	/* Enable PIRQ */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-			USBLEGSUP_DEFAULT);
-}
-
-
-static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
-{
-	int port;
-
-	/* If we have to ignore overcurrent events then almost by definition
-	 * we can't depend on resume-detect interrupts. */
-	if (ignore_oc)
-		return 1;
-
-	switch (to_pci_dev(uhci_dev(uhci))->vendor) {
-	    default:
-		break;
-
-	    case PCI_VENDOR_ID_GENESYS:
-		/* Genesys Logic's GL880S controllers don't generate
-		 * resume-detect interrupts.
-		 */
-		return 1;
-
-	    case PCI_VENDOR_ID_INTEL:
-		/* Some of Intel's USB controllers have a bug that causes
-		 * resume-detect interrupts if any port has an over-current
-		 * condition.  To make matters worse, some motherboards
-		 * hardwire unused USB ports' over-current inputs active!
-		 * To prevent problems, we will not enable resume-detect
-		 * interrupts if any ports are OC.
-		 */
-		for (port = 0; port < uhci->rh_numports; ++port) {
-			if (inw(uhci->io_addr + USBPORTSC1 + port * 2) &
-					USBPORTSC_OC)
-				return 1;
-		}
-		break;
-	}
-	return 0;
-}
-
-static int remote_wakeup_is_broken(struct uhci_hcd *uhci)
-{
-	int port;
-	char *sys_info;
-	static char bad_Asus_board[] = "A7V8X";
-
-	/* One of Asus's motherboards has a bug which causes it to
-	 * wake up immediately from suspend-to-RAM if any of the ports
-	 * are connected.  In such cases we will not set EGSM.
-	 */
-	sys_info = dmi_get_system_info(DMI_BOARD_NAME);
-	if (sys_info && !strcmp(sys_info, bad_Asus_board)) {
-		for (port = 0; port < uhci->rh_numports; ++port) {
-			if (inw(uhci->io_addr + USBPORTSC1 + port * 2) &
-					USBPORTSC_CCS)
-				return 1;
-		}
-	}
-
-	return 0;
-}
-
-static void suspend_rh(struct uhci_hcd *uhci, enum uhci_rh_state new_state)
-__releases(uhci->lock)
-__acquires(uhci->lock)
-{
-	int auto_stop;
-	int int_enable, egsm_enable;
-
-	auto_stop = (new_state == UHCI_RH_AUTO_STOPPED);
-	dev_dbg(&uhci_to_hcd(uhci)->self.root_hub->dev,
-			"%s%s\n", __FUNCTION__,
-			(auto_stop ? " (auto-stop)" : ""));
-
-	/* If we get a suspend request when we're already auto-stopped
-	 * then there's nothing to do.
-	 */
-	if (uhci->rh_state == UHCI_RH_AUTO_STOPPED) {
-		uhci->rh_state = new_state;
-		return;
-	}
-
-	/* Enable resume-detect interrupts if they work.
-	 * Then enter Global Suspend mode if _it_ works, still configured.
-	 */
-	egsm_enable = USBCMD_EGSM;
-	uhci->working_RD = 1;
-	int_enable = USBINTR_RESUME;
-	if (remote_wakeup_is_broken(uhci))
-		egsm_enable = 0;
-	if (resume_detect_interrupts_are_broken(uhci) || !egsm_enable ||
-			!device_may_wakeup(
-				&uhci_to_hcd(uhci)->self.root_hub->dev))
-		uhci->working_RD = int_enable = 0;
-
-	outw(int_enable, uhci->io_addr + USBINTR);
-	outw(egsm_enable | USBCMD_CF, uhci->io_addr + USBCMD);
-	mb();
-	udelay(5);
-
-	/* If we're auto-stopping then no devices have been attached
-	 * for a while, so there shouldn't be any active URBs and the
-	 * controller should stop after a few microseconds.  Otherwise
-	 * we will give the controller one frame to stop.
-	 */
-	if (!auto_stop && !(inw(uhci->io_addr + USBSTS) & USBSTS_HCH)) {
-		uhci->rh_state = UHCI_RH_SUSPENDING;
-		spin_unlock_irq(&uhci->lock);
-		msleep(1);
-		spin_lock_irq(&uhci->lock);
-		if (uhci->dead)
-			return;
-	}
-	if (!(inw(uhci->io_addr + USBSTS) & USBSTS_HCH))
-		dev_warn(&uhci_to_hcd(uhci)->self.root_hub->dev,
-			"Controller not stopped yet!\n");
-
-	uhci_get_current_frame_number(uhci);
-
-	uhci->rh_state = new_state;
-	uhci->is_stopped = UHCI_IS_STOPPED;
-	uhci_to_hcd(uhci)->poll_rh = !int_enable;
-
-	uhci_scan_schedule(uhci);
-	uhci_fsbr_off(uhci);
-}
-
-static void start_rh(struct uhci_hcd *uhci)
-{
-	uhci_to_hcd(uhci)->state = HC_STATE_RUNNING;
-	uhci->is_stopped = 0;
-
-	/* Mark it configured and running with a 64-byte max packet.
-	 * All interrupts are enabled, even though RESUME won't do anything.
-	 */
-	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, uhci->io_addr + USBCMD);
-	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
-			uhci->io_addr + USBINTR);
-	mb();
-	uhci->rh_state = UHCI_RH_RUNNING;
-	uhci_to_hcd(uhci)->poll_rh = 1;
-}
-
-static void wakeup_rh(struct uhci_hcd *uhci)
-__releases(uhci->lock)
-__acquires(uhci->lock)
-{
-	dev_dbg(&uhci_to_hcd(uhci)->self.root_hub->dev,
-			"%s%s\n", __FUNCTION__,
-			uhci->rh_state == UHCI_RH_AUTO_STOPPED ?
-				" (auto-start)" : "");
-
-	/* If we are auto-stopped then no devices are attached so there's
-	 * no need for wakeup signals.  Otherwise we send Global Resume
-	 * for 20 ms.
-	 */
-	if (uhci->rh_state == UHCI_RH_SUSPENDED) {
-		uhci->rh_state = UHCI_RH_RESUMING;
-		outw(USBCMD_FGR | USBCMD_EGSM | USBCMD_CF,
-				uhci->io_addr + USBCMD);
-		spin_unlock_irq(&uhci->lock);
-		msleep(20);
-		spin_lock_irq(&uhci->lock);
-		if (uhci->dead)
-			return;
-
-		/* End Global Resume and wait for EOP to be sent */
-		outw(USBCMD_CF, uhci->io_addr + USBCMD);
-		mb();
-		udelay(4);
-		if (inw(uhci->io_addr + USBCMD) & USBCMD_FGR)
-			dev_warn(uhci_dev(uhci), "FGR not stopped yet!\n");
-	}
-
-	start_rh(uhci);
-
-	/* Restart root hub polling */
-	mod_timer(&uhci_to_hcd(uhci)->rh_timer, jiffies);
-}
-
-static irqreturn_t uhci_irq(struct usb_hcd *hcd)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	unsigned short status;
-	unsigned long flags;
-
-	/*
-	 * Read the interrupt status, and write it back to clear the
-	 * interrupt cause.  Contrary to the UHCI specification, the
-	 * "HC Halted" status bit is persistent: it is RO, not R/WC.
-	 */
-	status = inw(uhci->io_addr + USBSTS);
-	if (!(status & ~USBSTS_HCH))	/* shared interrupt, not mine */
-		return IRQ_NONE;
-	outw(status, uhci->io_addr + USBSTS);		/* Clear it */
-
-	if (status & ~(USBSTS_USBINT | USBSTS_ERROR | USBSTS_RD)) {
-		if (status & USBSTS_HSE)
-			dev_err(uhci_dev(uhci), "host system error, "
-					"PCI problems?\n");
-		if (status & USBSTS_HCPE)
-			dev_err(uhci_dev(uhci), "host controller process "
-					"error, something bad happened!\n");
-		if (status & USBSTS_HCH) {
-			spin_lock_irqsave(&uhci->lock, flags);
-			if (uhci->rh_state >= UHCI_RH_RUNNING) {
-				dev_err(uhci_dev(uhci),
-					"host controller halted, "
-					"very bad!\n");
-				if (debug > 1 && errbuf) {
-					/* Print the schedule for debugging */
-					uhci_sprint_schedule(uhci,
-							errbuf, ERRBUF_LEN);
-					lprintk(errbuf);
-				}
-				uhci_hc_died(uhci);
-
-				/* Force a callback in case there are
-				 * pending unlinks */
-				mod_timer(&hcd->rh_timer, jiffies);
-			}
-			spin_unlock_irqrestore(&uhci->lock, flags);
-		}
-	}
-
-	if (status & USBSTS_RD)
-		usb_hcd_poll_rh_status(hcd);
-	else {
-		spin_lock_irqsave(&uhci->lock, flags);
-		uhci_scan_schedule(uhci);
-		spin_unlock_irqrestore(&uhci->lock, flags);
-	}
-
-	return IRQ_HANDLED;
-}
-
-/*
- * Store the current frame number in uhci->frame_number if the controller
- * is runnning.  Expand from 11 bits (of which we use only 10) to a
- * full-sized integer.
- *
- * Like many other parts of the driver, this code relies on being polled
- * more than once per second as long as the controller is running.
- */
-static void uhci_get_current_frame_number(struct uhci_hcd *uhci)
-{
-	if (!uhci->is_stopped) {
-		unsigned delta;
-
-		delta = (inw(uhci->io_addr + USBFRNUM) - uhci->frame_number) &
-				(UHCI_NUMFRAMES - 1);
-		uhci->frame_number += delta;
-	}
-}
-
-/*
- * De-allocate all resources
- */
-static void release_uhci(struct uhci_hcd *uhci)
-{
-	int i;
-
-	if (DEBUG_CONFIGURED) {
-		spin_lock_irq(&uhci->lock);
-		uhci->is_initialized = 0;
-		spin_unlock_irq(&uhci->lock);
-
-		debugfs_remove(uhci->dentry);
-	}
-
-	for (i = 0; i < UHCI_NUM_SKELQH; i++)
-		uhci_free_qh(uhci, uhci->skelqh[i]);
-
-	uhci_free_td(uhci, uhci->term_td);
-
-	dma_pool_destroy(uhci->qh_pool);
-
-	dma_pool_destroy(uhci->td_pool);
-
-	kfree(uhci->frame_cpu);
-
-	dma_free_coherent(uhci_dev(uhci),
-			UHCI_NUMFRAMES * sizeof(*uhci->frame),
-			uhci->frame, uhci->frame_dma_handle);
-}
-
-static int uhci_init(struct usb_hcd *hcd)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	unsigned io_size = (unsigned) hcd->rsrc_len;
-	int port;
-
-	uhci->io_addr = (unsigned long) hcd->rsrc_start;
-
-	/* The UHCI spec says devices must have 2 ports, and goes on to say
-	 * they may have more but gives no way to determine how many there
-	 * are.  However according to the UHCI spec, Bit 7 of the port
-	 * status and control register is always set to 1.  So we try to
-	 * use this to our advantage.  Another common failure mode when
-	 * a nonexistent register is addressed is to return all ones, so
-	 * we test for that also.
-	 */
-	for (port = 0; port < (io_size - USBPORTSC1) / 2; port++) {
-		unsigned int portstatus;
-
-		portstatus = inw(uhci->io_addr + USBPORTSC1 + (port * 2));
-		if (!(portstatus & 0x0080) || portstatus == 0xffff)
-			break;
-	}
-	if (debug)
-		dev_info(uhci_dev(uhci), "detected %d ports\n", port);
-
-	/* Anything greater than 7 is weird so we'll ignore it. */
-	if (port > UHCI_RH_MAXCHILD) {
-		dev_info(uhci_dev(uhci), "port count misdetected? "
-				"forcing to 2 ports\n");
-		port = 2;
-	}
-	uhci->rh_numports = port;
-
-	/* Kick BIOS off this hardware and reset if the controller
-	 * isn't already safely quiescent.
-	 */
-	check_and_reset_hc(uhci);
-	return 0;
-}
-
-/* Make sure the controller is quiescent and that we're not using it
- * any more.  This is mainly for the benefit of programs which, like kexec,
- * expect the hardware to be idle: not doing DMA or generating IRQs.
- *
- * This routine may be called in a damaged or failing kernel.  Hence we
- * do not acquire the spinlock before shutting down the controller.
- */
-static void uhci_shutdown(struct pci_dev *pdev)
-{
-	struct usb_hcd *hcd = (struct usb_hcd *) pci_get_drvdata(pdev);
-
-	uhci_hc_died(hcd_to_uhci(hcd));
-}
-
-/*
- * Allocate a frame list, and then setup the skeleton
- *
- * The hardware doesn't really know any difference
- * in the queues, but the order does matter for the
- * protocols higher up.  The order in which the queues
- * are encountered by the hardware is:
- *
- *  - All isochronous events are handled before any
- *    of the queues. We don't do that here, because
- *    we'll create the actual TD entries on demand.
- *  - The first queue is the high-period interrupt queue.
- *  - The second queue is the period-1 interrupt and async
- *    (low-speed control, full-speed control, then bulk) queue.
- *  - The third queue is the terminating bandwidth reclamation queue,
- *    which contains no members, loops back to itself, and is present
- *    only when FSBR is on and there are no full-speed control or bulk QHs.
- */
-static int uhci_start(struct usb_hcd *hcd)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	int retval = -EBUSY;
-	int i;
-	struct dentry *dentry;
-
-	hcd->uses_new_polling = 1;
-
-	spin_lock_init(&uhci->lock);
-	setup_timer(&uhci->fsbr_timer, uhci_fsbr_timeout,
-			(unsigned long) uhci);
-	INIT_LIST_HEAD(&uhci->idle_qh_list);
-	init_waitqueue_head(&uhci->waitqh);
-
-	if (DEBUG_CONFIGURED) {
-		dentry = debugfs_create_file(hcd->self.bus_name,
-				S_IFREG|S_IRUGO|S_IWUSR, uhci_debugfs_root,
-				uhci, &uhci_debug_operations);
-		if (!dentry) {
-			dev_err(uhci_dev(uhci), "couldn't create uhci "
-					"debugfs entry\n");
-			retval = -ENOMEM;
-			goto err_create_debug_entry;
-		}
-		uhci->dentry = dentry;
-	}
-
-	uhci->frame = dma_alloc_coherent(uhci_dev(uhci),
-			UHCI_NUMFRAMES * sizeof(*uhci->frame),
-			&uhci->frame_dma_handle, 0);
-	if (!uhci->frame) {
-		dev_err(uhci_dev(uhci), "unable to allocate "
-				"consistent memory for frame list\n");
-		goto err_alloc_frame;
-	}
-	memset(uhci->frame, 0, UHCI_NUMFRAMES * sizeof(*uhci->frame));
-
-	uhci->frame_cpu = kcalloc(UHCI_NUMFRAMES, sizeof(*uhci->frame_cpu),
-			GFP_KERNEL);
-	if (!uhci->frame_cpu) {
-		dev_err(uhci_dev(uhci), "unable to allocate "
-				"memory for frame pointers\n");
-		goto err_alloc_frame_cpu;
-	}
-
-	uhci->td_pool = dma_pool_create("uhci_td", uhci_dev(uhci),
-			sizeof(struct uhci_td), 16, 0);
-	if (!uhci->td_pool) {
-		dev_err(uhci_dev(uhci), "unable to create td dma_pool\n");
-		goto err_create_td_pool;
-	}
-
-	uhci->qh_pool = dma_pool_create("uhci_qh", uhci_dev(uhci),
-			sizeof(struct uhci_qh), 16, 0);
-	if (!uhci->qh_pool) {
-		dev_err(uhci_dev(uhci), "unable to create qh dma_pool\n");
-		goto err_create_qh_pool;
-	}
-
-	uhci->term_td = uhci_alloc_td(uhci);
-	if (!uhci->term_td) {
-		dev_err(uhci_dev(uhci), "unable to allocate terminating TD\n");
-		goto err_alloc_term_td;
-	}
-
-	for (i = 0; i < UHCI_NUM_SKELQH; i++) {
-		uhci->skelqh[i] = uhci_alloc_qh(uhci, NULL, NULL);
-		if (!uhci->skelqh[i]) {
-			dev_err(uhci_dev(uhci), "unable to allocate QH\n");
-			goto err_alloc_skelqh;
-		}
-	}
-
-	/*
-	 * 8 Interrupt queues; link all higher int queues to int1 = async
-	 */
-	for (i = SKEL_ISO + 1; i < SKEL_ASYNC; ++i)
-		uhci->skelqh[i]->link = LINK_TO_QH(uhci->skel_async_qh);
-	uhci->skel_async_qh->link = UHCI_PTR_TERM;
-	uhci->skel_term_qh->link = LINK_TO_QH(uhci->skel_term_qh);
-
-	/* This dummy TD is to work around a bug in Intel PIIX controllers */
-	uhci_fill_td(uhci->term_td, 0, uhci_explen(0) |
-			(0x7f << TD_TOKEN_DEVADDR_SHIFT) | USB_PID_IN, 0);
-	uhci->term_td->link = UHCI_PTR_TERM;
-	uhci->skel_async_qh->element = uhci->skel_term_qh->element =
-			LINK_TO_TD(uhci->term_td);
-
-	/*
-	 * Fill the frame list: make all entries point to the proper
-	 * interrupt queue.
-	 */
-	for (i = 0; i < UHCI_NUMFRAMES; i++) {
-
-		/* Only place we don't use the frame list routines */
-		uhci->frame[i] = uhci_frame_skel_link(uhci, i);
-	}
-
-	/*
-	 * Some architectures require a full mb() to enforce completion of
-	 * the memory writes above before the I/O transfers in configure_hc().
-	 */
-	mb();
-
-	configure_hc(uhci);
-	uhci->is_initialized = 1;
-	start_rh(uhci);
-	return 0;
-
-/*
- * error exits:
- */
-err_alloc_skelqh:
-	for (i = 0; i < UHCI_NUM_SKELQH; i++) {
-		if (uhci->skelqh[i])
-			uhci_free_qh(uhci, uhci->skelqh[i]);
-	}
-
-	uhci_free_td(uhci, uhci->term_td);
-
-err_alloc_term_td:
-	dma_pool_destroy(uhci->qh_pool);
-
-err_create_qh_pool:
-	dma_pool_destroy(uhci->td_pool);
-
-err_create_td_pool:
-	kfree(uhci->frame_cpu);
-
-err_alloc_frame_cpu:
-	dma_free_coherent(uhci_dev(uhci),
-			UHCI_NUMFRAMES * sizeof(*uhci->frame),
-			uhci->frame, uhci->frame_dma_handle);
-
-err_alloc_frame:
-	debugfs_remove(uhci->dentry);
-
-err_create_debug_entry:
-	return retval;
-}
-
-static void uhci_stop(struct usb_hcd *hcd)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-
-	spin_lock_irq(&uhci->lock);
-	if (test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags) && !uhci->dead)
-		uhci_hc_died(uhci);
-	uhci_scan_schedule(uhci);
-	spin_unlock_irq(&uhci->lock);
-
-	del_timer_sync(&uhci->fsbr_timer);
-	release_uhci(uhci);
-}
-
-#ifdef CONFIG_PM
-static int uhci_rh_suspend(struct usb_hcd *hcd)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	int rc = 0;
-
-	spin_lock_irq(&uhci->lock);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags))
-		rc = -ESHUTDOWN;
-	else if (!uhci->dead)
-		suspend_rh(uhci, UHCI_RH_SUSPENDED);
-	spin_unlock_irq(&uhci->lock);
-	return rc;
-}
-
-static int uhci_rh_resume(struct usb_hcd *hcd)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	int rc = 0;
-
-	spin_lock_irq(&uhci->lock);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags))
-		rc = -ESHUTDOWN;
-	else if (!uhci->dead)
-		wakeup_rh(uhci);
-	spin_unlock_irq(&uhci->lock);
-	return rc;
-}
-
-static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	int rc = 0;
-
-	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
-
-	spin_lock_irq(&uhci->lock);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags) || uhci->dead)
-		goto done_okay;		/* Already suspended or dead */
-
-	if (uhci->rh_state > UHCI_RH_SUSPENDED) {
-		dev_warn(uhci_dev(uhci), "Root hub isn't suspended!\n");
-		rc = -EBUSY;
-		goto done;
-	};
-
-	/* All PCI host controllers are required to disable IRQ generation
-	 * at the source, so we must turn off PIRQ.
-	 */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
-	mb();
-	hcd->poll_rh = 0;
-
-	/* FIXME: Enable non-PME# remote wakeup? */
-
-	/* make sure snapshot being resumed re-enumerates everything */
-	if (message.event == PM_EVENT_PRETHAW)
-		uhci_hc_died(uhci);
-
-done_okay:
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-done:
-	spin_unlock_irq(&uhci->lock);
-	return rc;
-}
-
-static int uhci_resume(struct usb_hcd *hcd)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-
-	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
-
-	/* Since we aren't in D3 any more, it's safe to set this flag
-	 * even if the controller was dead.
-	 */
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-	mb();
-
-	spin_lock_irq(&uhci->lock);
-
-	/* FIXME: Disable non-PME# remote wakeup? */
-
-	/* The firmware or a boot kernel may have changed the controller
-	 * settings during a system wakeup.  Check it and reconfigure
-	 * to avoid problems.
-	 */
-	check_and_reset_hc(uhci);
-
-	/* If the controller was dead before, it's back alive now */
-	configure_hc(uhci);
-
-	if (uhci->rh_state == UHCI_RH_RESET) {
-
-		/* The controller had to be reset */
-		usb_root_hub_lost_power(hcd->self.root_hub);
-		suspend_rh(uhci, UHCI_RH_SUSPENDED);
-	}
-
-	spin_unlock_irq(&uhci->lock);
-
-	if (!uhci->working_RD) {
-		/* Suspended root hub needs to be polled */
-		hcd->poll_rh = 1;
-		usb_hcd_poll_rh_status(hcd);
-	}
-	return 0;
-}
-#endif
-
-/* Wait until a particular device/endpoint's QH is idle, and free it */
-static void uhci_hcd_endpoint_disable(struct usb_hcd *hcd,
-		struct usb_host_endpoint *hep)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	struct uhci_qh *qh;
-
-	spin_lock_irq(&uhci->lock);
-	qh = (struct uhci_qh *) hep->hcpriv;
-	if (qh == NULL)
-		goto done;
-
-	while (qh->state != QH_STATE_IDLE) {
-		++uhci->num_waiting;
-		spin_unlock_irq(&uhci->lock);
-		wait_event_interruptible(uhci->waitqh,
-				qh->state == QH_STATE_IDLE);
-		spin_lock_irq(&uhci->lock);
-		--uhci->num_waiting;
-	}
-
-	uhci_free_qh(uhci, qh);
-done:
-	spin_unlock_irq(&uhci->lock);
-}
-
-static int uhci_hcd_get_frame_number(struct usb_hcd *hcd)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	unsigned frame_number;
-	unsigned delta;
-
-	/* Minimize latency by avoiding the spinlock */
-	frame_number = uhci->frame_number;
-	barrier();
-	delta = (inw(uhci->io_addr + USBFRNUM) - frame_number) &
-			(UHCI_NUMFRAMES - 1);
-	return frame_number + delta;
-}
-
-static const char hcd_name[] = "uhci_hcd";
-
-static const struct hc_driver uhci_driver = {
-	.description =		hcd_name,
-	.product_desc =		"UHCI Host Controller",
-	.hcd_priv_size =	sizeof(struct uhci_hcd),
-
-	/* Generic hardware linkage */
-	.irq =			uhci_irq,
-	.flags =		HCD_USB11,
-
-	/* Basic lifecycle operations */
-	.reset =		uhci_init,
-	.start =		uhci_start,
-#ifdef CONFIG_PM
-	.suspend =		uhci_suspend,
-	.resume =		uhci_resume,
-	.bus_suspend =		uhci_rh_suspend,
-	.bus_resume =		uhci_rh_resume,
-#endif
-	.stop =			uhci_stop,
-
-	.urb_enqueue =		uhci_urb_enqueue,
-	.urb_dequeue =		uhci_urb_dequeue,
-
-	.endpoint_disable =	uhci_hcd_endpoint_disable,
-	.get_frame_number =	uhci_hcd_get_frame_number,
-
-	.hub_status_data =	uhci_hub_status_data,
-	.hub_control =		uhci_hub_control,
-};
-
-static const struct pci_device_id uhci_pci_ids[] = { {
-	/* handle any USB UHCI controller */
-	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_UHCI, ~0),
-	.driver_data =	(unsigned long) &uhci_driver,
-	}, { /* end: all zeroes */ }
-};
-
-MODULE_DEVICE_TABLE(pci, uhci_pci_ids);
-
-static struct pci_driver uhci_pci_driver = {
-	.name =		(char *)hcd_name,
-	.id_table =	uhci_pci_ids,
-
-	.probe =	usb_hcd_pci_probe,
-	.remove =	usb_hcd_pci_remove,
-	.shutdown =	uhci_shutdown,
-
-#ifdef	CONFIG_PM
-	.suspend =	usb_hcd_pci_suspend,
-	.resume =	usb_hcd_pci_resume,
-#endif	/* PM */
-};
- 
-static int __init uhci_hcd_init(void)
-{
-	int retval = -ENOMEM;
-
-	printk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION "%s\n",
-			ignore_oc ? ", overcurrent ignored" : "");
-
-	if (usb_disabled())
-		return -ENODEV;
-
-	if (DEBUG_CONFIGURED) {
-		errbuf = kmalloc(ERRBUF_LEN, GFP_KERNEL);
-		if (!errbuf)
-			goto errbuf_failed;
-		uhci_debugfs_root = debugfs_create_dir("uhci", NULL);
-		if (!uhci_debugfs_root)
-			goto debug_failed;
-	}
-
-	uhci_up_cachep = kmem_cache_create("uhci_urb_priv",
-		sizeof(struct urb_priv), 0, 0, NULL);
-	if (!uhci_up_cachep)
-		goto up_failed;
-
-	retval = pci_register_driver(&uhci_pci_driver);
-	if (retval)
-		goto init_failed;
-
-	return 0;
-
-init_failed:
-	kmem_cache_destroy(uhci_up_cachep);
-
-up_failed:
-	debugfs_remove(uhci_debugfs_root);
-
-debug_failed:
-	kfree(errbuf);
-
-errbuf_failed:
-
-	return retval;
-}
-
-static void __exit uhci_hcd_cleanup(void) 
-{
-	pci_unregister_driver(&uhci_pci_driver);
-	kmem_cache_destroy(uhci_up_cachep);
-	debugfs_remove(uhci_debugfs_root);
-	kfree(errbuf);
-}
-
-module_init(uhci_hcd_init);
-module_exit(uhci_hcd_cleanup);
-
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE("GPL");
diff -urN host/.svn/text-base/uhci-hcd.h.svn-base host.new/.svn/text-base/uhci-hcd.h.svn-base
--- host/.svn/text-base/uhci-hcd.h.svn-base	2009-02-24 19:00:16.019938943 +0100
+++ host.new/.svn/text-base/uhci-hcd.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,480 +0,0 @@
-#ifndef __LINUX_UHCI_HCD_H
-#define __LINUX_UHCI_HCD_H
-
-#include <linux/list.h>
-#include <linux/usb.h>
-
-#define usb_packetid(pipe)	(usb_pipein(pipe) ? USB_PID_IN : USB_PID_OUT)
-#define PIPE_DEVEP_MASK		0x0007ff00
-
-
-/*
- * Universal Host Controller Interface data structures and defines
- */
-
-/* Command register */
-#define USBCMD		0
-#define   USBCMD_RS		0x0001	/* Run/Stop */
-#define   USBCMD_HCRESET	0x0002	/* Host reset */
-#define   USBCMD_GRESET		0x0004	/* Global reset */
-#define   USBCMD_EGSM		0x0008	/* Global Suspend Mode */
-#define   USBCMD_FGR		0x0010	/* Force Global Resume */
-#define   USBCMD_SWDBG		0x0020	/* SW Debug mode */
-#define   USBCMD_CF		0x0040	/* Config Flag (sw only) */
-#define   USBCMD_MAXP		0x0080	/* Max Packet (0 = 32, 1 = 64) */
-
-/* Status register */
-#define USBSTS		2
-#define   USBSTS_USBINT		0x0001	/* Interrupt due to IOC */
-#define   USBSTS_ERROR		0x0002	/* Interrupt due to error */
-#define   USBSTS_RD		0x0004	/* Resume Detect */
-#define   USBSTS_HSE		0x0008	/* Host System Error: PCI problems */
-#define   USBSTS_HCPE		0x0010	/* Host Controller Process Error:
-					 * the schedule is buggy */
-#define   USBSTS_HCH		0x0020	/* HC Halted */
-
-/* Interrupt enable register */
-#define USBINTR		4
-#define   USBINTR_TIMEOUT	0x0001	/* Timeout/CRC error enable */
-#define   USBINTR_RESUME	0x0002	/* Resume interrupt enable */
-#define   USBINTR_IOC		0x0004	/* Interrupt On Complete enable */
-#define   USBINTR_SP		0x0008	/* Short packet interrupt enable */
-
-#define USBFRNUM	6
-#define USBFLBASEADD	8
-#define USBSOF		12
-#define   USBSOF_DEFAULT	64	/* Frame length is exactly 1 ms */
-
-/* USB port status and control registers */
-#define USBPORTSC1	16
-#define USBPORTSC2	18
-#define   USBPORTSC_CCS		0x0001	/* Current Connect Status
-					 * ("device present") */
-#define   USBPORTSC_CSC		0x0002	/* Connect Status Change */
-#define   USBPORTSC_PE		0x0004	/* Port Enable */
-#define   USBPORTSC_PEC		0x0008	/* Port Enable Change */
-#define   USBPORTSC_DPLUS	0x0010	/* D+ high (line status) */
-#define   USBPORTSC_DMINUS	0x0020	/* D- high (line status) */
-#define   USBPORTSC_RD		0x0040	/* Resume Detect */
-#define   USBPORTSC_RES1	0x0080	/* reserved, always 1 */
-#define   USBPORTSC_LSDA	0x0100	/* Low Speed Device Attached */
-#define   USBPORTSC_PR		0x0200	/* Port Reset */
-/* OC and OCC from Intel 430TX and later (not UHCI 1.1d spec) */
-#define   USBPORTSC_OC		0x0400	/* Over Current condition */
-#define   USBPORTSC_OCC		0x0800	/* Over Current Change R/WC */
-#define   USBPORTSC_SUSP	0x1000	/* Suspend */
-#define   USBPORTSC_RES2	0x2000	/* reserved, write zeroes */
-#define   USBPORTSC_RES3	0x4000	/* reserved, write zeroes */
-#define   USBPORTSC_RES4	0x8000	/* reserved, write zeroes */
-
-/* Legacy support register */
-#define USBLEGSUP		0xc0
-#define   USBLEGSUP_DEFAULT	0x2000	/* only PIRQ enable set */
-#define   USBLEGSUP_RWC		0x8f00	/* the R/WC bits */
-#define   USBLEGSUP_RO		0x5040	/* R/O and reserved bits */
-
-#define UHCI_PTR_BITS		__constant_cpu_to_le32(0x000F)
-#define UHCI_PTR_TERM		__constant_cpu_to_le32(0x0001)
-#define UHCI_PTR_QH		__constant_cpu_to_le32(0x0002)
-#define UHCI_PTR_DEPTH		__constant_cpu_to_le32(0x0004)
-#define UHCI_PTR_BREADTH	__constant_cpu_to_le32(0x0000)
-
-#define UHCI_NUMFRAMES		1024	/* in the frame list [array] */
-#define UHCI_MAX_SOF_NUMBER	2047	/* in an SOF packet */
-#define CAN_SCHEDULE_FRAMES	1000	/* how far in the future frames
-					 * can be scheduled */
-#define MAX_PHASE		32	/* Periodic scheduling length */
-
-/* When no queues need Full-Speed Bandwidth Reclamation,
- * delay this long before turning FSBR off */
-#define FSBR_OFF_DELAY		msecs_to_jiffies(10)
-
-/* If a queue hasn't advanced after this much time, assume it is stuck */
-#define QH_WAIT_TIMEOUT		msecs_to_jiffies(200)
-
-
-/*
- *	Queue Headers
- */
-
-/*
- * One role of a QH is to hold a queue of TDs for some endpoint.  One QH goes
- * with each endpoint, and qh->element (updated by the HC) is either:
- *   - the next unprocessed TD in the endpoint's queue, or
- *   - UHCI_PTR_TERM (when there's no more traffic for this endpoint).
- *
- * The other role of a QH is to serve as a "skeleton" framelist entry, so we
- * can easily splice a QH for some endpoint into the schedule at the right
- * place.  Then qh->element is UHCI_PTR_TERM.
- *
- * In the schedule, qh->link maintains a list of QHs seen by the HC:
- *     skel1 --> ep1-qh --> ep2-qh --> ... --> skel2 --> ...
- *
- * qh->node is the software equivalent of qh->link.  The differences
- * are that the software list is doubly-linked and QHs in the UNLINKING
- * state are on the software list but not the hardware schedule.
- *
- * For bookkeeping purposes we maintain QHs even for Isochronous endpoints,
- * but they never get added to the hardware schedule.
- */
-#define QH_STATE_IDLE		1	/* QH is not being used */
-#define QH_STATE_UNLINKING	2	/* QH has been removed from the
-					 * schedule but the hardware may
-					 * still be using it */
-#define QH_STATE_ACTIVE		3	/* QH is on the schedule */
-
-struct uhci_qh {
-	/* Hardware fields */
-	__le32 link;			/* Next QH in the schedule */
-	__le32 element;			/* Queue element (TD) pointer */
-
-	/* Software fields */
-	dma_addr_t dma_handle;
-
-	struct list_head node;		/* Node in the list of QHs */
-	struct usb_host_endpoint *hep;	/* Endpoint information */
-	struct usb_device *udev;
-	struct list_head queue;		/* Queue of urbps for this QH */
-	struct uhci_td *dummy_td;	/* Dummy TD to end the queue */
-	struct uhci_td *post_td;	/* Last TD completed */
-
-	struct usb_iso_packet_descriptor *iso_packet_desc;
-					/* Next urb->iso_frame_desc entry */
-	unsigned long advance_jiffies;	/* Time of last queue advance */
-	unsigned int unlink_frame;	/* When the QH was unlinked */
-	unsigned int period;		/* For Interrupt and Isochronous QHs */
-	short phase;			/* Between 0 and period-1 */
-	short load;			/* Periodic time requirement, in us */
-	unsigned int iso_frame;		/* Frame # for iso_packet_desc */
-	int iso_status;			/* Status for Isochronous URBs */
-
-	int state;			/* QH_STATE_xxx; see above */
-	int type;			/* Queue type (control, bulk, etc) */
-	int skel;			/* Skeleton queue number */
-
-	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
-	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
-	unsigned int is_stopped:1;	/* Queue was stopped by error/unlink */
-	unsigned int wait_expired:1;	/* QH_WAIT_TIMEOUT has expired */
-	unsigned int bandwidth_reserved:1;	/* Periodic bandwidth has
-						 * been allocated */
-} __attribute__((aligned(16)));
-
-/*
- * We need a special accessor for the element pointer because it is
- * subject to asynchronous updates by the controller.
- */
-static inline __le32 qh_element(struct uhci_qh *qh) {
-	__le32 element = qh->element;
-
-	barrier();
-	return element;
-}
-
-#define LINK_TO_QH(qh)		(UHCI_PTR_QH | cpu_to_le32((qh)->dma_handle))
-
-
-/*
- *	Transfer Descriptors
- */
-
-/*
- * for TD <status>:
- */
-#define TD_CTRL_SPD		(1 << 29)	/* Short Packet Detect */
-#define TD_CTRL_C_ERR_MASK	(3 << 27)	/* Error Counter bits */
-#define TD_CTRL_C_ERR_SHIFT	27
-#define TD_CTRL_LS		(1 << 26)	/* Low Speed Device */
-#define TD_CTRL_IOS		(1 << 25)	/* Isochronous Select */
-#define TD_CTRL_IOC		(1 << 24)	/* Interrupt on Complete */
-#define TD_CTRL_ACTIVE		(1 << 23)	/* TD Active */
-#define TD_CTRL_STALLED		(1 << 22)	/* TD Stalled */
-#define TD_CTRL_DBUFERR		(1 << 21)	/* Data Buffer Error */
-#define TD_CTRL_BABBLE		(1 << 20)	/* Babble Detected */
-#define TD_CTRL_NAK		(1 << 19)	/* NAK Received */
-#define TD_CTRL_CRCTIMEO	(1 << 18)	/* CRC/Time Out Error */
-#define TD_CTRL_BITSTUFF	(1 << 17)	/* Bit Stuff Error */
-#define TD_CTRL_ACTLEN_MASK	0x7FF	/* actual length, encoded as n - 1 */
-
-#define TD_CTRL_ANY_ERROR	(TD_CTRL_STALLED | TD_CTRL_DBUFERR | \
-				 TD_CTRL_BABBLE | TD_CTRL_CRCTIME | \
-				 TD_CTRL_BITSTUFF)
-
-#define uhci_maxerr(err)		((err) << TD_CTRL_C_ERR_SHIFT)
-#define uhci_status_bits(ctrl_sts)	((ctrl_sts) & 0xF60000)
-#define uhci_actual_length(ctrl_sts)	(((ctrl_sts) + 1) & \
-			TD_CTRL_ACTLEN_MASK)	/* 1-based */
-
-/*
- * for TD <info>: (a.k.a. Token)
- */
-#define td_token(td)		le32_to_cpu((td)->token)
-#define TD_TOKEN_DEVADDR_SHIFT	8
-#define TD_TOKEN_TOGGLE_SHIFT	19
-#define TD_TOKEN_TOGGLE		(1 << 19)
-#define TD_TOKEN_EXPLEN_SHIFT	21
-#define TD_TOKEN_EXPLEN_MASK	0x7FF	/* expected length, encoded as n-1 */
-#define TD_TOKEN_PID_MASK	0xFF
-
-#define uhci_explen(len)	((((len) - 1) & TD_TOKEN_EXPLEN_MASK) << \
-					TD_TOKEN_EXPLEN_SHIFT)
-
-#define uhci_expected_length(token) ((((token) >> TD_TOKEN_EXPLEN_SHIFT) + \
-					1) & TD_TOKEN_EXPLEN_MASK)
-#define uhci_toggle(token)	(((token) >> TD_TOKEN_TOGGLE_SHIFT) & 1)
-#define uhci_endpoint(token)	(((token) >> 15) & 0xf)
-#define uhci_devaddr(token)	(((token) >> TD_TOKEN_DEVADDR_SHIFT) & 0x7f)
-#define uhci_devep(token)	(((token) >> TD_TOKEN_DEVADDR_SHIFT) & 0x7ff)
-#define uhci_packetid(token)	((token) & TD_TOKEN_PID_MASK)
-#define uhci_packetout(token)	(uhci_packetid(token) != USB_PID_IN)
-#define uhci_packetin(token)	(uhci_packetid(token) == USB_PID_IN)
-
-/*
- * The documentation says "4 words for hardware, 4 words for software".
- *
- * That's silly, the hardware doesn't care. The hardware only cares that
- * the hardware words are 16-byte aligned, and we can have any amount of
- * sw space after the TD entry.
- *
- * td->link points to either another TD (not necessarily for the same urb or
- * even the same endpoint), or nothing (PTR_TERM), or a QH.
- */
-struct uhci_td {
-	/* Hardware fields */
-	__le32 link;
-	__le32 status;
-	__le32 token;
-	__le32 buffer;
-
-	/* Software fields */
-	dma_addr_t dma_handle;
-
-	struct list_head list;
-
-	int frame;			/* for iso: what frame? */
-	struct list_head fl_list;
-} __attribute__((aligned(16)));
-
-/*
- * We need a special accessor for the control/status word because it is
- * subject to asynchronous updates by the controller.
- */
-static inline u32 td_status(struct uhci_td *td) {
-	__le32 status = td->status;
-
-	barrier();
-	return le32_to_cpu(status);
-}
-
-#define LINK_TO_TD(td)		(cpu_to_le32((td)->dma_handle))
-
-
-/*
- *	Skeleton Queue Headers
- */
-
-/*
- * The UHCI driver uses QHs with Interrupt, Control and Bulk URBs for
- * automatic queuing. To make it easy to insert entries into the schedule,
- * we have a skeleton of QHs for each predefined Interrupt latency.
- * Asynchronous QHs (low-speed control, full-speed control, and bulk)
- * go onto the period-1 interrupt list, since they all get accessed on
- * every frame.
- *
- * When we want to add a new QH, we add it to the list starting from the
- * appropriate skeleton QH.  For instance, the schedule can look like this:
- *
- * skel int128 QH
- * dev 1 interrupt QH
- * dev 5 interrupt QH
- * skel int64 QH
- * skel int32 QH
- * ...
- * skel int1 + async QH
- * dev 5 low-speed control QH
- * dev 1 bulk QH
- * dev 2 bulk QH
- *
- * There is a special terminating QH used to keep full-speed bandwidth
- * reclamation active when no full-speed control or bulk QHs are linked
- * into the schedule.  It has an inactive TD (to work around a PIIX bug,
- * see the Intel errata) and it points back to itself.
- *
- * There's a special skeleton QH for Isochronous QHs which never appears
- * on the schedule.  Isochronous TDs go on the schedule before the
- * the skeleton QHs.  The hardware accesses them directly rather than
- * through their QH, which is used only for bookkeeping purposes.
- * While the UHCI spec doesn't forbid the use of QHs for Isochronous,
- * it doesn't use them either.  And the spec says that queues never
- * advance on an error completion status, which makes them totally
- * unsuitable for Isochronous transfers.
- *
- * There's also a special skeleton QH used for QHs which are in the process
- * of unlinking and so may still be in use by the hardware.  It too never
- * appears on the schedule.
- */
-
-#define UHCI_NUM_SKELQH		11
-#define SKEL_UNLINK		0
-#define skel_unlink_qh		skelqh[SKEL_UNLINK]
-#define SKEL_ISO		1
-#define skel_iso_qh		skelqh[SKEL_ISO]
-	/* int128, int64, ..., int1 = 2, 3, ..., 9 */
-#define SKEL_INDEX(exponent)	(9 - exponent)
-#define SKEL_ASYNC		9
-#define skel_async_qh		skelqh[SKEL_ASYNC]
-#define SKEL_TERM		10
-#define skel_term_qh		skelqh[SKEL_TERM]
-
-/* The following entries refer to sublists of skel_async_qh */
-#define SKEL_LS_CONTROL		20
-#define SKEL_FS_CONTROL		21
-#define SKEL_FSBR		SKEL_FS_CONTROL
-#define SKEL_BULK		22
-
-/*
- *	The UHCI controller and root hub
- */
-
-/*
- * States for the root hub:
- *
- * To prevent "bouncing" in the presence of electrical noise,
- * when there are no devices attached we delay for 1 second in the
- * RUNNING_NODEVS state before switching to the AUTO_STOPPED state.
- * 
- * (Note that the AUTO_STOPPED state won't be necessary once the hub
- * driver learns to autosuspend.)
- */
-enum uhci_rh_state {
-	/* In the following states the HC must be halted.
-	 * These two must come first. */
-	UHCI_RH_RESET,
-	UHCI_RH_SUSPENDED,
-
-	UHCI_RH_AUTO_STOPPED,
-	UHCI_RH_RESUMING,
-
-	/* In this state the HC changes from running to halted,
-	 * so it can legally appear either way. */
-	UHCI_RH_SUSPENDING,
-
-	/* In the following states it's an error if the HC is halted.
-	 * These two must come last. */
-	UHCI_RH_RUNNING,		/* The normal state */
-	UHCI_RH_RUNNING_NODEVS,		/* Running with no devices attached */
-};
-
-/*
- * The full UHCI controller information:
- */
-struct uhci_hcd {
-
-	/* debugfs */
-	struct dentry *dentry;
-
-	/* Grabbed from PCI */
-	unsigned long io_addr;
-
-	struct dma_pool *qh_pool;
-	struct dma_pool *td_pool;
-
-	struct uhci_td *term_td;	/* Terminating TD, see UHCI bug */
-	struct uhci_qh *skelqh[UHCI_NUM_SKELQH];	/* Skeleton QHs */
-	struct uhci_qh *next_qh;	/* Next QH to scan */
-
-	spinlock_t lock;
-
-	dma_addr_t frame_dma_handle;	/* Hardware frame list */
-	__le32 *frame;
-	void **frame_cpu;		/* CPU's frame list */
-
-	enum uhci_rh_state rh_state;
-	unsigned long auto_stop_time;		/* When to AUTO_STOP */
-
-	unsigned int frame_number;		/* As of last check */
-	unsigned int is_stopped;
-#define UHCI_IS_STOPPED		9999		/* Larger than a frame # */
-	unsigned int last_iso_frame;		/* Frame of last scan */
-	unsigned int cur_iso_frame;		/* Frame for current scan */
-
-	unsigned int scan_in_progress:1;	/* Schedule scan is running */
-	unsigned int need_rescan:1;		/* Redo the schedule scan */
-	unsigned int dead:1;			/* Controller has died */
-	unsigned int working_RD:1;		/* Suspended root hub doesn't
-						   need to be polled */
-	unsigned int is_initialized:1;		/* Data structure is usable */
-	unsigned int fsbr_is_on:1;		/* FSBR is turned on */
-	unsigned int fsbr_is_wanted:1;		/* Does any URB want FSBR? */
-	unsigned int fsbr_expiring:1;		/* FSBR is timing out */
-
-	struct timer_list fsbr_timer;		/* For turning off FBSR */
-
-	/* Support for port suspend/resume/reset */
-	unsigned long port_c_suspend;		/* Bit-arrays of ports */
-	unsigned long resuming_ports;
-	unsigned long ports_timeout;		/* Time to stop signalling */
-
-	struct list_head idle_qh_list;		/* Where the idle QHs live */
-
-	int rh_numports;			/* Number of root-hub ports */
-
-	wait_queue_head_t waitqh;		/* endpoint_disable waiters */
-	int num_waiting;			/* Number of waiters */
-
-	int total_load;				/* Sum of array values */
-	short load[MAX_PHASE];			/* Periodic allocations */
-};
-
-/* Convert between a usb_hcd pointer and the corresponding uhci_hcd */
-static inline struct uhci_hcd *hcd_to_uhci(struct usb_hcd *hcd)
-{
-	return (struct uhci_hcd *) (hcd->hcd_priv);
-}
-static inline struct usb_hcd *uhci_to_hcd(struct uhci_hcd *uhci)
-{
-	return container_of((void *) uhci, struct usb_hcd, hcd_priv);
-}
-
-#define uhci_dev(u)	(uhci_to_hcd(u)->self.controller)
-
-/* Utility macro for comparing frame numbers */
-#define uhci_frame_before_eq(f1, f2)	(0 <= (int) ((f2) - (f1)))
-
-
-/*
- *	Private per-URB data
- */
-struct urb_priv {
-	struct list_head node;		/* Node in the QH's urbp list */
-
-	struct urb *urb;
-
-	struct uhci_qh *qh;		/* QH for this URB */
-	struct list_head td_list;
-
-	unsigned fsbr:1;		/* URB wants FSBR */
-};
-
-
-/*
- * Locking in uhci.c
- *
- * Almost everything relating to the hardware schedule and processing
- * of URBs is protected by uhci->lock.  urb->status is protected by
- * urb->lock; that's the one exception.
- *
- * To prevent deadlocks, never lock uhci->lock while holding urb->lock.
- * The safe order of locking is:
- *
- * #1 uhci->lock
- * #2 urb->lock
- */
-
-
-/* Some special IDs */
-
-#define PCI_VENDOR_ID_GENESYS		0x17a0
-#define PCI_DEVICE_ID_GL880S_UHCI	0x8083
-
-#endif
diff -urN host/.svn/text-base/uhci-hub.c.svn-base host.new/.svn/text-base/uhci-hub.c.svn-base
--- host/.svn/text-base/uhci-hub.c.svn-base	2009-02-24 19:00:16.023938740 +0100
+++ host.new/.svn/text-base/uhci-hub.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,414 +0,0 @@
-/*
- * Universal Host Controller Interface driver for USB.
- *
- * Maintainer: Alan Stern <stern@rowland.harvard.edu>
- *
- * (C) Copyright 1999 Linus Torvalds
- * (C) Copyright 1999-2002 Johannes Erdfelt, johannes@erdfelt.com
- * (C) Copyright 1999 Randy Dunlap
- * (C) Copyright 1999 Georg Acher, acher@in.tum.de
- * (C) Copyright 1999 Deti Fliegl, deti@fliegl.de
- * (C) Copyright 1999 Thomas Sailer, sailer@ife.ee.ethz.ch
- * (C) Copyright 2004 Alan Stern, stern@rowland.harvard.edu
- */
-
-static __u8 root_hub_hub_des[] =
-{
-	0x09,			/*  __u8  bLength; */
-	0x29,			/*  __u8  bDescriptorType; Hub-descriptor */
-	0x02,			/*  __u8  bNbrPorts; */
-	0x0a,			/* __u16  wHubCharacteristics; */
-	0x00,			/*   (per-port OC, no power switching) */
-	0x01,			/*  __u8  bPwrOn2pwrGood; 2ms */
-	0x00,			/*  __u8  bHubContrCurrent; 0 mA */
-	0x00,			/*  __u8  DeviceRemovable; *** 7 Ports max *** */
-	0xff			/*  __u8  PortPwrCtrlMask; *** 7 ports max *** */
-};
-
-#define	UHCI_RH_MAXCHILD	7
-
-/* must write as zeroes */
-#define WZ_BITS		(USBPORTSC_RES2 | USBPORTSC_RES3 | USBPORTSC_RES4)
-
-/* status change bits:  nonzero writes will clear */
-#define RWC_BITS	(USBPORTSC_OCC | USBPORTSC_PEC | USBPORTSC_CSC)
-
-/* suspend/resume bits: port suspended or port resuming */
-#define SUSPEND_BITS	(USBPORTSC_SUSP | USBPORTSC_RD)
-
-/* A port that either is connected or has a changed-bit set will prevent
- * us from AUTO_STOPPING.
- */
-static int any_ports_active(struct uhci_hcd *uhci)
-{
-	int port;
-
-	for (port = 0; port < uhci->rh_numports; ++port) {
-		if ((inw(uhci->io_addr + USBPORTSC1 + port * 2) &
-				(USBPORTSC_CCS | RWC_BITS)) ||
-				test_bit(port, &uhci->port_c_suspend))
-			return 1;
-	}
-	return 0;
-}
-
-static inline int get_hub_status_data(struct uhci_hcd *uhci, char *buf)
-{
-	int port;
-	int mask = RWC_BITS;
-
-	/* Some boards (both VIA and Intel apparently) report bogus
-	 * overcurrent indications, causing massive log spam unless
-	 * we completely ignore them.  This doesn't seem to be a problem
-	 * with the chipset so much as with the way it is connected on
-	 * the motherboard; if the overcurrent input is left to float
-	 * then it may constantly register false positives. */
-	if (ignore_oc)
-		mask &= ~USBPORTSC_OCC;
-
-	*buf = 0;
-	for (port = 0; port < uhci->rh_numports; ++port) {
-		if ((inw(uhci->io_addr + USBPORTSC1 + port * 2) & mask) ||
-				test_bit(port, &uhci->port_c_suspend))
-			*buf |= (1 << (port + 1));
-	}
-	return !!*buf;
-}
-
-#define OK(x)			len = (x); break
-
-#define CLR_RH_PORTSTAT(x) \
-	status = inw(port_addr); \
-	status &= ~(RWC_BITS|WZ_BITS); \
-	status &= ~(x); \
-	status |= RWC_BITS & (x); \
-	outw(status, port_addr)
-
-#define SET_RH_PORTSTAT(x) \
-	status = inw(port_addr); \
-	status |= (x); \
-	status &= ~(RWC_BITS|WZ_BITS); \
-	outw(status, port_addr)
-
-/* UHCI controllers don't automatically stop resume signalling after 20 msec,
- * so we have to poll and check timeouts in order to take care of it.
- */
-static void uhci_finish_suspend(struct uhci_hcd *uhci, int port,
-		unsigned long port_addr)
-{
-	int status;
-	int i;
-
-	if (inw(port_addr) & SUSPEND_BITS) {
-		CLR_RH_PORTSTAT(SUSPEND_BITS);
-		if (test_bit(port, &uhci->resuming_ports))
-			set_bit(port, &uhci->port_c_suspend);
-
-		/* The controller won't actually turn off the RD bit until
-		 * it has had a chance to send a low-speed EOP sequence,
-		 * which is supposed to take 3 bit times (= 2 microseconds).
-		 * Experiments show that some controllers take longer, so
-		 * we'll poll for completion. */
-		for (i = 0; i < 10; ++i) {
-			if (!(inw(port_addr) & SUSPEND_BITS))
-				break;
-			udelay(1);
-		}
-	}
-	clear_bit(port, &uhci->resuming_ports);
-}
-
-/* Wait for the UHCI controller in HP's iLO2 server management chip.
- * It can take up to 250 us to finish a reset and set the CSC bit.
- */
-static void wait_for_HP(unsigned long port_addr)
-{
-	int i;
-
-	for (i = 10; i < 250; i += 10) {
-		if (inw(port_addr) & USBPORTSC_CSC)
-			return;
-		udelay(10);
-	}
-	/* Log a warning? */
-}
-
-static void uhci_check_ports(struct uhci_hcd *uhci)
-{
-	unsigned int port;
-	unsigned long port_addr;
-	int status;
-
-	for (port = 0; port < uhci->rh_numports; ++port) {
-		port_addr = uhci->io_addr + USBPORTSC1 + 2 * port;
-		status = inw(port_addr);
-		if (unlikely(status & USBPORTSC_PR)) {
-			if (time_after_eq(jiffies, uhci->ports_timeout)) {
-				CLR_RH_PORTSTAT(USBPORTSC_PR);
-				udelay(10);
-
-				/* HP's server management chip requires
-				 * a longer delay. */
-				if (to_pci_dev(uhci_dev(uhci))->vendor ==
-						PCI_VENDOR_ID_HP)
-					wait_for_HP(port_addr);
-
-				/* If the port was enabled before, turning
-				 * reset on caused a port enable change.
-				 * Turning reset off causes a port connect
-				 * status change.  Clear these changes. */
-				CLR_RH_PORTSTAT(USBPORTSC_CSC | USBPORTSC_PEC);
-				SET_RH_PORTSTAT(USBPORTSC_PE);
-			}
-		}
-		if (unlikely(status & USBPORTSC_RD)) {
-			if (!test_bit(port, &uhci->resuming_ports)) {
-
-				/* Port received a wakeup request */
-				set_bit(port, &uhci->resuming_ports);
-				uhci->ports_timeout = jiffies +
-						msecs_to_jiffies(20);
-
-				/* Make sure we see the port again
-				 * after the resuming period is over. */
-				mod_timer(&uhci_to_hcd(uhci)->rh_timer,
-						uhci->ports_timeout);
-			} else if (time_after_eq(jiffies,
-						uhci->ports_timeout)) {
-				uhci_finish_suspend(uhci, port, port_addr);
-			}
-		}
-	}
-}
-
-static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	unsigned long flags;
-	int status = 0;
-
-	spin_lock_irqsave(&uhci->lock, flags);
-
-	uhci_scan_schedule(uhci);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags) || uhci->dead)
-		goto done;
-	uhci_check_ports(uhci);
-
-	status = get_hub_status_data(uhci, buf);
-
-	switch (uhci->rh_state) {
-	    case UHCI_RH_SUSPENDING:
-	    case UHCI_RH_SUSPENDED:
-		/* if port change, ask to be resumed */
-		if (status)
-			usb_hcd_resume_root_hub(hcd);
-		break;
-
-	    case UHCI_RH_AUTO_STOPPED:
-		/* if port change, auto start */
-		if (status)
-			wakeup_rh(uhci);
-		break;
-
-	    case UHCI_RH_RUNNING:
-		/* are any devices attached? */
-		if (!any_ports_active(uhci)) {
-			uhci->rh_state = UHCI_RH_RUNNING_NODEVS;
-			uhci->auto_stop_time = jiffies + HZ;
-		}
-		break;
-
-	    case UHCI_RH_RUNNING_NODEVS:
-		/* auto-stop if nothing connected for 1 second */
-		if (any_ports_active(uhci))
-			uhci->rh_state = UHCI_RH_RUNNING;
-		else if (time_after_eq(jiffies, uhci->auto_stop_time))
-			suspend_rh(uhci, UHCI_RH_AUTO_STOPPED);
-		break;
-
-	    default:
-		break;
-	}
-
-done:
-	spin_unlock_irqrestore(&uhci->lock, flags);
-	return status;
-}
-
-/* size of returned buffer is part of USB spec */
-static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
-			u16 wIndex, char *buf, u16 wLength)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	int status, lstatus, retval = 0, len = 0;
-	unsigned int port = wIndex - 1;
-	unsigned long port_addr = uhci->io_addr + USBPORTSC1 + 2 * port;
-	u16 wPortChange, wPortStatus;
-	unsigned long flags;
-
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags) || uhci->dead)
-		return -ETIMEDOUT;
-
-	spin_lock_irqsave(&uhci->lock, flags);
-	switch (typeReq) {
-
-	case GetHubStatus:
-		*(__le32 *)buf = cpu_to_le32(0);
-		OK(4);		/* hub power */
-	case GetPortStatus:
-		if (port >= uhci->rh_numports)
-			goto err;
-
-		uhci_check_ports(uhci);
-		status = inw(port_addr);
-
-		/* Intel controllers report the OverCurrent bit active on.
-		 * VIA controllers report it active off, so we'll adjust the
-		 * bit value.  (It's not standardized in the UHCI spec.)
-		 */
-		if (to_pci_dev(hcd->self.controller)->vendor ==
-				PCI_VENDOR_ID_VIA)
-			status ^= USBPORTSC_OC;
-
-		/* UHCI doesn't support C_RESET (always false) */
-		wPortChange = lstatus = 0;
-		if (status & USBPORTSC_CSC)
-			wPortChange |= USB_PORT_STAT_C_CONNECTION;
-		if (status & USBPORTSC_PEC)
-			wPortChange |= USB_PORT_STAT_C_ENABLE;
-		if ((status & USBPORTSC_OCC) && !ignore_oc)
-			wPortChange |= USB_PORT_STAT_C_OVERCURRENT;
-
-		if (test_bit(port, &uhci->port_c_suspend)) {
-			wPortChange |= USB_PORT_STAT_C_SUSPEND;
-			lstatus |= 1;
-		}
-		if (test_bit(port, &uhci->resuming_ports))
-			lstatus |= 4;
-
-		/* UHCI has no power switching (always on) */
-		wPortStatus = USB_PORT_STAT_POWER;
-		if (status & USBPORTSC_CCS)
-			wPortStatus |= USB_PORT_STAT_CONNECTION;
-		if (status & USBPORTSC_PE) {
-			wPortStatus |= USB_PORT_STAT_ENABLE;
-			if (status & SUSPEND_BITS)
-				wPortStatus |= USB_PORT_STAT_SUSPEND;
-		}
-		if (status & USBPORTSC_OC)
-			wPortStatus |= USB_PORT_STAT_OVERCURRENT;
-		if (status & USBPORTSC_PR)
-			wPortStatus |= USB_PORT_STAT_RESET;
-		if (status & USBPORTSC_LSDA)
-			wPortStatus |= USB_PORT_STAT_LOW_SPEED;
-
-		if (wPortChange)
-			dev_dbg(uhci_dev(uhci), "port %d portsc %04x,%02x\n",
-					wIndex, status, lstatus);
-
-		*(__le16 *)buf = cpu_to_le16(wPortStatus);
-		*(__le16 *)(buf + 2) = cpu_to_le16(wPortChange);
-		OK(4);
-	case SetHubFeature:		/* We don't implement these */
-	case ClearHubFeature:
-		switch (wValue) {
-		case C_HUB_OVER_CURRENT:
-		case C_HUB_LOCAL_POWER:
-			OK(0);
-		default:
-			goto err;
-		}
-		break;
-	case SetPortFeature:
-		if (port >= uhci->rh_numports)
-			goto err;
-
-		switch (wValue) {
-		case USB_PORT_FEAT_SUSPEND:
-			SET_RH_PORTSTAT(USBPORTSC_SUSP);
-			OK(0);
-		case USB_PORT_FEAT_RESET:
-			SET_RH_PORTSTAT(USBPORTSC_PR);
-
-			/* Reset terminates Resume signalling */
-			uhci_finish_suspend(uhci, port, port_addr);
-
-			/* USB v2.0 7.1.7.5 */
-			uhci->ports_timeout = jiffies + msecs_to_jiffies(50);
-			OK(0);
-		case USB_PORT_FEAT_POWER:
-			/* UHCI has no power switching */
-			OK(0);
-		default:
-			goto err;
-		}
-		break;
-	case ClearPortFeature:
-		if (port >= uhci->rh_numports)
-			goto err;
-
-		switch (wValue) {
-		case USB_PORT_FEAT_ENABLE:
-			CLR_RH_PORTSTAT(USBPORTSC_PE);
-
-			/* Disable terminates Resume signalling */
-			uhci_finish_suspend(uhci, port, port_addr);
-			OK(0);
-		case USB_PORT_FEAT_C_ENABLE:
-			CLR_RH_PORTSTAT(USBPORTSC_PEC);
-			OK(0);
-		case USB_PORT_FEAT_SUSPEND:
-			if (!(inw(port_addr) & USBPORTSC_SUSP)) {
-
-				/* Make certain the port isn't suspended */
-				uhci_finish_suspend(uhci, port, port_addr);
-			} else if (!test_and_set_bit(port,
-						&uhci->resuming_ports)) {
-				SET_RH_PORTSTAT(USBPORTSC_RD);
-
-				/* The controller won't allow RD to be set
-				 * if the port is disabled.  When this happens
-				 * just skip the Resume signalling.
-				 */
-				if (!(inw(port_addr) & USBPORTSC_RD))
-					uhci_finish_suspend(uhci, port,
-							port_addr);
-				else
-					/* USB v2.0 7.1.7.7 */
-					uhci->ports_timeout = jiffies +
-						msecs_to_jiffies(20);
-			}
-			OK(0);
-		case USB_PORT_FEAT_C_SUSPEND:
-			clear_bit(port, &uhci->port_c_suspend);
-			OK(0);
-		case USB_PORT_FEAT_POWER:
-			/* UHCI has no power switching */
-			goto err;
-		case USB_PORT_FEAT_C_CONNECTION:
-			CLR_RH_PORTSTAT(USBPORTSC_CSC);
-			OK(0);
-		case USB_PORT_FEAT_C_OVER_CURRENT:
-			CLR_RH_PORTSTAT(USBPORTSC_OCC);
-			OK(0);
-		case USB_PORT_FEAT_C_RESET:
-			/* this driver won't report these */
-			OK(0);
-		default:
-			goto err;
-		}
-		break;
-	case GetHubDescriptor:
-		len = min_t(unsigned int, sizeof(root_hub_hub_des), wLength);
-		memcpy(buf, root_hub_hub_des, len);
-		if (len > 2)
-			buf[2] = uhci->rh_numports;
-		OK(len);
-	default:
-err:
-		retval = -EPIPE;
-	}
-	spin_unlock_irqrestore(&uhci->lock, flags);
-
-	return retval;
-}
diff -urN host/.svn/text-base/uhci-q.c.svn-base host.new/.svn/text-base/uhci-q.c.svn-base
--- host/.svn/text-base/uhci-q.c.svn-base	2009-02-24 19:00:16.047937520 +0100
+++ host.new/.svn/text-base/uhci-q.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,1777 +0,0 @@
-/*
- * Universal Host Controller Interface driver for USB.
- *
- * Maintainer: Alan Stern <stern@rowland.harvard.edu>
- *
- * (C) Copyright 1999 Linus Torvalds
- * (C) Copyright 1999-2002 Johannes Erdfelt, johannes@erdfelt.com
- * (C) Copyright 1999 Randy Dunlap
- * (C) Copyright 1999 Georg Acher, acher@in.tum.de
- * (C) Copyright 1999 Deti Fliegl, deti@fliegl.de
- * (C) Copyright 1999 Thomas Sailer, sailer@ife.ee.ethz.ch
- * (C) Copyright 1999 Roman Weissgaerber, weissg@vienna.at
- * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface
- *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).
- * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)
- * (C) Copyright 2004-2007 Alan Stern, stern@rowland.harvard.edu
- */
-
-
-/*
- * Technically, updating td->status here is a race, but it's not really a
- * problem. The worst that can happen is that we set the IOC bit again
- * generating a spurious interrupt. We could fix this by creating another
- * QH and leaving the IOC bit always set, but then we would have to play
- * games with the FSBR code to make sure we get the correct order in all
- * the cases. I don't think it's worth the effort
- */
-static void uhci_set_next_interrupt(struct uhci_hcd *uhci)
-{
-	if (uhci->is_stopped)
-		mod_timer(&uhci_to_hcd(uhci)->rh_timer, jiffies);
-	uhci->term_td->status |= cpu_to_le32(TD_CTRL_IOC); 
-}
-
-static inline void uhci_clear_next_interrupt(struct uhci_hcd *uhci)
-{
-	uhci->term_td->status &= ~cpu_to_le32(TD_CTRL_IOC);
-}
-
-
-/*
- * Full-Speed Bandwidth Reclamation (FSBR).
- * We turn on FSBR whenever a queue that wants it is advancing,
- * and leave it on for a short time thereafter.
- */
-static void uhci_fsbr_on(struct uhci_hcd *uhci)
-{
-	struct uhci_qh *lqh;
-
-	/* The terminating skeleton QH always points back to the first
-	 * FSBR QH.  Make the last async QH point to the terminating
-	 * skeleton QH. */
-	uhci->fsbr_is_on = 1;
-	lqh = list_entry(uhci->skel_async_qh->node.prev,
-			struct uhci_qh, node);
-	lqh->link = LINK_TO_QH(uhci->skel_term_qh);
-}
-
-static void uhci_fsbr_off(struct uhci_hcd *uhci)
-{
-	struct uhci_qh *lqh;
-
-	/* Remove the link from the last async QH to the terminating
-	 * skeleton QH. */
-	uhci->fsbr_is_on = 0;
-	lqh = list_entry(uhci->skel_async_qh->node.prev,
-			struct uhci_qh, node);
-	lqh->link = UHCI_PTR_TERM;
-}
-
-static void uhci_add_fsbr(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct urb_priv *urbp = urb->hcpriv;
-
-	if (!(urb->transfer_flags & URB_NO_FSBR))
-		urbp->fsbr = 1;
-}
-
-static void uhci_urbp_wants_fsbr(struct uhci_hcd *uhci, struct urb_priv *urbp)
-{
-	if (urbp->fsbr) {
-		uhci->fsbr_is_wanted = 1;
-		if (!uhci->fsbr_is_on)
-			uhci_fsbr_on(uhci);
-		else if (uhci->fsbr_expiring) {
-			uhci->fsbr_expiring = 0;
-			del_timer(&uhci->fsbr_timer);
-		}
-	}
-}
-
-static void uhci_fsbr_timeout(unsigned long _uhci)
-{
-	struct uhci_hcd *uhci = (struct uhci_hcd *) _uhci;
-	unsigned long flags;
-
-	spin_lock_irqsave(&uhci->lock, flags);
-	if (uhci->fsbr_expiring) {
-		uhci->fsbr_expiring = 0;
-		uhci_fsbr_off(uhci);
-	}
-	spin_unlock_irqrestore(&uhci->lock, flags);
-}
-
-
-static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci)
-{
-	dma_addr_t dma_handle;
-	struct uhci_td *td;
-
-	td = dma_pool_alloc(uhci->td_pool, GFP_ATOMIC, &dma_handle);
-	if (!td)
-		return NULL;
-
-	td->dma_handle = dma_handle;
-	td->frame = -1;
-
-	INIT_LIST_HEAD(&td->list);
-	INIT_LIST_HEAD(&td->fl_list);
-
-	return td;
-}
-
-static void uhci_free_td(struct uhci_hcd *uhci, struct uhci_td *td)
-{
-	if (!list_empty(&td->list)) {
-		dev_warn(uhci_dev(uhci), "td %p still in list!\n", td);
-		WARN_ON(1);
-	}
-	if (!list_empty(&td->fl_list)) {
-		dev_warn(uhci_dev(uhci), "td %p still in fl_list!\n", td);
-		WARN_ON(1);
-	}
-
-	dma_pool_free(uhci->td_pool, td, td->dma_handle);
-}
-
-static inline void uhci_fill_td(struct uhci_td *td, u32 status,
-		u32 token, u32 buffer)
-{
-	td->status = cpu_to_le32(status);
-	td->token = cpu_to_le32(token);
-	td->buffer = cpu_to_le32(buffer);
-}
-
-static void uhci_add_td_to_urbp(struct uhci_td *td, struct urb_priv *urbp)
-{
-	list_add_tail(&td->list, &urbp->td_list);
-}
-
-static void uhci_remove_td_from_urbp(struct uhci_td *td)
-{
-	list_del_init(&td->list);
-}
-
-/*
- * We insert Isochronous URBs directly into the frame list at the beginning
- */
-static inline void uhci_insert_td_in_frame_list(struct uhci_hcd *uhci,
-		struct uhci_td *td, unsigned framenum)
-{
-	framenum &= (UHCI_NUMFRAMES - 1);
-
-	td->frame = framenum;
-
-	/* Is there a TD already mapped there? */
-	if (uhci->frame_cpu[framenum]) {
-		struct uhci_td *ftd, *ltd;
-
-		ftd = uhci->frame_cpu[framenum];
-		ltd = list_entry(ftd->fl_list.prev, struct uhci_td, fl_list);
-
-		list_add_tail(&td->fl_list, &ftd->fl_list);
-
-		td->link = ltd->link;
-		wmb();
-		ltd->link = LINK_TO_TD(td);
-	} else {
-		td->link = uhci->frame[framenum];
-		wmb();
-		uhci->frame[framenum] = LINK_TO_TD(td);
-		uhci->frame_cpu[framenum] = td;
-	}
-}
-
-static inline void uhci_remove_td_from_frame_list(struct uhci_hcd *uhci,
-		struct uhci_td *td)
-{
-	/* If it's not inserted, don't remove it */
-	if (td->frame == -1) {
-		WARN_ON(!list_empty(&td->fl_list));
-		return;
-	}
-
-	if (uhci->frame_cpu[td->frame] == td) {
-		if (list_empty(&td->fl_list)) {
-			uhci->frame[td->frame] = td->link;
-			uhci->frame_cpu[td->frame] = NULL;
-		} else {
-			struct uhci_td *ntd;
-
-			ntd = list_entry(td->fl_list.next, struct uhci_td, fl_list);
-			uhci->frame[td->frame] = LINK_TO_TD(ntd);
-			uhci->frame_cpu[td->frame] = ntd;
-		}
-	} else {
-		struct uhci_td *ptd;
-
-		ptd = list_entry(td->fl_list.prev, struct uhci_td, fl_list);
-		ptd->link = td->link;
-	}
-
-	list_del_init(&td->fl_list);
-	td->frame = -1;
-}
-
-static inline void uhci_remove_tds_from_frame(struct uhci_hcd *uhci,
-		unsigned int framenum)
-{
-	struct uhci_td *ftd, *ltd;
-
-	framenum &= (UHCI_NUMFRAMES - 1);
-
-	ftd = uhci->frame_cpu[framenum];
-	if (ftd) {
-		ltd = list_entry(ftd->fl_list.prev, struct uhci_td, fl_list);
-		uhci->frame[framenum] = ltd->link;
-		uhci->frame_cpu[framenum] = NULL;
-
-		while (!list_empty(&ftd->fl_list))
-			list_del_init(ftd->fl_list.prev);
-	}
-}
-
-/*
- * Remove all the TDs for an Isochronous URB from the frame list
- */
-static void uhci_unlink_isochronous_tds(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct urb_priv *urbp = (struct urb_priv *) urb->hcpriv;
-	struct uhci_td *td;
-
-	list_for_each_entry(td, &urbp->td_list, list)
-		uhci_remove_td_from_frame_list(uhci, td);
-}
-
-static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
-		struct usb_device *udev, struct usb_host_endpoint *hep)
-{
-	dma_addr_t dma_handle;
-	struct uhci_qh *qh;
-
-	qh = dma_pool_alloc(uhci->qh_pool, GFP_ATOMIC, &dma_handle);
-	if (!qh)
-		return NULL;
-
-	memset(qh, 0, sizeof(*qh));
-	qh->dma_handle = dma_handle;
-
-	qh->element = UHCI_PTR_TERM;
-	qh->link = UHCI_PTR_TERM;
-
-	INIT_LIST_HEAD(&qh->queue);
-	INIT_LIST_HEAD(&qh->node);
-
-	if (udev) {		/* Normal QH */
-		qh->type = hep->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
-		if (qh->type != USB_ENDPOINT_XFER_ISOC) {
-			qh->dummy_td = uhci_alloc_td(uhci);
-			if (!qh->dummy_td) {
-				dma_pool_free(uhci->qh_pool, qh, dma_handle);
-				return NULL;
-			}
-		}
-		qh->state = QH_STATE_IDLE;
-		qh->hep = hep;
-		qh->udev = udev;
-		hep->hcpriv = qh;
-
-		if (qh->type == USB_ENDPOINT_XFER_INT ||
-				qh->type == USB_ENDPOINT_XFER_ISOC)
-			qh->load = usb_calc_bus_time(udev->speed,
-					usb_endpoint_dir_in(&hep->desc),
-					qh->type == USB_ENDPOINT_XFER_ISOC,
-					le16_to_cpu(hep->desc.wMaxPacketSize))
-				/ 1000 + 1;
-
-	} else {		/* Skeleton QH */
-		qh->state = QH_STATE_ACTIVE;
-		qh->type = -1;
-	}
-	return qh;
-}
-
-static void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
-{
-	WARN_ON(qh->state != QH_STATE_IDLE && qh->udev);
-	if (!list_empty(&qh->queue)) {
-		dev_warn(uhci_dev(uhci), "qh %p list not empty!\n", qh);
-		WARN_ON(1);
-	}
-
-	list_del(&qh->node);
-	if (qh->udev) {
-		qh->hep->hcpriv = NULL;
-		if (qh->dummy_td)
-			uhci_free_td(uhci, qh->dummy_td);
-	}
-	dma_pool_free(uhci->qh_pool, qh, qh->dma_handle);
-}
-
-/*
- * When a queue is stopped and a dequeued URB is given back, adjust
- * the previous TD link (if the URB isn't first on the queue) or
- * save its toggle value (if it is first and is currently executing).
- *
- * Returns 0 if the URB should not yet be given back, 1 otherwise.
- */
-static int uhci_cleanup_queue(struct uhci_hcd *uhci, struct uhci_qh *qh,
-		struct urb *urb)
-{
-	struct urb_priv *urbp = urb->hcpriv;
-	struct uhci_td *td;
-	int ret = 1;
-
-	/* Isochronous pipes don't use toggles and their TD link pointers
-	 * get adjusted during uhci_urb_dequeue().  But since their queues
-	 * cannot truly be stopped, we have to watch out for dequeues
-	 * occurring after the nominal unlink frame. */
-	if (qh->type == USB_ENDPOINT_XFER_ISOC) {
-		ret = (uhci->frame_number + uhci->is_stopped !=
-				qh->unlink_frame);
-		goto done;
-	}
-
-	/* If the URB isn't first on its queue, adjust the link pointer
-	 * of the last TD in the previous URB.  The toggle doesn't need
-	 * to be saved since this URB can't be executing yet. */
-	if (qh->queue.next != &urbp->node) {
-		struct urb_priv *purbp;
-		struct uhci_td *ptd;
-
-		purbp = list_entry(urbp->node.prev, struct urb_priv, node);
-		WARN_ON(list_empty(&purbp->td_list));
-		ptd = list_entry(purbp->td_list.prev, struct uhci_td,
-				list);
-		td = list_entry(urbp->td_list.prev, struct uhci_td,
-				list);
-		ptd->link = td->link;
-		goto done;
-	}
-
-	/* If the QH element pointer is UHCI_PTR_TERM then then currently
-	 * executing URB has already been unlinked, so this one isn't it. */
-	if (qh_element(qh) == UHCI_PTR_TERM)
-		goto done;
-	qh->element = UHCI_PTR_TERM;
-
-	/* Control pipes don't have to worry about toggles */
-	if (qh->type == USB_ENDPOINT_XFER_CONTROL)
-		goto done;
-
-	/* Save the next toggle value */
-	WARN_ON(list_empty(&urbp->td_list));
-	td = list_entry(urbp->td_list.next, struct uhci_td, list);
-	qh->needs_fixup = 1;
-	qh->initial_toggle = uhci_toggle(td_token(td));
-
-done:
-	return ret;
-}
-
-/*
- * Fix up the data toggles for URBs in a queue, when one of them
- * terminates early (short transfer, error, or dequeued).
- */
-static void uhci_fixup_toggles(struct uhci_qh *qh, int skip_first)
-{
-	struct urb_priv *urbp = NULL;
-	struct uhci_td *td;
-	unsigned int toggle = qh->initial_toggle;
-	unsigned int pipe;
-
-	/* Fixups for a short transfer start with the second URB in the
-	 * queue (the short URB is the first). */
-	if (skip_first)
-		urbp = list_entry(qh->queue.next, struct urb_priv, node);
-
-	/* When starting with the first URB, if the QH element pointer is
-	 * still valid then we know the URB's toggles are okay. */
-	else if (qh_element(qh) != UHCI_PTR_TERM)
-		toggle = 2;
-
-	/* Fix up the toggle for the URBs in the queue.  Normally this
-	 * loop won't run more than once: When an error or short transfer
-	 * occurs, the queue usually gets emptied. */
-	urbp = list_prepare_entry(urbp, &qh->queue, node);
-	list_for_each_entry_continue(urbp, &qh->queue, node) {
-
-		/* If the first TD has the right toggle value, we don't
-		 * need to change any toggles in this URB */
-		td = list_entry(urbp->td_list.next, struct uhci_td, list);
-		if (toggle > 1 || uhci_toggle(td_token(td)) == toggle) {
-			td = list_entry(urbp->td_list.prev, struct uhci_td,
-					list);
-			toggle = uhci_toggle(td_token(td)) ^ 1;
-
-		/* Otherwise all the toggles in the URB have to be switched */
-		} else {
-			list_for_each_entry(td, &urbp->td_list, list) {
-				td->token ^= __constant_cpu_to_le32(
-							TD_TOKEN_TOGGLE);
-				toggle ^= 1;
-			}
-		}
-	}
-
-	wmb();
-	pipe = list_entry(qh->queue.next, struct urb_priv, node)->urb->pipe;
-	usb_settoggle(qh->udev, usb_pipeendpoint(pipe),
-			usb_pipeout(pipe), toggle);
-	qh->needs_fixup = 0;
-}
-
-/*
- * Link an Isochronous QH into its skeleton's list
- */
-static inline void link_iso(struct uhci_hcd *uhci, struct uhci_qh *qh)
-{
-	list_add_tail(&qh->node, &uhci->skel_iso_qh->node);
-
-	/* Isochronous QHs aren't linked by the hardware */
-}
-
-/*
- * Link a high-period interrupt QH into the schedule at the end of its
- * skeleton's list
- */
-static void link_interrupt(struct uhci_hcd *uhci, struct uhci_qh *qh)
-{
-	struct uhci_qh *pqh;
-
-	list_add_tail(&qh->node, &uhci->skelqh[qh->skel]->node);
-
-	pqh = list_entry(qh->node.prev, struct uhci_qh, node);
-	qh->link = pqh->link;
-	wmb();
-	pqh->link = LINK_TO_QH(qh);
-}
-
-/*
- * Link a period-1 interrupt or async QH into the schedule at the
- * correct spot in the async skeleton's list, and update the FSBR link
- */
-static void link_async(struct uhci_hcd *uhci, struct uhci_qh *qh)
-{
-	struct uhci_qh *pqh;
-	__le32 link_to_new_qh;
-
-	/* Find the predecessor QH for our new one and insert it in the list.
-	 * The list of QHs is expected to be short, so linear search won't
-	 * take too long. */
-	list_for_each_entry_reverse(pqh, &uhci->skel_async_qh->node, node) {
-		if (pqh->skel <= qh->skel)
-			break;
-	}
-	list_add(&qh->node, &pqh->node);
-
-	/* Link it into the schedule */
-	qh->link = pqh->link;
-	wmb();
-	link_to_new_qh = LINK_TO_QH(qh);
-	pqh->link = link_to_new_qh;
-
-	/* If this is now the first FSBR QH, link the terminating skeleton
-	 * QH to it. */
-	if (pqh->skel < SKEL_FSBR && qh->skel >= SKEL_FSBR)
-		uhci->skel_term_qh->link = link_to_new_qh;
-}
-
-/*
- * Put a QH on the schedule in both hardware and software
- */
-static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
-{
-	WARN_ON(list_empty(&qh->queue));
-
-	/* Set the element pointer if it isn't set already.
-	 * This isn't needed for Isochronous queues, but it doesn't hurt. */
-	if (qh_element(qh) == UHCI_PTR_TERM) {
-		struct urb_priv *urbp = list_entry(qh->queue.next,
-				struct urb_priv, node);
-		struct uhci_td *td = list_entry(urbp->td_list.next,
-				struct uhci_td, list);
-
-		qh->element = LINK_TO_TD(td);
-	}
-
-	/* Treat the queue as if it has just advanced */
-	qh->wait_expired = 0;
-	qh->advance_jiffies = jiffies;
-
-	if (qh->state == QH_STATE_ACTIVE)
-		return;
-	qh->state = QH_STATE_ACTIVE;
-
-	/* Move the QH from its old list to the correct spot in the appropriate
-	 * skeleton's list */
-	if (qh == uhci->next_qh)
-		uhci->next_qh = list_entry(qh->node.next, struct uhci_qh,
-				node);
-	list_del(&qh->node);
-
-	if (qh->skel == SKEL_ISO)
-		link_iso(uhci, qh);
-	else if (qh->skel < SKEL_ASYNC)
-		link_interrupt(uhci, qh);
-	else
-		link_async(uhci, qh);
-}
-
-/*
- * Unlink a high-period interrupt QH from the schedule
- */
-static void unlink_interrupt(struct uhci_hcd *uhci, struct uhci_qh *qh)
-{
-	struct uhci_qh *pqh;
-
-	pqh = list_entry(qh->node.prev, struct uhci_qh, node);
-	pqh->link = qh->link;
-	mb();
-}
-
-/*
- * Unlink a period-1 interrupt or async QH from the schedule
- */
-static void unlink_async(struct uhci_hcd *uhci, struct uhci_qh *qh)
-{
-	struct uhci_qh *pqh;
-	__le32 link_to_next_qh = qh->link;
-
-	pqh = list_entry(qh->node.prev, struct uhci_qh, node);
-	pqh->link = link_to_next_qh;
-
-	/* If this was the old first FSBR QH, link the terminating skeleton
-	 * QH to the next (new first FSBR) QH. */
-	if (pqh->skel < SKEL_FSBR && qh->skel >= SKEL_FSBR)
-		uhci->skel_term_qh->link = link_to_next_qh;
-	mb();
-}
-
-/*
- * Take a QH off the hardware schedule
- */
-static void uhci_unlink_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
-{
-	if (qh->state == QH_STATE_UNLINKING)
-		return;
-	WARN_ON(qh->state != QH_STATE_ACTIVE || !qh->udev);
-	qh->state = QH_STATE_UNLINKING;
-
-	/* Unlink the QH from the schedule and record when we did it */
-	if (qh->skel == SKEL_ISO)
-		;
-	else if (qh->skel < SKEL_ASYNC)
-		unlink_interrupt(uhci, qh);
-	else
-		unlink_async(uhci, qh);
-
-	uhci_get_current_frame_number(uhci);
-	qh->unlink_frame = uhci->frame_number;
-
-	/* Force an interrupt so we know when the QH is fully unlinked */
-	if (list_empty(&uhci->skel_unlink_qh->node))
-		uhci_set_next_interrupt(uhci);
-
-	/* Move the QH from its old list to the end of the unlinking list */
-	if (qh == uhci->next_qh)
-		uhci->next_qh = list_entry(qh->node.next, struct uhci_qh,
-				node);
-	list_move_tail(&qh->node, &uhci->skel_unlink_qh->node);
-}
-
-/*
- * When we and the controller are through with a QH, it becomes IDLE.
- * This happens when a QH has been off the schedule (on the unlinking
- * list) for more than one frame, or when an error occurs while adding
- * the first URB onto a new QH.
- */
-static void uhci_make_qh_idle(struct uhci_hcd *uhci, struct uhci_qh *qh)
-{
-	WARN_ON(qh->state == QH_STATE_ACTIVE);
-
-	if (qh == uhci->next_qh)
-		uhci->next_qh = list_entry(qh->node.next, struct uhci_qh,
-				node);
-	list_move(&qh->node, &uhci->idle_qh_list);
-	qh->state = QH_STATE_IDLE;
-
-	/* Now that the QH is idle, its post_td isn't being used */
-	if (qh->post_td) {
-		uhci_free_td(uhci, qh->post_td);
-		qh->post_td = NULL;
-	}
-
-	/* If anyone is waiting for a QH to become idle, wake them up */
-	if (uhci->num_waiting)
-		wake_up_all(&uhci->waitqh);
-}
-
-/*
- * Find the highest existing bandwidth load for a given phase and period.
- */
-static int uhci_highest_load(struct uhci_hcd *uhci, int phase, int period)
-{
-	int highest_load = uhci->load[phase];
-
-	for (phase += period; phase < MAX_PHASE; phase += period)
-		highest_load = max_t(int, highest_load, uhci->load[phase]);
-	return highest_load;
-}
-
-/*
- * Set qh->phase to the optimal phase for a periodic transfer and
- * check whether the bandwidth requirement is acceptable.
- */
-static int uhci_check_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)
-{
-	int minimax_load;
-
-	/* Find the optimal phase (unless it is already set) and get
-	 * its load value. */
-	if (qh->phase >= 0)
-		minimax_load = uhci_highest_load(uhci, qh->phase, qh->period);
-	else {
-		int phase, load;
-		int max_phase = min_t(int, MAX_PHASE, qh->period);
-
-		qh->phase = 0;
-		minimax_load = uhci_highest_load(uhci, qh->phase, qh->period);
-		for (phase = 1; phase < max_phase; ++phase) {
-			load = uhci_highest_load(uhci, phase, qh->period);
-			if (load < minimax_load) {
-				minimax_load = load;
-				qh->phase = phase;
-			}
-		}
-	}
-
-	/* Maximum allowable periodic bandwidth is 90%, or 900 us per frame */
-	if (minimax_load + qh->load > 900) {
-		dev_dbg(uhci_dev(uhci), "bandwidth allocation failed: "
-				"period %d, phase %d, %d + %d us\n",
-				qh->period, qh->phase, minimax_load, qh->load);
-		return -ENOSPC;
-	}
-	return 0;
-}
-
-/*
- * Reserve a periodic QH's bandwidth in the schedule
- */
-static void uhci_reserve_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)
-{
-	int i;
-	int load = qh->load;
-	char *p = "??";
-
-	for (i = qh->phase; i < MAX_PHASE; i += qh->period) {
-		uhci->load[i] += load;
-		uhci->total_load += load;
-	}
-	uhci_to_hcd(uhci)->self.bandwidth_allocated =
-			uhci->total_load / MAX_PHASE;
-	switch (qh->type) {
-	case USB_ENDPOINT_XFER_INT:
-		++uhci_to_hcd(uhci)->self.bandwidth_int_reqs;
-		p = "INT";
-		break;
-	case USB_ENDPOINT_XFER_ISOC:
-		++uhci_to_hcd(uhci)->self.bandwidth_isoc_reqs;
-		p = "ISO";
-		break;
-	}
-	qh->bandwidth_reserved = 1;
-	dev_dbg(uhci_dev(uhci),
-			"%s dev %d ep%02x-%s, period %d, phase %d, %d us\n",
-			"reserve", qh->udev->devnum,
-			qh->hep->desc.bEndpointAddress, p,
-			qh->period, qh->phase, load);
-}
-
-/*
- * Release a periodic QH's bandwidth reservation
- */
-static void uhci_release_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)
-{
-	int i;
-	int load = qh->load;
-	char *p = "??";
-
-	for (i = qh->phase; i < MAX_PHASE; i += qh->period) {
-		uhci->load[i] -= load;
-		uhci->total_load -= load;
-	}
-	uhci_to_hcd(uhci)->self.bandwidth_allocated =
-			uhci->total_load / MAX_PHASE;
-	switch (qh->type) {
-	case USB_ENDPOINT_XFER_INT:
-		--uhci_to_hcd(uhci)->self.bandwidth_int_reqs;
-		p = "INT";
-		break;
-	case USB_ENDPOINT_XFER_ISOC:
-		--uhci_to_hcd(uhci)->self.bandwidth_isoc_reqs;
-		p = "ISO";
-		break;
-	}
-	qh->bandwidth_reserved = 0;
-	dev_dbg(uhci_dev(uhci),
-			"%s dev %d ep%02x-%s, period %d, phase %d, %d us\n",
-			"release", qh->udev->devnum,
-			qh->hep->desc.bEndpointAddress, p,
-			qh->period, qh->phase, load);
-}
-
-static inline struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci,
-		struct urb *urb)
-{
-	struct urb_priv *urbp;
-
-	urbp = kmem_cache_zalloc(uhci_up_cachep, GFP_ATOMIC);
-	if (!urbp)
-		return NULL;
-
-	urbp->urb = urb;
-	urb->hcpriv = urbp;
-	
-	INIT_LIST_HEAD(&urbp->node);
-	INIT_LIST_HEAD(&urbp->td_list);
-
-	return urbp;
-}
-
-static void uhci_free_urb_priv(struct uhci_hcd *uhci,
-		struct urb_priv *urbp)
-{
-	struct uhci_td *td, *tmp;
-
-	if (!list_empty(&urbp->node)) {
-		dev_warn(uhci_dev(uhci), "urb %p still on QH's list!\n",
-				urbp->urb);
-		WARN_ON(1);
-	}
-
-	list_for_each_entry_safe(td, tmp, &urbp->td_list, list) {
-		uhci_remove_td_from_urbp(td);
-		uhci_free_td(uhci, td);
-	}
-
-	urbp->urb->hcpriv = NULL;
-	kmem_cache_free(uhci_up_cachep, urbp);
-}
-
-/*
- * Map status to standard result codes
- *
- * <status> is (td_status(td) & 0xF60000), a.k.a.
- * uhci_status_bits(td_status(td)).
- * Note: <status> does not include the TD_CTRL_NAK bit.
- * <dir_out> is True for output TDs and False for input TDs.
- */
-static int uhci_map_status(int status, int dir_out)
-{
-	if (!status)
-		return 0;
-	if (status & TD_CTRL_BITSTUFF)			/* Bitstuff error */
-		return -EPROTO;
-	if (status & TD_CTRL_CRCTIMEO) {		/* CRC/Timeout */
-		if (dir_out)
-			return -EPROTO;
-		else
-			return -EILSEQ;
-	}
-	if (status & TD_CTRL_BABBLE)			/* Babble */
-		return -EOVERFLOW;
-	if (status & TD_CTRL_DBUFERR)			/* Buffer error */
-		return -ENOSR;
-	if (status & TD_CTRL_STALLED)			/* Stalled */
-		return -EPIPE;
-	return 0;
-}
-
-/*
- * Control transfers
- */
-static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
-		struct uhci_qh *qh)
-{
-	struct uhci_td *td;
-	unsigned long destination, status;
-	int maxsze = le16_to_cpu(qh->hep->desc.wMaxPacketSize);
-	int len = urb->transfer_buffer_length;
-	dma_addr_t data = urb->transfer_dma;
-	__le32 *plink;
-	struct urb_priv *urbp = urb->hcpriv;
-	int skel;
-
-	/* The "pipe" thing contains the destination in bits 8--18 */
-	destination = (urb->pipe & PIPE_DEVEP_MASK) | USB_PID_SETUP;
-
-	/* 3 errors, dummy TD remains inactive */
-	status = uhci_maxerr(3);
-	if (urb->dev->speed == USB_SPEED_LOW)
-		status |= TD_CTRL_LS;
-
-	/*
-	 * Build the TD for the control request setup packet
-	 */
-	td = qh->dummy_td;
-	uhci_add_td_to_urbp(td, urbp);
-	uhci_fill_td(td, status, destination | uhci_explen(8),
-			urb->setup_dma);
-	plink = &td->link;
-	status |= TD_CTRL_ACTIVE;
-
-	/*
-	 * If direction is "send", change the packet ID from SETUP (0x2D)
-	 * to OUT (0xE1).  Else change it from SETUP to IN (0x69) and
-	 * set Short Packet Detect (SPD) for all data packets.
-	 *
-	 * 0-length transfers always get treated as "send".
-	 */
-	if (usb_pipeout(urb->pipe) || len == 0)
-		destination ^= (USB_PID_SETUP ^ USB_PID_OUT);
-	else {
-		destination ^= (USB_PID_SETUP ^ USB_PID_IN);
-		status |= TD_CTRL_SPD;
-	}
-
-	/*
-	 * Build the DATA TDs
-	 */
-	while (len > 0) {
-		int pktsze = maxsze;
-
-		if (len <= pktsze) {		/* The last data packet */
-			pktsze = len;
-			status &= ~TD_CTRL_SPD;
-		}
-
-		td = uhci_alloc_td(uhci);
-		if (!td)
-			goto nomem;
-		*plink = LINK_TO_TD(td);
-
-		/* Alternate Data0/1 (start with Data1) */
-		destination ^= TD_TOKEN_TOGGLE;
-	
-		uhci_add_td_to_urbp(td, urbp);
-		uhci_fill_td(td, status, destination | uhci_explen(pktsze),
-				data);
-		plink = &td->link;
-
-		data += pktsze;
-		len -= pktsze;
-	}
-
-	/*
-	 * Build the final TD for control status 
-	 */
-	td = uhci_alloc_td(uhci);
-	if (!td)
-		goto nomem;
-	*plink = LINK_TO_TD(td);
-
-	/* Change direction for the status transaction */
-	destination ^= (USB_PID_IN ^ USB_PID_OUT);
-	destination |= TD_TOKEN_TOGGLE;		/* End in Data1 */
-
-	uhci_add_td_to_urbp(td, urbp);
-	uhci_fill_td(td, status | TD_CTRL_IOC,
-			destination | uhci_explen(0), 0);
-	plink = &td->link;
-
-	/*
-	 * Build the new dummy TD and activate the old one
-	 */
-	td = uhci_alloc_td(uhci);
-	if (!td)
-		goto nomem;
-	*plink = LINK_TO_TD(td);
-
-	uhci_fill_td(td, 0, USB_PID_OUT | uhci_explen(0), 0);
-	wmb();
-	qh->dummy_td->status |= __constant_cpu_to_le32(TD_CTRL_ACTIVE);
-	qh->dummy_td = td;
-
-	/* Low-speed transfers get a different queue, and won't hog the bus.
-	 * Also, some devices enumerate better without FSBR; the easiest way
-	 * to do that is to put URBs on the low-speed queue while the device
-	 * isn't in the CONFIGURED state. */
-	if (urb->dev->speed == USB_SPEED_LOW ||
-			urb->dev->state != USB_STATE_CONFIGURED)
-		skel = SKEL_LS_CONTROL;
-	else {
-		skel = SKEL_FS_CONTROL;
-		uhci_add_fsbr(uhci, urb);
-	}
-	if (qh->state != QH_STATE_ACTIVE)
-		qh->skel = skel;
-
-	urb->actual_length = -8;	/* Account for the SETUP packet */
-	return 0;
-
-nomem:
-	/* Remove the dummy TD from the td_list so it doesn't get freed */
-	uhci_remove_td_from_urbp(qh->dummy_td);
-	return -ENOMEM;
-}
-
-/*
- * Common submit for bulk and interrupt
- */
-static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
-		struct uhci_qh *qh)
-{
-	struct uhci_td *td;
-	unsigned long destination, status;
-	int maxsze = le16_to_cpu(qh->hep->desc.wMaxPacketSize);
-	int len = urb->transfer_buffer_length;
-	dma_addr_t data = urb->transfer_dma;
-	__le32 *plink;
-	struct urb_priv *urbp = urb->hcpriv;
-	unsigned int toggle;
-
-	if (len < 0)
-		return -EINVAL;
-
-	/* The "pipe" thing contains the destination in bits 8--18 */
-	destination = (urb->pipe & PIPE_DEVEP_MASK) | usb_packetid(urb->pipe);
-	toggle = usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe),
-			 usb_pipeout(urb->pipe));
-
-	/* 3 errors, dummy TD remains inactive */
-	status = uhci_maxerr(3);
-	if (urb->dev->speed == USB_SPEED_LOW)
-		status |= TD_CTRL_LS;
-	if (usb_pipein(urb->pipe))
-		status |= TD_CTRL_SPD;
-
-	/*
-	 * Build the DATA TDs
-	 */
-	plink = NULL;
-	td = qh->dummy_td;
-	do {	/* Allow zero length packets */
-		int pktsze = maxsze;
-
-		if (len <= pktsze) {		/* The last packet */
-			pktsze = len;
-			if (!(urb->transfer_flags & URB_SHORT_NOT_OK))
-				status &= ~TD_CTRL_SPD;
-		}
-
-		if (plink) {
-			td = uhci_alloc_td(uhci);
-			if (!td)
-				goto nomem;
-			*plink = LINK_TO_TD(td);
-		}
-		uhci_add_td_to_urbp(td, urbp);
-		uhci_fill_td(td, status,
-				destination | uhci_explen(pktsze) |
-					(toggle << TD_TOKEN_TOGGLE_SHIFT),
-				data);
-		plink = &td->link;
-		status |= TD_CTRL_ACTIVE;
-
-		data += pktsze;
-		len -= maxsze;
-		toggle ^= 1;
-	} while (len > 0);
-
-	/*
-	 * URB_ZERO_PACKET means adding a 0-length packet, if direction
-	 * is OUT and the transfer_length was an exact multiple of maxsze,
-	 * hence (len = transfer_length - N * maxsze) == 0
-	 * however, if transfer_length == 0, the zero packet was already
-	 * prepared above.
-	 */
-	if ((urb->transfer_flags & URB_ZERO_PACKET) &&
-			usb_pipeout(urb->pipe) && len == 0 &&
-			urb->transfer_buffer_length > 0) {
-		td = uhci_alloc_td(uhci);
-		if (!td)
-			goto nomem;
-		*plink = LINK_TO_TD(td);
-
-		uhci_add_td_to_urbp(td, urbp);
-		uhci_fill_td(td, status,
-				destination | uhci_explen(0) |
-					(toggle << TD_TOKEN_TOGGLE_SHIFT),
-				data);
-		plink = &td->link;
-
-		toggle ^= 1;
-	}
-
-	/* Set the interrupt-on-completion flag on the last packet.
-	 * A more-or-less typical 4 KB URB (= size of one memory page)
-	 * will require about 3 ms to transfer; that's a little on the
-	 * fast side but not enough to justify delaying an interrupt
-	 * more than 2 or 3 URBs, so we will ignore the URB_NO_INTERRUPT
-	 * flag setting. */
-	td->status |= __constant_cpu_to_le32(TD_CTRL_IOC);
-
-	/*
-	 * Build the new dummy TD and activate the old one
-	 */
-	td = uhci_alloc_td(uhci);
-	if (!td)
-		goto nomem;
-	*plink = LINK_TO_TD(td);
-
-	uhci_fill_td(td, 0, USB_PID_OUT | uhci_explen(0), 0);
-	wmb();
-	qh->dummy_td->status |= __constant_cpu_to_le32(TD_CTRL_ACTIVE);
-	qh->dummy_td = td;
-
-	usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
-			usb_pipeout(urb->pipe), toggle);
-	return 0;
-
-nomem:
-	/* Remove the dummy TD from the td_list so it doesn't get freed */
-	uhci_remove_td_from_urbp(qh->dummy_td);
-	return -ENOMEM;
-}
-
-static int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
-		struct uhci_qh *qh)
-{
-	int ret;
-
-	/* Can't have low-speed bulk transfers */
-	if (urb->dev->speed == USB_SPEED_LOW)
-		return -EINVAL;
-
-	if (qh->state != QH_STATE_ACTIVE)
-		qh->skel = SKEL_BULK;
-	ret = uhci_submit_common(uhci, urb, qh);
-	if (ret == 0)
-		uhci_add_fsbr(uhci, urb);
-	return ret;
-}
-
-static int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
-		struct uhci_qh *qh)
-{
-	int ret;
-
-	/* USB 1.1 interrupt transfers only involve one packet per interval.
-	 * Drivers can submit URBs of any length, but longer ones will need
-	 * multiple intervals to complete.
-	 */
-
-	if (!qh->bandwidth_reserved) {
-		int exponent;
-
-		/* Figure out which power-of-two queue to use */
-		for (exponent = 7; exponent >= 0; --exponent) {
-			if ((1 << exponent) <= urb->interval)
-				break;
-		}
-		if (exponent < 0)
-			return -EINVAL;
-		qh->period = 1 << exponent;
-		qh->skel = SKEL_INDEX(exponent);
-
-		/* For now, interrupt phase is fixed by the layout
-		 * of the QH lists. */
-		qh->phase = (qh->period / 2) & (MAX_PHASE - 1);
-		ret = uhci_check_bandwidth(uhci, qh);
-		if (ret)
-			return ret;
-	} else if (qh->period > urb->interval)
-		return -EINVAL;		/* Can't decrease the period */
-
-	ret = uhci_submit_common(uhci, urb, qh);
-	if (ret == 0) {
-		urb->interval = qh->period;
-		if (!qh->bandwidth_reserved)
-			uhci_reserve_bandwidth(uhci, qh);
-	}
-	return ret;
-}
-
-/*
- * Fix up the data structures following a short transfer
- */
-static int uhci_fixup_short_transfer(struct uhci_hcd *uhci,
-		struct uhci_qh *qh, struct urb_priv *urbp)
-{
-	struct uhci_td *td;
-	struct list_head *tmp;
-	int ret;
-
-	td = list_entry(urbp->td_list.prev, struct uhci_td, list);
-	if (qh->type == USB_ENDPOINT_XFER_CONTROL) {
-
-		/* When a control transfer is short, we have to restart
-		 * the queue at the status stage transaction, which is
-		 * the last TD. */
-		WARN_ON(list_empty(&urbp->td_list));
-		qh->element = LINK_TO_TD(td);
-		tmp = td->list.prev;
-		ret = -EINPROGRESS;
-
-	} else {
-
-		/* When a bulk/interrupt transfer is short, we have to
-		 * fix up the toggles of the following URBs on the queue
-		 * before restarting the queue at the next URB. */
-		qh->initial_toggle = uhci_toggle(td_token(qh->post_td)) ^ 1;
-		uhci_fixup_toggles(qh, 1);
-
-		if (list_empty(&urbp->td_list))
-			td = qh->post_td;
-		qh->element = td->link;
-		tmp = urbp->td_list.prev;
-		ret = 0;
-	}
-
-	/* Remove all the TDs we skipped over, from tmp back to the start */
-	while (tmp != &urbp->td_list) {
-		td = list_entry(tmp, struct uhci_td, list);
-		tmp = tmp->prev;
-
-		uhci_remove_td_from_urbp(td);
-		uhci_free_td(uhci, td);
-	}
-	return ret;
-}
-
-/*
- * Common result for control, bulk, and interrupt
- */
-static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct urb_priv *urbp = urb->hcpriv;
-	struct uhci_qh *qh = urbp->qh;
-	struct uhci_td *td, *tmp;
-	unsigned status;
-	int ret = 0;
-
-	list_for_each_entry_safe(td, tmp, &urbp->td_list, list) {
-		unsigned int ctrlstat;
-		int len;
-
-		ctrlstat = td_status(td);
-		status = uhci_status_bits(ctrlstat);
-		if (status & TD_CTRL_ACTIVE)
-			return -EINPROGRESS;
-
-		len = uhci_actual_length(ctrlstat);
-		urb->actual_length += len;
-
-		if (status) {
-			ret = uhci_map_status(status,
-					uhci_packetout(td_token(td)));
-			if ((debug == 1 && ret != -EPIPE) || debug > 1) {
-				/* Some debugging code */
-				dev_dbg(&urb->dev->dev,
-						"%s: failed with status %x\n",
-						__FUNCTION__, status);
-
-				if (debug > 1 && errbuf) {
-					/* Print the chain for debugging */
-					uhci_show_qh(uhci, urbp->qh, errbuf,
-							ERRBUF_LEN, 0);
-					lprintk(errbuf);
-				}
-			}
-
-		/* Did we receive a short packet? */
-		} else if (len < uhci_expected_length(td_token(td))) {
-
-			/* For control transfers, go to the status TD if
-			 * this isn't already the last data TD */
-			if (qh->type == USB_ENDPOINT_XFER_CONTROL) {
-				if (td->list.next != urbp->td_list.prev)
-					ret = 1;
-			}
-
-			/* For bulk and interrupt, this may be an error */
-			else if (urb->transfer_flags & URB_SHORT_NOT_OK)
-				ret = -EREMOTEIO;
-
-			/* Fixup needed only if this isn't the URB's last TD */
-			else if (&td->list != urbp->td_list.prev)
-				ret = 1;
-		}
-
-		uhci_remove_td_from_urbp(td);
-		if (qh->post_td)
-			uhci_free_td(uhci, qh->post_td);
-		qh->post_td = td;
-
-		if (ret != 0)
-			goto err;
-	}
-	return ret;
-
-err:
-	if (ret < 0) {
-		/* Note that the queue has stopped and save
-		 * the next toggle value */
-		qh->element = UHCI_PTR_TERM;
-		qh->is_stopped = 1;
-		qh->needs_fixup = (qh->type != USB_ENDPOINT_XFER_CONTROL);
-		qh->initial_toggle = uhci_toggle(td_token(td)) ^
-				(ret == -EREMOTEIO);
-
-	} else		/* Short packet received */
-		ret = uhci_fixup_short_transfer(uhci, qh, urbp);
-	return ret;
-}
-
-/*
- * Isochronous transfers
- */
-static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
-		struct uhci_qh *qh)
-{
-	struct uhci_td *td = NULL;	/* Since urb->number_of_packets > 0 */
-	int i, frame;
-	unsigned long destination, status;
-	struct urb_priv *urbp = (struct urb_priv *) urb->hcpriv;
-
-	/* Values must not be too big (could overflow below) */
-	if (urb->interval >= UHCI_NUMFRAMES ||
-			urb->number_of_packets >= UHCI_NUMFRAMES)
-		return -EFBIG;
-
-	/* Check the period and figure out the starting frame number */
-	if (!qh->bandwidth_reserved) {
-		qh->period = urb->interval;
-		if (urb->transfer_flags & URB_ISO_ASAP) {
-			qh->phase = -1;		/* Find the best phase */
-			i = uhci_check_bandwidth(uhci, qh);
-			if (i)
-				return i;
-
-			/* Allow a little time to allocate the TDs */
-			uhci_get_current_frame_number(uhci);
-			frame = uhci->frame_number + 10;
-
-			/* Move forward to the first frame having the
-			 * correct phase */
-			urb->start_frame = frame + ((qh->phase - frame) &
-					(qh->period - 1));
-		} else {
-			i = urb->start_frame - uhci->last_iso_frame;
-			if (i <= 0 || i >= UHCI_NUMFRAMES)
-				return -EINVAL;
-			qh->phase = urb->start_frame & (qh->period - 1);
-			i = uhci_check_bandwidth(uhci, qh);
-			if (i)
-				return i;
-		}
-
-	} else if (qh->period != urb->interval) {
-		return -EINVAL;		/* Can't change the period */
-
-	} else {	/* Pick up where the last URB leaves off */
-		if (list_empty(&qh->queue)) {
-			frame = qh->iso_frame;
-		} else {
-			struct urb *lurb;
-
-			lurb = list_entry(qh->queue.prev,
-					struct urb_priv, node)->urb;
-			frame = lurb->start_frame +
-					lurb->number_of_packets *
-					lurb->interval;
-		}
-		if (urb->transfer_flags & URB_ISO_ASAP)
-			urb->start_frame = frame;
-		else if (urb->start_frame != frame)
-			return -EINVAL;
-	}
-
-	/* Make sure we won't have to go too far into the future */
-	if (uhci_frame_before_eq(uhci->last_iso_frame + UHCI_NUMFRAMES,
-			urb->start_frame + urb->number_of_packets *
-				urb->interval))
-		return -EFBIG;
-
-	status = TD_CTRL_ACTIVE | TD_CTRL_IOS;
-	destination = (urb->pipe & PIPE_DEVEP_MASK) | usb_packetid(urb->pipe);
-
-	for (i = 0; i < urb->number_of_packets; i++) {
-		td = uhci_alloc_td(uhci);
-		if (!td)
-			return -ENOMEM;
-
-		uhci_add_td_to_urbp(td, urbp);
-		uhci_fill_td(td, status, destination |
-				uhci_explen(urb->iso_frame_desc[i].length),
-				urb->transfer_dma +
-					urb->iso_frame_desc[i].offset);
-	}
-
-	/* Set the interrupt-on-completion flag on the last packet. */
-	td->status |= __constant_cpu_to_le32(TD_CTRL_IOC);
-
-	/* Add the TDs to the frame list */
-	frame = urb->start_frame;
-	list_for_each_entry(td, &urbp->td_list, list) {
-		uhci_insert_td_in_frame_list(uhci, td, frame);
-		frame += qh->period;
-	}
-
-	if (list_empty(&qh->queue)) {
-		qh->iso_packet_desc = &urb->iso_frame_desc[0];
-		qh->iso_frame = urb->start_frame;
-		qh->iso_status = 0;
-	}
-
-	qh->skel = SKEL_ISO;
-	if (!qh->bandwidth_reserved)
-		uhci_reserve_bandwidth(uhci, qh);
-	return 0;
-}
-
-static int uhci_result_isochronous(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct uhci_td *td, *tmp;
-	struct urb_priv *urbp = urb->hcpriv;
-	struct uhci_qh *qh = urbp->qh;
-
-	list_for_each_entry_safe(td, tmp, &urbp->td_list, list) {
-		unsigned int ctrlstat;
-		int status;
-		int actlength;
-
-		if (uhci_frame_before_eq(uhci->cur_iso_frame, qh->iso_frame))
-			return -EINPROGRESS;
-
-		uhci_remove_tds_from_frame(uhci, qh->iso_frame);
-
-		ctrlstat = td_status(td);
-		if (ctrlstat & TD_CTRL_ACTIVE) {
-			status = -EXDEV;	/* TD was added too late? */
-		} else {
-			status = uhci_map_status(uhci_status_bits(ctrlstat),
-					usb_pipeout(urb->pipe));
-			actlength = uhci_actual_length(ctrlstat);
-
-			urb->actual_length += actlength;
-			qh->iso_packet_desc->actual_length = actlength;
-			qh->iso_packet_desc->status = status;
-		}
-
-		if (status) {
-			urb->error_count++;
-			qh->iso_status = status;
-		}
-
-		uhci_remove_td_from_urbp(td);
-		uhci_free_td(uhci, td);
-		qh->iso_frame += qh->period;
-		++qh->iso_packet_desc;
-	}
-	return qh->iso_status;
-}
-
-static int uhci_urb_enqueue(struct usb_hcd *hcd,
-		struct usb_host_endpoint *hep,
-		struct urb *urb, gfp_t mem_flags)
-{
-	int ret;
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	unsigned long flags;
-	struct urb_priv *urbp;
-	struct uhci_qh *qh;
-
-	spin_lock_irqsave(&uhci->lock, flags);
-
-	ret = urb->status;
-	if (ret != -EINPROGRESS)		/* URB already unlinked! */
-		goto done;
-
-	ret = -ENOMEM;
-	urbp = uhci_alloc_urb_priv(uhci, urb);
-	if (!urbp)
-		goto done;
-
-	if (hep->hcpriv)
-		qh = (struct uhci_qh *) hep->hcpriv;
-	else {
-		qh = uhci_alloc_qh(uhci, urb->dev, hep);
-		if (!qh)
-			goto err_no_qh;
-	}
-	urbp->qh = qh;
-
-	switch (qh->type) {
-	case USB_ENDPOINT_XFER_CONTROL:
-		ret = uhci_submit_control(uhci, urb, qh);
-		break;
-	case USB_ENDPOINT_XFER_BULK:
-		ret = uhci_submit_bulk(uhci, urb, qh);
-		break;
-	case USB_ENDPOINT_XFER_INT:
-		ret = uhci_submit_interrupt(uhci, urb, qh);
-		break;
-	case USB_ENDPOINT_XFER_ISOC:
-		urb->error_count = 0;
-		ret = uhci_submit_isochronous(uhci, urb, qh);
-		break;
-	}
-	if (ret != 0)
-		goto err_submit_failed;
-
-	/* Add this URB to the QH */
-	urbp->qh = qh;
-	list_add_tail(&urbp->node, &qh->queue);
-
-	/* If the new URB is the first and only one on this QH then either
-	 * the QH is new and idle or else it's unlinked and waiting to
-	 * become idle, so we can activate it right away.  But only if the
-	 * queue isn't stopped. */
-	if (qh->queue.next == &urbp->node && !qh->is_stopped) {
-		uhci_activate_qh(uhci, qh);
-		uhci_urbp_wants_fsbr(uhci, urbp);
-	}
-	goto done;
-
-err_submit_failed:
-	if (qh->state == QH_STATE_IDLE)
-		uhci_make_qh_idle(uhci, qh);	/* Reclaim unused QH */
-
-err_no_qh:
-	uhci_free_urb_priv(uhci, urbp);
-
-done:
-	spin_unlock_irqrestore(&uhci->lock, flags);
-	return ret;
-}
-
-static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	unsigned long flags;
-	struct urb_priv *urbp;
-	struct uhci_qh *qh;
-
-	spin_lock_irqsave(&uhci->lock, flags);
-	urbp = urb->hcpriv;
-	if (!urbp)			/* URB was never linked! */
-		goto done;
-	qh = urbp->qh;
-
-	/* Remove Isochronous TDs from the frame list ASAP */
-	if (qh->type == USB_ENDPOINT_XFER_ISOC) {
-		uhci_unlink_isochronous_tds(uhci, urb);
-		mb();
-
-		/* If the URB has already started, update the QH unlink time */
-		uhci_get_current_frame_number(uhci);
-		if (uhci_frame_before_eq(urb->start_frame, uhci->frame_number))
-			qh->unlink_frame = uhci->frame_number;
-	}
-
-	uhci_unlink_qh(uhci, qh);
-
-done:
-	spin_unlock_irqrestore(&uhci->lock, flags);
-	return 0;
-}
-
-/*
- * Finish unlinking an URB and give it back
- */
-static void uhci_giveback_urb(struct uhci_hcd *uhci, struct uhci_qh *qh,
-		struct urb *urb)
-__releases(uhci->lock)
-__acquires(uhci->lock)
-{
-	struct urb_priv *urbp = (struct urb_priv *) urb->hcpriv;
-
-	if (qh->type == USB_ENDPOINT_XFER_CONTROL) {
-
-		/* urb->actual_length < 0 means the setup transaction didn't
-		 * complete successfully.  Either it failed or the URB was
-		 * unlinked first.  Regardless, don't confuse people with a
-		 * negative length. */
-		urb->actual_length = max(urb->actual_length, 0);
-
-		/* Report erroneous short transfers */
-		if (unlikely((urb->transfer_flags & URB_SHORT_NOT_OK) &&
-				urb->actual_length <
-					urb->transfer_buffer_length &&
-				urb->status == 0))
-			urb->status = -EREMOTEIO;
-	}
-
-	/* When giving back the first URB in an Isochronous queue,
-	 * reinitialize the QH's iso-related members for the next URB. */
-	else if (qh->type == USB_ENDPOINT_XFER_ISOC &&
-			urbp->node.prev == &qh->queue &&
-			urbp->node.next != &qh->queue) {
-		struct urb *nurb = list_entry(urbp->node.next,
-				struct urb_priv, node)->urb;
-
-		qh->iso_packet_desc = &nurb->iso_frame_desc[0];
-		qh->iso_frame = nurb->start_frame;
-		qh->iso_status = 0;
-	}
-
-	/* Take the URB off the QH's queue.  If the queue is now empty,
-	 * this is a perfect time for a toggle fixup. */
-	list_del_init(&urbp->node);
-	if (list_empty(&qh->queue) && qh->needs_fixup) {
-		usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
-				usb_pipeout(urb->pipe), qh->initial_toggle);
-		qh->needs_fixup = 0;
-	}
-
-	uhci_free_urb_priv(uhci, urbp);
-
-	spin_unlock(&uhci->lock);
-	usb_hcd_giveback_urb(uhci_to_hcd(uhci), urb);
-	spin_lock(&uhci->lock);
-
-	/* If the queue is now empty, we can unlink the QH and give up its
-	 * reserved bandwidth. */
-	if (list_empty(&qh->queue)) {
-		uhci_unlink_qh(uhci, qh);
-		if (qh->bandwidth_reserved)
-			uhci_release_bandwidth(uhci, qh);
-	}
-}
-
-/*
- * Scan the URBs in a QH's queue
- */
-#define QH_FINISHED_UNLINKING(qh)			\
-		(qh->state == QH_STATE_UNLINKING &&	\
-		uhci->frame_number + uhci->is_stopped != qh->unlink_frame)
-
-static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
-{
-	struct urb_priv *urbp;
-	struct urb *urb;
-	int status;
-
-	while (!list_empty(&qh->queue)) {
-		urbp = list_entry(qh->queue.next, struct urb_priv, node);
-		urb = urbp->urb;
-
-		if (qh->type == USB_ENDPOINT_XFER_ISOC)
-			status = uhci_result_isochronous(uhci, urb);
-		else
-			status = uhci_result_common(uhci, urb);
-		if (status == -EINPROGRESS)
-			break;
-
-		spin_lock(&urb->lock);
-		if (urb->status == -EINPROGRESS)	/* Not dequeued */
-			urb->status = status;
-		else
-			status = ECONNRESET;		/* Not -ECONNRESET */
-		spin_unlock(&urb->lock);
-
-		/* Dequeued but completed URBs can't be given back unless
-		 * the QH is stopped or has finished unlinking. */
-		if (status == ECONNRESET) {
-			if (QH_FINISHED_UNLINKING(qh))
-				qh->is_stopped = 1;
-			else if (!qh->is_stopped)
-				return;
-		}
-
-		uhci_giveback_urb(uhci, qh, urb);
-		if (status < 0 && qh->type != USB_ENDPOINT_XFER_ISOC)
-			break;
-	}
-
-	/* If the QH is neither stopped nor finished unlinking (normal case),
-	 * our work here is done. */
-	if (QH_FINISHED_UNLINKING(qh))
-		qh->is_stopped = 1;
-	else if (!qh->is_stopped)
-		return;
-
-	/* Otherwise give back each of the dequeued URBs */
-restart:
-	list_for_each_entry(urbp, &qh->queue, node) {
-		urb = urbp->urb;
-		if (urb->status != -EINPROGRESS) {
-
-			/* Fix up the TD links and save the toggles for
-			 * non-Isochronous queues.  For Isochronous queues,
-			 * test for too-recent dequeues. */
-			if (!uhci_cleanup_queue(uhci, qh, urb)) {
-				qh->is_stopped = 0;
-				return;
-			}
-			uhci_giveback_urb(uhci, qh, urb);
-			goto restart;
-		}
-	}
-	qh->is_stopped = 0;
-
-	/* There are no more dequeued URBs.  If there are still URBs on the
-	 * queue, the QH can now be re-activated. */
-	if (!list_empty(&qh->queue)) {
-		if (qh->needs_fixup)
-			uhci_fixup_toggles(qh, 0);
-
-		/* If the first URB on the queue wants FSBR but its time
-		 * limit has expired, set the next TD to interrupt on
-		 * completion before reactivating the QH. */
-		urbp = list_entry(qh->queue.next, struct urb_priv, node);
-		if (urbp->fsbr && qh->wait_expired) {
-			struct uhci_td *td = list_entry(urbp->td_list.next,
-					struct uhci_td, list);
-
-			td->status |= __cpu_to_le32(TD_CTRL_IOC);
-		}
-
-		uhci_activate_qh(uhci, qh);
-	}
-
-	/* The queue is empty.  The QH can become idle if it is fully
-	 * unlinked. */
-	else if (QH_FINISHED_UNLINKING(qh))
-		uhci_make_qh_idle(uhci, qh);
-}
-
-/*
- * Check for queues that have made some forward progress.
- * Returns 0 if the queue is not Isochronous, is ACTIVE, and
- * has not advanced since last examined; 1 otherwise.
- *
- * Early Intel controllers have a bug which causes qh->element sometimes
- * not to advance when a TD completes successfully.  The queue remains
- * stuck on the inactive completed TD.  We detect such cases and advance
- * the element pointer by hand.
- */
-static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
-{
-	struct urb_priv *urbp = NULL;
-	struct uhci_td *td;
-	int ret = 1;
-	unsigned status;
-
-	if (qh->type == USB_ENDPOINT_XFER_ISOC)
-		goto done;
-
-	/* Treat an UNLINKING queue as though it hasn't advanced.
-	 * This is okay because reactivation will treat it as though
-	 * it has advanced, and if it is going to become IDLE then
-	 * this doesn't matter anyway.  Furthermore it's possible
-	 * for an UNLINKING queue not to have any URBs at all, or
-	 * for its first URB not to have any TDs (if it was dequeued
-	 * just as it completed).  So it's not easy in any case to
-	 * test whether such queues have advanced. */
-	if (qh->state != QH_STATE_ACTIVE) {
-		urbp = NULL;
-		status = 0;
-
-	} else {
-		urbp = list_entry(qh->queue.next, struct urb_priv, node);
-		td = list_entry(urbp->td_list.next, struct uhci_td, list);
-		status = td_status(td);
-		if (!(status & TD_CTRL_ACTIVE)) {
-
-			/* We're okay, the queue has advanced */
-			qh->wait_expired = 0;
-			qh->advance_jiffies = jiffies;
-			goto done;
-		}
-		ret = 0;
-	}
-
-	/* The queue hasn't advanced; check for timeout */
-	if (qh->wait_expired)
-		goto done;
-
-	if (time_after(jiffies, qh->advance_jiffies + QH_WAIT_TIMEOUT)) {
-
-		/* Detect the Intel bug and work around it */
-		if (qh->post_td && qh_element(qh) == LINK_TO_TD(qh->post_td)) {
-			qh->element = qh->post_td->link;
-			qh->advance_jiffies = jiffies;
-			ret = 1;
-			goto done;
-		}
-
-		qh->wait_expired = 1;
-
-		/* If the current URB wants FSBR, unlink it temporarily
-		 * so that we can safely set the next TD to interrupt on
-		 * completion.  That way we'll know as soon as the queue
-		 * starts moving again. */
-		if (urbp && urbp->fsbr && !(status & TD_CTRL_IOC))
-			uhci_unlink_qh(uhci, qh);
-
-	} else {
-		/* Unmoving but not-yet-expired queues keep FSBR alive */
-		if (urbp)
-			uhci_urbp_wants_fsbr(uhci, urbp);
-	}
-
-done:
-	return ret;
-}
-
-/*
- * Process events in the schedule, but only in one thread at a time
- */
-static void uhci_scan_schedule(struct uhci_hcd *uhci)
-{
-	int i;
-	struct uhci_qh *qh;
-
-	/* Don't allow re-entrant calls */
-	if (uhci->scan_in_progress) {
-		uhci->need_rescan = 1;
-		return;
-	}
-	uhci->scan_in_progress = 1;
-rescan:
-	uhci->need_rescan = 0;
-	uhci->fsbr_is_wanted = 0;
-
-	uhci_clear_next_interrupt(uhci);
-	uhci_get_current_frame_number(uhci);
-	uhci->cur_iso_frame = uhci->frame_number;
-
-	/* Go through all the QH queues and process the URBs in each one */
-	for (i = 0; i < UHCI_NUM_SKELQH - 1; ++i) {
-		uhci->next_qh = list_entry(uhci->skelqh[i]->node.next,
-				struct uhci_qh, node);
-		while ((qh = uhci->next_qh) != uhci->skelqh[i]) {
-			uhci->next_qh = list_entry(qh->node.next,
-					struct uhci_qh, node);
-
-			if (uhci_advance_check(uhci, qh)) {
-				uhci_scan_qh(uhci, qh);
-				if (qh->state == QH_STATE_ACTIVE) {
-					uhci_urbp_wants_fsbr(uhci,
-	list_entry(qh->queue.next, struct urb_priv, node));
-				}
-			}
-		}
-	}
-
-	uhci->last_iso_frame = uhci->cur_iso_frame;
-	if (uhci->need_rescan)
-		goto rescan;
-	uhci->scan_in_progress = 0;
-
-	if (uhci->fsbr_is_on && !uhci->fsbr_is_wanted &&
-			!uhci->fsbr_expiring) {
-		uhci->fsbr_expiring = 1;
-		mod_timer(&uhci->fsbr_timer, jiffies + FSBR_OFF_DELAY);
-	}
-
-	if (list_empty(&uhci->skel_unlink_qh->node))
-		uhci_clear_next_interrupt(uhci);
-	else
-		uhci_set_next_interrupt(uhci);
-}
diff -urN host/.uhci-hcd.o.cmd host.new/.uhci-hcd.o.cmd
--- host/.uhci-hcd.o.cmd	2009-04-08 18:14:00.489453523 +0200
+++ host.new/.uhci-hcd.o.cmd	1970-01-01 01:00:00.000000000 +0100
@@ -1,447 +0,0 @@
-cmd_drivers/usb/host/uhci-hcd.o := arm-linux-uclibc-gcc -Wp,-MD,drivers/usb/host/.uhci-hcd.o.d  -nostdinc -isystem /home/xfs/toolchains/toolchain-arm_gcc4.2.3/bin/../lib/gcc/arm-linux-uclibc/4.2.3/include -D__KERNEL__ -Iinclude  -include include/linux/autoconf.h -mlittle-endian -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -O2 -marm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -mabi=apcs-gnu -mno-thumb-interwork -D__LINUX_ARM_ARCH__=4 -march=armv4   -msoft-float -Uarm -fno-omit-frame-pointer -fno-optimize-sibling-calls  -fno-stack-protector -funit-at-a-time -Wdeclaration-after-statement -Wno-pointer-sign    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(uhci_hcd)"  -D"KBUILD_MODNAME=KBUILD_STR(uhci_hcd)" -c -o drivers/usb/host/uhci-hcd.o drivers/usb/host/uhci-hcd.c
-
-deps_drivers/usb/host/uhci-hcd.o := \
-  drivers/usb/host/uhci-hcd.c \
-    $(wildcard include/config/pm.h) \
-  include/linux/module.h \
-    $(wildcard include/config/modules.h) \
-    $(wildcard include/config/modversions.h) \
-    $(wildcard include/config/unused/symbols.h) \
-    $(wildcard include/config/generic/bug.h) \
-    $(wildcard include/config/module/unload.h) \
-    $(wildcard include/config/kallsyms.h) \
-    $(wildcard include/config/sysfs.h) \
-  include/linux/list.h \
-    $(wildcard include/config/debug/list.h) \
-  include/linux/stddef.h \
-  include/linux/compiler.h \
-    $(wildcard include/config/enable/must/check.h) \
-  include/linux/compiler-gcc4.h \
-    $(wildcard include/config/forced/inlining.h) \
-  include/linux/compiler-gcc.h \
-  include/linux/poison.h \
-  include/linux/prefetch.h \
-  include/linux/types.h \
-    $(wildcard include/config/uid16.h) \
-    $(wildcard include/config/lbd.h) \
-    $(wildcard include/config/lsf.h) \
-    $(wildcard include/config/resources/64bit.h) \
-  include/linux/posix_types.h \
-  include/asm/posix_types.h \
-  include/asm/types.h \
-  include/asm/processor.h \
-    $(wildcard include/config/mmu.h) \
-  include/asm/ptrace.h \
-    $(wildcard include/config/arm/thumb.h) \
-    $(wildcard include/config/smp.h) \
-  include/asm/hwcap.h \
-  include/asm/cache.h \
-  include/asm/system.h \
-    $(wildcard include/config/cpu/cp15.h) \
-    $(wildcard include/config/cpu/xsc3.h) \
-    $(wildcard include/config/cpu/xscale.h) \
-    $(wildcard include/config/cpu/sa1100.h) \
-    $(wildcard include/config/cpu/sa110.h) \
-  include/asm/memory.h \
-    $(wildcard include/config/dram/size.h) \
-    $(wildcard include/config/dram/base.h) \
-    $(wildcard include/config/discontigmem.h) \
-  include/asm/arch/memory.h \
-  include/asm/sizes.h \
-  include/asm-generic/memory_model.h \
-    $(wildcard include/config/flatmem.h) \
-    $(wildcard include/config/sparsemem.h) \
-    $(wildcard include/config/out/of/line/pfn/to/page.h) \
-  include/linux/linkage.h \
-  include/asm/linkage.h \
-  include/linux/irqflags.h \
-    $(wildcard include/config/trace/irqflags.h) \
-    $(wildcard include/config/trace/irqflags/support.h) \
-    $(wildcard include/config/x86.h) \
-  include/asm/irqflags.h \
-  include/linux/stat.h \
-  include/asm/stat.h \
-  include/linux/time.h \
-  include/linux/cache.h \
-  include/linux/kernel.h \
-    $(wildcard include/config/preempt/voluntary.h) \
-    $(wildcard include/config/debug/spinlock/sleep.h) \
-    $(wildcard include/config/printk.h) \
-    $(wildcard include/config/noprintk.h) \
-    $(wildcard include/config/numa.h) \
-  /home/xfs/toolchains/toolchain-arm_gcc4.2.3/bin/../lib/gcc/arm-linux-uclibc/4.2.3/include/stdarg.h \
-  include/linux/bitops.h \
-  include/asm/bitops.h \
-  include/asm-generic/bitops/non-atomic.h \
-  include/asm-generic/bitops/ffz.h \
-  include/asm-generic/bitops/__ffs.h \
-  include/asm-generic/bitops/fls.h \
-  include/asm-generic/bitops/ffs.h \
-  include/asm-generic/bitops/fls64.h \
-  include/asm-generic/bitops/sched.h \
-  include/asm-generic/bitops/hweight.h \
-  include/linux/log2.h \
-    $(wildcard include/config/arch/has/ilog2/u32.h) \
-    $(wildcard include/config/arch/has/ilog2/u64.h) \
-  include/asm/byteorder.h \
-  include/linux/byteorder/little_endian.h \
-  include/linux/byteorder/swab.h \
-  include/linux/byteorder/generic.h \
-  include/asm/bug.h \
-    $(wildcard include/config/bug.h) \
-    $(wildcard include/config/debug/bugverbose.h) \
-  include/asm-generic/bug.h \
-  include/linux/seqlock.h \
-  include/linux/spinlock.h \
-    $(wildcard include/config/debug/spinlock.h) \
-    $(wildcard include/config/preempt.h) \
-    $(wildcard include/config/debug/lock/alloc.h) \
-  include/linux/preempt.h \
-    $(wildcard include/config/debug/preempt.h) \
-    $(wildcard include/config/preempt/notifiers.h) \
-  include/linux/thread_info.h \
-  include/asm/thread_info.h \
-    $(wildcard include/config/debug/stack/usage.h) \
-  include/asm/fpstate.h \
-    $(wildcard include/config/iwmmxt.h) \
-  include/asm/domain.h \
-    $(wildcard include/config/io/36.h) \
-  include/linux/stringify.h \
-  include/linux/bottom_half.h \
-  include/linux/spinlock_types.h \
-  include/linux/spinlock_types_up.h \
-  include/linux/lockdep.h \
-    $(wildcard include/config/lockdep.h) \
-    $(wildcard include/config/lock/stat.h) \
-    $(wildcard include/config/generic/hardirqs.h) \
-    $(wildcard include/config/prove/locking.h) \
-  include/linux/spinlock_up.h \
-  include/linux/spinlock_api_up.h \
-  include/asm/atomic.h \
-  include/asm-generic/atomic.h \
-  include/linux/kmod.h \
-    $(wildcard include/config/kmod.h) \
-  include/linux/errno.h \
-  include/asm/errno.h \
-  include/asm-generic/errno.h \
-  include/asm-generic/errno-base.h \
-  include/linux/elf.h \
-  include/linux/auxvec.h \
-  include/asm/auxvec.h \
-  include/linux/elf-em.h \
-  include/asm/elf.h \
-  include/asm/user.h \
-  include/asm/page.h \
-    $(wildcard include/config/cpu/copy/v3.h) \
-    $(wildcard include/config/cpu/copy/v4wt.h) \
-    $(wildcard include/config/cpu/copy/v4wb.h) \
-    $(wildcard include/config/cpu/copy/fa.h) \
-    $(wildcard include/config/cpu/copy/v6.h) \
-    $(wildcard include/config/aeabi.h) \
-  include/asm/glue.h \
-    $(wildcard include/config/cpu/arm610.h) \
-    $(wildcard include/config/cpu/arm710.h) \
-    $(wildcard include/config/cpu/abrt/lv4t.h) \
-    $(wildcard include/config/cpu/abrt/ev4.h) \
-    $(wildcard include/config/cpu/abrt/ev4t.h) \
-    $(wildcard include/config/cpu/abrt/ev5tj.h) \
-    $(wildcard include/config/cpu/abrt/ev5t.h) \
-    $(wildcard include/config/cpu/abrt/ev6.h) \
-    $(wildcard include/config/cpu/abrt/ev7.h) \
-  include/asm-generic/page.h \
-  include/linux/kobject.h \
-    $(wildcard include/config/hotplug.h) \
-  include/linux/sysfs.h \
-  include/linux/kref.h \
-  include/linux/wait.h \
-  include/asm/current.h \
-  include/linux/moduleparam.h \
-  include/linux/init.h \
-    $(wildcard include/config/hotplug/cpu.h) \
-    $(wildcard include/config/memory/hotplug.h) \
-    $(wildcard include/config/acpi/hotplug/memory.h) \
-  include/asm/local.h \
-  include/asm-generic/local.h \
-  include/linux/percpu.h \
-  include/linux/slab.h \
-    $(wildcard include/config/slab/debug.h) \
-    $(wildcard include/config/slub.h) \
-    $(wildcard include/config/slob.h) \
-    $(wildcard include/config/debug/slab.h) \
-  include/linux/gfp.h \
-    $(wildcard include/config/zone/dma.h) \
-    $(wildcard include/config/zone/dma32.h) \
-    $(wildcard include/config/highmem.h) \
-  include/linux/mmzone.h \
-    $(wildcard include/config/force/max/zoneorder.h) \
-    $(wildcard include/config/arch/populates/node/map.h) \
-    $(wildcard include/config/flat/node/mem/map.h) \
-    $(wildcard include/config/have/memory/present.h) \
-    $(wildcard include/config/need/node/memmap/size.h) \
-    $(wildcard include/config/need/multiple/nodes.h) \
-    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
-    $(wildcard include/config/sparsemem/extreme.h) \
-    $(wildcard include/config/nodes/span/other/nodes.h) \
-    $(wildcard include/config/holes/in/zone.h) \
-  include/linux/threads.h \
-    $(wildcard include/config/nr/cpus.h) \
-    $(wildcard include/config/base/small.h) \
-  include/linux/numa.h \
-    $(wildcard include/config/nodes/shift.h) \
-  include/linux/nodemask.h \
-  include/linux/bitmap.h \
-  include/linux/string.h \
-  include/asm/string.h \
-  include/linux/memory_hotplug.h \
-    $(wildcard include/config/have/arch/nodedata/extension.h) \
-  include/linux/notifier.h \
-  include/linux/mutex.h \
-    $(wildcard include/config/debug/mutexes.h) \
-  include/linux/rwsem.h \
-    $(wildcard include/config/rwsem/generic/spinlock.h) \
-  include/linux/rwsem-spinlock.h \
-  include/linux/srcu.h \
-  include/linux/topology.h \
-    $(wildcard include/config/sched/smt.h) \
-    $(wildcard include/config/sched/mc.h) \
-  include/linux/cpumask.h \
-  include/linux/smp.h \
-  include/asm/topology.h \
-  include/asm-generic/topology.h \
-  include/linux/slab_def.h \
-  include/linux/kmalloc_sizes.h \
-  include/asm/percpu.h \
-  include/asm-generic/percpu.h \
-  include/linux/hardirq.h \
-    $(wildcard include/config/preempt/bkl.h) \
-    $(wildcard include/config/virt/cpu/accounting.h) \
-  include/linux/smp_lock.h \
-    $(wildcard include/config/lock/kernel.h) \
-  include/asm/hardirq.h \
-  include/asm/irq.h \
-  include/asm/arch/irqs.h \
-    $(wildcard include/config/sl3516/asic.h) \
-  include/asm/arch/int_ctrl.h \
-  include/linux/irq_cpustat.h \
-  include/asm/module.h \
-  include/linux/pci.h \
-    $(wildcard include/config/pci/msi.h) \
-    $(wildcard include/config/pci.h) \
-    $(wildcard include/config/ht/irq.h) \
-    $(wildcard include/config/pci/domains.h) \
-  include/linux/pci_regs.h \
-  include/linux/mod_devicetable.h \
-  include/linux/ioport.h \
-  include/linux/device.h \
-    $(wildcard include/config/debug/devres.h) \
-  include/linux/klist.h \
-  include/linux/completion.h \
-  include/linux/pm.h \
-    $(wildcard include/config/suspend.h) \
-    $(wildcard include/config/pm/sleep.h) \
-  include/asm/semaphore.h \
-  include/asm/locks.h \
-  include/asm/device.h \
-    $(wildcard include/config/dmabounce.h) \
-  include/linux/pci_ids.h \
-  include/linux/dmapool.h \
-  include/asm/io.h \
-  include/asm/arch/io.h \
-  include/asm/scatterlist.h \
-  include/asm/pci.h \
-  include/asm-generic/pci-dma-compat.h \
-  include/linux/dma-mapping.h \
-    $(wildcard include/config/has/dma.h) \
-  include/linux/err.h \
-  include/asm/dma-mapping.h \
-  include/linux/mm.h \
-    $(wildcard include/config/sysctl.h) \
-    $(wildcard include/config/stack/growsup.h) \
-    $(wildcard include/config/debug/vm.h) \
-    $(wildcard include/config/shmem.h) \
-    $(wildcard include/config/split/ptlock/cpus.h) \
-    $(wildcard include/config/ia64.h) \
-    $(wildcard include/config/proc/fs.h) \
-    $(wildcard include/config/debug/pagealloc.h) \
-  include/linux/rbtree.h \
-  include/linux/prio_tree.h \
-  include/linux/debug_locks.h \
-    $(wildcard include/config/debug/locking/api/selftests.h) \
-  include/linux/backing-dev.h \
-  include/linux/mm_types.h \
-  include/asm/pgtable.h \
-  include/asm-generic/4level-fixup.h \
-  include/asm/proc-fns.h \
-    $(wildcard include/config/cpu/32.h) \
-    $(wildcard include/config/cpu/arm7tdmi.h) \
-    $(wildcard include/config/cpu/arm720t.h) \
-    $(wildcard include/config/cpu/arm740t.h) \
-    $(wildcard include/config/cpu/arm9tdmi.h) \
-    $(wildcard include/config/cpu/arm920t.h) \
-    $(wildcard include/config/cpu/arm922t.h) \
-    $(wildcard include/config/cpu/fa526.h) \
-    $(wildcard include/config/cpu/arm925t.h) \
-    $(wildcard include/config/cpu/arm926t.h) \
-    $(wildcard include/config/cpu/arm940t.h) \
-    $(wildcard include/config/cpu/arm946e.h) \
-    $(wildcard include/config/cpu/arm1020.h) \
-    $(wildcard include/config/cpu/arm1020e.h) \
-    $(wildcard include/config/cpu/arm1022.h) \
-    $(wildcard include/config/cpu/arm1026.h) \
-    $(wildcard include/config/cpu/v6.h) \
-    $(wildcard include/config/cpu/v7.h) \
-  include/asm/cpu-single.h \
-  include/asm/arch/vmalloc.h \
-  include/asm/pgtable-hwdef.h \
-  include/asm-generic/pgtable.h \
-  include/linux/page-flags.h \
-    $(wildcard include/config/s390.h) \
-    $(wildcard include/config/swap.h) \
-  include/linux/vmstat.h \
-    $(wildcard include/config/vm/event/counters.h) \
-  include/asm/hardware.h \
-  include/asm/arch/hardware.h \
-  include/asm/arch/platform.h \
-  include/asm/arch/sl2312.h \
-    $(wildcard include/config/net/sl351x.h) \
-    $(wildcard include/config/gemini/ipi.h) \
-    $(wildcard include/config/sl2312/share/pin.h) \
-  include/linux/delay.h \
-  include/asm/delay.h \
-  include/asm/param.h \
-    $(wildcard include/config/hz.h) \
-  include/linux/unistd.h \
-  include/asm/unistd.h \
-    $(wildcard include/config/oabi/compat.h) \
-  include/linux/interrupt.h \
-    $(wildcard include/config/high/res/timers.h) \
-    $(wildcard include/config/generic/irq/probe.h) \
-  include/linux/irqreturn.h \
-  include/linux/sched.h \
-    $(wildcard include/config/sched/debug.h) \
-    $(wildcard include/config/no/hz.h) \
-    $(wildcard include/config/detect/softlockup.h) \
-    $(wildcard include/config/keys.h) \
-    $(wildcard include/config/bsd/process/acct.h) \
-    $(wildcard include/config/taskstats.h) \
-    $(wildcard include/config/audit.h) \
-    $(wildcard include/config/inotify/user.h) \
-    $(wildcard include/config/schedstats.h) \
-    $(wildcard include/config/task/delay/acct.h) \
-    $(wildcard include/config/fair/group/sched.h) \
-    $(wildcard include/config/blk/dev/io/trace.h) \
-    $(wildcard include/config/cc/stackprotector.h) \
-    $(wildcard include/config/sysvipc.h) \
-    $(wildcard include/config/rt/mutexes.h) \
-    $(wildcard include/config/task/xacct.h) \
-    $(wildcard include/config/cpusets.h) \
-    $(wildcard include/config/compat.h) \
-    $(wildcard include/config/fault/injection.h) \
-  include/linux/capability.h \
-  include/linux/timex.h \
-  include/asm/timex.h \
-  include/asm/arch/timex.h \
-  include/asm/arch/sl2312.h \
-  include/linux/jiffies.h \
-  include/linux/calc64.h \
-  include/asm/div64.h \
-  include/asm/mmu.h \
-    $(wildcard include/config/cpu/has/asid.h) \
-  include/asm/cputime.h \
-  include/asm-generic/cputime.h \
-  include/linux/sem.h \
-  include/linux/ipc.h \
-  include/asm/ipcbuf.h \
-  include/asm/sembuf.h \
-  include/linux/signal.h \
-  include/asm/signal.h \
-  include/asm-generic/signal.h \
-  include/asm/sigcontext.h \
-  include/asm/siginfo.h \
-  include/asm-generic/siginfo.h \
-  include/linux/securebits.h \
-  include/linux/fs_struct.h \
-  include/linux/pid.h \
-  include/linux/rcupdate.h \
-  include/linux/seccomp.h \
-    $(wildcard include/config/seccomp.h) \
-  include/linux/futex.h \
-    $(wildcard include/config/futex.h) \
-  include/linux/rtmutex.h \
-    $(wildcard include/config/debug/rt/mutexes.h) \
-  include/linux/plist.h \
-    $(wildcard include/config/debug/pi/list.h) \
-  include/linux/param.h \
-  include/linux/resource.h \
-  include/asm/resource.h \
-  include/asm-generic/resource.h \
-  include/linux/timer.h \
-    $(wildcard include/config/timer/stats.h) \
-  include/linux/ktime.h \
-    $(wildcard include/config/ktime/scalar.h) \
-  include/linux/hrtimer.h \
-  include/linux/task_io_accounting.h \
-    $(wildcard include/config/task/io/accounting.h) \
-  include/linux/aio.h \
-  include/linux/workqueue.h \
-  include/linux/aio_abi.h \
-  include/linux/uio.h \
-  include/linux/debugfs.h \
-    $(wildcard include/config/debug/fs.h) \
-  include/linux/fs.h \
-    $(wildcard include/config/sl2312/tso.h) \
-    $(wildcard include/config/dnotify.h) \
-    $(wildcard include/config/quota.h) \
-    $(wildcard include/config/inotify.h) \
-    $(wildcard include/config/security.h) \
-    $(wildcard include/config/epoll.h) \
-    $(wildcard include/config/auditsyscall.h) \
-    $(wildcard include/config/block.h) \
-    $(wildcard include/config/fs/xip.h) \
-    $(wildcard include/config/migration.h) \
-  include/linux/limits.h \
-  include/linux/ioctl.h \
-  include/asm/ioctl.h \
-  include/asm-generic/ioctl.h \
-  include/linux/kdev_t.h \
-  include/linux/dcache.h \
-    $(wildcard include/config/profiling.h) \
-  include/linux/namei.h \
-  include/linux/radix-tree.h \
-  include/linux/sysctl.h \
-  include/linux/quota.h \
-  include/linux/dqblk_xfs.h \
-  include/linux/dqblk_v1.h \
-  include/linux/dqblk_v2.h \
-  include/linux/nfs_fs_i.h \
-  include/linux/nfs.h \
-  include/linux/sunrpc/msg_prot.h \
-  include/linux/fcntl.h \
-  include/asm/fcntl.h \
-  include/asm-generic/fcntl.h \
-    $(wildcard include/config/64bit.h) \
-  include/linux/usb.h \
-    $(wildcard include/config/usb/devicefs.h) \
-    $(wildcard include/config/usb/mon.h) \
-    $(wildcard include/config/usb/device/class.h) \
-    $(wildcard include/config/usb/suspend.h) \
-  include/linux/usb/ch9.h \
-    $(wildcard include/config/size.h) \
-    $(wildcard include/config/att/one.h) \
-    $(wildcard include/config/att/selfpower.h) \
-    $(wildcard include/config/att/wakeup.h) \
-    $(wildcard include/config/att/battery.h) \
-  include/linux/dmi.h \
-    $(wildcard include/config/dmi.h) \
-  include/asm/uaccess.h \
-  drivers/usb/host/../core/hcd.h \
-  drivers/usb/host/../core/hub.h \
-  drivers/usb/host/uhci-hcd.h \
-  drivers/usb/host/pci-quirks.h \
-  drivers/usb/host/uhci-debug.c \
-  drivers/usb/host/uhci-q.c \
-  drivers/usb/host/uhci-hub.c \
-
-drivers/usb/host/uhci-hcd.o: $(deps_drivers/usb/host/uhci-hcd.o)
-
-$(deps_drivers/usb/host/uhci-hcd.o):
diff -urN host/Kconfig host.new/Kconfig
--- host/Kconfig	2009-02-24 19:00:15.251977975 +0100
+++ host.new/Kconfig	2009-03-28 17:46:02.000000000 +0100
@@ -4,6 +4,19 @@
 comment "USB Host Controller Drivers"
 	depends on USB
 
+config USB_C67X00_HCD
+	tristate "Cypress C67x00 HCD support"
+	depends on USB
+	help
+	  The Cypress C67x00 (EZ-Host/EZ-OTG) chips are dual-role
+	  host/peripheral/OTG USB controllers.
+
+	  Enable this option to support this chip in host controller mode.
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called c67x00.
+
 config USB_EHCI_HCD
 	tristate "EHCI HCD (USB 2.0) support"
 	depends on USB && USB_ARCH_HAS_EHCI
@@ -11,10 +24,7 @@
 	  The Enhanced Host Controller Interface (EHCI) is standard for USB 2.0
 	  "high speed" (480 Mbit/sec, 60 Mbyte/sec) host controller hardware.
 	  If your USB host controller supports USB 2.0, you will likely want to
-	  configure this Host Controller Driver.  At the time of this writing, 
-	  the primary implementation of EHCI is a chip from NEC, widely available
-	  in add-on PCI cards, but implementations are in the works from other 
-	  vendors including Intel and Philips.  Motherboard support is appearing.
+	  configure this Host Controller Driver.
 
 	  EHCI controllers are packaged with "companion" host controllers (OHCI
 	  or UHCI) to handle USB 1.1 devices connected to root hub ports.  Ports
@@ -29,18 +39,9 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called ehci-hcd.
 
-config USB_EHCI_SPLIT_ISO
-	bool "Full speed ISO transactions (EXPERIMENTAL)"
-	depends on USB_EHCI_HCD && EXPERIMENTAL
-	default n
-	---help---
-	  This code is new and hasn't been used with many different
-	  EHCI or USB 2.0 transaction translator implementations.
-	  It should work for ISO-OUT transfers, like audio.
-
 config USB_EHCI_ROOT_HUB_TT
-	bool "Root Hub Transaction Translators (EXPERIMENTAL)"
-	depends on USB_EHCI_HCD && EXPERIMENTAL
+	bool "Root Hub Transaction Translators"
+	depends on USB_EHCI_HCD
 	---help---
 	  Some EHCI chips have vendor-specific extensions to integrate
 	  transaction translators, so that no OHCI or UHCI companion
@@ -69,21 +70,42 @@
 
 config USB_EHCI_BIG_ENDIAN_MMIO
 	bool
-	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX)
+	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX || ARCH_IXP4XX)
 	default y
 
 config USB_EHCI_BIG_ENDIAN_DESC
 	bool
-	depends on USB_EHCI_HCD && 440EPX
+	depends on USB_EHCI_HCD && (440EPX || ARCH_IXP4XX)
 	default y
 
 config USB_EHCI_FSL
-	bool
+	bool "Support for Freescale on-chip EHCI USB controller"
+	depends on USB_EHCI_HCD && FSL_SOC
 	select USB_EHCI_ROOT_HUB_TT
-	default y if MPC834x || PPC_MPC831x
 	---help---
 	  Variation of ARC USB block used in some Freescale chips.
 
+config USB_EHCI_HCD_PPC_OF
+	bool "EHCI support for PPC USB controller on OF platform bus"
+	depends on USB_EHCI_HCD && PPC_OF
+	default y
+	---help---
+	  Enables support for the USB controller present on the PowerPC
+	  OpenFirmware platform bus.
+
+config USB_OXU210HP_HCD
+	tristate "OXU210HP HCD support"
+	depends on USB
+	---help---
+	  The OXU210HP is an USB host/OTG/device controller. Enable this
+	  option if your board has this chip. If unsure, say N.
+
+	  This driver does not support isochronous transfers and doesn't
+	  implement OTG nor USB device controllers.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called oxu210hp-hcd.
+
 config USB_ISP116X_HCD
 	tristate "ISP116X HCD support"
 	depends on USB
@@ -96,11 +118,26 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called isp116x-hcd.
 
+config USB_ISP1760_HCD
+	tristate "ISP 1760 HCD support"
+	depends on USB && EXPERIMENTAL
+	---help---
+	  The ISP1760 chip is a USB 2.0 host controller.
+
+	  This driver does not support isochronous transfers or OTG.
+	  This USB controller is usually attached to a non-DMA-Master
+	  capable bus. NXP's eval kit brings this chip on PCI card
+	  where the chip itself is behind a PLB to simulate such
+	  a bus.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called isp1760.
+
 config USB_OHCI_HCD
 	tristate "OHCI HCD support"
 	depends on USB && USB_ARCH_HAS_OHCI
 	select ISP1301_OMAP if MACH_OMAP_H2 || MACH_OMAP_H3
-	select I2C if ARCH_PNX4008
+	select USB_OTG_UTILS if ARCH_OMAP
 	---help---
 	  The Open Host Controller Interface (OHCI) is a standard for accessing
 	  USB 1.1 host controller hardware.  It does more in hardware than Intel's
@@ -154,6 +191,19 @@
 	  Enables support for PCI-bus plug-in USB controller cards.
 	  If unsure, say Y.
 
+config USB_OHCI_HCD_SSB
+	bool "OHCI support for Broadcom SSB OHCI core"
+	depends on USB_OHCI_HCD && (SSB = y || SSB = USB_OHCI_HCD) && EXPERIMENTAL
+	default n
+	---help---
+	  Support for the Sonics Silicon Backplane (SSB) attached
+	  Broadcom USB OHCI core.
+
+	  This device is present in some embedded devices with
+	  Broadcom based SSB bus.
+
+	  If unsure, say N.
+
 config USB_OHCI_BIG_ENDIAN_DESC
 	bool
 	depends on USB_OHCI_HCD
@@ -186,6 +236,23 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called uhci-hcd.
 
+config USB_FHCI_HCD
+	tristate "Freescale QE USB Host Controller support"
+	depends on USB && OF_GPIO && QE_GPIO && QUICC_ENGINE
+	select FSL_GTM
+	select QE_USB
+	help
+	  This driver enables support for Freescale QE USB Host Controller
+	  (as found on MPC8360 and MPC8323 processors), the driver supports
+	  Full and Low Speed USB.
+
+config FHCI_DEBUG
+	bool "Freescale QE USB Host Controller debug support"
+	depends on USB_FHCI_HCD && DEBUG_FS
+	help
+	  Say "y" to see some FHCI debug information and statistics
+	  throught debugfs.
+
 config USB_U132_HCD
 	tristate "Elan U132 Adapter Host Controller"
 	depends on USB && USB_FTDI_ELAN
@@ -248,3 +315,37 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called r8a66597-hcd.
 
+config SUPERH_ON_CHIP_R8A66597
+	boolean "Enable SuperH on-chip R8A66597 USB"
+	depends on USB_R8A66597_HCD && (CPU_SUBTYPE_SH7366 || CPU_SUBTYPE_SH7723)
+	help
+	   This driver enables support for the on-chip R8A66597 in the
+	   SH7366 and SH7723 processors.
+
+config USB_WHCI_HCD
+	tristate "Wireless USB Host Controller Interface (WHCI) driver (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	depends on PCI && USB
+	select USB_WUSB
+	select UWB_WHCI
+	help
+	  A driver for PCI-based Wireless USB Host Controllers that are
+	  compliant with the WHCI specification.
+
+	  To compile this driver a module, choose M here: the module
+	  will be called "whci-hcd".
+
+config USB_HWA_HCD
+	tristate "Host Wire Adapter (HWA) driver (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	depends on USB
+	select USB_WUSB
+	select UWB_HWA
+	help
+	  This driver enables you to connect Wireless USB devices to
+	  your system using a Host Wire Adaptor USB dongle. This is an
+	  UWB Radio Controller and WUSB Host Controller connected to
+	  your machine via USB (specified in WUSB1.0).
+
+	  To compile this driver a module, choose M here: the module
+	  will be called "hwa-hc".
diff -urN host/Makefile host.new/Makefile
--- host/Makefile	2009-02-24 19:00:15.251977975 +0100
+++ host.new/Makefile	2009-03-28 17:46:02.000000000 +0100
@@ -6,14 +6,26 @@
 	EXTRA_CFLAGS		+= -DDEBUG
 endif
 
+isp1760-objs := isp1760-hcd.o isp1760-if.o
+fhci-objs := fhci-hcd.o fhci-hub.o fhci-q.o fhci-mem.o \
+	     fhci-tds.o fhci-sched.o
+ifeq ($(CONFIG_FHCI_DEBUG),y)
+fhci-objs += fhci-dbg.o
+endif
+
+obj-$(CONFIG_USB_WHCI_HCD)	+= whci/
+
 obj-$(CONFIG_PCI)		+= pci-quirks.o
 
 obj-$(CONFIG_USB_EHCI_HCD)	+= ehci-hcd.o
+obj-$(CONFIG_USB_OXU210HP_HCD)	+= oxu210hp-hcd.o
 obj-$(CONFIG_USB_ISP116X_HCD)	+= isp116x-hcd.o
 obj-$(CONFIG_USB_OHCI_HCD)	+= ohci-hcd.o
 obj-$(CONFIG_USB_UHCI_HCD)	+= uhci-hcd.o
+obj-$(CONFIG_USB_FHCI_HCD)	+= fhci.o
 obj-$(CONFIG_USB_SL811_HCD)	+= sl811-hcd.o
 obj-$(CONFIG_USB_SL811_CS)	+= sl811_cs.o
 obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
 obj-$(CONFIG_USB_R8A66597_HCD)	+= r8a66597-hcd.o
-
+obj-$(CONFIG_USB_ISP1760_HCD)	+= isp1760.o
+obj-$(CONFIG_USB_HWA_HCD)	+= hwa-hc.o
Files host/built-in.o and host.new/built-in.o differ
diff -urN host/ehci-au1xxx.c host.new/ehci-au1xxx.c
--- host/ehci-au1xxx.c	2009-02-24 19:00:15.255977772 +0100
+++ host.new/ehci-au1xxx.c	2009-03-28 17:46:02.000000000 +0100
@@ -19,262 +19,304 @@
 #define USB_MCFG_RDCOMB   (1<<30)
 #define USB_MCFG_SSDEN    (1<<23)
 #define USB_MCFG_PHYPLLEN (1<<19)
+#define USB_MCFG_UCECLKEN (1<<18)
 #define USB_MCFG_EHCCLKEN (1<<17)
+#ifdef CONFIG_DMA_COHERENT
 #define USB_MCFG_UCAM     (1<<7)
+#else
+#define USB_MCFG_UCAM     (0)
+#endif
 #define USB_MCFG_EBMEN    (1<<3)
 #define USB_MCFG_EMEMEN   (1<<2)
 
-#define USBH_ENABLE_CE    (USB_MCFG_PHYPLLEN | USB_MCFG_EHCCLKEN)
+#define USBH_ENABLE_CE	(USB_MCFG_PHYPLLEN | USB_MCFG_EHCCLKEN)
+#define USBH_ENABLE_INIT (USB_MCFG_PFEN  | USB_MCFG_RDCOMB |	\
+			  USBH_ENABLE_CE | USB_MCFG_SSDEN  |	\
+			  USB_MCFG_UCAM  | USB_MCFG_EBMEN  |	\
+			  USB_MCFG_EMEMEN)
 
-#ifdef CONFIG_DMA_COHERENT
-#define USBH_ENABLE_INIT  (USBH_ENABLE_CE \
-                         | USB_MCFG_PFEN | USB_MCFG_RDCOMB \
-                         | USB_MCFG_SSDEN | USB_MCFG_UCAM \
-                         | USB_MCFG_EBMEN | USB_MCFG_EMEMEN)
-#else
-#define USBH_ENABLE_INIT  (USBH_ENABLE_CE \
-                         | USB_MCFG_PFEN | USB_MCFG_RDCOMB \
-                         | USB_MCFG_SSDEN \
-                         | USB_MCFG_EBMEN | USB_MCFG_EMEMEN)
-#endif
 #define USBH_DISABLE      (USB_MCFG_EBMEN | USB_MCFG_EMEMEN)
 
 extern int usb_disabled(void);
 
-/*-------------------------------------------------------------------------*/
-
-static void au1xxx_start_ehc(struct platform_device *dev)
+static void au1xxx_start_ehc(void)
 {
-	pr_debug(__FILE__ ": starting Au1xxx EHCI USB Controller\n");
-
-	/* write HW defaults again in case Yamon cleared them */
-	if (au_readl(USB_HOST_CONFIG) == 0) {
-		au_writel(0x00d02000, USB_HOST_CONFIG);
-		au_readl(USB_HOST_CONFIG);
-		udelay(1000);
-	}
-	/* enable host controller */
-	au_writel(USBH_ENABLE_CE | au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
-	udelay(1000);
-	au_writel(USBH_ENABLE_INIT | au_readl(USB_HOST_CONFIG),
-		  USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
+	/* enable clock to EHCI block and HS PHY PLL*/
+	au_writel(au_readl(USB_HOST_CONFIG) | USBH_ENABLE_CE, USB_HOST_CONFIG);
+	au_sync();
 	udelay(1000);
 
-	pr_debug(__FILE__ ": Clock to USB host has been enabled\n");
+	/* enable EHCI mmio */
+	au_writel(au_readl(USB_HOST_CONFIG) | USBH_ENABLE_INIT, USB_HOST_CONFIG);
+	au_sync();
+	udelay(1000);
 }
 
-static void au1xxx_stop_ehc(struct platform_device *dev)
+static void au1xxx_stop_ehc(void)
 {
-	pr_debug(__FILE__ ": stopping Au1xxx EHCI USB Controller\n");
+	unsigned long c;
 
 	/* Disable mem */
-	au_writel(~USBH_DISABLE & au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
+	au_writel(au_readl(USB_HOST_CONFIG) & ~USBH_DISABLE, USB_HOST_CONFIG);
+	au_sync();
 	udelay(1000);
-	/* Disable clock */
-	au_writel(~USB_MCFG_EHCCLKEN & au_readl(USB_HOST_CONFIG),
-		  USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
+
+	/* Disable EHC clock. If the HS PHY is unused disable it too. */
+	c = au_readl(USB_HOST_CONFIG) & ~USB_MCFG_EHCCLKEN;
+	if (!(c & USB_MCFG_UCECLKEN))		/* UDC disabled? */
+		c &= ~USB_MCFG_PHYPLLEN;	/* yes: disable HS PHY PLL */
+	au_writel(c, USB_HOST_CONFIG);
+	au_sync();
 }
 
-/*-------------------------------------------------------------------------*/
+static const struct hc_driver ehci_au1xxx_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "Au1xxx EHCI",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 *
+	 * FIXME -- ehci_init() doesn't do enough here.
+	 * See ehci-ppc-soc for a complete implementation.
+	 */
+	.reset			= ehci_init,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ehci_get_frame,
 
-/* configure so an HC device and id are always provided */
-/* always called with process context; sleeping is OK */
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
+};
 
-/**
- * usb_ehci_au1xxx_probe - initialize Au1xxx-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- *
- */
-int usb_ehci_au1xxx_probe(const struct hc_driver *driver,
-			  struct usb_hcd **hcd_out, struct platform_device *dev)
+static int ehci_hcd_au1xxx_drv_probe(struct platform_device *pdev)
 {
-	int retval;
 	struct usb_hcd *hcd;
 	struct ehci_hcd *ehci;
+	int ret;
 
-#if defined(CONFIG_SOC_AU1200) && defined(CONFIG_DMA_COHERENT)
+	if (usb_disabled())
+		return -ENODEV;
 
+#if defined(CONFIG_SOC_AU1200) && defined(CONFIG_DMA_COHERENT)
 	/* Au1200 AB USB does not support coherent memory */
 	if (!(read_c0_prid() & 0xff)) {
-		pr_info("%s: this is chip revision AB!\n", dev->name);
-		pr_info("%s: update your board or re-configure the kernel\n",
-			dev->name);
+		printk(KERN_INFO "%s: this is chip revision AB!\n", pdev->name);
+		printk(KERN_INFO "%s: update your board or re-configure"
+				 " the kernel\n", pdev->name);
 		return -ENODEV;
 	}
 #endif
 
-	au1xxx_start_ehc(dev);
-
-	if (dev->resource[1].flags != IORESOURCE_IRQ) {
+	if (pdev->resource[1].flags != IORESOURCE_IRQ) {
 		pr_debug("resource[1] is not IORESOURCE_IRQ");
-		retval = -ENOMEM;
+		return -ENOMEM;
 	}
-	hcd = usb_create_hcd(driver, &dev->dev, "Au1xxx");
+	hcd = usb_create_hcd(&ehci_au1xxx_hc_driver, &pdev->dev, "Au1xxx");
 	if (!hcd)
 		return -ENOMEM;
-	hcd->rsrc_start = dev->resource[0].start;
-	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
+
+	hcd->rsrc_start = pdev->resource[0].start;
+	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
 
 	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
 		pr_debug("request_mem_region failed");
-		retval = -EBUSY;
+		ret = -EBUSY;
 		goto err1;
 	}
 
 	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
 	if (!hcd->regs) {
 		pr_debug("ioremap failed");
-		retval = -ENOMEM;
+		ret = -ENOMEM;
 		goto err2;
 	}
 
+	au1xxx_start_ehc();
+
 	ehci = hcd_to_ehci(hcd);
 	ehci->caps = hcd->regs;
 	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
 	/* cache this readonly data; minimize chip reads */
 	ehci->hcs_params = readl(&ehci->caps->hcs_params);
 
-	/* ehci_hcd_init(hcd_to_ehci(hcd)); */
-
-	retval =
-	    usb_add_hcd(hcd, dev->resource[1].start, IRQF_DISABLED | IRQF_SHARED);
-	if (retval == 0)
-		return retval;
+	ret = usb_add_hcd(hcd, pdev->resource[1].start,
+			  IRQF_DISABLED | IRQF_SHARED);
+	if (ret == 0) {
+		platform_set_drvdata(pdev, hcd);
+		return ret;
+	}
 
-	au1xxx_stop_ehc(dev);
+	au1xxx_stop_ehc();
 	iounmap(hcd->regs);
 err2:
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 err1:
 	usb_put_hcd(hcd);
-	return retval;
+	return ret;
 }
 
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_ehci_hcd_au1xxx_remove - shutdown processing for Au1xxx-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_ehci_hcd_au1xxx_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
- */
-void usb_ehci_au1xxx_remove(struct usb_hcd *hcd, struct platform_device *dev)
+static int ehci_hcd_au1xxx_drv_remove(struct platform_device *pdev)
 {
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
 	usb_remove_hcd(hcd);
 	iounmap(hcd->regs);
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 	usb_put_hcd(hcd);
-	au1xxx_stop_ehc(dev);
+	au1xxx_stop_ehc();
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
 }
 
-/*-------------------------------------------------------------------------*/
+#ifdef CONFIG_PM
+static int ehci_hcd_au1xxx_drv_suspend(struct platform_device *pdev,
+					pm_message_t message)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	unsigned long flags;
+	int rc;
 
-static const struct hc_driver ehci_au1xxx_hc_driver = {
-	.description = hcd_name,
-	.product_desc = "Au1xxx EHCI",
-	.hcd_priv_size = sizeof(struct ehci_hcd),
+	return 0;
+	rc = 0;
 
-	/*
-	 * generic hardware linkage
-	 */
-	.irq = ehci_irq,
-	.flags = HCD_MEMORY | HCD_USB2,
+	if (time_before(jiffies, ehci->next_statechange))
+		msleep(10);
 
-	/*
-	 * basic lifecycle operations
+	/* Root hub was already suspended. Disable irq emission and
+	 * mark HW unaccessible, bail out if RH has been resumed. Use
+	 * the spinlock to properly synchronize with possible pending
+	 * RH suspend or resume activity.
 	 *
-	 * FIXME -- ehci_init() doesn't do enough here.
-	 * See ehci-ppc-soc for a complete implementation.
-	 */
-	.reset = ehci_init,
-	.start = ehci_run,
-	.stop = ehci_stop,
-	.shutdown = ehci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
+	 * This is still racy as hcd->state is manipulated outside of
+	 * any locks =P But that will be a different fix.
 	 */
-	.urb_enqueue = ehci_urb_enqueue,
-	.urb_dequeue = ehci_urb_dequeue,
-	.endpoint_disable = ehci_endpoint_disable,
+	spin_lock_irqsave(&ehci->lock, flags);
+	if (hcd->state != HC_STATE_SUSPENDED) {
+		rc = -EINVAL;
+		goto bail;
+	}
+	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
+	(void)ehci_readl(ehci, &ehci->regs->intr_enable);
 
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number = ehci_get_frame,
+	/* make sure snapshot being resumed re-enumerates everything */
+	if (message.event == PM_EVENT_PRETHAW) {
+		ehci_halt(ehci);
+		ehci_reset(ehci);
+	}
 
-	/*
-	 * root hub support
-	 */
-	.hub_status_data = ehci_hub_status_data,
-	.hub_control = ehci_hub_control,
-#ifdef	CONFIG_PM
-	.hub_suspend = ehci_hub_suspend,
-	.hub_resume = ehci_hub_resume,
-#endif
-};
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 
-/*-------------------------------------------------------------------------*/
+	au1xxx_stop_ehc();
 
-static int ehci_hcd_au1xxx_drv_probe(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = NULL;
-	int ret;
+bail:
+	spin_unlock_irqrestore(&ehci->lock, flags);
 
-	pr_debug("In ehci_hcd_au1xxx_drv_probe\n");
+	// could save FLADJ in case of Vaux power loss
+	// ... we'd only use it to handle clock skew
 
-	if (usb_disabled())
-		return -ENODEV;
-
-	ret = usb_ehci_au1xxx_probe(&ehci_au1xxx_hc_driver, &hcd, pdev);
-	return ret;
+	return rc;
 }
 
-static int ehci_hcd_au1xxx_drv_remove(struct platform_device *pdev)
+
+static int ehci_hcd_au1xxx_drv_resume(struct platform_device *pdev)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 
-	usb_ehci_au1xxx_remove(hcd, pdev);
-	return 0;
-}
+	au1xxx_start_ehc();
 
- /*TBD*/
-/*static int ehci_hcd_au1xxx_drv_suspend(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	// maybe restore FLADJ
 
-	return 0;
-}
-static int ehci_hcd_au1xxx_drv_resume(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	if (time_before(jiffies, ehci->next_statechange))
+		msleep(100);
+
+	/* Mark hardware accessible again as we are out of D3 state by now */
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	/* If CF is still set, we maintained PCI Vaux power.
+	 * Just undo the effect of ehci_pci_suspend().
+	 */
+	if (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF) {
+		int	mask = INTR_MASK;
+
+		if (!hcd->self.root_hub->do_remote_wakeup)
+			mask &= ~STS_PCD;
+		ehci_writel(ehci, mask, &ehci->regs->intr_enable);
+		ehci_readl(ehci, &ehci->regs->intr_enable);
+		return 0;
+	}
+
+	ehci_dbg(ehci, "lost power, restarting\n");
+	usb_root_hub_lost_power(hcd->self.root_hub);
+
+	/* Else reset, to cope with power loss or flush-to-storage
+	 * style "resume" having let BIOS kick in during reboot.
+	 */
+	(void) ehci_halt(ehci);
+	(void) ehci_reset(ehci);
+
+	/* emptying the schedule aborts any urbs */
+	spin_lock_irq(&ehci->lock);
+	if (ehci->reclaim)
+		end_unlink_async(ehci);
+	ehci_work(ehci);
+	spin_unlock_irq(&ehci->lock);
+
+	ehci_writel(ehci, ehci->command, &ehci->regs->command);
+	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
+	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
+
+	/* here we "know" root ports should always stay powered */
+	ehci_port_power(ehci, 1);
+
+	hcd->state = HC_STATE_SUSPENDED;
 
 	return 0;
 }
-*/
-MODULE_ALIAS("au1xxx-ehci");
+
+#else
+#define ehci_hcd_au1xxx_drv_suspend NULL
+#define ehci_hcd_au1xxx_drv_resume NULL
+#endif
+
 static struct platform_driver ehci_hcd_au1xxx_driver = {
-	.probe = ehci_hcd_au1xxx_drv_probe,
-	.remove = ehci_hcd_au1xxx_drv_remove,
-	.shutdown = usb_hcd_platform_shutdown,
-	/*.suspend      = ehci_hcd_au1xxx_drv_suspend, */
-	/*.resume       = ehci_hcd_au1xxx_drv_resume, */
+	.probe		= ehci_hcd_au1xxx_drv_probe,
+	.remove		= ehci_hcd_au1xxx_drv_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.suspend	= ehci_hcd_au1xxx_drv_suspend,
+	.resume		= ehci_hcd_au1xxx_drv_resume,
 	.driver = {
-		.name = "au1xxx-ehci",
-		.bus = &platform_bus_type
+		.name	= "au1xxx-ehci",
+		.owner	= THIS_MODULE,
 	}
 };
+
+MODULE_ALIAS("platform:au1xxx-ehci");
diff -urN host/ehci-dbg.c host.new/ehci-dbg.c
--- host/ehci-dbg.c	2009-02-24 19:00:15.259977568 +0100
+++ host.new/ehci-dbg.c	2009-03-28 17:46:02.000000000 +0100
@@ -27,7 +27,7 @@
 #define ehci_warn(ehci, fmt, args...) \
 	dev_warn (ehci_to_hcd(ehci)->self.controller , fmt , ## args )
 
-#ifdef EHCI_VERBOSE_DEBUG
+#ifdef VERBOSE_DEBUG
 #	define vdbg dbg
 #	define ehci_vdbg ehci_dbg
 #else
@@ -323,7 +323,44 @@
 
 #else
 
-/* troubleshooting help: expose state in sysfs */
+/* troubleshooting help: expose state in debugfs */
+
+static int debug_async_open(struct inode *, struct file *);
+static int debug_periodic_open(struct inode *, struct file *);
+static int debug_registers_open(struct inode *, struct file *);
+static int debug_async_open(struct inode *, struct file *);
+static ssize_t debug_output(struct file*, char __user*, size_t, loff_t*);
+static int debug_close(struct inode *, struct file *);
+
+static const struct file_operations debug_async_fops = {
+	.owner		= THIS_MODULE,
+	.open		= debug_async_open,
+	.read		= debug_output,
+	.release	= debug_close,
+};
+static const struct file_operations debug_periodic_fops = {
+	.owner		= THIS_MODULE,
+	.open		= debug_periodic_open,
+	.read		= debug_output,
+	.release	= debug_close,
+};
+static const struct file_operations debug_registers_fops = {
+	.owner		= THIS_MODULE,
+	.open		= debug_registers_open,
+	.read		= debug_output,
+	.release	= debug_close,
+};
+
+static struct dentry *ehci_debug_root;
+
+struct debug_buffer {
+	ssize_t (*fill_func)(struct debug_buffer *);	/* fill method */
+	struct usb_bus *bus;
+	struct mutex mutex;	/* protect filling of buffer */
+	size_t count;		/* number of characters filled into buffer */
+	char *output_buf;
+	size_t alloc_size;
+};
 
 #define speed_char(info1) ({ char tmp; \
 		switch (info1 & (3 << 12)) { \
@@ -362,7 +399,7 @@
 	unsigned		size = *sizep;
 	char			*next = *nextp;
 	char			mark;
-	u32			list_end = EHCI_LIST_END(ehci);
+	__le32			list_end = EHCI_LIST_END(ehci);
 
 	if (qh->hw_qtd_next == list_end)	/* NEC does this */
 		mark = '@';
@@ -418,9 +455,7 @@
 				(scratch >> 16) & 0x7fff,
 				scratch,
 				td->urb);
-		if (temp < 0)
-			temp = 0;
-		else if (size < temp)
+		if (size < temp)
 			temp = size;
 		size -= temp;
 		next += temp;
@@ -429,9 +464,7 @@
 	}
 
 	temp = snprintf (next, size, "\n");
-	if (temp < 0)
-		temp = 0;
-	else if (size < temp)
+	if (size < temp)
 		temp = size;
 	size -= temp;
 	next += temp;
@@ -441,10 +474,8 @@
 	*nextp = next;
 }
 
-static ssize_t
-show_async (struct class_device *class_dev, char *buf)
+static ssize_t fill_async_buffer(struct debug_buffer *buf)
 {
-	struct usb_bus		*bus;
 	struct usb_hcd		*hcd;
 	struct ehci_hcd		*ehci;
 	unsigned long		flags;
@@ -452,13 +483,12 @@
 	char			*next;
 	struct ehci_qh		*qh;
 
-	*buf = 0;
-
-	bus = class_get_devdata(class_dev);
-	hcd = bus_to_hcd(bus);
+	hcd = bus_to_hcd(buf->bus);
 	ehci = hcd_to_ehci (hcd);
-	next = buf;
-	size = PAGE_SIZE;
+	next = buf->output_buf;
+	size = buf->alloc_size;
+
+	*next = 0;
 
 	/* dumps a snapshot of the async schedule.
 	 * usually empty except for long-term bulk reads, or head.
@@ -477,16 +507,12 @@
 	}
 	spin_unlock_irqrestore (&ehci->lock, flags);
 
-	return strlen (buf);
+	return strlen(buf->output_buf);
 }
-static CLASS_DEVICE_ATTR (async, S_IRUGO, show_async, NULL);
 
 #define DBG_SCHED_LIMIT 64
-
-static ssize_t
-show_periodic (struct class_device *class_dev, char *buf)
+static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 {
-	struct usb_bus		*bus;
 	struct usb_hcd		*hcd;
 	struct ehci_hcd		*ehci;
 	unsigned long		flags;
@@ -500,11 +526,10 @@
 		return 0;
 	seen_count = 0;
 
-	bus = class_get_devdata(class_dev);
-	hcd = bus_to_hcd(bus);
+	hcd = bus_to_hcd(buf->bus);
 	ehci = hcd_to_ehci (hcd);
-	next = buf;
-	size = PAGE_SIZE;
+	next = buf->output_buf;
+	size = buf->alloc_size;
 
 	temp = scnprintf (next, size, "size = %d\n", ehci->periodic_size);
 	size -= temp;
@@ -540,14 +565,16 @@
 				for (temp = 0; temp < seen_count; temp++) {
 					if (seen [temp].ptr != p.ptr)
 						continue;
-					if (p.qh->qh_next.ptr)
+					if (p.qh->qh_next.ptr) {
 						temp = scnprintf (next, size,
 							" ...");
-					p.ptr = NULL;
+						size -= temp;
+						next += temp;
+					}
 					break;
 				}
 				/* show more info the first time around */
-				if (temp == seen_count && p.ptr) {
+				if (temp == seen_count) {
 					u32	scratch = hc32_to_cpup(ehci,
 							&p.qh->hw_info1);
 					struct ehci_qtd	*qtd;
@@ -621,16 +648,12 @@
 	spin_unlock_irqrestore (&ehci->lock, flags);
 	kfree (seen);
 
-	return PAGE_SIZE - size;
+	return buf->alloc_size - size;
 }
-static CLASS_DEVICE_ATTR (periodic, S_IRUGO, show_periodic, NULL);
-
 #undef DBG_SCHED_LIMIT
 
-static ssize_t
-show_registers (struct class_device *class_dev, char *buf)
+static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 {
-	struct usb_bus		*bus;
 	struct usb_hcd		*hcd;
 	struct ehci_hcd		*ehci;
 	unsigned long		flags;
@@ -639,21 +662,20 @@
 	static char		fmt [] = "%*s\n";
 	static char		label [] = "";
 
-	bus = class_get_devdata(class_dev);
-	hcd = bus_to_hcd(bus);
+	hcd = bus_to_hcd(buf->bus);
 	ehci = hcd_to_ehci (hcd);
-	next = buf;
-	size = PAGE_SIZE;
+	next = buf->output_buf;
+	size = buf->alloc_size;
 
 	spin_lock_irqsave (&ehci->lock, flags);
 
-	if (bus->controller->power.power_state.event) {
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {
 		size = scnprintf (next, size,
-			"bus %s, device %s (driver " DRIVER_VERSION ")\n"
+			"bus %s, device %s\n"
 			"%s\n"
 			"SUSPENDED (no register access)\n",
 			hcd->self.controller->bus->name,
-			hcd->self.controller->bus_id,
+			dev_name(hcd->self.controller),
 			hcd->product_desc);
 		goto done;
 	}
@@ -661,11 +683,11 @@
 	/* Capability Registers */
 	i = HC_VERSION(ehci_readl(ehci, &ehci->caps->hc_capbase));
 	temp = scnprintf (next, size,
-		"bus %s, device %s (driver " DRIVER_VERSION ")\n"
+		"bus %s, device %s\n"
 		"%s\n"
 		"EHCI %x.%02x, hcd state %d\n",
 		hcd->self.controller->bus->name,
-		hcd->self.controller->bus_id,
+		dev_name(hcd->self.controller),
 		hcd->product_desc,
 		i >> 8, i & 0x0ff, hcd->state);
 	size -= temp;
@@ -763,9 +785,7 @@
 	}
 
 	if (ehci->reclaim) {
-		temp = scnprintf (next, size, "reclaim qh %p%s\n",
-				ehci->reclaim,
-				ehci->reclaim_ready ? " ready" : "");
+		temp = scnprintf(next, size, "reclaim qh %p\n", ehci->reclaim);
 		size -= temp;
 		next += temp;
 	}
@@ -787,28 +807,157 @@
 done:
 	spin_unlock_irqrestore (&ehci->lock, flags);
 
-	return PAGE_SIZE - size;
+	return buf->alloc_size - size;
+}
+
+static struct debug_buffer *alloc_buffer(struct usb_bus *bus,
+				ssize_t (*fill_func)(struct debug_buffer *))
+{
+	struct debug_buffer *buf;
+
+	buf = kzalloc(sizeof(struct debug_buffer), GFP_KERNEL);
+
+	if (buf) {
+		buf->bus = bus;
+		buf->fill_func = fill_func;
+		mutex_init(&buf->mutex);
+		buf->alloc_size = PAGE_SIZE;
+	}
+
+	return buf;
+}
+
+static int fill_buffer(struct debug_buffer *buf)
+{
+	int ret = 0;
+
+	if (!buf->output_buf)
+		buf->output_buf = (char *)vmalloc(buf->alloc_size);
+
+	if (!buf->output_buf) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = buf->fill_func(buf);
+
+	if (ret >= 0) {
+		buf->count = ret;
+		ret = 0;
+	}
+
+out:
+	return ret;
+}
+
+static ssize_t debug_output(struct file *file, char __user *user_buf,
+			    size_t len, loff_t *offset)
+{
+	struct debug_buffer *buf = file->private_data;
+	int ret = 0;
+
+	mutex_lock(&buf->mutex);
+	if (buf->count == 0) {
+		ret = fill_buffer(buf);
+		if (ret != 0) {
+			mutex_unlock(&buf->mutex);
+			goto out;
+		}
+	}
+	mutex_unlock(&buf->mutex);
+
+	ret = simple_read_from_buffer(user_buf, len, offset,
+				      buf->output_buf, buf->count);
+
+out:
+	return ret;
+
+}
+
+static int debug_close(struct inode *inode, struct file *file)
+{
+	struct debug_buffer *buf = file->private_data;
+
+	if (buf) {
+		if (buf->output_buf)
+			vfree(buf->output_buf);
+		kfree(buf);
+	}
+
+	return 0;
+}
+static int debug_async_open(struct inode *inode, struct file *file)
+{
+	file->private_data = alloc_buffer(inode->i_private, fill_async_buffer);
+
+	return file->private_data ? 0 : -ENOMEM;
+}
+
+static int debug_periodic_open(struct inode *inode, struct file *file)
+{
+	struct debug_buffer *buf;
+	buf = alloc_buffer(inode->i_private, fill_periodic_buffer);
+	if (!buf)
+		return -ENOMEM;
+
+	buf->alloc_size = (sizeof(void *) == 4 ? 6 : 8)*PAGE_SIZE;
+	file->private_data = buf;
+	return 0;
+}
+
+static int debug_registers_open(struct inode *inode, struct file *file)
+{
+	file->private_data = alloc_buffer(inode->i_private,
+					  fill_registers_buffer);
+
+	return file->private_data ? 0 : -ENOMEM;
 }
-static CLASS_DEVICE_ATTR (registers, S_IRUGO, show_registers, NULL);
 
 static inline void create_debug_files (struct ehci_hcd *ehci)
 {
-	struct class_device *cldev = ehci_to_hcd(ehci)->self.class_dev;
-	int retval;
+	struct usb_bus *bus = &ehci_to_hcd(ehci)->self;
 
-	retval = class_device_create_file(cldev, &class_device_attr_async);
-	retval = class_device_create_file(cldev, &class_device_attr_periodic);
-	retval = class_device_create_file(cldev, &class_device_attr_registers);
+	ehci->debug_dir = debugfs_create_dir(bus->bus_name, ehci_debug_root);
+	if (!ehci->debug_dir)
+		goto dir_error;
+
+	ehci->debug_async = debugfs_create_file("async", S_IRUGO,
+						ehci->debug_dir, bus,
+						&debug_async_fops);
+	if (!ehci->debug_async)
+		goto async_error;
+
+	ehci->debug_periodic = debugfs_create_file("periodic", S_IRUGO,
+						   ehci->debug_dir, bus,
+						   &debug_periodic_fops);
+	if (!ehci->debug_periodic)
+		goto periodic_error;
+
+	ehci->debug_registers = debugfs_create_file("registers", S_IRUGO,
+						    ehci->debug_dir, bus,
+						    &debug_registers_fops);
+	if (!ehci->debug_registers)
+		goto registers_error;
+	return;
+
+registers_error:
+	debugfs_remove(ehci->debug_periodic);
+periodic_error:
+	debugfs_remove(ehci->debug_async);
+async_error:
+	debugfs_remove(ehci->debug_dir);
+dir_error:
+	ehci->debug_periodic = NULL;
+	ehci->debug_async = NULL;
+	ehci->debug_dir = NULL;
 }
 
 static inline void remove_debug_files (struct ehci_hcd *ehci)
 {
-	struct class_device *cldev = ehci_to_hcd(ehci)->self.class_dev;
-
-	class_device_remove_file(cldev, &class_device_attr_async);
-	class_device_remove_file(cldev, &class_device_attr_periodic);
-	class_device_remove_file(cldev, &class_device_attr_registers);
+	debugfs_remove(ehci->debug_registers);
+	debugfs_remove(ehci->debug_periodic);
+	debugfs_remove(ehci->debug_async);
+	debugfs_remove(ehci->debug_dir);
 }
 
 #endif /* STUB_DEBUG_FILES */
-
diff -urN host/ehci-fotg2xx.c host.new/ehci-fotg2xx.c
--- host/ehci-fotg2xx.c	2009-04-09 20:23:39.431135292 +0200
+++ host.new/ehci-fotg2xx.c	2009-03-28 17:46:02.000000000 +0100
@@ -10,13 +10,12 @@
  */
 
 #include <linux/platform_device.h>
+#include <mach/hardware.h>
 
 #define otg_set(port, bits) writel(readl(hcd->regs + port) | bits, hcd->regs + port)
 
 #define otg_clear(port, bits) writel(readl(hcd->regs + port) & ~bits, hcd->regs + port)
 
-#define BIT(x) (1 << x)
-
 #define GLOBAL_ISR			0xC0
 #define GLOBAL_ICR			0xC4
 
@@ -178,7 +177,7 @@
 	dbg_hcc_params(ehci, "reset");
 
 	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
-//	hcd->has_tt = 1;
+	hcd->has_tt = 1;
 
 	result = ehci_halt(ehci);
 	if (result)
@@ -348,8 +347,8 @@
 	.bus_suspend		= ehci_bus_suspend,
 	.bus_resume		= ehci_bus_resume,
 #endif
-//	.relinquish_port	= ehci_relinquish_port,
-//	.port_handed_over	= ehci_port_handed_over,
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
 };
 
 static int fotg2xx_ehci_probe(struct platform_device *pdev)
diff -urN host/ehci-fsl.c host.new/ehci-fsl.c
--- host/ehci-fsl.c	2009-02-24 19:00:15.263977365 +0100
+++ host.new/ehci-fsl.c	2009-03-28 17:46:02.000000000 +0100
@@ -1,5 +1,4 @@
 /*
- * (C) Copyright David Brownell 2000-2002
  * Copyright (c) 2005 MontaVista Software
  *
  * This program is free software; you can redistribute it and/or modify it
@@ -25,10 +24,9 @@
 
 #include "ehci-fsl.h"
 
-/* FIXME: Power Managment is un-ported so temporarily disable it */
+/* FIXME: Power Management is un-ported so temporarily disable it */
 #undef CONFIG_PM
 
-/* PCI-based HCs are common, but plenty of non-PCI HCs are used too */
 
 /* configure so an HC device and id are always provided */
 /* always called with process context; sleeping is OK */
@@ -58,7 +56,7 @@
 	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
 	if (!pdata) {
 		dev_err(&pdev->dev,
-			"No platform data for %s.\n", pdev->dev.bus_id);
+			"No platform data for %s.\n", dev_name(&pdev->dev));
 		return -ENODEV;
 	}
 
@@ -71,7 +69,7 @@
 	      (pdata->operating_mode == FSL_USB2_DR_OTG))) {
 		dev_err(&pdev->dev,
 			"Non Host Mode configured for %s. Wrong driver linked.\n",
-			pdev->dev.bus_id);
+			dev_name(&pdev->dev));
 		return -ENODEV;
 	}
 
@@ -79,12 +77,12 @@
 	if (!res) {
 		dev_err(&pdev->dev,
 			"Found HC with no IRQ. Check %s setup!\n",
-			pdev->dev.bus_id);
+			dev_name(&pdev->dev));
 		return -ENODEV;
 	}
 	irq = res->start;
 
-	hcd = usb_create_hcd(driver, &pdev->dev, pdev->dev.bus_id);
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
 	if (!hcd) {
 		retval = -ENOMEM;
 		goto err1;
@@ -94,7 +92,7 @@
 	if (!res) {
 		dev_err(&pdev->dev,
 			"Found HC with no register addr. Check %s setup!\n",
-			pdev->dev.bus_id);
+			dev_name(&pdev->dev));
 		retval = -ENODEV;
 		goto err2;
 	}
@@ -122,7 +120,7 @@
 	temp = in_le32(hcd->regs + 0x1a8);
 	out_le32(hcd->regs + 0x1a8, temp | 0x3);
 
-	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
 	if (retval != 0)
 		goto err4;
 	return retval;
@@ -134,7 +132,7 @@
       err2:
 	usb_put_hcd(hcd);
       err1:
-	dev_err(&pdev->dev, "init %s fail, %d\n", pdev->dev.bus_id, retval);
+	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), retval);
 	return retval;
 }
 
@@ -232,8 +230,13 @@
 
 	/* put controller in host mode. */
 	ehci_writel(ehci, 0x00000003, non_ehci + FSL_SOC_USB_USBMODE);
+#ifdef CONFIG_PPC_85xx
+	out_be32(non_ehci + FSL_SOC_USB_PRICTRL, 0x00000008);
+	out_be32(non_ehci + FSL_SOC_USB_AGECNTTHRSH, 0x00000080);
+#else
 	out_be32(non_ehci + FSL_SOC_USB_PRICTRL, 0x0000000c);
 	out_be32(non_ehci + FSL_SOC_USB_AGECNTTHRSH, 0x00000040);
+#endif
 	out_be32(non_ehci + FSL_SOC_USB_SICTRL, 0x00000001);
 }
 
@@ -271,7 +274,7 @@
 	if (retval)
 		return retval;
 
-	ehci->is_tdi_rh_tt = 1;
+	hcd->has_tt = 1;
 
 	ehci->sbrn = 0x20;
 
@@ -297,10 +300,6 @@
 	 */
 	.reset = ehci_fsl_setup,
 	.start = ehci_run,
-#ifdef	CONFIG_PM
-	.suspend = ehci_bus_suspend,
-	.resume = ehci_bus_resume,
-#endif
 	.stop = ehci_stop,
 	.shutdown = ehci_shutdown,
 
@@ -323,6 +322,8 @@
 	.hub_control = ehci_hub_control,
 	.bus_suspend = ehci_bus_suspend,
 	.bus_resume = ehci_bus_resume,
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
 };
 
 static int ehci_fsl_drv_probe(struct platform_device *pdev)
@@ -330,6 +331,7 @@
 	if (usb_disabled())
 		return -ENODEV;
 
+	/* FIXME we only want one one probe() not two */
 	return usb_hcd_fsl_probe(&ehci_fsl_hc_driver, pdev);
 }
 
@@ -337,12 +339,12 @@
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 
+	/* FIXME we only want one one remove() not two */
 	usb_hcd_fsl_remove(hcd, pdev);
-
 	return 0;
 }
 
-MODULE_ALIAS("fsl-ehci");
+MODULE_ALIAS("platform:fsl-ehci");
 
 static struct platform_driver ehci_fsl_driver = {
 	.probe = ehci_fsl_drv_probe,
@@ -350,5 +352,5 @@
 	.shutdown = usb_hcd_platform_shutdown,
 	.driver = {
 		   .name = "fsl-ehci",
-		   },
+	},
 };
diff -urN host/ehci-hcd.c host.new/ehci-hcd.c
--- host/ehci-hcd.c	2009-04-09 20:14:41.585682781 +0200
+++ host.new/ehci-hcd.c	2009-03-28 17:46:02.000000000 +0100
@@ -24,6 +24,7 @@
 #include <linux/ioport.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
+#include <linux/vmalloc.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/timer.h>
@@ -33,6 +34,7 @@
 #include <linux/usb.h>
 #include <linux/moduleparam.h>
 #include <linux/dma-mapping.h>
+#include <linux/debugfs.h>
 
 #include "../core/hcd.h"
 
@@ -56,45 +58,15 @@
  * Special thanks to Intel and VIA for providing host controllers to
  * test this driver on, and Cypress (including In-System Design) for
  * providing early devices for those host controllers to talk to!
- *
- * HISTORY:
- *
- * 2004-05-10 Root hub and PCI suspend/resume support; remote wakeup. (db)
- * 2004-02-24 Replace pci_* with generic dma_* API calls (dsaxena@plexity.net)
- * 2003-12-29 Rewritten high speed iso transfer support (by Michal Sojka,
- *	<sojkam@centrum.cz>, updates by DB).
- *
- * 2002-11-29	Correct handling for hw async_next register.
- * 2002-08-06	Handling for bulk and interrupt transfers is mostly shared;
- *	only scheduling is different, no arbitrary limitations.
- * 2002-07-25	Sanity check PCI reads, mostly for better cardbus support,
- *	clean up HC run state handshaking.
- * 2002-05-24	Preliminary FS/LS interrupts, using scheduling shortcuts
- * 2002-05-11	Clear TT errors for FS/LS ctrl/bulk.  Fill in some other
- *	missing pieces:  enabling 64bit dma, handoff from BIOS/SMM.
- * 2002-05-07	Some error path cleanups to report better errors; wmb();
- *	use non-CVS version id; better iso bandwidth claim.
- * 2002-04-19	Control/bulk/interrupt submit no longer uses giveback() on
- *	errors in submit path.  Bugfixes to interrupt scheduling/processing.
- * 2002-03-05	Initial high-speed ISO support; reduce ITD memory; shift
- *	more checking to generic hcd framework (db).  Make it work with
- *	Philips EHCI; reduce PCI traffic; shorten IRQ path (Rory Bolt).
- * 2002-01-14	Minor cleanup; version synch.
- * 2002-01-08	Fix roothub handoff of FS/LS to companion controllers.
- * 2002-01-04	Control/Bulk queuing behaves.
- *
- * 2001-12-12	Initial patch version for Linux 2.5.1 kernel.
- * 2001-June	Works with usb-storage and NEC EHCI on 2.4
  */
 
-#define DRIVER_VERSION "10 Dec 2004"
 #define DRIVER_AUTHOR "David Brownell"
 #define DRIVER_DESC "USB 2.0 'Enhanced' Host Controller (EHCI) Driver"
 
 static const char	hcd_name [] = "ehci_hcd";
 
 
-#undef EHCI_VERBOSE_DEBUG
+#undef VERBOSE_DEBUG
 #undef EHCI_URB_TRACE
 
 #ifdef DEBUG
@@ -109,10 +81,10 @@
 #define	EHCI_TUNE_MULT_TT	1
 #define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
 
-#define EHCI_IAA_JIFFIES	(HZ/100)	/* arbitrary; ~10 msec */
+#define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
-#define EHCI_SHRINK_JIFFIES	(HZ/200)	/* async qh unlink delay */
+#define EHCI_SHRINK_FRAMES	5		/* async qh unlink delay */
 
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
@@ -125,7 +97,7 @@
 MODULE_PARM_DESC (park, "park setting; 1-3 back-to-back async packets");
 
 /* for flakey hardware, ignore overcurrent indicators */
-static int ignore_oc = 1;
+static int ignore_oc = 0;
 module_param (ignore_oc, bool, S_IRUGO);
 MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
 
@@ -138,6 +110,42 @@
 
 /*-------------------------------------------------------------------------*/
 
+static void
+timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
+{
+	/* Don't override timeouts which shrink or (later) disable
+	 * the async ring; just the I/O watchdog.  Note that if a
+	 * SHRINK were pending, OFF would never be requested.
+	 */
+	if (timer_pending(&ehci->watchdog)
+			&& ((BIT(TIMER_ASYNC_SHRINK) | BIT(TIMER_ASYNC_OFF))
+				& ehci->actions))
+		return;
+
+	if (!test_and_set_bit(action, &ehci->actions)) {
+		unsigned long t;
+
+		switch (action) {
+		case TIMER_IO_WATCHDOG:
+			t = EHCI_IO_JIFFIES;
+			break;
+		case TIMER_ASYNC_OFF:
+			t = EHCI_ASYNC_JIFFIES;
+			break;
+		/* case TIMER_ASYNC_SHRINK: */
+		default:
+			/* add a jiffie since we synch against the
+			 * 8 KHz uframe counter.
+			 */
+			t = DIV_ROUND_UP(EHCI_SHRINK_FRAMES * HZ, 1000) + 1;
+			break;
+		}
+		mod_timer(&ehci->watchdog, t + jiffies);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
 /*
  * handshake - spin reading hc until handshake completes or fails
  * @ptr: address of hc register to be read
@@ -184,7 +192,7 @@
 	if ((temp & STS_HALT) != 0)
 		return 0;
 
-#ifndef CONFIG_SL2312_USB
+#ifndef CONFIG_ARCH_GEMINI
 	temp = ehci_readl(ehci, &ehci->regs->command);
 	temp &= ~CMD_RUN;
 	ehci_writel(ehci, temp, &ehci->regs->command);
@@ -193,6 +201,22 @@
 			  STS_HALT, STS_HALT, 16 * 125);
 }
 
+static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
+				       u32 mask, u32 done, int usec)
+{
+	int error;
+
+	error = handshake(ehci, ptr, mask, done, usec);
+	if (error) {
+		ehci_halt(ehci);
+		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
+		ehci_err(ehci, "force halt; handhake %p %08x %08x -> %d\n",
+			ptr, mask, done, error);
+	}
+
+	return error;
+}
+
 /* put TDI/ARC silicon into EHCI mode */
 static void tdi_reset (struct ehci_hcd *ehci)
 {
@@ -228,8 +252,8 @@
 	if (retval)
 		return retval;
 
-	if (ehci_is_TDI(ehci))
-		tdi_reset (ehci);
+//	if (ehci_is_TDI(ehci))
+//		tdi_reset (ehci);
 
 	return retval;
 }
@@ -247,11 +271,9 @@
 	/* wait for any schedule enables/disables to take effect */
 	temp = ehci_readl(ehci, &ehci->regs->command) << 10;
 	temp &= STS_ASS | STS_PSS;
-	if (handshake (ehci, &ehci->regs->status, STS_ASS | STS_PSS,
-				temp, 16 * 125) != 0) {
-		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
+	if (handshake_on_error_set_halt(ehci, &ehci->regs->status,
+					STS_ASS | STS_PSS, temp, 16 * 125))
 		return;
-	}
 
 	/* then disable anything that's still active */
 	temp = ehci_readl(ehci, &ehci->regs->command);
@@ -259,15 +281,13 @@
 	ehci_writel(ehci, temp, &ehci->regs->command);
 
 	/* hardware can take 16 microframes to turn off ... */
-	if (handshake (ehci, &ehci->regs->status, STS_ASS | STS_PSS,
-				0, 16 * 125) != 0) {
-		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
-		return;
-	}
+	handshake_on_error_set_halt(ehci, &ehci->regs->status,
+				    STS_ASS | STS_PSS, 0, 16 * 125);
 }
 
 /*-------------------------------------------------------------------------*/
 
+static void end_unlink_async(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 
 #include "ehci-hub.c"
@@ -277,25 +297,62 @@
 
 /*-------------------------------------------------------------------------*/
 
-static void ehci_watchdog (unsigned long param)
+static void ehci_iaa_watchdog(unsigned long param)
 {
 	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
 	unsigned long		flags;
 
 	spin_lock_irqsave (&ehci->lock, flags);
 
-	/* lost IAA irqs wedge things badly; seen with a vt8235 */
-	if (ehci->reclaim) {
-		u32		status = ehci_readl(ehci, &ehci->regs->status);
-		if (status & STS_IAA) {
-			ehci_vdbg (ehci, "lost IAA\n");
+	/* Lost IAA irqs wedge things badly; seen first with a vt8235.
+	 * So we need this watchdog, but must protect it against both
+	 * (a) SMP races against real IAA firing and retriggering, and
+	 * (b) clean HC shutdown, when IAA watchdog was pending.
+	 */
+	if (ehci->reclaim
+			&& !timer_pending(&ehci->iaa_watchdog)
+			&& HC_IS_RUNNING(ehci_to_hcd(ehci)->state)) {
+		u32 cmd, status;
+
+		/* If we get here, IAA is *REALLY* late.  It's barely
+		 * conceivable that the system is so busy that CMD_IAAD
+		 * is still legitimately set, so let's be sure it's
+		 * clear before we read STS_IAA.  (The HC should clear
+		 * CMD_IAAD when it sets STS_IAA.)
+		 */
+		cmd = ehci_readl(ehci, &ehci->regs->command);
+		if (cmd & CMD_IAAD)
+			ehci_writel(ehci, cmd & ~CMD_IAAD,
+					&ehci->regs->command);
+
+		/* If IAA is set here it either legitimately triggered
+		 * before we cleared IAAD above (but _way_ late, so we'll
+		 * still count it as lost) ... or a silicon erratum:
+		 * - VIA seems to set IAA without triggering the IRQ;
+		 * - IAAD potentially cleared without setting IAA.
+		 */
+		status = ehci_readl(ehci, &ehci->regs->status);
+		if ((status & STS_IAA) || !(cmd & CMD_IAAD)) {
 			COUNT (ehci->stats.lost_iaa);
 			ehci_writel(ehci, STS_IAA, &ehci->regs->status);
-			ehci->reclaim_ready = 1;
 		}
+
+		ehci_vdbg(ehci, "IAA watchdog: status %x cmd %x\n",
+				status, cmd);
+		end_unlink_async(ehci);
 	}
 
- 	/* stop async processing after it's idled a bit */
+	spin_unlock_irqrestore(&ehci->lock, flags);
+}
+
+static void ehci_watchdog(unsigned long param)
+{
+	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&ehci->lock, flags);
+
+	/* stop async processing after it's idled a bit */
 	if (test_bit (TIMER_ASYNC_OFF, &ehci->actions))
 		start_unlink_async (ehci, ehci->async);
 
@@ -318,20 +375,15 @@
 				&ehci->regs->port_status[port]);
 }
 
-/* ehci_shutdown kick in for silicon on any bus (not just pci, etc).
- * This forcibly disables dma and IRQs, helping kexec and other cases
- * where the next system software may expect clean state.
+/*
+ * Halt HC, turn off all ports, and let the BIOS use the companion controllers.
+ * Should be called with ehci->lock held.
  */
-static void
-ehci_shutdown (struct usb_hcd *hcd)
+static void ehci_silence_controller(struct ehci_hcd *ehci)
 {
-	struct ehci_hcd	*ehci;
-
-	ehci = hcd_to_ehci (hcd);
-	(void) ehci_halt (ehci);
+	ehci_halt(ehci);
 	ehci_turn_off_all_ports(ehci);
-
-#ifndef CONFIG_SL2312_USB
+#ifndef CONFIG_ARCH_GEMINI
 	/* make BIOS/etc use companion controller during reboot */
 	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
 
@@ -340,6 +392,22 @@
 #endif
 }
 
+/* ehci_shutdown kick in for silicon on any bus (not just pci, etc).
+ * This forcibly disables dma and IRQs, helping kexec and other cases
+ * where the next system software may expect clean state.
+ */
+static void ehci_shutdown(struct usb_hcd *hcd)
+{
+	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
+
+	del_timer_sync(&ehci->watchdog);
+	del_timer_sync(&ehci->iaa_watchdog);
+
+	spin_lock_irq(&ehci->lock);
+	ehci_silence_controller(ehci);
+	spin_unlock_irq(&ehci->lock);
+}
+
 static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
 {
 	unsigned port;
@@ -367,8 +435,6 @@
 static void ehci_work (struct ehci_hcd *ehci)
 {
 	timer_action_done (ehci, TIMER_IO_WATCHDOG);
-	if (ehci->reclaim_ready)
-		end_unlink_async (ehci);
 
 	/* another CPU may drop ehci->lock during a schedule scan while
 	 * it reports urb completions.  this flag guards against bogus
@@ -392,31 +458,27 @@
 		timer_action (ehci, TIMER_IO_WATCHDOG);
 }
 
+/*
+ * Called when the ehci_hcd module is removed.
+ */
 static void ehci_stop (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 
 	ehci_dbg (ehci, "stop\n");
 
-	/* Turn off port power on all root hub ports. */
-	ehci_port_power (ehci, 0);
-
 	/* no more interrupts ... */
 	del_timer_sync (&ehci->watchdog);
+	del_timer_sync(&ehci->iaa_watchdog);
 
 	spin_lock_irq(&ehci->lock);
 	if (HC_IS_RUNNING (hcd->state))
 		ehci_quiesce (ehci);
 
+	ehci_silence_controller(ehci);
 	ehci_reset (ehci);
-	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
 	spin_unlock_irq(&ehci->lock);
 
-#ifndef CONFIG_SL2312_USB
-	/* let companion controllers work when we aren't */
-	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
-#endif
-
 	remove_companion_file(ehci);
 	remove_debug_files (ehci);
 
@@ -453,11 +515,16 @@
 	ehci->watchdog.function = ehci_watchdog;
 	ehci->watchdog.data = (unsigned long) ehci;
 
+	init_timer(&ehci->iaa_watchdog);
+	ehci->iaa_watchdog.function = ehci_iaa_watchdog;
+	ehci->iaa_watchdog.data = (unsigned long) ehci;
+
 	/*
 	 * hw default: 1K periodic list heads, one per frame.
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
 	 */
 	ehci->periodic_size = DEFAULT_I_TDPS;
+	INIT_LIST_HEAD(&ehci->cached_itd_list);
 	if ((retval = ehci_mem_init(ehci, GFP_KERNEL)) < 0)
 		return retval;
 
@@ -469,8 +536,8 @@
 		ehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 
 	ehci->reclaim = NULL;
-	ehci->reclaim_ready = 0;
 	ehci->next_uframe = -1;
+	ehci->clock_frame = -1;
 
 	/*
 	 * dedicate a qh for the async ring head, since we couldn't unlink
@@ -554,7 +621,6 @@
 	 * host side drivers though.
 	 */
 	hcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);
-#ifndef CONFIG_SL2312_USB
 	if (HCC_64BIT_ADDR(hcc_params)) {
 		ehci_writel(ehci, 0, &ehci->regs->segment);
 #if 0
@@ -563,12 +629,12 @@
 			ehci_info(ehci, "enabled 64bit DMA\n");
 #endif
 	}
-#endif
+
 
 	// Philips, Intel, and maybe others need CMD_RUN before the
 	// root hub will detect new devices (why?); NEC doesn't
 	ehci->command &= ~(CMD_LRESET|CMD_IAAD|CMD_PSE|CMD_ASE|CMD_RESET);
-#ifndef CONFIG_SL2312_USB
+#ifndef CONFIG_ARCH_GEMINI
 	ehci->command |= CMD_RUN;
 #endif
 	ehci_writel(ehci, ehci->command, &ehci->regs->command);
@@ -590,7 +656,7 @@
 	 */
 	down_write(&ehci_cf_port_reset_rwsem);
 	hcd->state = HC_STATE_RUNNING;
-#ifndef CONFIG_SL2312_USB
+#ifndef CONFIG_ARCH_GEMINI
 	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
 	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
 	msleep(5);
@@ -599,9 +665,9 @@
 
 	temp = HC_VERSION(ehci_readl(ehci, &ehci->caps->hc_capbase));
 	ehci_info (ehci,
-		"USB %x.%x started, EHCI %x.%02x, driver %s%s\n",
+		"USB %x.%x started, EHCI %x.%02x%s\n",
 		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
-		temp >> 8, temp & 0xff, DRIVER_VERSION,
+		temp >> 8, temp & 0xff,
 		ignore_oc ? ", overcurrent ignored" : "");
 
 	ehci_writel(ehci, INTR_MASK,
@@ -622,7 +688,7 @@
 static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	u32			status, pcd_status = 0;
+	u32			status, masked_status, pcd_status = 0, cmd;
 	int			bh;
 
 	spin_lock (&ehci->lock);
@@ -635,18 +701,18 @@
 		goto dead;
 	}
 
-	status &= INTR_MASK;
-	if (!status) {			/* irq sharing? */
+	masked_status = status & INTR_MASK;
+	if (!masked_status) {		/* irq sharing? */
 		spin_unlock(&ehci->lock);
 		return IRQ_NONE;
 	}
 
 	/* clear (just) interrupts */
-	ehci_writel(ehci, status, &ehci->regs->status);
-	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted write */
+	ehci_writel(ehci, masked_status, &ehci->regs->status);
+	cmd = ehci_readl(ehci, &ehci->regs->command);
 	bh = 0;
 
-#ifdef	EHCI_VERBOSE_DEBUG
+#ifdef	VERBOSE_DEBUG
 	/* unrequested/ignored: Frame List Rollover */
 	dbg_status (ehci, "irq", status);
 #endif
@@ -664,28 +730,42 @@
 
 	/* complete the unlinking of some qh [4.15.2.3] */
 	if (status & STS_IAA) {
-		COUNT (ehci->stats.reclaim);
-		ehci->reclaim_ready = 1;
-		bh = 1;
+		/* guard against (alleged) silicon errata */
+		if (cmd & CMD_IAAD) {
+			ehci_writel(ehci, cmd & ~CMD_IAAD,
+					&ehci->regs->command);
+			ehci_dbg(ehci, "IAA with IAAD still set?\n");
+		}
+		if (ehci->reclaim) {
+			COUNT(ehci->stats.reclaim);
+			end_unlink_async(ehci);
+		} else
+			ehci_dbg(ehci, "IAA with nothing to reclaim?\n");
 	}
 
 	/* remote wakeup [4.3.1] */
 	if (status & STS_PCD) {
 		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
 
+		/* kick root hub later */
+		pcd_status = status;
+
 		/* resume root hub? */
-		status = ehci_readl (ehci,&ehci->regs->command);
-#ifndef CONFIG_SL2312_USB
-		if (!(status & CMD_RUN))
-			ehci_writel (ehci,status | CMD_RUN, &ehci->regs->command);
+#ifndef CONFIG_ARCH_GEMINI
+		if (!(cmd & CMD_RUN))
+			usb_hcd_resume_root_hub(hcd);
 #endif
 		while (i--) {
-			int pstatus = readl (&ehci->regs->port_status [i]);
+			int pstatus = ehci_readl(ehci,
+						 &ehci->regs->port_status [i]);
 
 			if (pstatus & PORT_OWNER)
 				continue;
-			if (!(pstatus & PORT_RESUME)
-					|| ehci->reset_done [i] != 0)
+			if (!(test_bit(i, &ehci->suspended_ports) &&
+					((pstatus & PORT_RESUME) ||
+						!(pstatus & PORT_SUSPEND)) &&
+					(pstatus & PORT_PE) &&
+					ehci->reset_done[i] == 0))
 				continue;
 
 			/* start 20 msec resume signaling from this port,
@@ -695,41 +775,30 @@
 			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
 			mod_timer(&hcd->rh_timer, ehci->reset_done[i]);
-//			usb_hcd_resume_root_hub(hcd);
 		}
 	}
 
-#ifdef CONFIG_SL2312_USB
-	/* XXX */
-	if (unlikely ((status & STS_FATAL) != 0))
-		status = ehci_readl (ehci, &ehci->regs->status);
-#endif
-
 	/* PCI errors [4.15.2.4] */
 	if (unlikely ((status & STS_FATAL) != 0)) {
-		/* bogus "fatal" IRQs appear on some chips... why?  */
-		status = ehci_readl(ehci, &ehci->regs->status);
-		dbg_cmd (ehci, "fatal", ehci_readl(ehci,
-						   &ehci->regs->command));
-		dbg_status (ehci, "fatal", status);
-		if (status & STS_HALT) {
-			ehci_err (ehci, "fatal error\n");
+		ehci_err(ehci, "fatal error\n");
+		dbg_cmd(ehci, "fatal", cmd);
+		dbg_status(ehci, "fatal", status);
+		ehci_halt(ehci);
 dead:
-			ehci_reset (ehci);
-#ifndef CONFIG_SL2312_USB
-			ehci_writel(ehci, 0, &ehci->regs->configured_flag);
+		ehci_reset(ehci);
+#ifndef CONFIG_ARCH_GEMINI
+		ehci_writel(ehci, 0, &ehci->regs->configured_flag);
 #endif
-			/* generic layer kills/unlinks all urbs, then
-			 * uses ehci_stop to clean up the rest
-			 */
-			bh = 1;
-		}
+		/* generic layer kills/unlinks all urbs, then
+		 * uses ehci_stop to clean up the rest
+		 */
+		bh = 1;
 	}
 
 	if (bh)
 		ehci_work (ehci);
 	spin_unlock (&ehci->lock);
-	if (pcd_status & STS_PCD)
+	if (pcd_status)
 		usb_hcd_poll_rh_status(hcd);
 	return IRQ_HANDLED;
 }
@@ -750,7 +819,6 @@
  */
 static int ehci_urb_enqueue (
 	struct usb_hcd	*hcd,
-	struct usb_host_endpoint *ep,
 	struct urb	*urb,
 	gfp_t		mem_flags
 ) {
@@ -760,17 +828,23 @@
 	INIT_LIST_HEAD (&qtd_list);
 
 	switch (usb_pipetype (urb->pipe)) {
-	// case PIPE_CONTROL:
-	// case PIPE_BULK:
+	case PIPE_CONTROL:
+		/* qh_completions() code doesn't handle all the fault cases
+		 * in multi-TD control transfers.  Even 1KB is rare anyway.
+		 */
+		if (urb->transfer_buffer_length > (16 * 1024))
+			return -EMSGSIZE;
+		/* FALLTHROUGH */
+	/* case PIPE_BULK: */
 	default:
 		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
 			return -ENOMEM;
-		return submit_async (ehci, ep, urb, &qtd_list, mem_flags);
+		return submit_async(ehci, urb, &qtd_list, mem_flags);
 
 	case PIPE_INTERRUPT:
 		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
 			return -ENOMEM;
-		return intr_submit (ehci, ep, urb, &qtd_list, mem_flags);
+		return intr_submit(ehci, urb, &qtd_list, mem_flags);
 
 	case PIPE_ISOCHRONOUS:
 		if (urb->dev->speed == USB_SPEED_HIGH)
@@ -782,10 +856,16 @@
 
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	/* if we need to use IAA and it's busy, defer */
-	if (qh->qh_state == QH_STATE_LINKED
-			&& ehci->reclaim
-			&& HC_IS_RUNNING (ehci_to_hcd(ehci)->state)) {
+	/* failfast */
+	if (!HC_IS_RUNNING(ehci_to_hcd(ehci)->state) && ehci->reclaim)
+		end_unlink_async(ehci);
+
+	/* if it's not linked then there's nothing to do */
+	if (qh->qh_state != QH_STATE_LINKED)
+		;
+
+	/* defer till later if busy */
+	else if (ehci->reclaim) {
 		struct ehci_qh		*last;
 
 		for (last = ehci->reclaim;
@@ -795,12 +875,8 @@
 		qh->qh_state = QH_STATE_UNLINK_WAIT;
 		last->reclaim = qh;
 
-	/* bypass IAA if the hc can't care */
-	} else if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state) && ehci->reclaim)
-		end_unlink_async (ehci);
-
-	/* something else might have unlinked the qh by now */
-	if (qh->qh_state == QH_STATE_LINKED)
+	/* start IAA cycle */
+	} else
 		start_unlink_async (ehci, qh);
 }
 
@@ -808,13 +884,18 @@
  * completions normally happen asynchronously
  */
 
-static int ehci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
+static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	struct ehci_qh		*qh;
 	unsigned long		flags;
+	int			rc;
 
 	spin_lock_irqsave (&ehci->lock, flags);
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto done;
+
 	switch (usb_pipetype (urb->pipe)) {
 	// case PIPE_CONTROL:
 	// case PIPE_BULK:
@@ -822,7 +903,19 @@
 		qh = (struct ehci_qh *) urb->hcpriv;
 		if (!qh)
 			break;
-		unlink_async (ehci, qh);
+		switch (qh->qh_state) {
+		case QH_STATE_LINKED:
+		case QH_STATE_COMPLETING:
+			unlink_async(ehci, qh);
+			break;
+		case QH_STATE_UNLINK:
+		case QH_STATE_UNLINK_WAIT:
+			/* already started */
+			break;
+		case QH_STATE_IDLE:
+			WARN_ON(1);
+			break;
+		}
 		break;
 
 	case PIPE_INTERRUPT:
@@ -845,18 +938,18 @@
 		/* reschedule QH iff another request is queued */
 		if (!list_empty (&qh->qtd_list)
 				&& HC_IS_RUNNING (hcd->state)) {
-			int status;
-
-			status = qh_schedule (ehci, qh);
-			spin_unlock_irqrestore (&ehci->lock, flags);
+			rc = qh_schedule(ehci, qh);
 
-			if (status != 0) {
-				// shouldn't happen often, but ...
-				// FIXME kill those tds' urbs
-				err ("can't reschedule qh %p, err %d",
-					qh, status);
-			}
-			return status;
+			/* An error here likely indicates handshake failure
+			 * or no space left in the schedule.  Neither fault
+			 * should happen often ...
+			 *
+			 * FIXME kill the now-dysfunctional queued urbs
+			 */
+			if (rc != 0)
+				ehci_err(ehci,
+					"can't reschedule qh %p, err %d",
+					qh, rc);
 		}
 		break;
 
@@ -869,7 +962,7 @@
 	}
 done:
 	spin_unlock_irqrestore (&ehci->lock, flags);
-	return 0;
+	return rc;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -914,6 +1007,7 @@
 		unlink_async (ehci, qh);
 		/* FALL THROUGH */
 	case QH_STATE_UNLINK:		/* wait for hw to finish? */
+	case QH_STATE_UNLINK_WAIT:
 idle_timeout:
 		spin_unlock_irqrestore (&ehci->lock, flags);
 		schedule_timeout_uninterruptible(1);
@@ -949,20 +1043,18 @@
 
 /*-------------------------------------------------------------------------*/
 
-#define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
-
-MODULE_DESCRIPTION (DRIVER_INFO);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_AUTHOR (DRIVER_AUTHOR);
 MODULE_LICENSE ("GPL");
 
 #ifdef CONFIG_PCI
-#ifdef CONFIG_ARCH_SL2312
-#include "ehci-fotg2xx.c"
-#define	PLATFORM_DRIVER		fotg2xx_ehci_driver
-#else
 #include "ehci-pci.c"
 #define	PCI_DRIVER		ehci_pci_driver
 #endif
+
+#ifdef CONFIG_ARCH_GEMINI
+#include "ehci-fotg2xx.c"
+#define PLATFORM_DRIVER		fotg2xx_ehci_driver
 #endif
 
 #ifdef CONFIG_USB_EHCI_FSL
@@ -980,13 +1072,23 @@
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
 #endif
 
-#ifdef CONFIG_440EPX
-#include "ehci-ppc-soc.c"
-#define	PLATFORM_DRIVER		ehci_ppc_soc_driver
+#ifdef CONFIG_USB_EHCI_HCD_PPC_OF
+#include "ehci-ppc-of.c"
+#define OF_PLATFORM_DRIVER	ehci_hcd_ppc_of_driver
+#endif
+
+#ifdef CONFIG_PLAT_ORION
+#include "ehci-orion.c"
+#define	PLATFORM_DRIVER		ehci_orion_driver
+#endif
+
+#ifdef CONFIG_ARCH_IXP4XX
+#include "ehci-ixp4xx.c"
+#define	PLATFORM_DRIVER		ixp4xx_ehci_driver
 #endif
 
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
-    !defined(PS3_SYSTEM_BUS_DRIVER)
+    !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
 #endif
 
@@ -994,46 +1096,85 @@
 {
 	int retval = 0;
 
+	if (usb_disabled())
+		return -ENODEV;
+
+	printk(KERN_INFO "%s: " DRIVER_DESC "\n", hcd_name);
+	set_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
+	if (test_bit(USB_UHCI_LOADED, &usb_hcds_loaded) ||
+			test_bit(USB_OHCI_LOADED, &usb_hcds_loaded))
+		printk(KERN_WARNING "Warning! ehci_hcd should always be loaded"
+				" before uhci_hcd and ohci_hcd, not after\n");
+
 	pr_debug("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
 		 hcd_name,
 		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
 		 sizeof(struct ehci_itd), sizeof(struct ehci_sitd));
 
+#ifdef DEBUG
+	ehci_debug_root = debugfs_create_dir("ehci", NULL);
+	if (!ehci_debug_root) {
+		retval = -ENOENT;
+		goto err_debug;
+	}
+#endif
+
 #ifdef PLATFORM_DRIVER
 	retval = platform_driver_register(&PLATFORM_DRIVER);
 	if (retval < 0)
-		return retval;
+		goto clean0;
 #endif
 
 #ifdef PCI_DRIVER
 	retval = pci_register_driver(&PCI_DRIVER);
-	if (retval < 0) {
-#ifdef PLATFORM_DRIVER
-		platform_driver_unregister(&PLATFORM_DRIVER);
-#endif
-		return retval;
-	}
+	if (retval < 0)
+		goto clean1;
 #endif
 
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	retval = ps3_ehci_driver_register(&PS3_SYSTEM_BUS_DRIVER);
-	if (retval < 0) {
-#ifdef PLATFORM_DRIVER
-		platform_driver_unregister(&PLATFORM_DRIVER);
+	if (retval < 0)
+		goto clean2;
+#endif
+
+#ifdef OF_PLATFORM_DRIVER
+	retval = of_register_platform_driver(&OF_PLATFORM_DRIVER);
+	if (retval < 0)
+		goto clean3;
+#endif
+	return retval;
+
+#ifdef OF_PLATFORM_DRIVER
+	/* of_unregister_platform_driver(&OF_PLATFORM_DRIVER); */
+clean3:
+#endif
+#ifdef PS3_SYSTEM_BUS_DRIVER
+	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
+clean2:
 #endif
 #ifdef PCI_DRIVER
-		pci_unregister_driver(&PCI_DRIVER);
+	pci_unregister_driver(&PCI_DRIVER);
+clean1:
 #endif
-		return retval;
-	}
+#ifdef PLATFORM_DRIVER
+	platform_driver_unregister(&PLATFORM_DRIVER);
+clean0:
 #endif
-
+#ifdef DEBUG
+	debugfs_remove(ehci_debug_root);
+	ehci_debug_root = NULL;
+err_debug:
+#endif
+	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 	return retval;
 }
 module_init(ehci_hcd_init);
 
 static void __exit ehci_hcd_cleanup(void)
 {
+#ifdef OF_PLATFORM_DRIVER
+	of_unregister_platform_driver(&OF_PLATFORM_DRIVER);
+#endif
 #ifdef PLATFORM_DRIVER
 	platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
@@ -1043,6 +1184,10 @@
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
 #endif
+#ifdef DEBUG
+	debugfs_remove(ehci_debug_root);
+#endif
+	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 }
 module_exit(ehci_hcd_cleanup);
 
Files host/ehci-hcd.o and host.new/ehci-hcd.o differ
diff -urN host/ehci-hub.c host.new/ehci-hub.c
--- host/ehci-hub.c	2009-04-09 20:18:46.369626148 +0200
+++ host.new/ehci-hub.c	2009-03-28 17:46:02.000000000 +0100
@@ -28,7 +28,9 @@
 
 /*-------------------------------------------------------------------------*/
 
-#ifdef	CONFIG_USB_PERSIST
+#define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
+
+#ifdef	CONFIG_PM
 
 static int ehci_hub_control(
 	struct usb_hcd	*hcd,
@@ -104,15 +106,6 @@
 	ehci->owned_ports = 0;
 }
 
-#else	/* CONFIG_USB_PERSIST */
-
-static inline void ehci_handover_companion_ports(struct ehci_hcd *ehci)
-{ }
-
-#endif
-
-#ifdef	CONFIG_PM
-
 static int ehci_bus_suspend (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
@@ -123,6 +116,8 @@
 
 	if (time_before (jiffies, ehci->next_statechange))
 		msleep(5);
+	del_timer_sync(&ehci->watchdog);
+	del_timer_sync(&ehci->iaa_watchdog);
 
 	port = HCS_N_PORTS (ehci->hcs_params);
 	spin_lock_irq (&ehci->lock);
@@ -133,8 +128,6 @@
 		hcd->state = HC_STATE_QUIESCING;
 	}
 	ehci->command = ehci_readl(ehci, &ehci->regs->command);
-	if (ehci->reclaim)
-		ehci->reclaim_ready = 1;
 	ehci_work(ehci);
 
 	/* Unlike other USB host controller types, EHCI doesn't have
@@ -158,10 +151,10 @@
 		}
 
 		/* enable remote wakeup on all ports */
-		if (device_may_wakeup(&hcd->self.root_hub->dev))
-			t2 |= PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E;
+		if (hcd->self.root_hub->do_remote_wakeup)
+			t2 |= PORT_WAKE_BITS;
 		else
-			t2 &= ~(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E);
+			t2 &= ~PORT_WAKE_BITS;
 
 		if (t1 != t2) {
 			ehci_vdbg (ehci, "port %d, %08x -> %08x\n",
@@ -170,14 +163,20 @@
 		}
 	}
 
+	/* Apparently some devices need a >= 1-uframe delay here */
+	if (ehci->bus_suspended)
+		udelay(150);
+
 	/* turn off now-idle HC */
-	del_timer_sync (&ehci->watchdog);
 	ehci_halt (ehci);
 	hcd->state = HC_STATE_SUSPENDED;
 
+	if (ehci->reclaim)
+		end_unlink_async(ehci);
+
 	/* allow remote wakeup */
 	mask = INTR_MASK;
-	if (!device_may_wakeup(&hcd->self.root_hub->dev))
+	if (!hcd->self.root_hub->do_remote_wakeup)
 		mask &= ~STS_PCD;
 	ehci_writel(ehci, mask, &ehci->regs->intr_enable);
 	ehci_readl(ehci, &ehci->regs->intr_enable);
@@ -195,6 +194,7 @@
 	u32			temp;
 	u32			power_okay;
 	int			i;
+	u8			resume_needed = 0;
 
 	if (time_before (jiffies, ehci->next_statechange))
 		msleep(5);
@@ -229,23 +229,31 @@
 
 	/* Some controller/firmware combinations need a delay during which
 	 * they set up the port statuses.  See Bugzilla #8190. */
-	mdelay(8);
+	spin_unlock_irq(&ehci->lock);
+	msleep(8);
+	spin_lock_irq(&ehci->lock);
 
 	/* manually resume the ports we suspended during bus_suspend() */
 	i = HCS_N_PORTS (ehci->hcs_params);
 	while (i--) {
 		temp = ehci_readl(ehci, &ehci->regs->port_status [i]);
-		temp &= ~(PORT_RWC_BITS
-			| PORT_WKOC_E | PORT_WKDISC_E | PORT_WKCONN_E);
+		temp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
 		if (test_bit(i, &ehci->bus_suspended) &&
 				(temp & PORT_SUSPEND)) {
-			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
 			temp |= PORT_RESUME;
+			resume_needed = 1;
 		}
 		ehci_writel(ehci, temp, &ehci->regs->port_status [i]);
 	}
+
+	/* msleep for 20ms only if code is trying to resume port */
+	if (resume_needed) {
+		spin_unlock_irq(&ehci->lock);
+		msleep(20);
+		spin_lock_irq(&ehci->lock);
+	}
+
 	i = HCS_N_PORTS (ehci->hcs_params);
-	mdelay (20);
 	while (i--) {
 		temp = ehci_readl(ehci, &ehci->regs->port_status [i]);
 		if (test_bit(i, &ehci->bus_suspended) &&
@@ -275,9 +283,7 @@
 	ehci_writel(ehci, INTR_MASK, &ehci->regs->intr_enable);
 
 	spin_unlock_irq (&ehci->lock);
-
-	if (!power_okay)
-		ehci_handover_companion_ports(ehci);
+	ehci_handover_companion_ports(ehci);
 	return 0;
 }
 
@@ -291,14 +297,16 @@
 /*-------------------------------------------------------------------------*/
 
 /* Display the ports dedicated to the companion controller */
-static ssize_t show_companion(struct class_device *class_dev, char *buf)
+static ssize_t show_companion(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
 {
 	struct ehci_hcd		*ehci;
 	int			nports, index, n;
 	int			count = PAGE_SIZE;
 	char			*ptr = buf;
 
-	ehci = hcd_to_ehci(bus_to_hcd(class_get_devdata(class_dev)));
+	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
 	nports = HCS_N_PORTS(ehci->hcs_params);
 
 	for (index = 0; index < nports; ++index) {
@@ -312,40 +320,21 @@
 }
 
 /*
- * Dedicate or undedicate a port to the companion controller.
- * Syntax is "[-]portnum", where a leading '-' sign means
- * return control of the port to the EHCI controller.
+ * Sets the owner of a port
  */
-static ssize_t store_companion(struct class_device *class_dev,
-		const char *buf, size_t count)
+static void set_owner(struct ehci_hcd *ehci, int portnum, int new_owner)
 {
-	struct ehci_hcd		*ehci;
-	int			portnum, new_owner, try;
 	u32 __iomem		*status_reg;
 	u32			port_status;
+	int 			try;
 
-	ehci = hcd_to_ehci(bus_to_hcd(class_get_devdata(class_dev)));
-	new_owner = PORT_OWNER;		/* Owned by companion */
-	if (sscanf(buf, "%d", &portnum) != 1)
-		return -EINVAL;
-	if (portnum < 0) {
-		portnum = - portnum;
-		new_owner = 0;		/* Owned by EHCI */
-	}
-	if (portnum <= 0 || portnum > HCS_N_PORTS(ehci->hcs_params))
-		return -ENOENT;
-	status_reg = &ehci->regs->port_status[--portnum];
-	if (new_owner)
-		set_bit(portnum, &ehci->companion_ports);
-	else
-		clear_bit(portnum, &ehci->companion_ports);
+	status_reg = &ehci->regs->port_status[portnum];
 
 	/*
 	 * The controller won't set the OWNER bit if the port is
 	 * enabled, so this loop will sometimes require at least two
 	 * iterations: one to disable the port and one to set OWNER.
 	 */
-
 	for (try = 4; try > 0; --try) {
 		spin_lock_irq(&ehci->lock);
 		port_status = ehci_readl(ehci, status_reg);
@@ -362,9 +351,39 @@
 		if (try > 1)
 			msleep(5);
 	}
+}
+
+/*
+ * Dedicate or undedicate a port to the companion controller.
+ * Syntax is "[-]portnum", where a leading '-' sign means
+ * return control of the port to the EHCI controller.
+ */
+static ssize_t store_companion(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct ehci_hcd		*ehci;
+	int			portnum, new_owner;
+
+	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	new_owner = PORT_OWNER;		/* Owned by companion */
+	if (sscanf(buf, "%d", &portnum) != 1)
+		return -EINVAL;
+	if (portnum < 0) {
+		portnum = - portnum;
+		new_owner = 0;		/* Owned by EHCI */
+	}
+	if (portnum <= 0 || portnum > HCS_N_PORTS(ehci->hcs_params))
+		return -ENOENT;
+	portnum--;
+	if (new_owner)
+		set_bit(portnum, &ehci->companion_ports);
+	else
+		clear_bit(portnum, &ehci->companion_ports);
+	set_owner(ehci, portnum, new_owner);
 	return count;
 }
-static CLASS_DEVICE_ATTR(companion, 0644, show_companion, store_companion);
+static DEVICE_ATTR(companion, 0644, show_companion, store_companion);
 
 static inline void create_companion_file(struct ehci_hcd *ehci)
 {
@@ -372,16 +391,16 @@
 
 	/* with integrated TT there is no companion! */
 	if (!ehci_is_TDI(ehci))
-		i = class_device_create_file(ehci_to_hcd(ehci)->self.class_dev,
-				&class_device_attr_companion);
+		i = device_create_file(ehci_to_hcd(ehci)->self.dev,
+				       &dev_attr_companion);
 }
 
 static inline void remove_companion_file(struct ehci_hcd *ehci)
 {
 	/* with integrated TT there is no companion! */
 	if (!ehci_is_TDI(ehci))
-		class_device_remove_file(ehci_to_hcd(ehci)->self.class_dev,
-				&class_device_attr_companion);
+		device_remove_file(ehci_to_hcd(ehci)->self.dev,
+				   &dev_attr_companion);
 }
 
 
@@ -393,12 +412,9 @@
 	u32 __iomem	*status_reg,
 	int		port_status
 ) {
-	if (!(port_status & PORT_CONNECT)) {
-		ehci->reset_done [index] = 0;
+	if (!(port_status & PORT_CONNECT))
 		return port_status;
-	}
 
-#ifndef CONFIG_SL2312_USB
 	/* if reset finished and it's still not enabled -- handoff */
 	if (!(port_status & PORT_PE)) {
 
@@ -418,9 +434,15 @@
 		port_status &= ~PORT_RWC_BITS;
 		ehci_writel(ehci, port_status, status_reg);
 
-	} else
+		/* ensure 440EPX ohci controller state is operational */
+		if (ehci->has_amcc_usb23)
+			set_ohci_hcfs(ehci, 1);
+	} else {
 		ehci_dbg (ehci, "port %d high speed\n", index + 1);
-#endif
+		/* ensure 440EPx ohci controller state is suspended */
+		if (ehci->has_amcc_usb23)
+			set_ohci_hcfs(ehci, 0);
+	}
 
 	return port_status;
 }
@@ -453,7 +475,7 @@
 
 	/* Some boards (mostly VIA?) report bogus overcurrent indications,
 	 * causing massive log spam unless we completely ignore them.  It
-	 * may be relevant that VIA VT8235 controlers, where PORT_POWER is
+	 * may be relevant that VIA VT8235 controllers, where PORT_POWER is
 	 * always set, seem to clear PORT_OCC and PORT_CSC when writing to
 	 * PORT_POWER; that's surprising, but maybe within-spec.
 	 */
@@ -477,12 +499,9 @@
 		 * controller by the user.
 		 */
 
-		if (!(temp & PORT_CONNECT))
-			ehci->reset_done [i] = 0;
-		if ((temp & mask) != 0
-				|| ((temp & PORT_RESUME) != 0
-					&& time_after_eq(jiffies,
-						ehci->reset_done[i]))) {
+		if ((temp & mask) != 0 || test_bit(i, &ehci->port_c_suspend)
+				|| (ehci->reset_done[i] && time_after_eq(
+					jiffies, ehci->reset_done[i]))) {
 			if (i < 7)
 			    buf [0] |= 1 << (i + 1);
 			else
@@ -527,13 +546,11 @@
 	if (HCS_INDICATOR (ehci->hcs_params))
 		temp |= 0x0080;		/* per-port indicators (LEDs) */
 #endif
-	desc->wHubCharacteristics = (__force __u16)cpu_to_le16 (temp);
+	desc->wHubCharacteristics = cpu_to_le16(temp);
 }
 
 /*-------------------------------------------------------------------------*/
 
-#define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
-
 static int ehci_hub_control (
 	struct usb_hcd	*hcd,
 	u16		typeReq,
@@ -608,7 +625,7 @@
 			}
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
-			/* we auto-clear this feature */
+			clear_bit(wIndex, &ehci->port_c_suspend);
 			break;
 		case USB_PORT_FEAT_POWER:
 			if (HCS_PPC (ehci->hcs_params))
@@ -687,7 +704,8 @@
 			/* resume completed? */
 			else if (time_after_eq(jiffies,
 					ehci->reset_done[wIndex])) {
-				status |= 1 << USB_PORT_FEAT_C_SUSPEND;
+				clear_bit(wIndex, &ehci->suspended_ports);
+				set_bit(wIndex, &ehci->port_c_suspend);
 				ehci->reset_done[wIndex] = 0;
 
 				/* stop resume signaling */
@@ -731,15 +749,17 @@
 			/* see what we found out */
 			temp = check_reset_complete (ehci, wIndex, status_reg,
 					ehci_readl(ehci, status_reg));
-#ifdef CONFIG_SL2312_USB
+#ifdef CONFIG_ARCH_GEMINI
 			/* restart schedule */
-			ehci_writel(ehci, ehci_readl(ehci, &ehci->regs->command)|(CMD_RUN),&ehci->regs->command);
+			ehci_writel(ehci, ehci_readl(ehci, &ehci->regs->command) | CMD_RUN, &ehci->regs->command);
 
 //			hcd->state = HC_STATE_RUNNING;
-
 #endif
 		}
 
+		if (!(temp & (PORT_RESUME|PORT_RESET)))
+			ehci->reset_done[wIndex] = 0;
+
 		/* transfer dedicated ports to the companion hc */
 		if ((temp & PORT_CONNECT) &&
 				test_bit(wIndex, &ehci->companion_ports)) {
@@ -761,23 +781,33 @@
 			// status may be from integrated TT
 			status |= ehci_port_speed(ehci, temp);
 		}
-
 		if (temp & PORT_PE)
 			status |= 1 << USB_PORT_FEAT_ENABLE;
-		if (temp & (PORT_SUSPEND|PORT_RESUME))
+
+		/* maybe the port was unsuspended without our knowledge */
+		if (temp & (PORT_SUSPEND|PORT_RESUME)) {
 			status |= 1 << USB_PORT_FEAT_SUSPEND;
+		} else if (test_bit(wIndex, &ehci->suspended_ports)) {
+			clear_bit(wIndex, &ehci->suspended_ports);
+			ehci->reset_done[wIndex] = 0;
+			if (temp & PORT_PE)
+				set_bit(wIndex, &ehci->port_c_suspend);
+		}
+
 		if (temp & PORT_OC)
 			status |= 1 << USB_PORT_FEAT_OVER_CURRENT;
 		if (temp & PORT_RESET)
 			status |= 1 << USB_PORT_FEAT_RESET;
 		if (temp & PORT_POWER)
 			status |= 1 << USB_PORT_FEAT_POWER;
+		if (test_bit(wIndex, &ehci->port_c_suspend))
+			status |= 1 << USB_PORT_FEAT_C_SUSPEND;
 
-#ifndef	EHCI_VERBOSE_DEBUG
+#ifndef	VERBOSE_DEBUG
 	if (status & ~0xffff)	/* only if wPortChange is interesting */
 #endif
 		dbg_port (ehci, "GetStatus", wIndex + 1, temp);
-		put_unaligned(cpu_to_le32 (status), (__le32 *) buf);
+		put_unaligned_le32(status, buf);
 		break;
 	case SetHubFeature:
 		switch (wValue) {
@@ -807,9 +837,8 @@
 			if ((temp & PORT_PE) == 0
 					|| (temp & PORT_RESET) != 0)
 				goto error;
-			if (device_may_wakeup(&hcd->self.root_hub->dev))
-				temp |= PORT_WAKE_BITS;
 			ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
+			set_bit(wIndex, &ehci->suspended_ports);
 			break;
 		case USB_PORT_FEAT_POWER:
 			if (HCS_PPC (ehci->hcs_params))
@@ -830,8 +859,7 @@
 					"port %d low speed --> companion\n",
 					wIndex + 1);
 				temp |= PORT_OWNER;
-			} else
-			{
+			} else {
 				ehci_vdbg (ehci, "port %d reset\n", wIndex + 1);
 				temp |= PORT_RESET;
 				temp &= ~PORT_PE;
@@ -875,3 +903,23 @@
 	spin_unlock_irqrestore (&ehci->lock, flags);
 	return retval;
 }
+
+static void ehci_relinquish_port(struct usb_hcd *hcd, int portnum)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+
+	if (ehci_is_TDI(ehci))
+		return;
+	set_owner(ehci, --portnum, PORT_OWNER);
+}
+
+static int ehci_port_handed_over(struct usb_hcd *hcd, int portnum)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+	u32 __iomem		*reg;
+
+	if (ehci_is_TDI(ehci))
+		return 0;
+	reg = &ehci->regs->port_status[portnum - 1];
+	return ehci_readl(ehci, reg) & PORT_OWNER;
+}
diff -urN host/ehci-ixp4xx.c host.new/ehci-ixp4xx.c
--- host/ehci-ixp4xx.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/ehci-ixp4xx.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,153 @@
+/*
+ * IXP4XX EHCI Host Controller Driver
+ *
+ * Author: Vladimir Barinov <vbarinov@embeddedalley.com>
+ *
+ * Based on "ehci-fsl.c" by Randy Vinson <rvinson@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/platform_device.h>
+
+static int ixp4xx_ehci_init(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval = 0;
+
+	ehci->big_endian_desc = 1;
+	ehci->big_endian_mmio = 1;
+
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100
+		+ HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	hcd->has_tt = 1;
+	ehci_reset(ehci);
+
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	ehci_port_power(ehci, 0);
+
+	return retval;
+}
+
+static const struct hc_driver ixp4xx_ehci_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "IXP4XX EHCI Host Controller",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+	.reset			= ixp4xx_ehci_init,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+	.get_frame_number	= ehci_get_frame,
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+#if defined(CONFIG_PM)
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+#endif
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
+};
+
+static int ixp4xx_ehci_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd;
+	const struct hc_driver *driver = &ixp4xx_ehci_hc_driver;
+	struct resource *res;
+	int irq;
+	int retval;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no IRQ. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	irq = res->start;
+
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto fail_create_hcd;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no register addr. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		retval = -ENODEV;
+		goto fail_request_resource;
+	}
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = res->end - res->start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
+				driver->description)) {
+		dev_dbg(&pdev->dev, "controller already in use\n");
+		retval = -EBUSY;
+		goto fail_request_resource;
+	}
+
+	hcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);
+	if (hcd->regs == NULL) {
+		dev_dbg(&pdev->dev, "error mapping memory\n");
+		retval = -EFAULT;
+		goto fail_ioremap;
+	}
+
+	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (retval)
+		goto fail_add_hcd;
+
+	return retval;
+
+fail_add_hcd:
+	iounmap(hcd->regs);
+fail_ioremap:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+fail_request_resource:
+	usb_put_hcd(hcd);
+fail_create_hcd:
+	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), retval);
+	return retval;
+}
+
+static int ixp4xx_ehci_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+MODULE_ALIAS("platform:ixp4xx-ehci");
+
+static struct platform_driver ixp4xx_ehci_driver = {
+	.probe = ixp4xx_ehci_probe,
+	.remove = ixp4xx_ehci_remove,
+	.driver = {
+		.name = "ixp4xx-ehci",
+	},
+};
diff -urN host/ehci-mem.c host.new/ehci-mem.c
--- host/ehci-mem.c	2009-02-24 19:00:15.279976552 +0100
+++ host.new/ehci-mem.c	2009-03-28 17:46:02.000000000 +0100
@@ -128,6 +128,7 @@
 
 static void ehci_mem_cleanup (struct ehci_hcd *ehci)
 {
+	free_cached_itd_list(ehci);
 	if (ehci->async)
 		qh_put (ehci->async);
 	ehci->async = NULL;
diff -urN host/ehci-orion.c host.new/ehci-orion.c
--- host/ehci-orion.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/ehci-orion.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,314 @@
+/*
+ * drivers/usb/host/ehci-orion.c
+ *
+ * Tzachi Perelstein <tzachi@marvell.com>
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/mbus.h>
+#include <plat/ehci-orion.h>
+
+#define rdl(off)	__raw_readl(hcd->regs + (off))
+#define wrl(off, val)	__raw_writel((val), hcd->regs + (off))
+
+#define USB_CMD			0x140
+#define USB_MODE		0x1a8
+#define USB_CAUSE		0x310
+#define USB_MASK		0x314
+#define USB_WINDOW_CTRL(i)	(0x320 + ((i) << 4))
+#define USB_WINDOW_BASE(i)	(0x324 + ((i) << 4))
+#define USB_IPG			0x360
+#define USB_PHY_PWR_CTRL	0x400
+#define USB_PHY_TX_CTRL		0x420
+#define USB_PHY_RX_CTRL		0x430
+#define USB_PHY_IVREF_CTRL	0x440
+#define USB_PHY_TST_GRP_CTRL	0x450
+
+/*
+ * Implement Orion USB controller specification guidelines
+ */
+static void orion_usb_phy_v1_setup(struct usb_hcd *hcd)
+{
+	/* The below GLs are according to the Orion Errata document */
+	/*
+	 * Clear interrupt cause and mask
+	 */
+	wrl(USB_CAUSE, 0);
+	wrl(USB_MASK, 0);
+
+	/*
+	 * Reset controller
+	 */
+	wrl(USB_CMD, rdl(USB_CMD) | 0x2);
+	while (rdl(USB_CMD) & 0x2);
+
+	/*
+	 * GL# USB-10: Set IPG for non start of frame packets
+	 * Bits[14:8]=0xc
+	 */
+	wrl(USB_IPG, (rdl(USB_IPG) & ~0x7f00) | 0xc00);
+
+	/*
+	 * GL# USB-9: USB 2.0 Power Control
+	 * BG_VSEL[7:6]=0x1
+	 */
+	wrl(USB_PHY_PWR_CTRL, (rdl(USB_PHY_PWR_CTRL) & ~0xc0)| 0x40);
+
+	/*
+	 * GL# USB-1: USB PHY Tx Control - force calibration to '8'
+	 * TXDATA_BLOCK_EN[21]=0x1, EXT_RCAL_EN[13]=0x1, IMP_CAL[6:3]=0x8
+	 */
+	wrl(USB_PHY_TX_CTRL, (rdl(USB_PHY_TX_CTRL) & ~0x78) | 0x202040);
+
+	/*
+	 * GL# USB-3 GL# USB-9: USB PHY Rx Control
+	 * RXDATA_BLOCK_LENGHT[31:30]=0x3, EDGE_DET_SEL[27:26]=0,
+	 * CDR_FASTLOCK_EN[21]=0, DISCON_THRESHOLD[9:8]=0, SQ_THRESH[7:4]=0x1
+	 */
+	wrl(USB_PHY_RX_CTRL, (rdl(USB_PHY_RX_CTRL) & ~0xc2003f0) | 0xc0000010);
+
+	/*
+	 * GL# USB-3 GL# USB-9: USB PHY IVREF Control
+	 * PLLVDD12[1:0]=0x2, RXVDD[5:4]=0x3, Reserved[19]=0
+	 */
+	wrl(USB_PHY_IVREF_CTRL, (rdl(USB_PHY_IVREF_CTRL) & ~0x80003 ) | 0x32);
+
+	/*
+	 * GL# USB-3 GL# USB-9: USB PHY Test Group Control
+	 * REG_FIFO_SQ_RST[15]=0
+	 */
+	wrl(USB_PHY_TST_GRP_CTRL, rdl(USB_PHY_TST_GRP_CTRL) & ~0x8000);
+
+	/*
+	 * Stop and reset controller
+	 */
+	wrl(USB_CMD, rdl(USB_CMD) & ~0x1);
+	wrl(USB_CMD, rdl(USB_CMD) | 0x2);
+	while (rdl(USB_CMD) & 0x2);
+
+	/*
+	 * GL# USB-5 Streaming disable REG_USB_MODE[4]=1
+	 * TBD: This need to be done after each reset!
+	 * GL# USB-4 Setup USB Host mode
+	 */
+	wrl(USB_MODE, 0x13);
+}
+
+static int ehci_orion_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	/*
+	 * data structure init
+	 */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	hcd->has_tt = 1;
+
+	ehci_reset(ehci);
+	ehci_port_power(ehci, 0);
+
+	return retval;
+}
+
+static const struct hc_driver ehci_orion_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "Marvell Orion EHCI",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = ehci_irq,
+	.flags = HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset = ehci_orion_setup,
+	.start = ehci_run,
+	.stop = ehci_stop,
+	.shutdown = ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+};
+
+static void __init
+ehci_orion_conf_mbus_windows(struct usb_hcd *hcd,
+				struct mbus_dram_target_info *dram)
+{
+	int i;
+
+	for (i = 0; i < 4; i++) {
+		wrl(USB_WINDOW_CTRL(i), 0);
+		wrl(USB_WINDOW_BASE(i), 0);
+	}
+
+	for (i = 0; i < dram->num_cs; i++) {
+		struct mbus_dram_window *cs = dram->cs + i;
+
+		wrl(USB_WINDOW_CTRL(i), ((cs->size - 1) & 0xffff0000) |
+					(cs->mbus_attr << 8) |
+					(dram->mbus_dram_target_id << 4) | 1);
+		wrl(USB_WINDOW_BASE(i), cs->base);
+	}
+}
+
+static int __init ehci_orion_drv_probe(struct platform_device *pdev)
+{
+	struct orion_ehci_data *pd = pdev->dev.platform_data;
+	struct resource *res;
+	struct usb_hcd *hcd;
+	struct ehci_hcd *ehci;
+	void __iomem *regs;
+	int irq, err;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	pr_debug("Initializing Orion-SoC USB Host Controller\n");
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		dev_err(&pdev->dev,
+			"Found HC with no IRQ. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		err = -ENODEV;
+		goto err1;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no register addr. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		err = -ENODEV;
+		goto err1;
+	}
+
+	if (!request_mem_region(res->start, res->end - res->start + 1,
+				ehci_orion_hc_driver.description)) {
+		dev_dbg(&pdev->dev, "controller already in use\n");
+		err = -EBUSY;
+		goto err1;
+	}
+
+	regs = ioremap(res->start, res->end - res->start + 1);
+	if (regs == NULL) {
+		dev_dbg(&pdev->dev, "error mapping memory\n");
+		err = -EFAULT;
+		goto err2;
+	}
+
+	hcd = usb_create_hcd(&ehci_orion_hc_driver,
+			&pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		err = -ENOMEM;
+		goto err3;
+	}
+
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = res->end - res->start + 1;
+	hcd->regs = regs;
+
+	ehci = hcd_to_ehci(hcd);
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100 +
+		HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+	hcd->has_tt = 1;
+	ehci->sbrn = 0x20;
+
+	/*
+	 * (Re-)program MBUS remapping windows if we are asked to.
+	 */
+	if (pd != NULL && pd->dram != NULL)
+		ehci_orion_conf_mbus_windows(hcd, pd->dram);
+
+	/*
+	 * setup Orion USB controller.
+	 */
+	switch (pd->phy_version) {
+	case EHCI_PHY_NA:	/* dont change USB phy settings */
+		break;
+	case EHCI_PHY_ORION:
+		orion_usb_phy_v1_setup(hcd);
+		break;
+	case EHCI_PHY_DD:
+	case EHCI_PHY_KW:
+	default:
+		printk(KERN_WARNING "Orion ehci -USB phy version isn't supported.\n");
+	}
+
+	err = usb_add_hcd(hcd, irq, IRQF_SHARED | IRQF_DISABLED);
+	if (err)
+		goto err4;
+
+	return 0;
+
+err4:
+	usb_put_hcd(hcd);
+err3:
+	iounmap(regs);
+err2:
+	release_mem_region(res->start, res->end - res->start + 1);
+err1:
+	dev_err(&pdev->dev, "init %s fail, %d\n",
+		dev_name(&pdev->dev), err);
+
+	return err;
+}
+
+static int __exit ehci_orion_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+MODULE_ALIAS("platform:orion-ehci");
+
+static struct platform_driver ehci_orion_driver = {
+	.probe		= ehci_orion_drv_probe,
+	.remove		= __exit_p(ehci_orion_drv_remove),
+	.shutdown	= usb_hcd_platform_shutdown,
+	.driver.name	= "orion-ehci",
+};
diff -urN host/ehci-pci.c host.new/ehci-pci.c
--- host/ehci-pci.c	2009-02-24 19:00:15.283976348 +0100
+++ host.new/ehci-pci.c	2009-03-28 17:46:02.000000000 +0100
@@ -58,8 +58,6 @@
 	if (!retval)
 		ehci_dbg(ehci, "MWI active\n");
 
-	ehci_port_power(ehci, 0);
-
 	return 0;
 }
 
@@ -68,6 +66,8 @@
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	struct pci_dev		*pdev = to_pci_dev(hcd->self.controller);
+	struct pci_dev		*p_smbus;
+	u8			rev;
 	u32			temp;
 	int			retval;
 
@@ -131,7 +131,7 @@
 	switch (pdev->vendor) {
 	case PCI_VENDOR_ID_TDI:
 		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI) {
-			ehci->is_tdi_rh_tt = 1;
+			hcd->has_tt = 1;
 			tdi_reset(ehci);
 		}
 		break;
@@ -154,10 +154,45 @@
 			break;
 		}
 		break;
+	case PCI_VENDOR_ID_VIA:
+		if (pdev->device == 0x3104 && (pdev->revision & 0xf0) == 0x60) {
+			u8 tmp;
+
+			/* The VT6212 defaults to a 1 usec EHCI sleep time which
+			 * hogs the PCI bus *badly*. Setting bit 5 of 0x4B makes
+			 * that sleep time use the conventional 10 usec.
+			 */
+			pci_read_config_byte(pdev, 0x4b, &tmp);
+			if (tmp & 0x20)
+				break;
+			pci_write_config_byte(pdev, 0x4b, tmp | 0x20);
+		}
+		break;
+	case PCI_VENDOR_ID_ATI:
+		/* SB600 and old version of SB700 have a bug in EHCI controller,
+		 * which causes usb devices lose response in some cases.
+		 */
+		if ((pdev->device == 0x4386) || (pdev->device == 0x4396)) {
+			p_smbus = pci_get_device(PCI_VENDOR_ID_ATI,
+						 PCI_DEVICE_ID_ATI_SBX00_SMBUS,
+						 NULL);
+			if (!p_smbus)
+				break;
+			rev = p_smbus->revision;
+			if ((pdev->device == 0x4386) || (rev == 0x3a)
+			    || (rev == 0x3b)) {
+				u8 tmp;
+				ehci_info(ehci, "applying AMD SB600/SB700 USB "
+					"freeze workaround\n");
+				pci_read_config_byte(pdev, 0x53, &tmp);
+				pci_write_config_byte(pdev, 0x53, tmp | (1<<3));
+			}
+			pci_dev_put(p_smbus);
+		}
+		break;
 	}
 
-	if (ehci_is_TDI(ehci))
-		ehci_reset(ehci);
+	ehci_reset(ehci);
 
 	/* at least the Genesys GL880S needs fixup here */
 	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
@@ -184,15 +219,19 @@
 	/* Serial Bus Release Number is at PCI 0x60 offset */
 	pci_read_config_byte(pdev, 0x60, &ehci->sbrn);
 
-	/* Workaround current PCI init glitch:  wakeup bits aren't
-	 * being set from PCI PM capability.
+	/* Keep this around for a while just in case some EHCI
+	 * implementation uses legacy PCI PM support.  This test
+	 * can be removed on 17 Dec 2009 if the dev_warn() hasn't
+	 * been triggered by then.
 	 */
 	if (!device_can_wakeup(&pdev->dev)) {
 		u16	port_wake;
 
 		pci_read_config_word(pdev, 0x62, &port_wake);
-		if (port_wake & 0x0001)
-			device_init_wakeup(&pdev->dev, 1);
+		if (port_wake & 0x0001) {
+			dev_warn(&pdev->dev, "Enabling legacy PCI PM\n");
+			device_set_wakeup_capable(&pdev->dev, 1);
+		}
 	}
 
 #ifdef	CONFIG_USB_SUSPEND
@@ -210,6 +249,7 @@
 		ehci_warn(ehci, "selective suspend/wakeup unavailable\n");
 #endif
 
+	ehci_port_power(ehci, 1);
 	retval = ehci_pci_reinit(ehci, pdev);
 done:
 	return retval;
@@ -288,7 +328,7 @@
 	if (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF) {
 		int	mask = INTR_MASK;
 
-		if (!device_may_wakeup(&hcd->self.root_hub->dev))
+		if (!hcd->self.root_hub->do_remote_wakeup)
 			mask &= ~STS_PCD;
 		ehci_writel(ehci, mask, &ehci->regs->intr_enable);
 		ehci_readl(ehci, &ehci->regs->intr_enable);
@@ -308,7 +348,7 @@
 	/* emptying the schedule aborts any urbs */
 	spin_lock_irq(&ehci->lock);
 	if (ehci->reclaim)
-		ehci->reclaim_ready = 1;
+		end_unlink_async(ehci);
 	ehci_work(ehci);
 	spin_unlock_irq(&ehci->lock);
 
@@ -318,7 +358,6 @@
 
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
-	ehci_handover_companion_ports(ehci);
 
 	hcd->state = HC_STATE_SUSPENDED;
 	return 0;
@@ -342,8 +381,8 @@
 	.reset =		ehci_pci_setup,
 	.start =		ehci_run,
 #ifdef	CONFIG_PM
-	.suspend =		ehci_pci_suspend,
-	.resume =		ehci_pci_resume,
+	.pci_suspend =		ehci_pci_suspend,
+	.pci_resume =		ehci_pci_resume,
 #endif
 	.stop =			ehci_stop,
 	.shutdown =		ehci_shutdown,
@@ -367,6 +406,8 @@
 	.hub_control =		ehci_hub_control,
 	.bus_suspend =		ehci_bus_suspend,
 	.bus_resume =		ehci_bus_resume,
+	.relinquish_port =	ehci_relinquish_port,
+	.port_handed_over =	ehci_port_handed_over,
 };
 
 /*-------------------------------------------------------------------------*/
diff -urN host/ehci-ppc-of.c host.new/ehci-ppc-of.c
--- host/ehci-ppc-of.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/ehci-ppc-of.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,283 @@
+/*
+ * EHCI HCD (Host Controller Driver) for USB.
+ *
+ * Bus Glue for PPC On-Chip EHCI driver on the of_platform bus
+ * Tested on AMCC PPC 440EPx
+ *
+ * Valentine Barshak <vbarshak@ru.mvista.com>
+ *
+ * Based on "ehci-ppc-soc.c" by Stefan Roese <sr@denx.de>
+ * and "ohci-ppc-of.c" by Sylvain Munaut <tnt@246tNt.com>
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/signal.h>
+
+#include <linux/of.h>
+#include <linux/of_platform.h>
+
+/* called during probe() after chip reset completes */
+static int ehci_ppc_of_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
+	int		retval;
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	ehci->sbrn = 0x20;
+	return ehci_reset(ehci);
+}
+
+
+static const struct hc_driver ehci_ppc_of_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "OF EHCI",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset			= ehci_ppc_of_setup,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+#endif
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
+};
+
+
+/*
+ * 440EPx Errata USBH_3
+ * Fix: Enable Break Memory Transfer (BMT) in INSNREG3
+ */
+#define PPC440EPX_EHCI0_INSREG_BMT	(0x1 << 0)
+static int __devinit
+ppc44x_enable_bmt(struct device_node *dn)
+{
+	__iomem u32 *insreg_virt;
+
+	insreg_virt = of_iomap(dn, 1);
+	if (!insreg_virt)
+		return  -EINVAL;
+
+	out_be32(insreg_virt + 3, PPC440EPX_EHCI0_INSREG_BMT);
+
+	iounmap(insreg_virt);
+	return 0;
+}
+
+
+static int __devinit
+ehci_hcd_ppc_of_probe(struct of_device *op, const struct of_device_id *match)
+{
+	struct device_node *dn = op->node;
+	struct usb_hcd *hcd;
+	struct ehci_hcd	*ehci = NULL;
+	struct resource res;
+	int irq;
+	int rv;
+
+	struct device_node *np;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	dev_dbg(&op->dev, "initializing PPC-OF USB Controller\n");
+
+	rv = of_address_to_resource(dn, 0, &res);
+	if (rv)
+		return rv;
+
+	hcd = usb_create_hcd(&ehci_ppc_of_hc_driver, &op->dev, "PPC-OF USB");
+	if (!hcd)
+		return -ENOMEM;
+
+	hcd->rsrc_start = res.start;
+	hcd->rsrc_len = res.end - res.start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		printk(KERN_ERR __FILE__ ": request_mem_region failed\n");
+		rv = -EBUSY;
+		goto err_rmr;
+	}
+
+	irq = irq_of_parse_and_map(dn, 0);
+	if (irq == NO_IRQ) {
+		printk(KERN_ERR __FILE__ ": irq_of_parse_and_map failed\n");
+		rv = -EBUSY;
+		goto err_irq;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		printk(KERN_ERR __FILE__ ": ioremap failed\n");
+		rv = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	ehci = hcd_to_ehci(hcd);
+	np = of_find_compatible_node(NULL, NULL, "ibm,usb-ohci-440epx");
+	if (np != NULL) {
+		/* claim we really affected by usb23 erratum */
+		if (!of_address_to_resource(np, 0, &res))
+			ehci->ohci_hcctrl_reg = ioremap(res.start +
+					OHCI_HCCTRL_OFFSET, OHCI_HCCTRL_LEN);
+		else
+			pr_debug(__FILE__ ": no ohci offset in fdt\n");
+		if (!ehci->ohci_hcctrl_reg) {
+			pr_debug(__FILE__ ": ioremap for ohci hcctrl failed\n");
+		} else {
+			ehci->has_amcc_usb23 = 1;
+		}
+	}
+
+	if (of_get_property(dn, "big-endian", NULL)) {
+		ehci->big_endian_mmio = 1;
+		ehci->big_endian_desc = 1;
+	}
+	if (of_get_property(dn, "big-endian-regs", NULL))
+		ehci->big_endian_mmio = 1;
+	if (of_get_property(dn, "big-endian-desc", NULL))
+		ehci->big_endian_desc = 1;
+
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs +
+			HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	if (of_device_is_compatible(dn, "ibm,usb-ehci-440epx")) {
+		rv = ppc44x_enable_bmt(dn);
+		ehci_dbg(ehci, "Break Memory Transfer (BMT) is %senabled!\n",
+				rv ? "NOT ": "");
+	}
+
+	rv = usb_add_hcd(hcd, irq, 0);
+	if (rv == 0)
+		return 0;
+
+	iounmap(hcd->regs);
+err_ioremap:
+	irq_dispose_mapping(irq);
+err_irq:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+
+	if (ehci->has_amcc_usb23)
+		iounmap(ehci->ohci_hcctrl_reg);
+err_rmr:
+	usb_put_hcd(hcd);
+
+	return rv;
+}
+
+
+static int ehci_hcd_ppc_of_remove(struct of_device *op)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(&op->dev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	struct device_node *np;
+	struct resource res;
+
+	dev_set_drvdata(&op->dev, NULL);
+
+	dev_dbg(&op->dev, "stopping PPC-OF USB Controller\n");
+
+	usb_remove_hcd(hcd);
+
+	iounmap(hcd->regs);
+	irq_dispose_mapping(hcd->irq);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+
+	/* use request_mem_region to test if the ohci driver is loaded.  if so
+	 * ensure the ohci core is operational.
+	 */
+	if (ehci->has_amcc_usb23) {
+		np = of_find_compatible_node(NULL, NULL, "ibm,usb-ohci-440epx");
+		if (np != NULL) {
+			if (!of_address_to_resource(np, 0, &res))
+				if (!request_mem_region(res.start,
+							    0x4, hcd_name))
+					set_ohci_hcfs(ehci, 1);
+				else
+					release_mem_region(res.start, 0x4);
+			else
+				pr_debug(__FILE__ ": no ohci offset in fdt\n");
+			of_node_put(np);
+		}
+
+		iounmap(ehci->ohci_hcctrl_reg);
+	}
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+
+static int ehci_hcd_ppc_of_shutdown(struct of_device *op)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(&op->dev);
+
+	if (hcd->driver->shutdown)
+		hcd->driver->shutdown(hcd);
+
+	return 0;
+}
+
+
+static struct of_device_id ehci_hcd_ppc_of_match[] = {
+	{
+		.compatible = "usb-ehci",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, ehci_hcd_ppc_of_match);
+
+
+static struct of_platform_driver ehci_hcd_ppc_of_driver = {
+	.name		= "ppc-of-ehci",
+	.match_table	= ehci_hcd_ppc_of_match,
+	.probe		= ehci_hcd_ppc_of_probe,
+	.remove		= ehci_hcd_ppc_of_remove,
+	.shutdown	= ehci_hcd_ppc_of_shutdown,
+	.driver		= {
+		.name	= "ppc-of-ehci",
+		.owner	= THIS_MODULE,
+	},
+};
diff -urN host/ehci-ppc-soc.c host.new/ehci-ppc-soc.c
--- host/ehci-ppc-soc.c	2009-02-24 19:00:15.287976145 +0100
+++ host.new/ehci-ppc-soc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,200 +0,0 @@
-/*
- * EHCI HCD (Host Controller Driver) for USB.
- *
- * (C) Copyright 2006-2007 Stefan Roese <sr@denx.de>, DENX Software Engineering
- *
- * Bus Glue for PPC On-Chip EHCI driver
- * Tested on AMCC 440EPx
- *
- * Based on "ehci-au1xxx.c" by K.Boge <karsten.boge@amd.com>
- *
- * This file is licenced under the GPL.
- */
-
-#include <linux/platform_device.h>
-
-extern int usb_disabled(void);
-
-/* called during probe() after chip reset completes */
-static int ehci_ppc_soc_setup(struct usb_hcd *hcd)
-{
-	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
-	int		retval;
-
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
-
-	retval = ehci_init(hcd);
-	if (retval)
-		return retval;
-
-	ehci->sbrn = 0x20;
-	return ehci_reset(ehci);
-}
-
-/**
- * usb_ehci_ppc_soc_probe - initialize PPC-SoC-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- *
- */
-int usb_ehci_ppc_soc_probe(const struct hc_driver *driver,
-			   struct usb_hcd **hcd_out,
-			   struct platform_device *dev)
-{
-	int retval;
-	struct usb_hcd *hcd;
-	struct ehci_hcd *ehci;
-
-	if (dev->resource[1].flags != IORESOURCE_IRQ) {
-		pr_debug("resource[1] is not IORESOURCE_IRQ");
-		retval = -ENOMEM;
-	}
-	hcd = usb_create_hcd(driver, &dev->dev, "PPC-SOC EHCI");
-	if (!hcd)
-		return -ENOMEM;
-	hcd->rsrc_start = dev->resource[0].start;
-	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		pr_debug("request_mem_region failed");
-		retval = -EBUSY;
-		goto err1;
-	}
-
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-	if (!hcd->regs) {
-		pr_debug("ioremap failed");
-		retval = -ENOMEM;
-		goto err2;
-	}
-
-	ehci = hcd_to_ehci(hcd);
-	ehci->big_endian_mmio = 1;
-	ehci->big_endian_desc = 1;
-	ehci->caps = hcd->regs;
-	ehci->regs = hcd->regs + HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
-
-	/* cache this readonly data; minimize chip reads */
-	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
-
-#if defined(CONFIG_440EPX)
-	/*
-	 * 440EPx Errata USBH_3
-	 * Fix: Enable Break Memory Transfer (BMT) in INSNREG3
-	 */
-	out_be32((void *)((ulong)(&ehci->regs->command) + 0x8c), (1 << 0));
-	ehci_dbg(ehci, "Break Memory Transfer (BMT) has beed enabled!\n");
-#endif
-
-	retval = usb_add_hcd(hcd, dev->resource[1].start, IRQF_DISABLED);
-	if (retval == 0)
-		return retval;
-
-	iounmap(hcd->regs);
-err2:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-err1:
-	usb_put_hcd(hcd);
-	return retval;
-}
-
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_ehci_hcd_ppc_soc_remove - shutdown processing for PPC-SoC-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_ehci_hcd_ppc_soc_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
- */
-void usb_ehci_ppc_soc_remove(struct usb_hcd *hcd, struct platform_device *dev)
-{
-	usb_remove_hcd(hcd);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
-}
-
-static const struct hc_driver ehci_ppc_soc_hc_driver = {
-	.description = hcd_name,
-	.product_desc = "PPC-SOC EHCI",
-	.hcd_priv_size = sizeof(struct ehci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq = ehci_irq,
-	.flags = HCD_MEMORY | HCD_USB2,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset = ehci_ppc_soc_setup,
-	.start = ehci_run,
-	.stop = ehci_stop,
-	.shutdown = ehci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue = ehci_urb_enqueue,
-	.urb_dequeue = ehci_urb_dequeue,
-	.endpoint_disable = ehci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number = ehci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data = ehci_hub_status_data,
-	.hub_control = ehci_hub_control,
-#ifdef	CONFIG_PM
-	.hub_suspend = ehci_hub_suspend,
-	.hub_resume = ehci_hub_resume,
-#endif
-};
-
-static int ehci_hcd_ppc_soc_drv_probe(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = NULL;
-	int ret;
-
-	pr_debug("In ehci_hcd_ppc_soc_drv_probe\n");
-
-	if (usb_disabled())
-		return -ENODEV;
-
-	ret = usb_ehci_ppc_soc_probe(&ehci_ppc_soc_hc_driver, &hcd, pdev);
-	return ret;
-}
-
-static int ehci_hcd_ppc_soc_drv_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	usb_ehci_ppc_soc_remove(hcd, pdev);
-	return 0;
-}
-
-MODULE_ALIAS("ppc-soc-ehci");
-static struct platform_driver ehci_ppc_soc_driver = {
-	.probe = ehci_hcd_ppc_soc_drv_probe,
-	.remove = ehci_hcd_ppc_soc_drv_remove,
-	.shutdown = usb_hcd_platform_shutdown,
-	.driver = {
-		.name = "ppc-soc-ehci",
-		.bus = &platform_bus_type
-	}
-};
diff -urN host/ehci-ps3.c host.new/ehci-ps3.c
--- host/ehci-ps3.c	2009-02-24 19:00:15.287976145 +0100
+++ host.new/ehci-ps3.c	2009-03-28 17:46:02.000000000 +0100
@@ -47,7 +47,7 @@
 	if (result)
 		return result;
 
-	ehci_port_power(ehci, 0);
+	ehci_reset(ehci);
 
 	return result;
 }
@@ -72,6 +72,8 @@
 	.bus_suspend		= ehci_bus_suspend,
 	.bus_resume		= ehci_bus_resume,
 #endif
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
 };
 
 static int ps3_ehci_probe(struct ps3_system_bus_device *dev)
@@ -124,10 +126,9 @@
 		goto fail_irq;
 	}
 
-	dev->core.power.power_state = PMSG_ON;
 	dev->core.dma_mask = &dummy_mask; /* FIXME: for improper usb code */
 
-	hcd = usb_create_hcd(&ps3_ehci_hc_driver, &dev->core, dev->core.bus_id);
+	hcd = usb_create_hcd(&ps3_ehci_hc_driver, &dev->core, dev_name(&dev->core));
 
 	if (!hcd) {
 		dev_dbg(&dev->core, "%s:%d: usb_create_hcd failed\n", __func__,
@@ -204,6 +205,7 @@
 
 	tmp = hcd->irq;
 
+	ehci_shutdown(hcd);
 	usb_remove_hcd(hcd);
 
 	ps3_system_bus_set_driver_data(dev, NULL);
diff -urN host/ehci-q.c host.new/ehci-q.c
--- host/ehci-q.c	2009-02-24 19:00:15.299975535 +0100
+++ host.new/ehci-q.c	2009-03-28 17:46:02.000000000 +0100
@@ -139,64 +139,67 @@
 
 /*-------------------------------------------------------------------------*/
 
-static void qtd_copy_status (
+static int qtd_copy_status (
 	struct ehci_hcd *ehci,
 	struct urb *urb,
 	size_t length,
 	u32 token
 )
 {
+	int	status = -EINPROGRESS;
+
 	/* count IN/OUT bytes, not SETUP (even short packets) */
 	if (likely (QTD_PID (token) != 2))
 		urb->actual_length += length - QTD_LENGTH (token);
 
 	/* don't modify error codes */
-	if (unlikely (urb->status != -EINPROGRESS))
-		return;
+	if (unlikely(urb->unlinked))
+		return status;
 
 	/* force cleanup after short read; not always an error */
 	if (unlikely (IS_SHORT_READ (token)))
-		urb->status = -EREMOTEIO;
+		status = -EREMOTEIO;
 
 	/* serious "can't proceed" faults reported by the hardware */
 	if (token & QTD_STS_HALT) {
 		if (token & QTD_STS_BABBLE) {
 			/* FIXME "must" disable babbling device's port too */
-			urb->status = -EOVERFLOW;
+			status = -EOVERFLOW;
 		} else if (token & QTD_STS_MMF) {
 			/* fs/ls interrupt xfer missed the complete-split */
-			urb->status = -EPROTO;
+			status = -EPROTO;
 		} else if (token & QTD_STS_DBE) {
-			urb->status = (QTD_PID (token) == 1) /* IN ? */
+			status = (QTD_PID (token) == 1) /* IN ? */
 				? -ENOSR  /* hc couldn't read data */
 				: -ECOMM; /* hc couldn't write data */
 		} else if (token & QTD_STS_XACT) {
 			/* timeout, bad crc, wrong PID, etc; retried */
 			if (QTD_CERR (token))
-				urb->status = -EPIPE;
+				status = -EPIPE;
 			else {
 				ehci_dbg (ehci, "devpath %s ep%d%s 3strikes\n",
 					urb->dev->devpath,
 					usb_pipeendpoint (urb->pipe),
 					usb_pipein (urb->pipe) ? "in" : "out");
-				urb->status = -EPROTO;
+				status = -EPROTO;
 			}
 		/* CERR nonzero + no errors + halt --> stall */
 		} else if (QTD_CERR (token))
-			urb->status = -EPIPE;
+			status = -EPIPE;
 		else	/* unknown */
-			urb->status = -EPROTO;
+			status = -EPROTO;
 
 		ehci_vdbg (ehci,
 			"dev%d ep%d%s qtd token %08x --> status %d\n",
 			usb_pipedevice (urb->pipe),
 			usb_pipeendpoint (urb->pipe),
 			usb_pipein (urb->pipe) ? "in" : "out",
-			token, urb->status);
+			token, status);
 
 		/* if async CSPLIT failed, try cleaning out the TT buffer */
-		if (urb->status != -EPIPE
-				&& urb->dev->tt && !usb_pipeint (urb->pipe)
+		if (status != -EPIPE
+				&& urb->dev->tt
+				&& !usb_pipeint(urb->pipe)
 				&& ((token & QTD_STS_MMF) != 0
 					|| QTD_CERR(token) == 0)
 				&& (!ehci_is_TDI(ehci)
@@ -209,13 +212,18 @@
 				urb->dev->ttport, urb->dev->devnum,
 				usb_pipeendpoint (urb->pipe), token);
 #endif /* DEBUG */
+			/* REVISIT ARC-derived cores don't clear the root
+			 * hub TT buffer in this way...
+			 */
 			usb_hub_tt_clear_buffer (urb->dev, urb->pipe);
 		}
 	}
+
+	return status;
 }
 
 static void
-ehci_urb_done (struct ehci_hcd *ehci, struct urb *urb)
+ehci_urb_done(struct ehci_hcd *ehci, struct urb *urb, int status)
 __releases(ehci->lock)
 __acquires(ehci->lock)
 {
@@ -231,39 +239,29 @@
 		qh_put (qh);
 	}
 
-	spin_lock (&urb->lock);
-	urb->hcpriv = NULL;
-	switch (urb->status) {
-	case -EINPROGRESS:		/* success */
-		urb->status = 0;
-	default:			/* fault */
-		COUNT (ehci->stats.complete);
-		break;
-	case -EREMOTEIO:		/* fault or normal */
-		if (!(urb->transfer_flags & URB_SHORT_NOT_OK))
-			urb->status = 0;
-		COUNT (ehci->stats.complete);
-		break;
-	case -ECONNRESET:		/* canceled */
-	case -ENOENT:
-		COUNT (ehci->stats.unlink);
-		break;
+	if (unlikely(urb->unlinked)) {
+		COUNT(ehci->stats.unlink);
+	} else {
+		/* report non-error and short read status as zero */
+		if (status == -EINPROGRESS || status == -EREMOTEIO)
+			status = 0;
+		COUNT(ehci->stats.complete);
 	}
-	spin_unlock (&urb->lock);
 
 #ifdef EHCI_URB_TRACE
 	ehci_dbg (ehci,
 		"%s %s urb %p ep%d%s status %d len %d/%d\n",
-		__FUNCTION__, urb->dev->devpath, urb,
+		__func__, urb->dev->devpath, urb,
 		usb_pipeendpoint (urb->pipe),
 		usb_pipein (urb->pipe) ? "in" : "out",
-		urb->status,
+		status,
 		urb->actual_length, urb->transfer_buffer_length);
 #endif
 
 	/* complete() can reenter this HCD */
+	usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
 	spin_unlock (&ehci->lock);
-	usb_hcd_giveback_urb (ehci_to_hcd(ehci), urb);
+	usb_hcd_giveback_urb(ehci_to_hcd(ehci), urb, status);
 	spin_lock (&ehci->lock);
 }
 
@@ -283,11 +281,11 @@
 {
 	struct ehci_qtd		*last = NULL, *end = qh->dummy;
 	struct list_head	*entry, *tmp;
+	int			last_status = -EINPROGRESS;
 	int			stopped;
 	unsigned		count = 0;
-	int			do_status = 0;
 	u8			state;
-	u32			halt = HALT_BIT(ehci);
+	__le32			halt = HALT_BIT(ehci);
 
 	if (unlikely (list_empty (&qh->qtd_list)))
 		return count;
@@ -318,8 +316,9 @@
 		/* clean up any state from previous QTD ...*/
 		if (last) {
 			if (likely (last->urb != urb)) {
-				ehci_urb_done (ehci, last->urb);
+				ehci_urb_done(ehci, last->urb, last_status);
 				count++;
+				last_status = -EINPROGRESS;
 			}
 			ehci_qtd_free (ehci, last);
 			last = NULL;
@@ -334,13 +333,50 @@
 		token = hc32_to_cpu(ehci, qtd->hw_token);
 
 		/* always clean up qtds the hc de-activated */
+ retry_xacterr:
 		if ((token & QTD_STS_ACTIVE) == 0) {
 
+			/* on STALL, error, and short reads this urb must
+			 * complete and all its qtds must be recycled.
+			 */
 			if ((token & QTD_STS_HALT) != 0) {
+
+				/* retry transaction errors until we
+				 * reach the software xacterr limit
+				 */
+				if ((token & QTD_STS_XACT) &&
+						QTD_CERR(token) == 0 &&
+						--qh->xacterrs > 0 &&
+						!urb->unlinked) {
+					ehci_dbg(ehci,
+	"detected XactErr len %zu/%zu retry %d\n",
+	qtd->length - QTD_LENGTH(token), qtd->length,
+	QH_XACTERR_MAX - qh->xacterrs);
+
+					/* reset the token in the qtd and the
+					 * qh overlay (which still contains
+					 * the qtd) so that we pick up from
+					 * where we left off
+					 */
+					token &= ~QTD_STS_HALT;
+					token |= QTD_STS_ACTIVE |
+							(EHCI_TUNE_CERR << 10);
+					qtd->hw_token = cpu_to_hc32(ehci,
+							token);
+					wmb();
+					qh->hw_token = cpu_to_hc32(ehci, token);
+					goto retry_xacterr;
+				}
 				stopped = 1;
 
 			/* magic dummy for some short reads; qh won't advance.
 			 * that silicon quirk can kick in with this dummy too.
+			 *
+			 * other short reads won't stop the queue, including
+			 * control transfers (status stage handles that) or
+			 * most other single-qtd reads ... the queue stops if
+			 * URB_SHORT_NOT_OK was set so the driver submitting
+			 * the urbs could clean it up.
 			 */
 			} else if (IS_SHORT_READ (token)
 					&& !(qtd->hw_alt_next
@@ -354,27 +390,21 @@
 				&& HC_IS_RUNNING (ehci_to_hcd(ehci)->state))) {
 			break;
 
+		/* scan the whole queue for unlinks whenever it stops */
 		} else {
 			stopped = 1;
 
-			if (unlikely (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state)))
-				urb->status = -ESHUTDOWN;
+			/* cancel everything if we halt, suspend, etc */
+			if (!HC_IS_RUNNING(ehci_to_hcd(ehci)->state))
+				last_status = -ESHUTDOWN;
 
-			/* ignore active urbs unless some previous qtd
-			 * for the urb faulted (including short read) or
-			 * its urb was canceled.  we may patch qh or qtds.
+			/* this qtd is active; skip it unless a previous qtd
+			 * for its urb faulted, or its urb was canceled.
 			 */
-			if (likely (urb->status == -EINPROGRESS))
+			else if (last_status == -EINPROGRESS && !urb->unlinked)
 				continue;
 
-			/* issue status after short control reads */
-			if (unlikely (do_status != 0)
-					&& QTD_PID (token) == 0 /* OUT */) {
-				do_status = 0;
-				continue;
-			}
-
-			/* token in overlay may be most current */
+			/* qh unlinked; token in overlay may be most current */
 			if (state == QH_STATE_IDLE
 					&& cpu_to_hc32(ehci, qtd->qtd_dma)
 						== qh->hw_current)
@@ -391,25 +421,42 @@
 			}
 		}
 
-		/* remove it from the queue */
-		spin_lock (&urb->lock);
-		qtd_copy_status (ehci, urb, qtd->length, token);
-		do_status = (urb->status == -EREMOTEIO)
-				&& usb_pipecontrol (urb->pipe);
-		spin_unlock (&urb->lock);
+		/* unless we already know the urb's status, collect qtd status
+		 * and update count of bytes transferred.  in common short read
+		 * cases with only one data qtd (including control transfers),
+		 * queue processing won't halt.  but with two or more qtds (for
+		 * example, with a 32 KB transfer), when the first qtd gets a
+		 * short read the second must be removed by hand.
+		 */
+		if (last_status == -EINPROGRESS) {
+			last_status = qtd_copy_status(ehci, urb,
+					qtd->length, token);
+			if (last_status == -EREMOTEIO
+					&& (qtd->hw_alt_next
+						& EHCI_LIST_END(ehci)))
+				last_status = -EINPROGRESS;
+		}
 
+		/* if we're removing something not at the queue head,
+		 * patch the hardware queue pointer.
+		 */
 		if (stopped && qtd->qtd_list.prev != &qh->qtd_list) {
 			last = list_entry (qtd->qtd_list.prev,
 					struct ehci_qtd, qtd_list);
 			last->hw_next = qtd->hw_next;
 		}
+
+		/* remove qtd; it's recycled after possible urb completion */
 		list_del (&qtd->qtd_list);
 		last = qtd;
+
+		/* reinit the xacterr counter for the next qtd */
+		qh->xacterrs = QH_XACTERR_MAX;
 	}
 
 	/* last urb's completion might still need calling */
 	if (likely (last != NULL)) {
-		ehci_urb_done (ehci, last->urb);
+		ehci_urb_done(ehci, last->urb, last_status);
 		count++;
 		ehci_qtd_free (ehci, last);
 	}
@@ -427,7 +474,15 @@
 			qh_refresh(ehci, qh);
 			break;
 		case QH_STATE_LINKED:
-			/* should be rare for periodic transfers,
+			/* We won't refresh a QH that's linked (after the HC
+			 * stopped the queue).  That avoids a race:
+			 *  - HC reads first part of QH;
+			 *  - CPU updates that first part and the token;
+			 *  - HC reads rest of that QH, including token
+			 * Result:  HC gets an inconsistent image, and then
+			 * DMAs to/from the wrong memory (corrupting it).
+			 *
+			 * That should be rare for interrupt transfers,
 			 * except maybe high bandwidth ...
 			 */
 			if ((cpu_to_hc32(ehci, QH_SMASK)
@@ -545,6 +600,12 @@
 		this_qtd_len = qtd_fill(ehci, qtd, buf, len, token, maxpacket);
 		len -= this_qtd_len;
 		buf += this_qtd_len;
+
+		/*
+		 * short reads advance to a "magic" dummy instead of the next
+		 * qtd ... that forces the queue to stop, for manual cleanup.
+		 * (this will usually be overridden later.)
+		 */
 		if (is_input)
 			qtd->hw_alt_next = ehci->async->hw_alt_next;
 
@@ -564,8 +625,10 @@
 		list_add_tail (&qtd->qtd_list, head);
 	}
 
-	/* unless the bulk/interrupt caller wants a chance to clean
-	 * up after short reads, hc should advance qh past this urb
+	/*
+	 * unless the caller requires manual cleanup after short reads,
+	 * have the alt_next mechanism keep the queue running after the
+	 * last data qtd (the only one, for control and most other cases).
 	 */
 	if (likely ((urb->transfer_flags & URB_SHORT_NOT_OK) == 0
 				|| usb_pipecontrol (urb->pipe)))
@@ -638,6 +701,7 @@
 	u32			info1 = 0, info2 = 0;
 	int			is_input, type;
 	int			maxp = 0;
+	struct usb_tt		*tt = urb->dev->tt;
 
 	if (!qh)
 		return qh;
@@ -652,6 +716,14 @@
 	type = usb_pipetype (urb->pipe);
 	maxp = usb_maxpacket (urb->dev, urb->pipe, !is_input);
 
+	/* 1024 byte maxpacket is a hardware ceiling.  High bandwidth
+	 * acts like up to 3KB, but is built from smaller packets.
+	 */
+	if (max_packet(maxp) > 1024) {
+		ehci_dbg(ehci, "bogus qh maxpacket %d\n", max_packet(maxp));
+		goto done;
+	}
+
 	/* Compute interrupt scheduling parameters just once, and save.
 	 * - allowing for high bandwidth, how many nsec/uframe are used?
 	 * - split transactions need a second CSPLIT uframe; same question
@@ -661,8 +733,9 @@
 	 * For control/bulk requests, the HC or TT handles these.
 	 */
 	if (type == PIPE_INTERRUPT) {
-		qh->usecs = NS_TO_US (usb_calc_bus_time (USB_SPEED_HIGH, is_input, 0,
-				hb_mult (maxp) * max_packet (maxp)));
+		qh->usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,
+				is_input, 0,
+				hb_mult(maxp) * max_packet(maxp)));
 		qh->start = NO_FRAME;
 
 		if (urb->dev->speed == USB_SPEED_HIGH) {
@@ -680,7 +753,6 @@
 				goto done;
 			}
 		} else {
-			struct usb_tt	*tt = urb->dev->tt;
 			int		think_time;
 
 			/* gap is f(FS/LS transfer times) */
@@ -736,10 +808,8 @@
 		/* set the address of the TT; for TDI's integrated
 		 * root hub tt, leave it zeroed.
 		 */
-		if (!ehci_is_TDI(ehci)
-				|| urb->dev->tt->hub !=
-					ehci_to_hcd(ehci)->self.root_hub)
-			info2 |= urb->dev->tt->hub->devnum << 16;
+		if (tt && tt->hub != ehci_to_hcd(ehci)->self.root_hub)
+			info2 |= tt->hub->devnum << 16;
 
 		/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets c-mask } */
 
@@ -754,7 +824,13 @@
 			info2 |= (EHCI_TUNE_MULT_HS << 30);
 		} else if (type == PIPE_BULK) {
 			info1 |= (EHCI_TUNE_RL_HS << 28);
-			info1 |= 512 << 16;	/* usb2 fixed maxpacket */
+			/* The USB spec says that high speed bulk endpoints
+			 * always use 512 byte maxpacket.  But some device
+			 * vendors decided to ignore that, and MSFT is happy
+			 * to help them do so.  So now people expect to use
+			 * such nonconformant devices with Linux too; sigh.
+			 */
+			info1 |= max_packet(maxp) << 16;
 			info2 |= (EHCI_TUNE_MULT_HS << 30);
 		} else {		/* PIPE_INTERRUPT */
 			info1 |= max_packet (maxp) << 16;
@@ -817,6 +893,7 @@
 	head->qh_next.qh = qh;
 	head->hw_next = dma;
 
+	qh->xacterrs = QH_XACTERR_MAX;
 	qh->qh_state = QH_STATE_LINKED;
 	/* qtd completions reported later by interrupt */
 }
@@ -838,7 +915,7 @@
 )
 {
 	struct ehci_qh		*qh = NULL;
-	u32			qh_addr_mask = cpu_to_hc32(ehci, 0x7f);
+	__hc32			qh_addr_mask = cpu_to_hc32(ehci, 0x7f);
 
 	qh = (struct ehci_qh *) *ptr;
 	if (unlikely (qh == NULL)) {
@@ -887,7 +964,7 @@
 
 			list_del (&qtd->qtd_list);
 			list_add (&dummy->qtd_list, qtd_list);
-			__list_splice (qtd_list, qh->qtd_list.prev);
+			list_splice_tail(qtd_list, &qh->qtd_list);
 
 			ehci_qtd_init(ehci, qtd, qtd->qtd_dma);
 			qh->dummy = qtd;
@@ -913,7 +990,6 @@
 static int
 submit_async (
 	struct ehci_hcd		*ehci,
-	struct usb_host_endpoint *ep,
 	struct urb		*urb,
 	struct list_head	*qtd_list,
 	gfp_t			mem_flags
@@ -922,18 +998,18 @@
 	int			epnum;
 	unsigned long		flags;
 	struct ehci_qh		*qh = NULL;
-	int			rc = 0;
+	int			rc;
 
 	qtd = list_entry (qtd_list->next, struct ehci_qtd, qtd_list);
-	epnum = ep->desc.bEndpointAddress;
+	epnum = urb->ep->desc.bEndpointAddress;
 
 #ifdef EHCI_URB_TRACE
 	ehci_dbg (ehci,
 		"%s %s urb %p ep%d%s len %d, qtd %p [qh %p]\n",
-		__FUNCTION__, urb->dev->devpath, urb,
+		__func__, urb->dev->devpath, urb,
 		epnum & 0x0f, (epnum & USB_DIR_IN) ? "in" : "out",
 		urb->transfer_buffer_length,
-		qtd, ep->hcpriv);
+		qtd, urb->ep->hcpriv);
 #endif
 
 	spin_lock_irqsave (&ehci->lock, flags);
@@ -942,9 +1018,13 @@
 		rc = -ESHUTDOWN;
 		goto done;
 	}
+	rc = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);
+	if (unlikely(rc))
+		goto done;
 
-	qh = qh_append_tds (ehci, urb, qtd_list, epnum, &ep->hcpriv);
+	qh = qh_append_tds(ehci, urb, qtd_list, epnum, &urb->ep->hcpriv);
 	if (unlikely(qh == NULL)) {
+		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
 		rc = -ENOMEM;
 		goto done;
 	}
@@ -970,7 +1050,7 @@
 	struct ehci_qh		*qh = ehci->reclaim;
 	struct ehci_qh		*next;
 
-	timer_action_done (ehci, TIMER_IAA_WATCHDOG);
+	iaa_watchdog_done(ehci);
 
 	// qh->hw_next = cpu_to_hc32(qh->qh_dma);
 	qh->qh_state = QH_STATE_IDLE;
@@ -980,7 +1060,6 @@
 	/* other unlink(s) may be pending (in QH_STATE_UNLINK_WAIT) */
 	next = qh->reclaim;
 	ehci->reclaim = next;
-	ehci->reclaim_ready = 0;
 	qh->reclaim = NULL;
 
 	qh_completions (ehci, qh);
@@ -1048,7 +1127,8 @@
 	prev->qh_next = qh->qh_next;
 	wmb ();
 
-	if (unlikely (ehci_to_hcd(ehci)->state == HC_STATE_HALT)) {
+	/* If the controller isn't running, we don't have to wait for it */
+	if (unlikely(!HC_IS_RUNNING(ehci_to_hcd(ehci)->state))) {
 		/* if (unlikely (qh->reclaim != 0))
 		 *	this will recurse, probably not much
 		 */
@@ -1056,11 +1136,10 @@
 		return;
 	}
 
-	ehci->reclaim_ready = 0;
 	cmd |= CMD_IAAD;
 	ehci_writel(ehci, cmd, &ehci->regs->command);
 	(void)ehci_readl(ehci, &ehci->regs->command);
-	timer_action (ehci, TIMER_IAA_WATCHDOG);
+	iaa_watchdog_start(ehci);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1070,8 +1149,7 @@
 	struct ehci_qh		*qh;
 	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
 
-	if (!++(ehci->stamp))
-		ehci->stamp++;
+	ehci->stamp = ehci_readl(ehci, &ehci->regs->frame_index);
 	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
 rescan:
 	qh = ehci->async->qh_next.qh;
@@ -1096,18 +1174,20 @@
 				}
 			}
 
-			/* unlink idle entries, reducing HC PCI usage as well
+			/* unlink idle entries, reducing DMA usage as well
 			 * as HCD schedule-scanning costs.  delay for any qh
 			 * we just scanned, there's a not-unusual case that it
 			 * doesn't stay idle for long.
 			 * (plus, avoids some kind of re-activation race.)
 			 */
-			if (list_empty (&qh->qtd_list)) {
-				if (qh->stamp == ehci->stamp)
+			if (list_empty(&qh->qtd_list)
+					&& qh->qh_state == QH_STATE_LINKED) {
+				if (!ehci->reclaim
+					&& ((ehci->stamp - qh->stamp) & 0x1fff)
+						>= (EHCI_SHRINK_FRAMES * 8))
+					start_unlink_async(ehci, qh);
+				else
 					action = TIMER_ASYNC_SHRINK;
-				else if (!ehci->reclaim
-					    && qh->qh_state == QH_STATE_LINKED)
-					start_unlink_async (ehci, qh);
 			}
 
 			qh = qh->qh_next.qh;
diff -urN host/ehci-sched.c host.new/ehci-sched.c
--- host/ehci-sched.c	2009-02-24 19:00:15.315974722 +0100
+++ host.new/ehci-sched.c	2009-03-28 17:46:02.000000000 +0100
@@ -119,7 +119,8 @@
 			q = &q->fstn->fstn_next;
 			break;
 		case Q_TYPE_ITD:
-			usecs += q->itd->usecs [uframe];
+			if (q->itd->hw_transaction[uframe])
+				usecs += q->itd->stream->usecs;
 			hw_p = &q->itd->hw_next;
 			q = &q->itd->itd_next;
 			break;
@@ -211,7 +212,7 @@
  * low/fullspeed transfer can "carry over" from one uframe to the next,
  * since the TT just performs downstream transfers in sequence.
  *
- * For example two seperate 100 usec transfers can start in the same uframe,
+ * For example two separate 100 usec transfers can start in the same uframe,
  * and the second one would "carry over" 75 usecs into the next uframe.
  */
 static void
@@ -436,14 +437,16 @@
 	u32	cmd;
 	int	status;
 
+	if (ehci->periodic_sched++)
+		return 0;
+
 	/* did clearing PSE did take effect yet?
 	 * takes effect only at frame boundaries...
 	 */
-	status = handshake(ehci, &ehci->regs->status, STS_PSS, 0, 9 * 125);
-	if (status != 0) {
-		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
+	status = handshake_on_error_set_halt(ehci, &ehci->regs->status,
+					     STS_PSS, 0, 9 * 125);
+	if (status)
 		return status;
-	}
 
 	cmd = ehci_readl(ehci, &ehci->regs->command) | CMD_PSE;
 	ehci_writel(ehci, cmd, &ehci->regs->command);
@@ -461,14 +464,16 @@
 	u32	cmd;
 	int	status;
 
+	if (--ehci->periodic_sched)
+		return 0;
+
 	/* did setting PSE not take effect yet?
 	 * takes effect only at frame boundaries...
 	 */
-	status = handshake(ehci, &ehci->regs->status, STS_PSS, STS_PSS, 9 * 125);
-	if (status != 0) {
-		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
+	status = handshake_on_error_set_halt(ehci, &ehci->regs->status,
+					     STS_PSS, STS_PSS, 9 * 125);
+	if (status)
 		return status;
-	}
 
 	cmd = ehci_readl(ehci, &ehci->regs->command) & ~CMD_PSE;
 	ehci_writel(ehci, cmd, &ehci->regs->command);
@@ -545,13 +550,10 @@
 		: (qh->usecs * 8);
 
 	/* maybe enable periodic schedule processing */
-	if (!ehci->periodic_sched++)
-		return enable_periodic (ehci);
-
-	return 0;
+	return enable_periodic(ehci);
 }
 
-static void qh_unlink_periodic (struct ehci_hcd *ehci, struct ehci_qh *qh)
+static int qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	unsigned	i;
 	unsigned	period;
@@ -561,7 +563,7 @@
 	//   and this qh is active in the current uframe
 	//   (and overlay token SplitXstate is false?)
 	// THEN
-	//   qh->hw_info1 |= __constant_cpu_to_hc32(1 << 7 /* "ignore" */);
+	//   qh->hw_info1 |= cpu_to_hc32(1 << 7 /* "ignore" */);
 
 	/* high bandwidth, or otherwise part of every microframe */
 	if ((period = qh->period) == 0)
@@ -587,9 +589,7 @@
 	qh_put (qh);
 
 	/* maybe turn off periodic schedule */
-	ehci->periodic_sched--;
-	if (!ehci->periodic_sched)
-		(void) disable_periodic (ehci);
+	return disable_periodic(ehci);
 }
 
 static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
@@ -797,7 +797,6 @@
 
 static int intr_submit (
 	struct ehci_hcd		*ehci,
-	struct usb_host_endpoint *ep,
 	struct urb		*urb,
 	struct list_head	*qtd_list,
 	gfp_t			mem_flags
@@ -805,23 +804,26 @@
 	unsigned		epnum;
 	unsigned long		flags;
 	struct ehci_qh		*qh;
-	int			status = 0;
+	int			status;
 	struct list_head	empty;
 
 	/* get endpoint and transfer/schedule data */
-	epnum = ep->desc.bEndpointAddress;
+	epnum = urb->ep->desc.bEndpointAddress;
 
 	spin_lock_irqsave (&ehci->lock, flags);
 
 	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
 			&ehci_to_hcd(ehci)->flags))) {
 		status = -ESHUTDOWN;
-		goto done;
+		goto done_not_linked;
 	}
+	status = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);
+	if (unlikely(status))
+		goto done_not_linked;
 
 	/* get qh and force any scheduling errors */
 	INIT_LIST_HEAD (&empty);
-	qh = qh_append_tds (ehci, urb, &empty, epnum, &ep->hcpriv);
+	qh = qh_append_tds(ehci, urb, &empty, epnum, &urb->ep->hcpriv);
 	if (qh == NULL) {
 		status = -ENOMEM;
 		goto done;
@@ -832,13 +834,16 @@
 	}
 
 	/* then queue the urb's tds to the qh */
-	qh = qh_append_tds (ehci, urb, qtd_list, epnum, &ep->hcpriv);
+	qh = qh_append_tds(ehci, urb, qtd_list, epnum, &urb->ep->hcpriv);
 	BUG_ON (qh == NULL);
 
 	/* ... update usbfs periodic stats */
 	ehci_to_hcd(ehci)->self.bandwidth_int_reqs++;
 
 done:
+	if (unlikely(status))
+		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
+done_not_linked:
 	spin_unlock_irqrestore (&ehci->lock, flags);
 	if (status)
 		qtd_list_free (ehci, urb, qtd_list);
@@ -913,7 +918,7 @@
 		 */
 		stream->usecs = HS_USECS_ISO (maxp);
 		bandwidth = stream->usecs * 8;
-		bandwidth /= 1 << (interval - 1);
+		bandwidth /= interval;
 
 	} else {
 		u32		addr;
@@ -946,7 +951,7 @@
 		} else
 			stream->raw_mask = smask_out [hs_transfers - 1];
 		bandwidth = stream->usecs + stream->c_usecs;
-		bandwidth /= 1 << (interval + 2);
+		bandwidth /= interval << 3;
 
 		/* stream->splits gets created from raw_mask later */
 		stream->address = cpu_to_hc32(ehci, addr);
@@ -999,7 +1004,8 @@
 
 		is_in = (stream->bEndpointAddress & USB_DIR_IN) ? 0x10 : 0;
 		stream->bEndpointAddress &= 0x0f;
-		stream->ep->hcpriv = NULL;
+		if (stream->ep)
+			stream->ep->hcpriv = NULL;
 
 		if (stream->rescheduled) {
 			ehci_info (ehci, "ep%d%s-iso rescheduled "
@@ -1177,21 +1183,18 @@
 					struct ehci_itd, itd_list);
 			list_del (&itd->itd_list);
 			itd_dma = itd->itd_dma;
-		} else
-			itd = NULL;
-
-		if (!itd) {
+		} else {
 			spin_unlock_irqrestore (&ehci->lock, flags);
 			itd = dma_pool_alloc (ehci->itd_pool, mem_flags,
 					&itd_dma);
 			spin_lock_irqsave (&ehci->lock, flags);
+			if (!itd) {
+				iso_sched_free(stream, sched);
+				spin_unlock_irqrestore(&ehci->lock, flags);
+				return -ENOMEM;
+			}
 		}
 
-		if (unlikely (NULL == itd)) {
-			iso_sched_free (stream, sched);
-			spin_unlock_irqrestore (&ehci->lock, flags);
-			return -ENOMEM;
-		}
 		memset (itd, 0, sizeof *itd);
 		itd->itd_dma = itd_dma;
 		list_add (&itd->itd_list, &sched->td_list);
@@ -1348,18 +1351,27 @@
 	/* when's the last uframe this urb could start? */
 	max = now + mod;
 
-	/* typical case: reuse current schedule. stream is still active,
-	 * and no gaps from host falling behind (irq delays etc)
+	/* Typical case: reuse current schedule, stream is still active.
+	 * Hopefully there are no gaps from the host falling behind
+	 * (irq delays etc), but if there are we'll take the next
+	 * slot in the schedule, implicitly assuming URB_ISO_ASAP.
 	 */
 	if (likely (!list_empty (&stream->td_list))) {
 		start = stream->next_uframe;
 		if (start < now)
 			start += mod;
-		if (likely ((start + sched->span) < max))
-			goto ready;
-		/* else fell behind; someday, try to reschedule */
-		status = -EL2NSYNC;
-		goto fail;
+
+		/* Fell behind (by up to twice the slop amount)? */
+		if (start >= max - 2 * 8 * SCHEDULE_SLOP)
+			start += stream->interval * DIV_ROUND_UP(
+					max - start, stream->interval) - mod;
+
+		/* Tried to schedule too far into the future? */
+		if (unlikely((start + sched->span) >= max)) {
+			status = -EFBIG;
+			goto fail;
+		}
+		goto ready;
 	}
 
 	/* need to schedule; when's the next (u)frame we could start?
@@ -1524,14 +1536,13 @@
 					struct ehci_itd, itd_list);
 			list_move_tail (&itd->itd_list, &stream->td_list);
 			itd->stream = iso_stream_get (stream);
-			itd->urb = usb_get_urb (urb);
+			itd->urb = urb;
 			itd_init (ehci, stream, itd);
 		}
 
 		uframe = next_uframe & 0x07;
 		frame = next_uframe >> 3;
 
-		itd->usecs [uframe] = stream->usecs;
 		itd_patch(ehci, itd, iso_sched, packet, uframe);
 
 		next_uframe += stream->interval;
@@ -1553,13 +1564,21 @@
 	urb->hcpriv = NULL;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
-	if (unlikely (!ehci->periodic_sched++))
-		return enable_periodic (ehci);
-	return 0;
+	return enable_periodic(ehci);
 }
 
 #define	ISO_ERRS (EHCI_ISOC_BUF_ERR | EHCI_ISOC_BABBLE | EHCI_ISOC_XACTERR)
 
+/* Process and recycle a completed ITD.  Return true iff its urb completed,
+ * and hence its completion callback probably added things to the hardware
+ * schedule.
+ *
+ * Note that we carefully avoid recycling this descriptor until after any
+ * completion callback runs, so that it won't be reused quickly.  That is,
+ * assuming (a) no more than two urbs per frame on this endpoint, and also
+ * (b) only this endpoint's completions submit URBs.  It seems some silicon
+ * corrupts things if you reuse completed descriptors very quickly...
+ */
 static unsigned
 itd_complete (
 	struct ehci_hcd	*ehci,
@@ -1572,6 +1591,7 @@
 	int					urb_index = -1;
 	struct ehci_iso_stream			*stream = itd->stream;
 	struct usb_device			*dev;
+	unsigned				retval = false;
 
 	/* for each uframe with a packet */
 	for (uframe = 0; uframe < 8; uframe++) {
@@ -1602,36 +1622,30 @@
 		} else if (likely ((t & EHCI_ISOC_ACTIVE) == 0)) {
 			desc->status = 0;
 			desc->actual_length = EHCI_ITD_LENGTH (t);
+		} else {
+			/* URB was too late */
+			desc->status = -EXDEV;
 		}
 	}
 
-	usb_put_urb (urb);
-	itd->urb = NULL;
-	itd->stream = NULL;
-	list_move (&itd->itd_list, &stream->free_list);
-	iso_stream_put (ehci, stream);
-
 	/* handle completion now? */
 	if (likely ((urb_index + 1) != urb->number_of_packets))
-		return 0;
+		goto done;
 
 	/* ASSERT: it's really the last itd for this urb
 	list_for_each_entry (itd, &stream->td_list, itd_list)
 		BUG_ON (itd->urb == urb);
 	 */
 
-	/* give urb back to the driver ... can be out-of-order */
+	/* give urb back to the driver; completion often (re)submits */
 	dev = urb->dev;
-	ehci_urb_done (ehci, urb);
+	ehci_urb_done(ehci, urb, 0);
+	retval = true;
 	urb = NULL;
-
-	/* defer stopping schedule; completion can submit */
-	ehci->periodic_sched--;
-	if (unlikely (!ehci->periodic_sched))
-		(void) disable_periodic (ehci);
+	(void) disable_periodic(ehci);
 	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;
 
-	if (unlikely (list_empty (&stream->td_list))) {
+	if (unlikely(list_is_singular(&stream->td_list))) {
 		ehci_to_hcd(ehci)->self.bandwidth_allocated
 				-= stream->bandwidth;
 		ehci_vdbg (ehci,
@@ -1641,7 +1655,27 @@
 	}
 	iso_stream_put (ehci, stream);
 
-	return 1;
+done:
+	itd->urb = NULL;
+	if (ehci->clock_frame != itd->frame || itd->index[7] != -1) {
+		/* OK to recycle this ITD now. */
+		itd->stream = NULL;
+		list_move(&itd->itd_list, &stream->free_list);
+		iso_stream_put(ehci, stream);
+	} else {
+		/* HW might remember this ITD, so we can't recycle it yet.
+		 * Move it to a safe place until a new frame starts.
+		 */
+		list_move(&itd->itd_list, &ehci->cached_itd_list);
+		if (stream->refcount == 2) {
+			/* If iso_stream_put() were called here, stream
+			 * would be freed.  Instead, just prevent reuse.
+			 */
+			stream->ep->hcpriv = NULL;
+			stream->ep = NULL;
+		}
+	}
+	return retval;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1668,7 +1702,7 @@
 #ifdef EHCI_URB_TRACE
 	ehci_dbg (ehci,
 		"%s %s urb %p ep%d%s len %d, %d pkts %d uframes [%p]\n",
-		__FUNCTION__, urb->dev->devpath, urb,
+		__func__, urb->dev->devpath, urb,
 		usb_pipeendpoint (urb->pipe),
 		usb_pipein (urb->pipe) ? "in" : "out",
 		urb->transfer_buffer_length,
@@ -1686,12 +1720,19 @@
 	/* schedule ... need to lock */
 	spin_lock_irqsave (&ehci->lock, flags);
 	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			       &ehci_to_hcd(ehci)->flags)))
+			       &ehci_to_hcd(ehci)->flags))) {
 		status = -ESHUTDOWN;
-	else
-		status = iso_stream_schedule (ehci, urb, stream);
+		goto done_not_linked;
+	}
+	status = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);
+	if (unlikely(status))
+		goto done_not_linked;
+	status = iso_stream_schedule(ehci, urb, stream);
 	if (likely (status == 0))
 		itd_link_urb (ehci, urb, ehci->periodic_size << 3, stream);
+	else
+		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
+done_not_linked:
 	spin_unlock_irqrestore (&ehci->lock, flags);
 
 done:
@@ -1700,8 +1741,6 @@
 	return status;
 }
 
-#ifdef CONFIG_USB_EHCI_SPLIT_ISO
-
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -1797,21 +1836,18 @@
 					 struct ehci_sitd, sitd_list);
 			list_del (&sitd->sitd_list);
 			sitd_dma = sitd->sitd_dma;
-		} else
-			sitd = NULL;
-
-		if (!sitd) {
+		} else {
 			spin_unlock_irqrestore (&ehci->lock, flags);
 			sitd = dma_pool_alloc (ehci->sitd_pool, mem_flags,
 					&sitd_dma);
 			spin_lock_irqsave (&ehci->lock, flags);
+			if (!sitd) {
+				iso_sched_free(stream, iso_sched);
+				spin_unlock_irqrestore(&ehci->lock, flags);
+				return -ENOMEM;
+			}
 		}
 
-		if (!sitd) {
-			iso_sched_free (stream, iso_sched);
-			spin_unlock_irqrestore (&ehci->lock, flags);
-			return -ENOMEM;
-		}
 		memset (sitd, 0, sizeof *sitd);
 		sitd->sitd_dma = sitd_dma;
 		list_add (&sitd->sitd_list, &iso_sched->td_list);
@@ -1912,7 +1948,7 @@
 				struct ehci_sitd, sitd_list);
 		list_move_tail (&sitd->sitd_list, &stream->td_list);
 		sitd->stream = iso_stream_get (stream);
-		sitd->urb = usb_get_urb (urb);
+		sitd->urb = urb;
 
 		sitd_patch(ehci, stream, sitd, sched, packet);
 		sitd_link (ehci, (next_uframe >> 3) % ehci->periodic_size,
@@ -1928,9 +1964,7 @@
 	urb->hcpriv = NULL;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
-	if (!ehci->periodic_sched++)
-		return enable_periodic (ehci);
-	return 0;
+	return enable_periodic(ehci);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1938,6 +1972,16 @@
 #define	SITD_ERRS (SITD_STS_ERR | SITD_STS_DBE | SITD_STS_BABBLE \
 				| SITD_STS_XACT | SITD_STS_MMF)
 
+/* Process and recycle a completed SITD.  Return true iff its urb completed,
+ * and hence its completion callback probably added things to the hardware
+ * schedule.
+ *
+ * Note that we carefully avoid recycling this descriptor until after any
+ * completion callback runs, so that it won't be reused quickly.  That is,
+ * assuming (a) no more than two urbs per frame on this endpoint, and also
+ * (b) only this endpoint's completions submit URBs.  It seems some silicon
+ * corrupts things if you reuse completed descriptors very quickly...
+ */
 static unsigned
 sitd_complete (
 	struct ehci_hcd		*ehci,
@@ -1949,6 +1993,7 @@
 	int					urb_index = -1;
 	struct ehci_iso_stream			*stream = sitd->stream;
 	struct usb_device			*dev;
+	unsigned				retval = false;
 
 	urb_index = sitd->index;
 	desc = &urb->iso_frame_desc [urb_index];
@@ -1969,35 +2014,26 @@
 		desc->status = 0;
 		desc->actual_length = desc->length - SITD_LENGTH (t);
 	}
-
-	usb_put_urb (urb);
-	sitd->urb = NULL;
-	sitd->stream = NULL;
-	list_move (&sitd->sitd_list, &stream->free_list);
 	stream->depth -= stream->interval << 3;
-	iso_stream_put (ehci, stream);
 
 	/* handle completion now? */
 	if ((urb_index + 1) != urb->number_of_packets)
-		return 0;
+		goto done;
 
 	/* ASSERT: it's really the last sitd for this urb
 	list_for_each_entry (sitd, &stream->td_list, sitd_list)
 		BUG_ON (sitd->urb == urb);
 	 */
 
-	/* give urb back to the driver */
+	/* give urb back to the driver; completion often (re)submits */
 	dev = urb->dev;
-	ehci_urb_done (ehci, urb);
+	ehci_urb_done(ehci, urb, 0);
+	retval = true;
 	urb = NULL;
-
-	/* defer stopping schedule; completion can submit */
-	ehci->periodic_sched--;
-	if (!ehci->periodic_sched)
-		(void) disable_periodic (ehci);
+	(void) disable_periodic(ehci);
 	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;
 
-	if (list_empty (&stream->td_list)) {
+	if (list_is_singular(&stream->td_list)) {
 		ehci_to_hcd(ehci)->self.bandwidth_allocated
 				-= stream->bandwidth;
 		ehci_vdbg (ehci,
@@ -2006,8 +2042,14 @@
 			(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out");
 	}
 	iso_stream_put (ehci, stream);
+	/* OK to recycle this SITD now that its completion callback ran. */
+done:
+	sitd->urb = NULL;
+	sitd->stream = NULL;
+	list_move(&sitd->sitd_list, &stream->free_list);
+	iso_stream_put(ehci, stream);
 
-	return 1;
+	return retval;
 }
 
 
@@ -2049,12 +2091,19 @@
 	/* schedule ... need to lock */
 	spin_lock_irqsave (&ehci->lock, flags);
 	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			       &ehci_to_hcd(ehci)->flags)))
+			       &ehci_to_hcd(ehci)->flags))) {
 		status = -ESHUTDOWN;
-	else
-		status = iso_stream_schedule (ehci, urb, stream);
+		goto done_not_linked;
+	}
+	status = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);
+	if (unlikely(status))
+		goto done_not_linked;
+	status = iso_stream_schedule(ehci, urb, stream);
 	if (status == 0)
 		sitd_link_urb (ehci, urb, ehci->periodic_size << 3, stream);
+	else
+		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
+done_not_linked:
 	spin_unlock_irqrestore (&ehci->lock, flags);
 
 done:
@@ -2063,32 +2112,26 @@
 	return status;
 }
 
-#else
+/*-------------------------------------------------------------------------*/
 
-static inline int
-sitd_submit (struct ehci_hcd *ehci, struct urb *urb, gfp_t mem_flags)
+static void free_cached_itd_list(struct ehci_hcd *ehci)
 {
-	ehci_dbg (ehci, "split iso support is disabled\n");
-	return -ENOSYS;
-}
+	struct ehci_itd *itd, *n;
 
-static inline unsigned
-sitd_complete (
-	struct ehci_hcd		*ehci,
-	struct ehci_sitd	*sitd
-) {
-	ehci_err (ehci, "sitd_complete %p?\n", sitd);
-	return 0;
+	list_for_each_entry_safe(itd, n, &ehci->cached_itd_list, itd_list) {
+		struct ehci_iso_stream	*stream = itd->stream;
+		itd->stream = NULL;
+		list_move(&itd->itd_list, &stream->free_list);
+		iso_stream_put(ehci, stream);
+	}
 }
 
-#endif /* USB_EHCI_SPLIT_ISO */
-
 /*-------------------------------------------------------------------------*/
 
 static void
 scan_periodic (struct ehci_hcd *ehci)
 {
-	unsigned	frame, clock, now_uframe, mod;
+	unsigned	now_uframe, frame, clock, clock_frame, mod;
 	unsigned	modified;
 
 	mod = ehci->periodic_size << 3;
@@ -2099,26 +2142,26 @@
 	 * Touches as few pages as possible:  cache-friendly.
 	 */
 	now_uframe = ehci->next_uframe;
-	if (HC_IS_RUNNING (ehci_to_hcd(ehci)->state))
+	if (HC_IS_RUNNING(ehci_to_hcd(ehci)->state)) {
 		clock = ehci_readl(ehci, &ehci->regs->frame_index);
-	else
+		clock_frame = (clock >> 3) % ehci->periodic_size;
+	} else  {
 		clock = now_uframe + mod - 1;
+		clock_frame = -1;
+	}
+	if (ehci->clock_frame != clock_frame) {
+		free_cached_itd_list(ehci);
+		ehci->clock_frame = clock_frame;
+	}
 	clock %= mod;
+	clock_frame = clock >> 3;
 
 	for (;;) {
 		union ehci_shadow	q, *q_p;
 		__hc32			type, *hw_p;
-		unsigned		uframes;
+		unsigned		incomplete = false;
 
-		/* don't scan past the live uframe */
 		frame = now_uframe >> 3;
-		if (frame == (clock >> 3))
-			uframes = now_uframe & 0x07;
-		else {
-			/* safe to scan the whole frame at once */
-			now_uframe |= 0x07;
-			uframes = 8;
-		}
 
 restart:
 		/* scan each element in frame's queue for completions */
@@ -2156,23 +2199,32 @@
 				q = q.fstn->fstn_next;
 				break;
 			case Q_TYPE_ITD:
-				/* skip itds for later in the frame */
-				rmb ();
-				for (uf = live ? uframes : 8; uf < 8; uf++) {
-					if (0 == (q.itd->hw_transaction [uf]
-							& ITD_ACTIVE(ehci)))
-						continue;
-					q_p = &q.itd->itd_next;
-					hw_p = &q.itd->hw_next;
-					type = Q_NEXT_TYPE(ehci,
+				/* If this ITD is still active, leave it for
+				 * later processing ... check the next entry.
+				 * No need to check for activity unless the
+				 * frame is current.
+				 */
+				if (frame == clock_frame && live) {
+					rmb();
+					for (uf = 0; uf < 8; uf++) {
+						if (q.itd->hw_transaction[uf] &
+							    ITD_ACTIVE(ehci))
+							break;
+					}
+					if (uf < 8) {
+						incomplete = true;
+						q_p = &q.itd->itd_next;
+						hw_p = &q.itd->hw_next;
+						type = Q_NEXT_TYPE(ehci,
 							q.itd->hw_next);
-					q = *q_p;
-					break;
+						q = *q_p;
+						break;
+					}
 				}
-				if (uf != 8)
-					break;
 
-				/* this one's ready ... HC won't cache the
+				/* Take finished ITDs out of the schedule
+				 * and process them:  recycle, maybe report
+				 * URB completion.  HC won't cache the
 				 * pointer for much longer, if at all.
 				 */
 				*q_p = q.itd->itd_next;
@@ -2183,8 +2235,15 @@
 				q = *q_p;
 				break;
 			case Q_TYPE_SITD:
-				if ((q.sitd->hw_results & SITD_ACTIVE(ehci))
-						&& live) {
+				/* If this SITD is still active, leave it for
+				 * later processing ... check the next entry.
+				 * No need to check for activity unless the
+				 * frame is current.
+				 */
+				if (frame == clock_frame && live &&
+						(q.sitd->hw_results &
+							SITD_ACTIVE(ehci))) {
+					incomplete = true;
 					q_p = &q.sitd->sitd_next;
 					hw_p = &q.sitd->hw_next;
 					type = Q_NEXT_TYPE(ehci,
@@ -2192,6 +2251,11 @@
 					q = *q_p;
 					break;
 				}
+
+				/* Take finished SITDs out of the schedule
+				 * and process them:  recycle, maybe report
+				 * URB completion.
+				 */
 				*q_p = q.sitd->sitd_next;
 				*hw_p = q.sitd->hw_next;
 				type = Q_NEXT_TYPE(ehci, q.sitd->hw_next);
@@ -2207,11 +2271,23 @@
 			}
 
 			/* assume completion callbacks modify the queue */
-			if (unlikely (modified))
-				goto restart;
+			if (unlikely (modified)) {
+				if (likely(ehci->periodic_sched > 0))
+					goto restart;
+				/* short-circuit this scan */
+				now_uframe = clock;
+				break;
+			}
 		}
 
-		/* stop when we catch up to the HC */
+		/* If we can tell we caught up to the hardware, stop now.
+		 * We can't advance our scan without collecting the ISO
+		 * transfers that are still pending in this frame.
+		 */
+		if (incomplete && HC_IS_RUNNING(ehci_to_hcd(ehci)->state)) {
+			ehci->next_uframe = now_uframe;
+			break;
+		}
 
 		// FIXME:  this assumes we won't get lapped when
 		// latencies climb; that should be rare, but...
@@ -2224,7 +2300,8 @@
 		if (now_uframe == clock) {
 			unsigned	now;
 
-			if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state))
+			if (!HC_IS_RUNNING (ehci_to_hcd(ehci)->state)
+					|| ehci->periodic_sched == 0)
 				break;
 			ehci->next_uframe = now_uframe;
 			now = ehci_readl(ehci, &ehci->regs->frame_index) % mod;
@@ -2233,6 +2310,11 @@
 
 			/* rescan the rest of this frame, then ... */
 			clock = now;
+			clock_frame = clock >> 3;
+			if (ehci->clock_frame != clock_frame) {
+				free_cached_itd_list(ehci);
+				ehci->clock_frame = clock_frame;
+			}
 		} else {
 			now_uframe++;
 			now_uframe %= mod;
diff -urN host/ehci.h host.new/ehci.h
--- host/ehci.h	2009-04-09 20:06:11.981152556 +0200
+++ host.new/ehci.h	2009-03-28 17:46:02.000000000 +0100
@@ -74,7 +74,6 @@
 	/* async schedule support */
 	struct ehci_qh		*async;
 	struct ehci_qh		*reclaim;
-	unsigned		reclaim_ready : 1;
 	unsigned		scanning : 1;
 
 	/* periodic schedule support */
@@ -88,6 +87,10 @@
 	int			next_uframe;	/* scan periodic, start here */
 	unsigned		periodic_sched;	/* periodic activity count */
 
+	/* list of itds completed while clock_frame was still active */
+	struct list_head	cached_itd_list;
+	unsigned		clock_frame;
+
 	/* per root hub port */
 	unsigned long		reset_done [EHCI_MAX_ROOT_PORTS];
 
@@ -98,6 +101,10 @@
 			dedicated to the companion controller */
 	unsigned long		owned_ports;		/* which ports are
 			owned by the companion during a bus suspend */
+	unsigned long		port_c_suspend;		/* which ports have
+			the change-suspend feature turned on */
+	unsigned long		suspended_ports;	/* which ports are
+			suspended */
 
 	/* per-HC memory pools (could be per-bus, but ...) */
 	struct dma_pool		*qh_pool;	/* qh per active urb */
@@ -105,6 +112,7 @@
 	struct dma_pool		*itd_pool;	/* itd per iso urb */
 	struct dma_pool		*sitd_pool;	/* sitd per split iso urb */
 
+	struct timer_list	iaa_watchdog;
 	struct timer_list	watchdog;
 	unsigned long		actions;
 	unsigned		stamp;
@@ -112,11 +120,20 @@
 	u32			command;
 
 	/* SILICON QUIRKS */
-	unsigned		is_tdi_rh_tt:1;	/* TDI roothub with TT */
 	unsigned		no_selective_suspend:1;
 	unsigned		has_fsl_port_bug:1; /* FreeScale */
 	unsigned		big_endian_mmio:1;
 	unsigned		big_endian_desc:1;
+	unsigned		has_amcc_usb23:1;
+
+	/* required for usb32 quirk */
+	#define OHCI_CTRL_HCFS          (3 << 6)
+	#define OHCI_USB_OPER           (2 << 6)
+	#define OHCI_USB_SUSPEND        (3 << 6)
+
+	#define OHCI_HCCTRL_OFFSET      0x4
+	#define OHCI_HCCTRL_LEN         0x4
+	__hc32			*ohci_hcctrl_reg;
 
 	u8			sbrn;		/* packed release number */
 
@@ -127,6 +144,14 @@
 #else
 #	define COUNT(x) do {} while (0)
 #endif
+
+	/* debug files */
+#ifdef DEBUG
+	struct dentry		*debug_dir;
+	struct dentry		*debug_async;
+	struct dentry		*debug_periodic;
+	struct dentry		*debug_registers;
+#endif
 };
 
 /* convert between an HCD pointer and the corresponding EHCI_HCD */
@@ -140,9 +165,21 @@
 }
 
 
+static inline void
+iaa_watchdog_start(struct ehci_hcd *ehci)
+{
+	WARN_ON(timer_pending(&ehci->iaa_watchdog));
+	mod_timer(&ehci->iaa_watchdog,
+			jiffies + msecs_to_jiffies(EHCI_IAA_MSECS));
+}
+
+static inline void iaa_watchdog_done(struct ehci_hcd *ehci)
+{
+	del_timer(&ehci->iaa_watchdog);
+}
+
 enum ehci_timer_action {
 	TIMER_IO_WATCHDOG,
-	TIMER_IAA_WATCHDOG,
 	TIMER_ASYNC_SHRINK,
 	TIMER_ASYNC_OFF,
 };
@@ -153,228 +190,11 @@
 	clear_bit (action, &ehci->actions);
 }
 
-static inline void
-timer_action (struct ehci_hcd *ehci, enum ehci_timer_action action)
-{
-	if (!test_and_set_bit (action, &ehci->actions)) {
-		unsigned long t;
-
-		switch (action) {
-		case TIMER_IAA_WATCHDOG:
-			t = EHCI_IAA_JIFFIES;
-			break;
-		case TIMER_IO_WATCHDOG:
-			t = EHCI_IO_JIFFIES;
-			break;
-		case TIMER_ASYNC_OFF:
-			t = EHCI_ASYNC_JIFFIES;
-			break;
-		// case TIMER_ASYNC_SHRINK:
-		default:
-			t = EHCI_SHRINK_JIFFIES;
-			break;
-		}
-		t += jiffies;
-		// all timings except IAA watchdog can be overridden.
-		// async queue SHRINK often precedes IAA.  while it's ready
-		// to go OFF neither can matter, and afterwards the IO
-		// watchdog stops unless there's still periodic traffic.
-		if (action != TIMER_IAA_WATCHDOG
-				&& t > ehci->watchdog.expires
-				&& timer_pending (&ehci->watchdog))
-			return;
-		mod_timer (&ehci->watchdog, t);
-	}
-}
+static void free_cached_itd_list(struct ehci_hcd *ehci);
 
 /*-------------------------------------------------------------------------*/
 
-/* EHCI register interface, corresponds to EHCI Revision 0.95 specification */
-
-/* Section 2.2 Host Controller Capability Registers */
-struct ehci_caps {
-	/* these fields are specified as 8 and 16 bit registers,
-	 * but some hosts can't perform 8 or 16 bit PCI accesses.
-	 */
-	u32		hc_capbase;
-#define HC_LENGTH(p)		(((p)>>00)&0x00ff)	/* bits 7:0 */
-#define HC_VERSION(p)		(((p)>>16)&0xffff)	/* bits 31:16 */
-	u32		hcs_params;     /* HCSPARAMS - offset 0x4 */
-#ifndef CONFIG_SL2312_USB
-#define HCS_DEBUG_PORT(p)	(((p)>>20)&0xf)	/* bits 23:20, debug port? */
-#define HCS_INDICATOR(p)	((p)&(1 << 16))	/* true: has port indicators */
-#define HCS_N_CC(p)		(((p)>>12)&0xf)	/* bits 15:12, #companion HCs */
-#else
-#define HCS_DEBUG_PORT(p)	(0)
-#define HCS_INDICATOR(p)	(0)
-#define HCS_N_CC(p)		(0)
-#endif
-
-#define HCS_N_PCC(p)		(((p)>>8)&0xf)	/* bits 11:8, ports per CC */
-#ifndef CONFIG_SL2312_USB
-#define HCS_PORTROUTED(p)	((p)&(1 << 7))	/* true: port routing */
-#define HCS_PPC(p)		((p)&(1 << 4))	/* true: port power control */
-#else
-#define HCS_PORTROUTED(p)	(0)	/* true: port routing */
-#define HCS_PPC(p)		(0)	/* true: port power control */
-#endif
-
-#define HCS_N_PORTS(p)		(((p)>>0)&0xf)	/* bits 3:0, ports on HC */
-
-	u32		hcc_params;      /* HCCPARAMS - offset 0x8 */
-#ifndef CONFIG_SL2312_USB
-#define HCC_EXT_CAPS(p)		(((p)>>8)&0xff)	/* for pci extended caps */
-#else
-#define HCC_EXT_CAPS(p)		(0)	/* for pci extended caps */
-#endif
-
-#define HCC_ISOC_CACHE(p)       ((p)&(1 << 7))  /* true: can cache isoc frame */
-
-#ifndef CONFIG_SL2312_USB
-#define HCC_ISOC_THRES(p)       (((p)>>4)&0x7)  /* bits 6:4, uframes cached */
-#define HCC_CANPARK(p)		((p)&(1 << 2))  /* true: can park on async qh */
-#else
-#define HCC_ISOC_THRES(p)       (0)  /* bits 6:4, uframes cached */
-#define HCC_CANPARK(p)		(0)  /* true: can park on async qh */
-#endif
-
-#define HCC_PGM_FRAMELISTLEN(p) ((p)&(1 << 1))  /* true: periodic_size changes*/
-
-#ifndef CONFIG_SL2312_USB
-#define HCC_64BIT_ADDR(p)       ((p)&(1))       /* true: can use 64-bit addr */
-#else
-#define HCC_64BIT_ADDR(p)       (0)       /* true: can use 64-bit addr */
-#endif
-
-	u8		portroute [8];	 /* nibbles for routing - offset 0xC */
-} __attribute__ ((packed));
-
-
-/* Section 2.3 Host Controller Operational Registers */
-struct ehci_regs {
-
-	/* USBCMD: offset 0x00 */
-	u32		command;
-/* 23:16 is r/w intr rate, in microframes; default "8" == 1/msec */
-#define CMD_PARK	(1<<11)		/* enable "park" on async qh */
-#define CMD_PARK_CNT(c)	(((c)>>8)&3)	/* how many transfers to park for */
-
-#ifndef CONFIG_SL2312_USB
-#define CMD_LRESET	(1<<7)		/* partial reset (no ports, etc) */
-#else
-#define CMD_LRESET	(0)
-#endif
-#define CMD_IAAD	(1<<6)		/* "doorbell" interrupt async advance */
-#define CMD_ASE		(1<<5)		/* async schedule enable */
-#define CMD_PSE		(1<<4)		/* periodic schedule enable */
-/* 3:2 is periodic frame list size */
-#define CMD_RESET	(1<<1)		/* reset HC not bus */
-#define CMD_RUN		(1<<0)		/* start/stop HC */
-
-	/* USBSTS: offset 0x04 */
-	u32		status;
-#define STS_ASS		(1<<15)		/* Async Schedule Status */
-#define STS_PSS		(1<<14)		/* Periodic Schedule Status */
-#define STS_RECL	(1<<13)		/* Reclamation */
-#define STS_HALT	(1<<12)		/* Not running (any reason) */
-/* some bits reserved */
-	/* these STS_* flags are also intr_enable bits (USBINTR) */
-#define STS_IAA		(1<<5)		/* Interrupted on async advance */
-#define STS_FATAL	(1<<4)		/* such as some PCI access errors */
-#define STS_FLR		(1<<3)		/* frame list rolled over */
-#define STS_PCD		(1<<2)		/* port change detect */
-#define STS_ERR		(1<<1)		/* "error" completion (overflow, ...) */
-#define STS_INT		(1<<0)		/* "normal" completion (short, ...) */
-
-	/* USBINTR: offset 0x08 */
-	u32		intr_enable;
-
-	/* FRINDEX: offset 0x0C */
-	u32		frame_index;	/* current microframe number */
-
-#ifdef CONFIG_SL2312_USB
-	u32		reserved1[1];
-#else
-	/* CTRLDSSEGMENT: offset 0x10 */
-	u32		segment;	/* address bits 63:32 if needed */
-#endif
-	/* PERIODICLISTBASE: offset 0x14 */
-	u32		frame_list;	/* points to periodic list */
-	/* ASYNCLISTADDR: offset 0x18 */
-	u32		async_next;	/* address of next async queue head */
-
-#ifdef CONFIG_SL2312_USB
-	u32		reserved2[1];
-#else
-	u32		reserved [9];
-
-	/* CONFIGFLAG: offset 0x40 */
-	u32		configured_flag;
-#define FLAG_CF		(1<<0)		/* true: we'll support "high speed" */
-#endif
-
-	/* PORTSC: offset 0x44 */
-#ifdef CONFIG_SL2312_USB
-	u32		port_status [1];	/* up to N_PORTS */
-#else
-	u32		port_status [0];	/* up to N_PORTS */
-#endif
-/* 31:23 reserved */
-#define PORT_WKOC_E	(1<<22)		/* wake on overcurrent (enable) */
-#define PORT_WKDISC_E	(1<<21)		/* wake on disconnect (enable) */
-#define PORT_WKCONN_E	(1<<20)		/* wake on connect (enable) */
-/* 19:16 for port testing */
-#define PORT_LED_OFF	(0<<14)
-#define PORT_LED_AMBER	(1<<14)
-#define PORT_LED_GREEN	(2<<14)
-#define PORT_LED_MASK	(3<<14)
-#define PORT_OWNER	(1<<13)		/* true: companion hc owns this port */
-#define PORT_POWER	(1<<12)		/* true: has power (see PPC) */
-#define PORT_USB11(x) (((x)&(3<<10))==(1<<10))	/* USB 1.1 device */
-/* 11:10 for detecting lowspeed devices (reset vs release ownership) */
-/* 9 reserved */
-#define PORT_RESET	(1<<8)		/* reset port */
-#define PORT_SUSPEND	(1<<7)		/* suspend port */
-#define PORT_RESUME	(1<<6)		/* resume it */
-#define PORT_OCC	(1<<5)		/* over current change */
-#define PORT_OC		(1<<4)		/* over current active */
-#define PORT_PEC	(1<<3)		/* port enable change */
-#define PORT_PE		(1<<2)		/* port enable */
-#define PORT_CSC	(1<<1)		/* connect status change */
-#define PORT_CONNECT	(1<<0)		/* device connected */
-#define PORT_RWC_BITS   (PORT_CSC | PORT_PEC | PORT_OCC)
-} __attribute__ ((packed));
-
-#define USBMODE		0x68		/* USB Device mode */
-#define USBMODE_SDIS	(1<<3)		/* Stream disable */
-#define USBMODE_BE	(1<<2)		/* BE/LE endianness select */
-#define USBMODE_CM_HC	(3<<0)		/* host controller mode */
-#define USBMODE_CM_IDLE	(0<<0)		/* idle state */
-
-/* Appendix C, Debug port ... intended for use with special "debug devices"
- * that can help if there's no serial console.  (nonstandard enumeration.)
- */
-struct ehci_dbg_port {
-	u32	control;
-#define DBGP_OWNER	(1<<30)
-#define DBGP_ENABLED	(1<<28)
-#define DBGP_DONE	(1<<16)
-#define DBGP_INUSE	(1<<10)
-#define DBGP_ERRCODE(x)	(((x)>>7)&0x07)
-#	define DBGP_ERR_BAD	1
-#	define DBGP_ERR_SIGNAL	2
-#define DBGP_ERROR	(1<<6)
-#define DBGP_GO		(1<<5)
-#define DBGP_OUT	(1<<4)
-#define DBGP_LEN(x)	(((x)>>0)&0x0f)
-	u32	pids;
-#define DBGP_PID_GET(x)		(((x)>>16)&0xff)
-#define DBGP_PID_SET(data,tok)	(((data)<<8)|(tok))
-	u32	data03;
-	u32	data47;
-	u32	address;
-#define DBGP_EPADDR(dev,ep)	(((dev)<<8)|(ep))
-} __attribute__ ((packed));
+#include <linux/usb/ehci_def.h>
 
 /*-------------------------------------------------------------------------*/
 
@@ -433,7 +253,7 @@
 
 /*
  * Now the following defines are not converted using the
- * __constant_cpu_to_le32() macro anymore, since we have to support
+ * cpu_to_le32() macro anymore, since we have to support
  * "dynamic" switching between be and le support, so that the driver
  * can be used on one system with SoC EHCI controller using big-endian
  * descriptors as well as a normal little-endian PCI EHCI controller.
@@ -522,6 +342,9 @@
 #define	QH_STATE_UNLINK_WAIT	4		/* LINKED and on reclaim q */
 #define	QH_STATE_COMPLETING	5		/* don't touch token.HALT */
 
+	u8			xacterrs;	/* XactErr retry counter */
+#define	QH_XACTERR_MAX		32		/* XactErr retry limit */
+
 	/* periodic schedule info */
 	u8			usecs;		/* intr bandwidth */
 	u8			gap_uf;		/* uframes split/csplit gap */
@@ -583,8 +406,8 @@
 	 * trusting urb->interval == f(epdesc->bInterval) and
 	 * including the extra info for hw_bufp[0..2]
 	 */
-	u8			interval;
 	u8			usecs, c_usecs;
+	u16			interval;
 	u16			tt_usecs;
 	u16			maxp;
 	u16			raw_mask;
@@ -635,7 +458,6 @@
 	unsigned		frame;		/* where scheduled */
 	unsigned		pg;
 	unsigned		index[8];	/* in urb->iso_frame_desc */
-	u8			usecs[8];
 } __attribute__ ((aligned (32)));
 
 /*-------------------------------------------------------------------------*/
@@ -712,15 +534,19 @@
  * needed (mostly in root hub code).
  */
 
-#define	ehci_is_TDI(e)			((e)->is_tdi_rh_tt)
+#define	ehci_is_TDI(e)			(ehci_to_hcd(e)->has_tt)
 
 /* Returns the speed of a device attached to a port on the root hub. */
 static inline unsigned int
 ehci_port_speed(struct ehci_hcd *ehci, unsigned int portsc)
 {
 	if (ehci_is_TDI(ehci)) {
+#ifdef CONFIG_ARCH_GEMINI
 		portsc = readl(ehci_to_hcd(ehci)->regs + 0x80);
 		switch ((portsc>>22)&3) {
+#else
+		switch ((portsc>>26)&3) {
+#endif
 		case 0:
 			return 0;
 		case 1:
@@ -770,14 +596,10 @@
 /*
  * Big-endian read/write functions are arch-specific.
  * Other arches can be added if/when they're needed.
- *
- * REVISIT: arch/powerpc now has readl/writel_be, so the
- * definition below can die once the 4xx support is
- * finally ported over.
- */
-#if defined(CONFIG_PPC)
-#define readl_be(addr)		in_be32((__force unsigned *)addr)
-#define writel_be(val, addr)	out_be32((__force unsigned *)addr, val)
+ */
+#if defined(CONFIG_ARM) && defined(CONFIG_ARCH_IXP4XX)
+#define readl_be(addr)		__raw_readl((__force unsigned *)addr)
+#define writel_be(val, addr)	__raw_writel(val, (__force unsigned *)addr)
 #endif
 
 static inline unsigned int ehci_readl(const struct ehci_hcd *ehci,
@@ -804,6 +626,30 @@
 #endif
 }
 
+/*
+ * On certain ppc-44x SoC there is a HW issue, that could only worked around with
+ * explicit suspend/operate of OHCI. This function hereby makes sense only on that arch.
+ * Other common bits are dependant on has_amcc_usb23 quirk flag.
+ */
+#ifdef CONFIG_44x
+static inline void set_ohci_hcfs(struct ehci_hcd *ehci, int operational)
+{
+	u32 hc_control;
+
+	hc_control = (readl_be(ehci->ohci_hcctrl_reg) & ~OHCI_CTRL_HCFS);
+	if (operational)
+		hc_control |= OHCI_USB_OPER;
+	else
+		hc_control |= OHCI_USB_SUSPEND;
+
+	writel_be(hc_control, ehci->ohci_hcctrl_reg);
+	(void) readl_be(ehci->ohci_hcctrl_reg);
+}
+#else
+static inline void set_ohci_hcfs(struct ehci_hcd *ehci, int operational)
+{ }
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 /*
diff -urN host/fhci-dbg.c host.new/fhci-dbg.c
--- host/fhci-dbg.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/fhci-dbg.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,139 @@
+/*
+ * Freescale QUICC Engine USB Host Controller Driver
+ *
+ * Copyright (c) Freescale Semicondutor, Inc. 2006.
+ *               Shlomi Gridish <gridish@freescale.com>
+ *               Jerry Huang <Chang-Ming.Huang@freescale.com>
+ * Copyright (c) Logic Product Development, Inc. 2007
+ *               Peter Barada <peterb@logicpd.com>
+ * Copyright (c) MontaVista Software, Inc. 2008.
+ *               Anton Vorontsov <avorontsov@ru.mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/usb.h>
+#include "../core/hcd.h"
+#include "fhci.h"
+
+void fhci_dbg_isr(struct fhci_hcd *fhci, int usb_er)
+{
+	int i;
+
+	if (usb_er == -1) {
+		fhci->usb_irq_stat[12]++;
+		return;
+	}
+
+	for (i = 0; i < 12; ++i) {
+		if (usb_er & (1 << i))
+			fhci->usb_irq_stat[i]++;
+	}
+}
+
+static int fhci_dfs_regs_show(struct seq_file *s, void *v)
+{
+	struct fhci_hcd *fhci = s->private;
+	struct fhci_regs __iomem *regs = fhci->regs;
+
+	seq_printf(s,
+		"mode: 0x%x\n" "addr: 0x%x\n"
+		"command: 0x%x\n" "ep0: 0x%x\n"
+		"event: 0x%x\n" "mask: 0x%x\n"
+		"status: 0x%x\n" "SOF timer: %d\n"
+		"frame number: %d\n"
+		"lines status: 0x%x\n",
+		in_8(&regs->usb_mod), in_8(&regs->usb_addr),
+		in_8(&regs->usb_comm), in_be16(&regs->usb_ep[0]),
+		in_be16(&regs->usb_event), in_be16(&regs->usb_mask),
+		in_8(&regs->usb_status), in_be16(&regs->usb_sof_tmr),
+		in_be16(&regs->usb_frame_num),
+		fhci_ioports_check_bus_state(fhci));
+
+	return 0;
+}
+
+static int fhci_dfs_irq_stat_show(struct seq_file *s, void *v)
+{
+	struct fhci_hcd *fhci = s->private;
+	int *usb_irq_stat = fhci->usb_irq_stat;
+
+	seq_printf(s,
+		"RXB: %d\n" "TXB: %d\n" "BSY: %d\n"
+		"SOF: %d\n" "TXE0: %d\n" "TXE1: %d\n"
+		"TXE2: %d\n" "TXE3: %d\n" "IDLE: %d\n"
+		"RESET: %d\n" "SFT: %d\n" "MSF: %d\n"
+		"IDLE_ONLY: %d\n",
+		usb_irq_stat[0], usb_irq_stat[1], usb_irq_stat[2],
+		usb_irq_stat[3], usb_irq_stat[4], usb_irq_stat[5],
+		usb_irq_stat[6], usb_irq_stat[7], usb_irq_stat[8],
+		usb_irq_stat[9], usb_irq_stat[10], usb_irq_stat[11],
+		usb_irq_stat[12]);
+
+	return 0;
+}
+
+static int fhci_dfs_regs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, fhci_dfs_regs_show, inode->i_private);
+}
+
+static int fhci_dfs_irq_stat_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, fhci_dfs_irq_stat_show, inode->i_private);
+}
+
+static const struct file_operations fhci_dfs_regs_fops = {
+	.open = fhci_dfs_regs_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static const struct file_operations fhci_dfs_irq_stat_fops = {
+	.open = fhci_dfs_irq_stat_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+void fhci_dfs_create(struct fhci_hcd *fhci)
+{
+	struct device *dev = fhci_to_hcd(fhci)->self.controller;
+
+	fhci->dfs_root = debugfs_create_dir(dev_name(dev), NULL);
+	if (!fhci->dfs_root) {
+		WARN_ON(1);
+		return;
+	}
+
+	fhci->dfs_regs = debugfs_create_file("regs", S_IFREG | S_IRUGO,
+		fhci->dfs_root, fhci, &fhci_dfs_regs_fops);
+
+	fhci->dfs_irq_stat = debugfs_create_file("irq_stat",
+		S_IFREG | S_IRUGO, fhci->dfs_root, fhci,
+		&fhci_dfs_irq_stat_fops);
+
+	WARN_ON(!fhci->dfs_regs || !fhci->dfs_irq_stat);
+}
+
+void fhci_dfs_destroy(struct fhci_hcd *fhci)
+{
+	if (!fhci->dfs_root)
+		return;
+
+	if (fhci->dfs_irq_stat)
+		debugfs_remove(fhci->dfs_irq_stat);
+
+	if (fhci->dfs_regs)
+		debugfs_remove(fhci->dfs_regs);
+
+	debugfs_remove(fhci->dfs_root);
+}
diff -urN host/fhci-hcd.c host.new/fhci-hcd.c
--- host/fhci-hcd.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/fhci-hcd.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,836 @@
+/*
+ * Freescale QUICC Engine USB Host Controller Driver
+ *
+ * Copyright (c) Freescale Semicondutor, Inc. 2006.
+ *               Shlomi Gridish <gridish@freescale.com>
+ *               Jerry Huang <Chang-Ming.Huang@freescale.com>
+ * Copyright (c) Logic Product Development, Inc. 2007
+ *               Peter Barada <peterb@logicpd.com>
+ * Copyright (c) MontaVista Software, Inc. 2008.
+ *               Anton Vorontsov <avorontsov@ru.mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/usb.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <asm/qe.h>
+#include <asm/fsl_gtm.h>
+#include "../core/hcd.h"
+#include "fhci.h"
+
+void fhci_start_sof_timer(struct fhci_hcd *fhci)
+{
+	fhci_dbg(fhci, "-> %s\n", __func__);
+
+	/* clear frame_n */
+	out_be16(&fhci->pram->frame_num, 0);
+
+	out_be16(&fhci->regs->usb_sof_tmr, 0);
+	setbits8(&fhci->regs->usb_mod, USB_MODE_SFTE);
+
+	fhci_dbg(fhci, "<- %s\n", __func__);
+}
+
+void fhci_stop_sof_timer(struct fhci_hcd *fhci)
+{
+	fhci_dbg(fhci, "-> %s\n", __func__);
+
+	clrbits8(&fhci->regs->usb_mod, USB_MODE_SFTE);
+	gtm_stop_timer16(fhci->timer);
+
+	fhci_dbg(fhci, "<- %s\n", __func__);
+}
+
+u16 fhci_get_sof_timer_count(struct fhci_usb *usb)
+{
+	return be16_to_cpu(in_be16(&usb->fhci->regs->usb_sof_tmr) / 12);
+}
+
+/* initialize the endpoint zero */
+static u32 endpoint_zero_init(struct fhci_usb *usb,
+			      enum fhci_mem_alloc data_mem,
+			      u32 ring_len)
+{
+	u32 rc;
+
+	rc = fhci_create_ep(usb, data_mem, ring_len);
+	if (rc)
+		return rc;
+
+	/* inilialize endpoint registers */
+	fhci_init_ep_registers(usb, usb->ep0, data_mem);
+
+	return 0;
+}
+
+/* enable the USB interrupts */
+void fhci_usb_enable_interrupt(struct fhci_usb *usb)
+{
+	struct fhci_hcd *fhci = usb->fhci;
+
+	if (usb->intr_nesting_cnt == 1) {
+		/* initialize the USB interrupt */
+		enable_irq(fhci_to_hcd(fhci)->irq);
+
+		/* initialize the event register and mask register */
+		out_be16(&usb->fhci->regs->usb_event, 0xffff);
+		out_be16(&usb->fhci->regs->usb_mask, usb->saved_msk);
+
+		/* enable the timer interrupts */
+		enable_irq(fhci->timer->irq);
+	} else if (usb->intr_nesting_cnt > 1)
+		fhci_info(fhci, "unbalanced USB interrupts nesting\n");
+	usb->intr_nesting_cnt--;
+}
+
+/* diable the usb interrupt */
+void fhci_usb_disable_interrupt(struct fhci_usb *usb)
+{
+	struct fhci_hcd *fhci = usb->fhci;
+
+	if (usb->intr_nesting_cnt == 0) {
+		/* diable the timer interrupt */
+		disable_irq_nosync(fhci->timer->irq);
+
+		/* disable the usb interrupt */
+		disable_irq_nosync(fhci_to_hcd(fhci)->irq);
+		out_be16(&usb->fhci->regs->usb_mask, 0);
+	}
+	usb->intr_nesting_cnt++;
+}
+
+/* enable the USB controller */
+static u32 fhci_usb_enable(struct fhci_hcd *fhci)
+{
+	struct fhci_usb *usb = fhci->usb_lld;
+
+	out_be16(&usb->fhci->regs->usb_event, 0xffff);
+	out_be16(&usb->fhci->regs->usb_mask, usb->saved_msk);
+	setbits8(&usb->fhci->regs->usb_mod, USB_MODE_EN);
+
+	mdelay(100);
+
+	return 0;
+}
+
+/* disable the USB controller */
+static u32 fhci_usb_disable(struct fhci_hcd *fhci)
+{
+	struct fhci_usb *usb = fhci->usb_lld;
+
+	fhci_usb_disable_interrupt(usb);
+	fhci_port_disable(fhci);
+
+	/* disable the usb controller */
+	if (usb->port_status == FHCI_PORT_FULL ||
+			usb->port_status == FHCI_PORT_LOW)
+		fhci_device_disconnected_interrupt(fhci);
+
+	clrbits8(&usb->fhci->regs->usb_mod, USB_MODE_EN);
+
+	return 0;
+}
+
+/* check the bus state by polling the QE bit on the IO ports */
+int fhci_ioports_check_bus_state(struct fhci_hcd *fhci)
+{
+	u8 bits = 0;
+
+	/* check USBOE,if transmitting,exit */
+	if (!gpio_get_value(fhci->gpios[GPIO_USBOE]))
+		return -1;
+
+	/* check USBRP */
+	if (gpio_get_value(fhci->gpios[GPIO_USBRP]))
+		bits |= 0x2;
+
+	/* check USBRN */
+	if (gpio_get_value(fhci->gpios[GPIO_USBRN]))
+		bits |= 0x1;
+
+	return bits;
+}
+
+static void fhci_mem_free(struct fhci_hcd *fhci)
+{
+	struct ed *ed;
+	struct ed *next_ed;
+	struct td *td;
+	struct td *next_td;
+
+	list_for_each_entry_safe(ed, next_ed, &fhci->empty_eds, node) {
+		list_del(&ed->node);
+		kfree(ed);
+	}
+
+	list_for_each_entry_safe(td, next_td, &fhci->empty_tds, node) {
+		list_del(&td->node);
+		kfree(td);
+	}
+
+	kfree(fhci->vroot_hub);
+	fhci->vroot_hub = NULL;
+
+	kfree(fhci->hc_list);
+	fhci->hc_list = NULL;
+}
+
+static int fhci_mem_init(struct fhci_hcd *fhci)
+{
+	int i;
+
+	fhci->hc_list = kzalloc(sizeof(*fhci->hc_list), GFP_KERNEL);
+	if (!fhci->hc_list)
+		goto err;
+
+	INIT_LIST_HEAD(&fhci->hc_list->ctrl_list);
+	INIT_LIST_HEAD(&fhci->hc_list->bulk_list);
+	INIT_LIST_HEAD(&fhci->hc_list->iso_list);
+	INIT_LIST_HEAD(&fhci->hc_list->intr_list);
+	INIT_LIST_HEAD(&fhci->hc_list->done_list);
+
+	fhci->vroot_hub = kzalloc(sizeof(*fhci->vroot_hub), GFP_KERNEL);
+	if (!fhci->vroot_hub)
+		goto err;
+
+	INIT_LIST_HEAD(&fhci->empty_eds);
+	INIT_LIST_HEAD(&fhci->empty_tds);
+
+	/* initialize work queue to handle done list */
+	fhci_tasklet.data = (unsigned long)fhci;
+	fhci->process_done_task = &fhci_tasklet;
+
+	for (i = 0; i < MAX_TDS; i++) {
+		struct td *td;
+
+		td = kmalloc(sizeof(*td), GFP_KERNEL);
+		if (!td)
+			goto err;
+		fhci_recycle_empty_td(fhci, td);
+	}
+	for (i = 0; i < MAX_EDS; i++) {
+		struct ed *ed;
+
+		ed = kmalloc(sizeof(*ed), GFP_KERNEL);
+		if (!ed)
+			goto err;
+		fhci_recycle_empty_ed(fhci, ed);
+	}
+
+	fhci->active_urbs = 0;
+	return 0;
+err:
+	fhci_mem_free(fhci);
+	return -ENOMEM;
+}
+
+/* destroy the fhci_usb structure */
+static void fhci_usb_free(void *lld)
+{
+	struct fhci_usb *usb = lld;
+	struct fhci_hcd *fhci = usb->fhci;
+
+	if (usb) {
+		fhci_config_transceiver(fhci, FHCI_PORT_POWER_OFF);
+		fhci_ep0_free(usb);
+		kfree(usb->actual_frame);
+		kfree(usb);
+	}
+}
+
+/* initialize the USB */
+static int fhci_usb_init(struct fhci_hcd *fhci)
+{
+	struct fhci_usb *usb = fhci->usb_lld;
+
+	memset_io(usb->fhci->pram, 0, FHCI_PRAM_SIZE);
+
+	usb->port_status = FHCI_PORT_DISABLED;
+	usb->max_frame_usage = FRAME_TIME_USAGE;
+	usb->sw_transaction_time = SW_FIX_TIME_BETWEEN_TRANSACTION;
+
+	usb->actual_frame = kzalloc(sizeof(*usb->actual_frame), GFP_KERNEL);
+	if (!usb->actual_frame) {
+		fhci_usb_free(usb);
+		return -ENOMEM;
+	}
+
+	INIT_LIST_HEAD(&usb->actual_frame->tds_list);
+
+	/* initializing registers on chip, clear frame number */
+	out_be16(&fhci->pram->frame_num, 0);
+
+	/* clear rx state */
+	out_be32(&fhci->pram->rx_state, 0);
+
+	/* set mask register */
+	usb->saved_msk = (USB_E_TXB_MASK |
+			  USB_E_TXE1_MASK |
+			  USB_E_IDLE_MASK |
+			  USB_E_RESET_MASK | USB_E_SFT_MASK | USB_E_MSF_MASK);
+
+	out_8(&usb->fhci->regs->usb_mod, USB_MODE_HOST | USB_MODE_EN);
+
+	/* clearing the mask register */
+	out_be16(&usb->fhci->regs->usb_mask, 0);
+
+	/* initialing the event register */
+	out_be16(&usb->fhci->regs->usb_event, 0xffff);
+
+	if (endpoint_zero_init(usb, DEFAULT_DATA_MEM, DEFAULT_RING_LEN) != 0) {
+		fhci_usb_free(usb);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* initialize the fhci_usb struct and the corresponding data staruct */
+static struct fhci_usb *fhci_create_lld(struct fhci_hcd *fhci)
+{
+	struct fhci_usb *usb;
+
+	/* allocate memory for SCC data structure */
+	usb = kzalloc(sizeof(*usb), GFP_KERNEL);
+	if (!usb) {
+		fhci_err(fhci, "no memory for SCC data struct\n");
+		return NULL;
+	}
+
+	usb->fhci = fhci;
+	usb->hc_list = fhci->hc_list;
+	usb->vroot_hub = fhci->vroot_hub;
+
+	usb->transfer_confirm = fhci_transfer_confirm_callback;
+
+	return usb;
+}
+
+static int fhci_start(struct usb_hcd *hcd)
+{
+	int ret;
+	struct fhci_hcd *fhci = hcd_to_fhci(hcd);
+
+	ret = fhci_mem_init(fhci);
+	if (ret) {
+		fhci_err(fhci, "failed to allocate memory\n");
+		goto err;
+	}
+
+	fhci->usb_lld = fhci_create_lld(fhci);
+	if (!fhci->usb_lld) {
+		fhci_err(fhci, "low level driver config failed\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	ret = fhci_usb_init(fhci);
+	if (ret) {
+		fhci_err(fhci, "low level driver initialize failed\n");
+		goto err;
+	}
+
+	spin_lock_init(&fhci->lock);
+
+	/* connect the virtual root hub */
+	fhci->vroot_hub->dev_num = 1;	/* this field may be needed to fix */
+	fhci->vroot_hub->hub.wHubStatus = 0;
+	fhci->vroot_hub->hub.wHubChange = 0;
+	fhci->vroot_hub->port.wPortStatus = 0;
+	fhci->vroot_hub->port.wPortChange = 0;
+
+	hcd->state = HC_STATE_RUNNING;
+
+	/*
+	 * From here on, khubd concurrently accesses the root
+	 * hub; drivers will be talking to enumerated devices.
+	 * (On restart paths, khubd already knows about the root
+	 * hub and could find work as soon as we wrote FLAG_CF.)
+	 *
+	 * Before this point the HC was idle/ready.  After, khubd
+	 * and device drivers may start it running.
+	 */
+	fhci_usb_enable(fhci);
+	return 0;
+err:
+	fhci_mem_free(fhci);
+	return ret;
+}
+
+static void fhci_stop(struct usb_hcd *hcd)
+{
+	struct fhci_hcd *fhci = hcd_to_fhci(hcd);
+
+	fhci_usb_disable_interrupt(fhci->usb_lld);
+	fhci_usb_disable(fhci);
+
+	fhci_usb_free(fhci->usb_lld);
+	fhci->usb_lld = NULL;
+	fhci_mem_free(fhci);
+}
+
+static int fhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
+			    gfp_t mem_flags)
+{
+	struct fhci_hcd *fhci = hcd_to_fhci(hcd);
+	u32 pipe = urb->pipe;
+	int ret;
+	int i;
+	int size = 0;
+	struct urb_priv *urb_priv;
+	unsigned long flags;
+
+	switch (usb_pipetype(pipe)) {
+	case PIPE_CONTROL:
+		/* 1 td fro setup,1 for ack */
+		size = 2;
+	case PIPE_BULK:
+		/* one td for every 4096 bytes(can be upto 8k) */
+		size += urb->transfer_buffer_length / 4096;
+		/* ...add for any remaining bytes... */
+		if ((urb->transfer_buffer_length % 4096) != 0)
+			size++;
+		/* ..and maybe a zero length packet to wrap it up */
+		if (size == 0)
+			size++;
+		else if ((urb->transfer_flags & URB_ZERO_PACKET) != 0
+			 && (urb->transfer_buffer_length
+			     % usb_maxpacket(urb->dev, pipe,
+					     usb_pipeout(pipe))) != 0)
+			size++;
+		break;
+	case PIPE_ISOCHRONOUS:
+		size = urb->number_of_packets;
+		if (size <= 0)
+			return -EINVAL;
+		for (i = 0; i < urb->number_of_packets; i++) {
+			urb->iso_frame_desc[i].actual_length = 0;
+			urb->iso_frame_desc[i].status = (u32) (-EXDEV);
+		}
+		break;
+	case PIPE_INTERRUPT:
+		size = 1;
+	}
+
+	/* allocate the private part of the URB */
+	urb_priv = kzalloc(sizeof(*urb_priv), mem_flags);
+	if (!urb_priv)
+		return -ENOMEM;
+
+	/* allocate the private part of the URB */
+	urb_priv->tds = kzalloc(size * sizeof(struct td), mem_flags);
+	if (!urb_priv->tds) {
+		kfree(urb_priv);
+		return -ENOMEM;
+	}
+
+	spin_lock_irqsave(&fhci->lock, flags);
+
+	ret = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (ret)
+		goto err;
+
+	/* fill the private part of the URB */
+	urb_priv->num_of_tds = size;
+
+	urb->status = -EINPROGRESS;
+	urb->actual_length = 0;
+	urb->error_count = 0;
+	urb->hcpriv = urb_priv;
+
+	fhci_queue_urb(fhci, urb);
+err:
+	if (ret) {
+		kfree(urb_priv->tds);
+		kfree(urb_priv);
+	}
+	spin_unlock_irqrestore(&fhci->lock, flags);
+	return ret;
+}
+
+/* dequeue FHCI URB */
+static int fhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
+{
+	struct fhci_hcd *fhci = hcd_to_fhci(hcd);
+	struct fhci_usb *usb = fhci->usb_lld;
+	int ret = -EINVAL;
+	unsigned long flags;
+
+	if (!urb || !urb->dev || !urb->dev->bus)
+		goto out;
+
+	spin_lock_irqsave(&fhci->lock, flags);
+
+	ret = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (ret)
+		goto out2;
+
+	if (usb->port_status != FHCI_PORT_DISABLED) {
+		struct urb_priv *urb_priv;
+
+		/*
+		 * flag the urb's data for deletion in some upcoming
+		 * SF interrupt's delete list processing
+		 */
+		urb_priv = urb->hcpriv;
+
+		if (!urb_priv || (urb_priv->state == URB_DEL))
+			goto out2;
+
+		urb_priv->state = URB_DEL;
+
+		/* already pending? */
+		urb_priv->ed->state = FHCI_ED_URB_DEL;
+	} else {
+		fhci_urb_complete_free(fhci, urb);
+	}
+
+out2:
+	spin_unlock_irqrestore(&fhci->lock, flags);
+out:
+	return ret;
+}
+
+static void fhci_endpoint_disable(struct usb_hcd *hcd,
+				  struct usb_host_endpoint *ep)
+{
+	struct fhci_hcd *fhci;
+	struct ed *ed;
+	unsigned long flags;
+
+	fhci = hcd_to_fhci(hcd);
+	spin_lock_irqsave(&fhci->lock, flags);
+	ed = ep->hcpriv;
+	if (ed) {
+		while (ed->td_head != NULL) {
+			struct td *td = fhci_remove_td_from_ed(ed);
+			fhci_urb_complete_free(fhci, td->urb);
+		}
+		fhci_recycle_empty_ed(fhci, ed);
+		ep->hcpriv = NULL;
+	}
+	spin_unlock_irqrestore(&fhci->lock, flags);
+}
+
+static int fhci_get_frame_number(struct usb_hcd *hcd)
+{
+	struct fhci_hcd *fhci = hcd_to_fhci(hcd);
+
+	return get_frame_num(fhci);
+}
+
+static const struct hc_driver fhci_driver = {
+	.description = "fsl,usb-fhci",
+	.product_desc = "FHCI HOST Controller",
+	.hcd_priv_size = sizeof(struct fhci_hcd),
+
+	/* generic hardware linkage */
+	.irq = fhci_irq,
+	.flags = HCD_USB11 | HCD_MEMORY,
+
+	/* basic lifecycle operation */
+	.start = fhci_start,
+	.stop = fhci_stop,
+
+	/* managing i/o requests and associated device resources */
+	.urb_enqueue = fhci_urb_enqueue,
+	.urb_dequeue = fhci_urb_dequeue,
+	.endpoint_disable = fhci_endpoint_disable,
+
+	/* scheduling support */
+	.get_frame_number = fhci_get_frame_number,
+
+	/* root hub support */
+	.hub_status_data = fhci_hub_status_data,
+	.hub_control = fhci_hub_control,
+};
+
+static int __devinit of_fhci_probe(struct of_device *ofdev,
+				   const struct of_device_id *ofid)
+{
+	struct device *dev = &ofdev->dev;
+	struct device_node *node = ofdev->node;
+	struct usb_hcd *hcd;
+	struct fhci_hcd *fhci;
+	struct resource usb_regs;
+	unsigned long pram_addr;
+	unsigned int usb_irq;
+	const char *sprop;
+	const u32 *iprop;
+	int size;
+	int ret;
+	int i;
+	int j;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	sprop = of_get_property(node, "mode", NULL);
+	if (sprop && strcmp(sprop, "host"))
+		return -ENODEV;
+
+	hcd = usb_create_hcd(&fhci_driver, dev, dev_name(dev));
+	if (!hcd) {
+		dev_err(dev, "could not create hcd\n");
+		return -ENOMEM;
+	}
+
+	fhci = hcd_to_fhci(hcd);
+	hcd->self.controller = dev;
+	dev_set_drvdata(dev, hcd);
+
+	iprop = of_get_property(node, "hub-power-budget", &size);
+	if (iprop && size == sizeof(*iprop))
+		hcd->power_budget = *iprop;
+
+	/* FHCI registers. */
+	ret = of_address_to_resource(node, 0, &usb_regs);
+	if (ret) {
+		dev_err(dev, "could not get regs\n");
+		goto err_regs;
+	}
+
+	hcd->regs = ioremap(usb_regs.start, usb_regs.end - usb_regs.start + 1);
+	if (!hcd->regs) {
+		dev_err(dev, "could not ioremap regs\n");
+		ret = -ENOMEM;
+		goto err_regs;
+	}
+	fhci->regs = hcd->regs;
+
+	/* Parameter RAM. */
+	iprop = of_get_property(node, "reg", &size);
+	if (!iprop || size < sizeof(*iprop) * 4) {
+		dev_err(dev, "can't get pram offset\n");
+		ret = -EINVAL;
+		goto err_pram;
+	}
+
+	pram_addr = cpm_muram_alloc_fixed(iprop[2], FHCI_PRAM_SIZE);
+	if (IS_ERR_VALUE(pram_addr)) {
+		dev_err(dev, "failed to allocate usb pram\n");
+		ret = -ENOMEM;
+		goto err_pram;
+	}
+	fhci->pram = cpm_muram_addr(pram_addr);
+
+	/* GPIOs and pins */
+	for (i = 0; i < NUM_GPIOS; i++) {
+		int gpio;
+		enum of_gpio_flags flags;
+
+		gpio = of_get_gpio_flags(node, i, &flags);
+		fhci->gpios[i] = gpio;
+		fhci->alow_gpios[i] = flags & OF_GPIO_ACTIVE_LOW;
+
+		if (!gpio_is_valid(gpio)) {
+			if (i < GPIO_SPEED) {
+				dev_err(dev, "incorrect GPIO%d: %d\n",
+					i, gpio);
+				goto err_gpios;
+			} else {
+				dev_info(dev, "assuming board doesn't have "
+					"%s gpio\n", i == GPIO_SPEED ?
+					"speed" : "power");
+				continue;
+			}
+		}
+
+		ret = gpio_request(gpio, dev_name(dev));
+		if (ret) {
+			dev_err(dev, "failed to request gpio %d", i);
+			goto err_gpios;
+		}
+
+		if (i >= GPIO_SPEED) {
+			ret = gpio_direction_output(gpio, 0);
+			if (ret) {
+				dev_err(dev, "failed to set gpio %d as "
+					"an output\n", i);
+				i++;
+				goto err_gpios;
+			}
+		}
+	}
+
+	for (j = 0; j < NUM_PINS; j++) {
+		fhci->pins[j] = qe_pin_request(ofdev->node, j);
+		if (IS_ERR(fhci->pins[j])) {
+			ret = PTR_ERR(fhci->pins[j]);
+			dev_err(dev, "can't get pin %d: %d\n", j, ret);
+			goto err_pins;
+		}
+	}
+
+	/* Frame limit timer and its interrupt. */
+	fhci->timer = gtm_get_timer16();
+	if (IS_ERR(fhci->timer)) {
+		ret = PTR_ERR(fhci->timer);
+		dev_err(dev, "failed to request qe timer: %i", ret);
+		goto err_get_timer;
+	}
+
+	ret = request_irq(fhci->timer->irq, fhci_frame_limit_timer_irq,
+			  IRQF_DISABLED, "qe timer (usb)", hcd);
+	if (ret) {
+		dev_err(dev, "failed to request timer irq");
+		goto err_timer_irq;
+	}
+
+	/* USB Host interrupt. */
+	usb_irq = irq_of_parse_and_map(node, 0);
+	if (usb_irq == NO_IRQ) {
+		dev_err(dev, "could not get usb irq\n");
+		ret = -EINVAL;
+		goto err_usb_irq;
+	}
+
+	/* Clocks. */
+	sprop = of_get_property(node, "fsl,fullspeed-clock", NULL);
+	if (sprop) {
+		fhci->fullspeed_clk = qe_clock_source(sprop);
+		if (fhci->fullspeed_clk == QE_CLK_DUMMY) {
+			dev_err(dev, "wrong fullspeed-clock\n");
+			ret = -EINVAL;
+			goto err_clocks;
+		}
+	}
+
+	sprop = of_get_property(node, "fsl,lowspeed-clock", NULL);
+	if (sprop) {
+		fhci->lowspeed_clk = qe_clock_source(sprop);
+		if (fhci->lowspeed_clk == QE_CLK_DUMMY) {
+			dev_err(dev, "wrong lowspeed-clock\n");
+			ret = -EINVAL;
+			goto err_clocks;
+		}
+	}
+
+	if (fhci->fullspeed_clk == QE_CLK_NONE &&
+			fhci->lowspeed_clk == QE_CLK_NONE) {
+		dev_err(dev, "no clocks specified\n");
+		ret = -EINVAL;
+		goto err_clocks;
+	}
+
+	dev_info(dev, "at 0x%p, irq %d\n", hcd->regs, usb_irq);
+
+	fhci_config_transceiver(fhci, FHCI_PORT_POWER_OFF);
+
+	/* Start with full-speed, if possible. */
+	if (fhci->fullspeed_clk != QE_CLK_NONE) {
+		fhci_config_transceiver(fhci, FHCI_PORT_FULL);
+		qe_usb_clock_set(fhci->fullspeed_clk, USB_CLOCK);
+	} else {
+		fhci_config_transceiver(fhci, FHCI_PORT_LOW);
+		qe_usb_clock_set(fhci->lowspeed_clk, USB_CLOCK >> 3);
+	}
+
+	/* Clear and disable any pending interrupts. */
+	out_be16(&fhci->regs->usb_event, 0xffff);
+	out_be16(&fhci->regs->usb_mask, 0);
+
+	ret = usb_add_hcd(hcd, usb_irq, IRQF_DISABLED);
+	if (ret < 0)
+		goto err_add_hcd;
+
+	fhci_dfs_create(fhci);
+
+	return 0;
+
+err_add_hcd:
+err_clocks:
+	irq_dispose_mapping(usb_irq);
+err_usb_irq:
+	free_irq(fhci->timer->irq, hcd);
+err_timer_irq:
+	gtm_put_timer16(fhci->timer);
+err_get_timer:
+err_pins:
+	while (--j >= 0)
+		qe_pin_free(fhci->pins[j]);
+err_gpios:
+	while (--i >= 0) {
+		if (gpio_is_valid(fhci->gpios[i]))
+			gpio_free(fhci->gpios[i]);
+	}
+	cpm_muram_free(pram_addr);
+err_pram:
+	iounmap(hcd->regs);
+err_regs:
+	usb_put_hcd(hcd);
+	return ret;
+}
+
+static int __devexit fhci_remove(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct fhci_hcd *fhci = hcd_to_fhci(hcd);
+	int i;
+	int j;
+
+	usb_remove_hcd(hcd);
+	free_irq(fhci->timer->irq, hcd);
+	gtm_put_timer16(fhci->timer);
+	cpm_muram_free(cpm_muram_offset(fhci->pram));
+	for (i = 0; i < NUM_GPIOS; i++) {
+		if (!gpio_is_valid(fhci->gpios[i]))
+			continue;
+		gpio_free(fhci->gpios[i]);
+	}
+	for (j = 0; j < NUM_PINS; j++)
+		qe_pin_free(fhci->pins[j]);
+	fhci_dfs_destroy(fhci);
+	usb_put_hcd(hcd);
+	return 0;
+}
+
+static int __devexit of_fhci_remove(struct of_device *ofdev)
+{
+	return fhci_remove(&ofdev->dev);
+}
+
+static struct of_device_id of_fhci_match[] = {
+	{ .compatible = "fsl,mpc8323-qe-usb", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_fhci_match);
+
+static struct of_platform_driver of_fhci_driver = {
+	.name		= "fsl,usb-fhci",
+	.match_table	= of_fhci_match,
+	.probe		= of_fhci_probe,
+	.remove		= __devexit_p(of_fhci_remove),
+};
+
+static int __init fhci_module_init(void)
+{
+	return of_register_platform_driver(&of_fhci_driver);
+}
+module_init(fhci_module_init);
+
+static void __exit fhci_module_exit(void)
+{
+	of_unregister_platform_driver(&of_fhci_driver);
+}
+module_exit(fhci_module_exit);
+
+MODULE_DESCRIPTION("USB Freescale Host Controller Interface Driver");
+MODULE_AUTHOR("Shlomi Gridish <gridish@freescale.com>, "
+	      "Jerry Huang <Chang-Ming.Huang@freescale.com>, "
+	      "Anton Vorontsov <avorontsov@ru.mvista.com>");
+MODULE_LICENSE("GPL");
diff -urN host/fhci-hub.c host.new/fhci-hub.c
--- host/fhci-hub.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/fhci-hub.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,345 @@
+/*
+ * Freescale QUICC Engine USB Host Controller Driver
+ *
+ * Copyright (c) Freescale Semicondutor, Inc. 2006.
+ *               Shlomi Gridish <gridish@freescale.com>
+ *               Jerry Huang <Chang-Ming.Huang@freescale.com>
+ * Copyright (c) Logic Product Development, Inc. 2007
+ *               Peter Barada <peterb@logicpd.com>
+ * Copyright (c) MontaVista Software, Inc. 2008.
+ *               Anton Vorontsov <avorontsov@ru.mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/usb.h>
+#include <linux/gpio.h>
+#include <asm/qe.h>
+#include "../core/hcd.h"
+#include "fhci.h"
+
+/* virtual root hub specific descriptor */
+static u8 root_hub_des[] = {
+	0x09, /* blength */
+	0x29, /* bDescriptorType;hub-descriptor */
+	0x01, /* bNbrPorts */
+	0x00, /* wHubCharacteristics */
+	0x00,
+	0x01, /* bPwrOn2pwrGood;2ms */
+	0x00, /* bHubContrCurrent;0mA */
+	0x00, /* DeviceRemoveable */
+	0xff, /* PortPwrCtrlMask */
+};
+
+static void fhci_gpio_set_value(struct fhci_hcd *fhci, int gpio_nr, bool on)
+{
+	int gpio = fhci->gpios[gpio_nr];
+	bool alow = fhci->alow_gpios[gpio_nr];
+
+	if (!gpio_is_valid(gpio))
+		return;
+
+	gpio_set_value(gpio, on ^ alow);
+	mdelay(5);
+}
+
+void fhci_config_transceiver(struct fhci_hcd *fhci,
+			     enum fhci_port_status status)
+{
+	fhci_dbg(fhci, "-> %s: %d\n", __func__, status);
+
+	switch (status) {
+	case FHCI_PORT_POWER_OFF:
+		fhci_gpio_set_value(fhci, GPIO_POWER, false);
+		break;
+	case FHCI_PORT_DISABLED:
+	case FHCI_PORT_WAITING:
+		fhci_gpio_set_value(fhci, GPIO_POWER, true);
+		break;
+	case FHCI_PORT_LOW:
+		fhci_gpio_set_value(fhci, GPIO_SPEED, false);
+		break;
+	case FHCI_PORT_FULL:
+		fhci_gpio_set_value(fhci, GPIO_SPEED, true);
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	fhci_dbg(fhci, "<- %s: %d\n", __func__, status);
+}
+
+/* disable the USB port by clearing the EN bit in the USBMOD register */
+void fhci_port_disable(struct fhci_hcd *fhci)
+{
+	struct fhci_usb *usb = (struct fhci_usb *)fhci->usb_lld;
+	enum fhci_port_status port_status;
+
+	fhci_dbg(fhci, "-> %s\n", __func__);
+
+	fhci_stop_sof_timer(fhci);
+
+	fhci_flush_all_transmissions(usb);
+
+	fhci_usb_disable_interrupt((struct fhci_usb *)fhci->usb_lld);
+	port_status = usb->port_status;
+	usb->port_status = FHCI_PORT_DISABLED;
+
+	/* Enable IDLE since we want to know if something comes along */
+	usb->saved_msk |= USB_E_IDLE_MASK;
+	out_be16(&usb->fhci->regs->usb_mask, usb->saved_msk);
+
+	/* check if during the disconnection process attached new device */
+	if (port_status == FHCI_PORT_WAITING)
+		fhci_device_connected_interrupt(fhci);
+	usb->vroot_hub->port.wPortStatus &= ~USB_PORT_STAT_ENABLE;
+	usb->vroot_hub->port.wPortChange |= USB_PORT_STAT_C_ENABLE;
+	fhci_usb_enable_interrupt((struct fhci_usb *)fhci->usb_lld);
+
+	fhci_dbg(fhci, "<- %s\n", __func__);
+}
+
+/* enable the USB port by setting the EN bit in the USBMOD register */
+void fhci_port_enable(void *lld)
+{
+	struct fhci_usb *usb = (struct fhci_usb *)lld;
+	struct fhci_hcd *fhci = usb->fhci;
+
+	fhci_dbg(fhci, "-> %s\n", __func__);
+
+	fhci_config_transceiver(fhci, usb->port_status);
+
+	if ((usb->port_status != FHCI_PORT_FULL) &&
+			(usb->port_status != FHCI_PORT_LOW))
+		fhci_start_sof_timer(fhci);
+
+	usb->vroot_hub->port.wPortStatus |= USB_PORT_STAT_ENABLE;
+	usb->vroot_hub->port.wPortChange |= USB_PORT_STAT_C_ENABLE;
+
+	fhci_dbg(fhci, "<- %s\n", __func__);
+}
+
+void fhci_io_port_generate_reset(struct fhci_hcd *fhci)
+{
+	fhci_dbg(fhci, "-> %s\n", __func__);
+
+	gpio_direction_output(fhci->gpios[GPIO_USBOE], 0);
+	gpio_direction_output(fhci->gpios[GPIO_USBTP], 0);
+	gpio_direction_output(fhci->gpios[GPIO_USBTN], 0);
+
+	mdelay(5);
+
+	qe_pin_set_dedicated(fhci->pins[PIN_USBOE]);
+	qe_pin_set_dedicated(fhci->pins[PIN_USBTP]);
+	qe_pin_set_dedicated(fhci->pins[PIN_USBTN]);
+
+	fhci_dbg(fhci, "<- %s\n", __func__);
+}
+
+/* generate the RESET condition on the bus */
+void fhci_port_reset(void *lld)
+{
+	struct fhci_usb *usb = (struct fhci_usb *)lld;
+	struct fhci_hcd *fhci = usb->fhci;
+	u8 mode;
+	u16 mask;
+
+	fhci_dbg(fhci, "-> %s\n", __func__);
+
+	fhci_stop_sof_timer(fhci);
+	/* disable the USB controller */
+	mode = in_8(&fhci->regs->usb_mod);
+	out_8(&fhci->regs->usb_mod, mode & (~USB_MODE_EN));
+
+	/* disable idle interrupts */
+	mask = in_be16(&fhci->regs->usb_mask);
+	out_be16(&fhci->regs->usb_mask, mask & (~USB_E_IDLE_MASK));
+
+	fhci_io_port_generate_reset(fhci);
+
+	/* enable interrupt on this endpoint */
+	out_be16(&fhci->regs->usb_mask, mask);
+
+	/* enable the USB controller */
+	mode = in_8(&fhci->regs->usb_mod);
+	out_8(&fhci->regs->usb_mod, mode | USB_MODE_EN);
+	fhci_start_sof_timer(fhci);
+
+	fhci_dbg(fhci, "<- %s\n", __func__);
+}
+
+int fhci_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	struct fhci_hcd *fhci = hcd_to_fhci(hcd);
+	int ret = 0;
+	unsigned long flags;
+
+	fhci_dbg(fhci, "-> %s\n", __func__);
+
+	spin_lock_irqsave(&fhci->lock, flags);
+
+	if (fhci->vroot_hub->port.wPortChange & (USB_PORT_STAT_C_CONNECTION |
+			USB_PORT_STAT_C_ENABLE | USB_PORT_STAT_C_SUSPEND |
+			USB_PORT_STAT_C_RESET | USB_PORT_STAT_C_OVERCURRENT)) {
+		*buf = 1 << 1;
+		ret = 1;
+		fhci_dbg(fhci, "-- %s\n", __func__);
+	}
+
+	spin_unlock_irqrestore(&fhci->lock, flags);
+
+	fhci_dbg(fhci, "<- %s\n", __func__);
+
+	return ret;
+}
+
+int fhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
+			    u16 wIndex, char *buf, u16 wLength)
+{
+	struct fhci_hcd *fhci = hcd_to_fhci(hcd);
+	int retval = 0;
+	int len = 0;
+	struct usb_hub_status *hub_status;
+	struct usb_port_status *port_status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&fhci->lock, flags);
+
+	fhci_dbg(fhci, "-> %s\n", __func__);
+
+	switch (typeReq) {
+	case ClearHubFeature:
+		switch (wValue) {
+		case C_HUB_LOCAL_POWER:
+		case C_HUB_OVER_CURRENT:
+			break;
+		default:
+			goto error;
+		}
+		break;
+	case ClearPortFeature:
+		fhci->vroot_hub->feature &= (1 << wValue);
+
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			fhci->vroot_hub->port.wPortStatus &=
+			    ~USB_PORT_STAT_ENABLE;
+			fhci_port_disable(fhci);
+			break;
+		case USB_PORT_FEAT_C_ENABLE:
+			fhci->vroot_hub->port.wPortChange &=
+			    ~USB_PORT_STAT_C_ENABLE;
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			fhci->vroot_hub->port.wPortStatus &=
+			    ~USB_PORT_STAT_SUSPEND;
+			fhci_stop_sof_timer(fhci);
+			break;
+		case USB_PORT_FEAT_C_SUSPEND:
+			fhci->vroot_hub->port.wPortChange &=
+			    ~USB_PORT_STAT_C_SUSPEND;
+			break;
+		case USB_PORT_FEAT_POWER:
+			fhci->vroot_hub->port.wPortStatus &=
+			    ~USB_PORT_STAT_POWER;
+			fhci_config_transceiver(fhci, FHCI_PORT_POWER_OFF);
+			break;
+		case USB_PORT_FEAT_C_CONNECTION:
+			fhci->vroot_hub->port.wPortChange &=
+			    ~USB_PORT_STAT_C_CONNECTION;
+			break;
+		case USB_PORT_FEAT_C_OVER_CURRENT:
+			fhci->vroot_hub->port.wPortChange &=
+			    ~USB_PORT_STAT_C_OVERCURRENT;
+			break;
+		case USB_PORT_FEAT_C_RESET:
+			fhci->vroot_hub->port.wPortChange &=
+			    ~USB_PORT_STAT_C_RESET;
+			break;
+		default:
+			goto error;
+		}
+		break;
+	case GetHubDescriptor:
+		memcpy(buf, root_hub_des, sizeof(root_hub_des));
+		buf[3] = 0x11; /* per-port power, no ovrcrnt */
+		len = (buf[0] < wLength) ? buf[0] : wLength;
+		break;
+	case GetHubStatus:
+		hub_status = (struct usb_hub_status *)buf;
+		hub_status->wHubStatus =
+		    cpu_to_le16(fhci->vroot_hub->hub.wHubStatus);
+		hub_status->wHubChange =
+		    cpu_to_le16(fhci->vroot_hub->hub.wHubChange);
+		len = 4;
+		break;
+	case GetPortStatus:
+		port_status = (struct usb_port_status *)buf;
+		port_status->wPortStatus =
+		    cpu_to_le16(fhci->vroot_hub->port.wPortStatus);
+		port_status->wPortChange =
+		    cpu_to_le16(fhci->vroot_hub->port.wPortChange);
+		len = 4;
+		break;
+	case SetHubFeature:
+		switch (wValue) {
+		case C_HUB_OVER_CURRENT:
+		case C_HUB_LOCAL_POWER:
+			break;
+		default:
+			goto error;
+		}
+		break;
+	case SetPortFeature:
+		fhci->vroot_hub->feature |= (1 << wValue);
+
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			fhci->vroot_hub->port.wPortStatus |=
+			    USB_PORT_STAT_ENABLE;
+			fhci_port_enable(fhci->usb_lld);
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			fhci->vroot_hub->port.wPortStatus |=
+			    USB_PORT_STAT_SUSPEND;
+			fhci_stop_sof_timer(fhci);
+			break;
+		case USB_PORT_FEAT_RESET:
+			fhci->vroot_hub->port.wPortStatus |=
+			    USB_PORT_STAT_RESET;
+			fhci_port_reset(fhci->usb_lld);
+			fhci->vroot_hub->port.wPortStatus |=
+			    USB_PORT_STAT_ENABLE;
+			fhci->vroot_hub->port.wPortStatus &=
+			    ~USB_PORT_STAT_RESET;
+			break;
+		case USB_PORT_FEAT_POWER:
+			fhci->vroot_hub->port.wPortStatus |=
+			    USB_PORT_STAT_POWER;
+			fhci_config_transceiver(fhci, FHCI_PORT_WAITING);
+			break;
+		default:
+			goto error;
+		}
+		break;
+	default:
+error:
+		retval = -EPIPE;
+	}
+
+	fhci_dbg(fhci, "<- %s\n", __func__);
+
+	spin_unlock_irqrestore(&fhci->lock, flags);
+
+	return retval;
+}
diff -urN host/fhci-mem.c host.new/fhci-mem.c
--- host/fhci-mem.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/fhci-mem.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,113 @@
+/*
+ * Freescale QUICC Engine USB Host Controller Driver
+ *
+ * Copyright (c) Freescale Semicondutor, Inc. 2006.
+ *               Shlomi Gridish <gridish@freescale.com>
+ *               Jerry Huang <Chang-Ming.Huang@freescale.com>
+ * Copyright (c) Logic Product Development, Inc. 2007
+ *               Peter Barada <peterb@logicpd.com>
+ * Copyright (c) MontaVista Software, Inc. 2008.
+ *               Anton Vorontsov <avorontsov@ru.mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/list.h>
+#include <linux/usb.h>
+#include "../core/hcd.h"
+#include "fhci.h"
+
+static void init_td(struct td *td)
+{
+	memset(td, 0, sizeof(*td));
+	INIT_LIST_HEAD(&td->node);
+	INIT_LIST_HEAD(&td->frame_lh);
+}
+
+static void init_ed(struct ed *ed)
+{
+	memset(ed, 0, sizeof(*ed));
+	INIT_LIST_HEAD(&ed->td_list);
+	INIT_LIST_HEAD(&ed->node);
+}
+
+static struct td *get_empty_td(struct fhci_hcd *fhci)
+{
+	struct td *td;
+
+	if (!list_empty(&fhci->empty_tds)) {
+		td = list_entry(fhci->empty_tds.next, struct td, node);
+		list_del(fhci->empty_tds.next);
+	} else {
+		td = kmalloc(sizeof(*td), GFP_ATOMIC);
+		if (!td)
+			fhci_err(fhci, "No memory to allocate to TD\n");
+		else
+			init_td(td);
+	}
+
+	return td;
+}
+
+void fhci_recycle_empty_td(struct fhci_hcd *fhci, struct td *td)
+{
+	init_td(td);
+	list_add(&td->node, &fhci->empty_tds);
+}
+
+struct ed *fhci_get_empty_ed(struct fhci_hcd *fhci)
+{
+	struct ed *ed;
+
+	if (!list_empty(&fhci->empty_eds)) {
+		ed = list_entry(fhci->empty_eds.next, struct ed, node);
+		list_del(fhci->empty_eds.next);
+	} else {
+		ed = kmalloc(sizeof(*ed), GFP_ATOMIC);
+		if (!ed)
+			fhci_err(fhci, "No memory to allocate to ED\n");
+		else
+			init_ed(ed);
+	}
+
+	return ed;
+}
+
+void fhci_recycle_empty_ed(struct fhci_hcd *fhci, struct ed *ed)
+{
+	init_ed(ed);
+	list_add(&ed->node, &fhci->empty_eds);
+}
+
+struct td *fhci_td_fill(struct fhci_hcd *fhci, struct urb *urb,
+			struct urb_priv *urb_priv, struct ed *ed, u16 index,
+			enum fhci_ta_type type, int toggle, u8 *data, u32 len,
+			u16 interval, u16 start_frame, bool ioc)
+{
+	struct td *td = get_empty_td(fhci);
+
+	if (!td)
+		return NULL;
+
+	td->urb = urb;
+	td->ed = ed;
+	td->type = type;
+	td->toggle = toggle;
+	td->data = data;
+	td->len = len;
+	td->iso_index = index;
+	td->interval = interval;
+	td->start_frame = start_frame;
+	td->ioc = ioc;
+	td->status = USB_TD_OK;
+
+	urb_priv->tds[index] = td;
+
+	return td;
+}
diff -urN host/fhci-q.c host.new/fhci-q.c
--- host/fhci-q.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/fhci-q.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,284 @@
+/*
+ * Freescale QUICC Engine USB Host Controller Driver
+ *
+ * Copyright (c) Freescale Semicondutor, Inc. 2006.
+ *               Shlomi Gridish <gridish@freescale.com>
+ *               Jerry Huang <Chang-Ming.Huang@freescale.com>
+ * Copyright (c) Logic Product Development, Inc. 2007
+ *               Peter Barada <peterb@logicpd.com>
+ * Copyright (c) MontaVista Software, Inc. 2008.
+ *               Anton Vorontsov <avorontsov@ru.mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/usb.h>
+#include "../core/hcd.h"
+#include "fhci.h"
+
+/* maps the hardware error code to the USB error code */
+static int status_to_error(u32 status)
+{
+	if (status == USB_TD_OK)
+		return 0;
+	else if (status & USB_TD_RX_ER_CRC)
+		return -EILSEQ;
+	else if (status & USB_TD_RX_ER_NONOCT)
+		return -EPROTO;
+	else if (status & USB_TD_RX_ER_OVERUN)
+		return -ECOMM;
+	else if (status & USB_TD_RX_ER_BITSTUFF)
+		return -EPROTO;
+	else if (status & USB_TD_RX_ER_PID)
+		return -EILSEQ;
+	else if (status & (USB_TD_TX_ER_NAK | USB_TD_TX_ER_TIMEOUT))
+		return -ETIMEDOUT;
+	else if (status & USB_TD_TX_ER_STALL)
+		return -EPIPE;
+	else if (status & USB_TD_TX_ER_UNDERUN)
+		return -ENOSR;
+	else if (status & USB_TD_RX_DATA_UNDERUN)
+		return -EREMOTEIO;
+	else if (status & USB_TD_RX_DATA_OVERUN)
+		return -EOVERFLOW;
+	else
+		return -EINVAL;
+}
+
+void fhci_add_td_to_frame(struct fhci_time_frame *frame, struct td *td)
+{
+	list_add_tail(&td->frame_lh, &frame->tds_list);
+}
+
+void fhci_add_tds_to_ed(struct ed *ed, struct td **td_list, int number)
+{
+	int i;
+
+	for (i = 0; i < number; i++) {
+		struct td *td = td_list[i];
+		list_add_tail(&td->node, &ed->td_list);
+	}
+	if (ed->td_head == NULL)
+		ed->td_head = td_list[0];
+}
+
+static struct td *peek_td_from_ed(struct ed *ed)
+{
+	struct td *td;
+
+	if (!list_empty(&ed->td_list))
+		td = list_entry(ed->td_list.next, struct td, node);
+	else
+		td = NULL;
+
+	return td;
+}
+
+struct td *fhci_remove_td_from_frame(struct fhci_time_frame *frame)
+{
+	struct td *td;
+
+	if (!list_empty(&frame->tds_list)) {
+		td = list_entry(frame->tds_list.next, struct td, frame_lh);
+		list_del_init(frame->tds_list.next);
+	} else
+		td = NULL;
+
+	return td;
+}
+
+struct td *fhci_peek_td_from_frame(struct fhci_time_frame *frame)
+{
+	struct td *td;
+
+	if (!list_empty(&frame->tds_list))
+		td = list_entry(frame->tds_list.next, struct td, frame_lh);
+	else
+		td = NULL;
+
+	return td;
+}
+
+struct td *fhci_remove_td_from_ed(struct ed *ed)
+{
+	struct td *td;
+
+	if (!list_empty(&ed->td_list)) {
+		td = list_entry(ed->td_list.next, struct td, node);
+		list_del_init(ed->td_list.next);
+
+		/* if this TD was the ED's head, find next TD */
+		if (!list_empty(&ed->td_list))
+			ed->td_head = list_entry(ed->td_list.next, struct td,
+						 node);
+		else
+			ed->td_head = NULL;
+	} else
+		td = NULL;
+
+	return td;
+}
+
+struct td *fhci_remove_td_from_done_list(struct fhci_controller_list *p_list)
+{
+	struct td *td;
+
+	if (!list_empty(&p_list->done_list)) {
+		td = list_entry(p_list->done_list.next, struct td, node);
+		list_del_init(p_list->done_list.next);
+	} else
+		td = NULL;
+
+	return td;
+}
+
+void fhci_move_td_from_ed_to_done_list(struct fhci_usb *usb, struct ed *ed)
+{
+	struct td *td;
+
+	td = ed->td_head;
+	list_del_init(&td->node);
+
+	/* If this TD was the ED's head,find next TD */
+	if (!list_empty(&ed->td_list))
+		ed->td_head = list_entry(ed->td_list.next, struct td, node);
+	else {
+		ed->td_head = NULL;
+		ed->state = FHCI_ED_SKIP;
+	}
+	ed->toggle_carry = td->toggle;
+	list_add_tail(&td->node, &usb->hc_list->done_list);
+	if (td->ioc)
+		usb->transfer_confirm(usb->fhci);
+}
+
+/* free done FHCI URB resource such as ED and TD */
+static void free_urb_priv(struct fhci_hcd *fhci, struct urb *urb)
+{
+	int i;
+	struct urb_priv *urb_priv = urb->hcpriv;
+	struct ed *ed = urb_priv->ed;
+
+	for (i = 0; i < urb_priv->num_of_tds; i++) {
+		list_del_init(&urb_priv->tds[i]->node);
+		fhci_recycle_empty_td(fhci, urb_priv->tds[i]);
+	}
+
+	/* if this TD was the ED's head,find the next TD */
+	if (!list_empty(&ed->td_list))
+		ed->td_head = list_entry(ed->td_list.next, struct td, node);
+	else
+		ed->td_head = NULL;
+
+	kfree(urb_priv->tds);
+	kfree(urb_priv);
+	urb->hcpriv = NULL;
+
+	/* if this TD was the ED's head,find next TD */
+	if (ed->td_head == NULL)
+		list_del_init(&ed->node);
+	fhci->active_urbs--;
+}
+
+/* this routine called to complete and free done URB */
+void fhci_urb_complete_free(struct fhci_hcd *fhci, struct urb *urb)
+{
+	free_urb_priv(fhci, urb);
+
+	if (urb->status == -EINPROGRESS) {
+		if (urb->actual_length != urb->transfer_buffer_length &&
+				urb->transfer_flags & URB_SHORT_NOT_OK)
+			urb->status = -EREMOTEIO;
+		else
+			urb->status = 0;
+	}
+
+	usb_hcd_unlink_urb_from_ep(fhci_to_hcd(fhci), urb);
+
+	spin_unlock(&fhci->lock);
+
+	usb_hcd_giveback_urb(fhci_to_hcd(fhci), urb, urb->status);
+
+	spin_lock(&fhci->lock);
+}
+
+/*
+ * caculate transfer length/stats and update the urb
+ * Precondition: irqsafe(only for urb-?status locking)
+ */
+void fhci_done_td(struct urb *urb, struct td *td)
+{
+	struct ed *ed = td->ed;
+	u32 cc = td->status;
+
+	/* ISO...drivers see per-TD length/status */
+	if (ed->mode == FHCI_TF_ISO) {
+		u32 len;
+		if (!(urb->transfer_flags & URB_SHORT_NOT_OK &&
+				cc == USB_TD_RX_DATA_UNDERUN))
+			cc = USB_TD_OK;
+
+		if (usb_pipeout(urb->pipe))
+			len = urb->iso_frame_desc[td->iso_index].length;
+		else
+			len = td->actual_len;
+
+		urb->actual_length += len;
+		urb->iso_frame_desc[td->iso_index].actual_length = len;
+		urb->iso_frame_desc[td->iso_index].status =
+			status_to_error(cc);
+	}
+
+	/* BULK,INT,CONTROL... drivers see aggregate length/status,
+	 * except that "setup" bytes aren't counted and "short" transfers
+	 * might not be reported as errors.
+	 */
+	else {
+		if (td->error_cnt >= 3)
+			urb->error_count = 3;
+
+		/* control endpoint only have soft stalls */
+
+		/* update packet status if needed(short may be ok) */
+		if (!(urb->transfer_flags & URB_SHORT_NOT_OK) &&
+				cc == USB_TD_RX_DATA_UNDERUN) {
+			ed->state = FHCI_ED_OPER;
+			cc = USB_TD_OK;
+		}
+		if (cc != USB_TD_OK) {
+			if (urb->status == -EINPROGRESS)
+				urb->status = status_to_error(cc);
+		}
+
+		/* count all non-empty packets except control SETUP packet */
+		if (td->type != FHCI_TA_SETUP || td->iso_index != 0)
+			urb->actual_length += td->actual_len;
+	}
+}
+
+/* there are some pedning request to unlink */
+void fhci_del_ed_list(struct fhci_hcd *fhci, struct ed *ed)
+{
+	struct td *td = peek_td_from_ed(ed);
+	struct urb *urb = td->urb;
+	struct urb_priv *urb_priv = urb->hcpriv;
+
+	if (urb_priv->state == URB_DEL) {
+		td = fhci_remove_td_from_ed(ed);
+		/* HC may have partly processed this TD */
+		if (td->status != USB_TD_INPROGRESS)
+			fhci_done_td(urb, td);
+
+		/* URB is done;clean up */
+		if (++(urb_priv->tds_cnt) == urb_priv->num_of_tds)
+			fhci_urb_complete_free(fhci, urb);
+	}
+}
diff -urN host/fhci-sched.c host.new/fhci-sched.c
--- host/fhci-sched.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/fhci-sched.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,888 @@
+/*
+ * Freescale QUICC Engine USB Host Controller Driver
+ *
+ * Copyright (c) Freescale Semicondutor, Inc. 2006.
+ *               Shlomi Gridish <gridish@freescale.com>
+ *               Jerry Huang <Chang-Ming.Huang@freescale.com>
+ * Copyright (c) Logic Product Development, Inc. 2007
+ *               Peter Barada <peterb@logicpd.com>
+ * Copyright (c) MontaVista Software, Inc. 2008.
+ *               Anton Vorontsov <avorontsov@ru.mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/usb.h>
+#include <asm/qe.h>
+#include <asm/fsl_gtm.h>
+#include "../core/hcd.h"
+#include "fhci.h"
+
+static void recycle_frame(struct fhci_usb *usb, struct packet *pkt)
+{
+	pkt->data = NULL;
+	pkt->len = 0;
+	pkt->status = USB_TD_OK;
+	pkt->info = 0;
+	pkt->priv_data = NULL;
+
+	cq_put(usb->ep0->empty_frame_Q, pkt);
+}
+
+/* confirm submitted packet */
+void fhci_transaction_confirm(struct fhci_usb *usb, struct packet *pkt)
+{
+	struct td *td;
+	struct packet *td_pkt;
+	struct ed *ed;
+	u32 trans_len;
+	bool td_done = false;
+
+	td = fhci_remove_td_from_frame(usb->actual_frame);
+	td_pkt = td->pkt;
+	trans_len = pkt->len;
+	td->status = pkt->status;
+	if (td->type == FHCI_TA_IN && td_pkt->info & PKT_DUMMY_PACKET) {
+		if ((td->data + td->actual_len) && trans_len)
+			memcpy(td->data + td->actual_len, pkt->data,
+			       trans_len);
+		cq_put(usb->ep0->dummy_packets_Q, pkt->data);
+	}
+
+	recycle_frame(usb, pkt);
+
+	ed = td->ed;
+	if (ed->mode == FHCI_TF_ISO) {
+		if (ed->td_list.next->next != &ed->td_list) {
+			struct td *td_next =
+			    list_entry(ed->td_list.next->next, struct td,
+				       node);
+
+			td_next->start_frame = usb->actual_frame->frame_num;
+		}
+		td->actual_len = trans_len;
+		td_done = true;
+	} else if ((td->status & USB_TD_ERROR) &&
+			!(td->status & USB_TD_TX_ER_NAK)) {
+		/*
+		 * There was an error on the transaction (but not NAK).
+		 * If it is fatal error (data underrun, stall, bad pid or 3
+		 * errors exceeded), mark this TD as done.
+		 */
+		if ((td->status & USB_TD_RX_DATA_UNDERUN) ||
+				(td->status & USB_TD_TX_ER_STALL) ||
+				(td->status & USB_TD_RX_ER_PID) ||
+				(++td->error_cnt >= 3)) {
+			ed->state = FHCI_ED_HALTED;
+			td_done = true;
+
+			if (td->status & USB_TD_RX_DATA_UNDERUN) {
+				fhci_dbg(usb->fhci, "td err fu\n");
+				td->toggle = !td->toggle;
+				td->actual_len += trans_len;
+			} else {
+				fhci_dbg(usb->fhci, "td err f!u\n");
+			}
+		} else {
+			fhci_dbg(usb->fhci, "td err !f\n");
+			/* it is not a fatal error -retry this transaction */
+			td->nak_cnt = 0;
+			td->error_cnt++;
+			td->status = USB_TD_OK;
+		}
+	} else if (td->status & USB_TD_TX_ER_NAK) {
+		/* there was a NAK response */
+		fhci_vdbg(usb->fhci, "td nack\n");
+		td->nak_cnt++;
+		td->error_cnt = 0;
+		td->status = USB_TD_OK;
+	} else {
+		/* there was no error on transaction */
+		td->error_cnt = 0;
+		td->nak_cnt = 0;
+		td->toggle = !td->toggle;
+		td->actual_len += trans_len;
+
+		if (td->len == td->actual_len)
+			td_done = true;
+	}
+
+	if (td_done)
+		fhci_move_td_from_ed_to_done_list(usb, ed);
+}
+
+/*
+ * Flush all transmitted packets from BDs
+ * This routine is called when disabling the USB port to flush all
+ * transmissions that are allready scheduled in the BDs
+ */
+void fhci_flush_all_transmissions(struct fhci_usb *usb)
+{
+	u8 mode;
+	struct td *td;
+
+	mode = in_8(&usb->fhci->regs->usb_mod);
+	clrbits8(&usb->fhci->regs->usb_mod, USB_MODE_EN);
+
+	fhci_flush_bds(usb);
+
+	while ((td = fhci_peek_td_from_frame(usb->actual_frame)) != NULL) {
+		struct packet *pkt = td->pkt;
+
+		pkt->status = USB_TD_TX_ER_TIMEOUT;
+		fhci_transaction_confirm(usb, pkt);
+	}
+
+	usb->actual_frame->frame_status = FRAME_END_TRANSMISSION;
+
+	/* reset the event register */
+	out_be16(&usb->fhci->regs->usb_event, 0xffff);
+	/* enable the USB controller */
+	out_8(&usb->fhci->regs->usb_mod, mode | USB_MODE_EN);
+}
+
+/*
+ * This function forms the packet and transmit the packet. This function
+ * will handle all endpoint type:ISO,interrupt,control and bulk
+ */
+static int add_packet(struct fhci_usb *usb, struct ed *ed, struct td *td)
+{
+	u32 fw_transaction_time, len = 0;
+	struct packet *pkt;
+	u8 *data = NULL;
+
+	/* calcalate data address,len and toggle and then add the transaction */
+	if (td->toggle == USB_TD_TOGGLE_CARRY)
+		td->toggle = ed->toggle_carry;
+
+	switch (ed->mode) {
+	case FHCI_TF_ISO:
+		len = td->len;
+		if (td->type != FHCI_TA_IN)
+			data = td->data;
+		break;
+	case FHCI_TF_CTRL:
+	case FHCI_TF_BULK:
+		len = min(td->len - td->actual_len, ed->max_pkt_size);
+		if (!((td->type == FHCI_TA_IN) &&
+		      ((len + td->actual_len) == td->len)))
+			data = td->data + td->actual_len;
+		break;
+	case FHCI_TF_INTR:
+		len = min(td->len, ed->max_pkt_size);
+		if (!((td->type == FHCI_TA_IN) &&
+		      ((td->len + CRC_SIZE) >= ed->max_pkt_size)))
+			data = td->data;
+		break;
+	default:
+		break;
+	}
+
+	if (usb->port_status == FHCI_PORT_FULL)
+		fw_transaction_time = (((len + PROTOCOL_OVERHEAD) * 11) >> 4);
+	else
+		fw_transaction_time = ((len + PROTOCOL_OVERHEAD) * 6);
+
+	/* check if there's enough space in this frame to submit this TD */
+	if (usb->actual_frame->total_bytes + len + PROTOCOL_OVERHEAD >=
+			usb->max_bytes_per_frame) {
+		fhci_vdbg(usb->fhci, "not enough space in this frame: "
+			  "%d %d %d\n", usb->actual_frame->total_bytes, len,
+			  usb->max_bytes_per_frame);
+		return -1;
+	}
+
+	/* check if there's enough time in this frame to submit this TD */
+	if (usb->actual_frame->frame_status != FRAME_IS_PREPARED &&
+	    (usb->actual_frame->frame_status & FRAME_END_TRANSMISSION ||
+	     (fw_transaction_time + usb->sw_transaction_time >=
+	      1000 - fhci_get_sof_timer_count(usb)))) {
+		fhci_dbg(usb->fhci, "not enough time in this frame\n");
+		return -1;
+	}
+
+	/* update frame object fields before transmitting */
+	pkt = cq_get(usb->ep0->empty_frame_Q);
+	if (!pkt) {
+		fhci_dbg(usb->fhci, "there is no empty frame\n");
+		return -1;
+	}
+	td->pkt = pkt;
+
+	pkt->info = 0;
+	if (data == NULL) {
+		data = cq_get(usb->ep0->dummy_packets_Q);
+		BUG_ON(!data);
+		pkt->info = PKT_DUMMY_PACKET;
+	}
+	pkt->data = data;
+	pkt->len = len;
+	pkt->status = USB_TD_OK;
+	/* update TD status field before transmitting */
+	td->status = USB_TD_INPROGRESS;
+	/* update actual frame time object with the actual transmission */
+	usb->actual_frame->total_bytes += (len + PROTOCOL_OVERHEAD);
+	fhci_add_td_to_frame(usb->actual_frame, td);
+
+	if (usb->port_status != FHCI_PORT_FULL &&
+			usb->port_status != FHCI_PORT_LOW) {
+		pkt->status = USB_TD_TX_ER_TIMEOUT;
+		pkt->len = 0;
+		fhci_transaction_confirm(usb, pkt);
+	} else if (fhci_host_transaction(usb, pkt, td->type, ed->dev_addr,
+			ed->ep_addr, ed->mode, ed->speed, td->toggle)) {
+		/* remove TD from actual frame */
+		list_del_init(&td->frame_lh);
+		td->status = USB_TD_OK;
+		if (pkt->info & PKT_DUMMY_PACKET)
+			cq_put(usb->ep0->dummy_packets_Q, pkt->data);
+		recycle_frame(usb, pkt);
+		usb->actual_frame->total_bytes -= (len + PROTOCOL_OVERHEAD);
+		fhci_err(usb->fhci, "host transaction failed\n");
+		return -1;
+	}
+
+	return len;
+}
+
+static void move_head_to_tail(struct list_head *list)
+{
+	struct list_head *node = list->next;
+
+	if (!list_empty(list)) {
+		list_del(node);
+		list_add_tail(node, list);
+	}
+}
+
+/*
+ * This function goes through the endpoint list and schedules the
+ * transactions within this list
+ */
+static int scan_ed_list(struct fhci_usb *usb,
+			struct list_head *list, enum fhci_tf_mode list_type)
+{
+	static const int frame_part[4] = {
+		[FHCI_TF_CTRL] = MAX_BYTES_PER_FRAME,
+		[FHCI_TF_ISO] = (MAX_BYTES_PER_FRAME *
+				 MAX_PERIODIC_FRAME_USAGE) / 100,
+		[FHCI_TF_BULK] = MAX_BYTES_PER_FRAME,
+		[FHCI_TF_INTR] = (MAX_BYTES_PER_FRAME *
+				  MAX_PERIODIC_FRAME_USAGE) / 100
+	};
+	struct ed *ed;
+	struct td *td;
+	int ans = 1;
+	u32 save_transaction_time = usb->sw_transaction_time;
+
+	list_for_each_entry(ed, list, node) {
+		td = ed->td_head;
+
+		if (!td || (td && td->status == USB_TD_INPROGRESS))
+			continue;
+
+		if (ed->state != FHCI_ED_OPER) {
+			if (ed->state == FHCI_ED_URB_DEL) {
+				td->status = USB_TD_OK;
+				fhci_move_td_from_ed_to_done_list(usb, ed);
+				ed->state = FHCI_ED_SKIP;
+			}
+			continue;
+		}
+
+		/*
+		 * if it isn't interrupt pipe or it is not iso pipe and the
+		 * interval time passed
+		 */
+		if ((list_type == FHCI_TF_INTR || list_type == FHCI_TF_ISO) &&
+				(((usb->actual_frame->frame_num -
+				   td->start_frame) & 0x7ff) < td->interval))
+			continue;
+
+		if (add_packet(usb, ed, td) < 0)
+			continue;
+
+		/* update time stamps in the TD */
+		td->start_frame = usb->actual_frame->frame_num;
+		usb->sw_transaction_time += save_transaction_time;
+
+		if (usb->actual_frame->total_bytes >=
+					usb->max_bytes_per_frame) {
+			usb->actual_frame->frame_status =
+				FRAME_DATA_END_TRANSMISSION;
+			fhci_push_dummy_bd(usb->ep0);
+			ans = 0;
+			break;
+		}
+
+		if (usb->actual_frame->total_bytes >= frame_part[list_type])
+			break;
+	}
+
+	/* be fair to each ED(move list head around) */
+	move_head_to_tail(list);
+	usb->sw_transaction_time = save_transaction_time;
+
+	return ans;
+}
+
+static u32 rotate_frames(struct fhci_usb *usb)
+{
+	struct fhci_hcd *fhci = usb->fhci;
+
+	if (!list_empty(&usb->actual_frame->tds_list)) {
+		if ((((in_be16(&fhci->pram->frame_num) & 0x07ff) -
+		      usb->actual_frame->frame_num) & 0x7ff) > 5)
+			fhci_flush_actual_frame(usb);
+		else
+			return -EINVAL;
+	}
+
+	usb->actual_frame->frame_status = FRAME_IS_PREPARED;
+	usb->actual_frame->frame_num = in_be16(&fhci->pram->frame_num) & 0x7ff;
+	usb->actual_frame->total_bytes = 0;
+
+	return 0;
+}
+
+/*
+ * This function schedule the USB transaction and will process the
+ * endpoint in the following order: iso, interrupt, control and bulk.
+ */
+void fhci_schedule_transactions(struct fhci_usb *usb)
+{
+	int left = 1;
+
+	if (usb->actual_frame->frame_status & FRAME_END_TRANSMISSION)
+		if (rotate_frames(usb) != 0)
+			return;
+
+	if (usb->actual_frame->frame_status & FRAME_END_TRANSMISSION)
+		return;
+
+	if (usb->actual_frame->total_bytes == 0) {
+		/*
+		 * schedule the next available ISO transfer
+		 *or next stage of the ISO transfer
+		 */
+		scan_ed_list(usb, &usb->hc_list->iso_list, FHCI_TF_ISO);
+
+		/*
+		 * schedule the next available interrupt transfer or
+		 * the next stage of the interrupt transfer
+		 */
+		scan_ed_list(usb, &usb->hc_list->intr_list, FHCI_TF_INTR);
+
+		/*
+		 * schedule the next available control transfer
+		 * or the next stage of the control transfer
+		 */
+		left = scan_ed_list(usb, &usb->hc_list->ctrl_list,
+				    FHCI_TF_CTRL);
+	}
+
+	/*
+	 * schedule the next available bulk transfer or the next stage of the
+	 * bulk transfer
+	 */
+	if (left > 0)
+		scan_ed_list(usb, &usb->hc_list->bulk_list, FHCI_TF_BULK);
+}
+
+/* Handles SOF interrupt */
+static void sof_interrupt(struct fhci_hcd *fhci)
+{
+	struct fhci_usb *usb = fhci->usb_lld;
+
+	if ((usb->port_status == FHCI_PORT_DISABLED) &&
+	    (usb->vroot_hub->port.wPortStatus & USB_PORT_STAT_CONNECTION) &&
+	    !(usb->vroot_hub->port.wPortChange & USB_PORT_STAT_C_CONNECTION)) {
+		if (usb->vroot_hub->port.wPortStatus & USB_PORT_STAT_LOW_SPEED)
+			usb->port_status = FHCI_PORT_LOW;
+		else
+			usb->port_status = FHCI_PORT_FULL;
+		/* Disable IDLE */
+		usb->saved_msk &= ~USB_E_IDLE_MASK;
+		out_be16(&usb->fhci->regs->usb_mask, usb->saved_msk);
+	}
+
+	gtm_set_exact_timer16(fhci->timer, usb->max_frame_usage, false);
+
+	fhci_host_transmit_actual_frame(usb);
+	usb->actual_frame->frame_status = FRAME_IS_TRANSMITTED;
+
+	fhci_schedule_transactions(usb);
+}
+
+/* Handles device disconnected interrupt on port */
+void fhci_device_disconnected_interrupt(struct fhci_hcd *fhci)
+{
+	struct fhci_usb *usb = fhci->usb_lld;
+
+	fhci_dbg(fhci, "-> %s\n", __func__);
+
+	fhci_usb_disable_interrupt(usb);
+	clrbits8(&usb->fhci->regs->usb_mod, USB_MODE_LSS);
+	usb->port_status = FHCI_PORT_DISABLED;
+
+	fhci_stop_sof_timer(fhci);
+
+	/* Enable IDLE since we want to know if something comes along */
+	usb->saved_msk |= USB_E_IDLE_MASK;
+	out_be16(&usb->fhci->regs->usb_mask, usb->saved_msk);
+
+	usb->vroot_hub->port.wPortStatus &= ~USB_PORT_STAT_CONNECTION;
+	usb->vroot_hub->port.wPortChange |= USB_PORT_STAT_C_CONNECTION;
+	usb->max_bytes_per_frame = 0;
+	fhci_usb_enable_interrupt(usb);
+
+	fhci_dbg(fhci, "<- %s\n", __func__);
+}
+
+/* detect a new device connected on the USB port */
+void fhci_device_connected_interrupt(struct fhci_hcd *fhci)
+{
+
+	struct fhci_usb *usb = fhci->usb_lld;
+	int state;
+	int ret;
+
+	fhci_dbg(fhci, "-> %s\n", __func__);
+
+	fhci_usb_disable_interrupt(usb);
+	state = fhci_ioports_check_bus_state(fhci);
+
+	/* low-speed device was connected to the USB port */
+	if (state == 1) {
+		ret = qe_usb_clock_set(fhci->lowspeed_clk, USB_CLOCK >> 3);
+		if (ret) {
+			fhci_warn(fhci, "Low-Speed device is not supported, "
+				  "try use BRGx\n");
+			goto out;
+		}
+
+		usb->port_status = FHCI_PORT_LOW;
+		setbits8(&usb->fhci->regs->usb_mod, USB_MODE_LSS);
+		usb->vroot_hub->port.wPortStatus |=
+		    (USB_PORT_STAT_LOW_SPEED |
+		     USB_PORT_STAT_CONNECTION);
+		usb->vroot_hub->port.wPortChange |=
+		    USB_PORT_STAT_C_CONNECTION;
+		usb->max_bytes_per_frame =
+		    (MAX_BYTES_PER_FRAME >> 3) - 7;
+		fhci_port_enable(usb);
+	} else if (state == 2) {
+		ret = qe_usb_clock_set(fhci->fullspeed_clk, USB_CLOCK);
+		if (ret) {
+			fhci_warn(fhci, "Full-Speed device is not supported, "
+				  "try use CLKx\n");
+			goto out;
+		}
+
+		usb->port_status = FHCI_PORT_FULL;
+		clrbits8(&usb->fhci->regs->usb_mod, USB_MODE_LSS);
+		usb->vroot_hub->port.wPortStatus &=
+		    ~USB_PORT_STAT_LOW_SPEED;
+		usb->vroot_hub->port.wPortStatus |=
+		    USB_PORT_STAT_CONNECTION;
+		usb->vroot_hub->port.wPortChange |=
+		    USB_PORT_STAT_C_CONNECTION;
+		usb->max_bytes_per_frame = (MAX_BYTES_PER_FRAME - 15);
+		fhci_port_enable(usb);
+	}
+out:
+	fhci_usb_enable_interrupt(usb);
+	fhci_dbg(fhci, "<- %s\n", __func__);
+}
+
+irqreturn_t fhci_frame_limit_timer_irq(int irq, void *_hcd)
+{
+	struct usb_hcd *hcd = _hcd;
+	struct fhci_hcd *fhci = hcd_to_fhci(hcd);
+	struct fhci_usb *usb = fhci->usb_lld;
+
+	spin_lock(&fhci->lock);
+
+	gtm_set_exact_timer16(fhci->timer, 1000, false);
+
+	if (usb->actual_frame->frame_status == FRAME_IS_TRANSMITTED) {
+		usb->actual_frame->frame_status = FRAME_TIMER_END_TRANSMISSION;
+		fhci_push_dummy_bd(usb->ep0);
+	}
+
+	fhci_schedule_transactions(usb);
+
+	spin_unlock(&fhci->lock);
+
+	return IRQ_HANDLED;
+}
+
+/* Cancel transmission on the USB endpoint */
+static void abort_transmission(struct fhci_usb *usb)
+{
+	fhci_dbg(usb->fhci, "-> %s\n", __func__);
+	/* issue stop Tx command */
+	qe_issue_cmd(QE_USB_STOP_TX, QE_CR_SUBBLOCK_USB, EP_ZERO, 0);
+	/* flush Tx FIFOs */
+	out_8(&usb->fhci->regs->usb_comm, USB_CMD_FLUSH_FIFO | EP_ZERO);
+	udelay(1000);
+	/* reset Tx BDs */
+	fhci_flush_bds(usb);
+	/* issue restart Tx command */
+	qe_issue_cmd(QE_USB_RESTART_TX, QE_CR_SUBBLOCK_USB, EP_ZERO, 0);
+	fhci_dbg(usb->fhci, "<- %s\n", __func__);
+}
+
+irqreturn_t fhci_irq(struct usb_hcd *hcd)
+{
+	struct fhci_hcd *fhci = hcd_to_fhci(hcd);
+	struct fhci_usb *usb;
+	u16 usb_er = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&fhci->lock, flags);
+
+	usb = fhci->usb_lld;
+
+	usb_er |= in_be16(&usb->fhci->regs->usb_event) &
+		  in_be16(&usb->fhci->regs->usb_mask);
+
+	/* clear event bits for next time */
+	out_be16(&usb->fhci->regs->usb_event, usb_er);
+
+	fhci_dbg_isr(fhci, usb_er);
+
+	if (usb_er & USB_E_RESET_MASK) {
+		if ((usb->port_status == FHCI_PORT_FULL) ||
+				(usb->port_status == FHCI_PORT_LOW)) {
+			fhci_device_disconnected_interrupt(fhci);
+			usb_er &= ~USB_E_IDLE_MASK;
+		} else if (usb->port_status == FHCI_PORT_WAITING) {
+			usb->port_status = FHCI_PORT_DISCONNECTING;
+
+			/* Turn on IDLE since we want to disconnect */
+			usb->saved_msk |= USB_E_IDLE_MASK;
+			out_be16(&usb->fhci->regs->usb_event,
+				 usb->saved_msk);
+		} else if (usb->port_status == FHCI_PORT_DISABLED) {
+			if (fhci_ioports_check_bus_state(fhci) == 1 &&
+					usb->port_status != FHCI_PORT_LOW &&
+					usb->port_status != FHCI_PORT_FULL)
+				fhci_device_connected_interrupt(fhci);
+		}
+		usb_er &= ~USB_E_RESET_MASK;
+	}
+
+	if (usb_er & USB_E_MSF_MASK) {
+		abort_transmission(fhci->usb_lld);
+		usb_er &= ~USB_E_MSF_MASK;
+	}
+
+	if (usb_er & (USB_E_SOF_MASK | USB_E_SFT_MASK)) {
+		sof_interrupt(fhci);
+		usb_er &= ~(USB_E_SOF_MASK | USB_E_SFT_MASK);
+	}
+
+	if (usb_er & USB_E_TXB_MASK) {
+		fhci_tx_conf_interrupt(fhci->usb_lld);
+		usb_er &= ~USB_E_TXB_MASK;
+	}
+
+	if (usb_er & USB_E_TXE1_MASK) {
+		fhci_tx_conf_interrupt(fhci->usb_lld);
+		usb_er &= ~USB_E_TXE1_MASK;
+	}
+
+	if (usb_er & USB_E_IDLE_MASK) {
+		if (usb->port_status == FHCI_PORT_DISABLED &&
+				usb->port_status != FHCI_PORT_LOW &&
+				usb->port_status != FHCI_PORT_FULL) {
+			usb_er &= ~USB_E_RESET_MASK;
+			fhci_device_connected_interrupt(fhci);
+		} else if (usb->port_status ==
+				FHCI_PORT_DISCONNECTING) {
+			/* XXX usb->port_status = FHCI_PORT_WAITING; */
+			/* Disable IDLE */
+			usb->saved_msk &= ~USB_E_IDLE_MASK;
+			out_be16(&usb->fhci->regs->usb_mask,
+				 usb->saved_msk);
+		} else {
+			fhci_dbg_isr(fhci, -1);
+		}
+
+		usb_er &= ~USB_E_IDLE_MASK;
+	}
+
+	spin_unlock_irqrestore(&fhci->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+
+/*
+ * Process normal completions(error or sucess) and clean the schedule.
+ *
+ * This is the main path for handing urbs back to drivers. The only other patth
+ * is process_del_list(),which unlinks URBs by scanning EDs,instead of scanning
+ * the (re-reversed) done list as this does.
+ */
+static void process_done_list(unsigned long data)
+{
+	struct urb *urb;
+	struct ed *ed;
+	struct td *td;
+	struct urb_priv *urb_priv;
+	struct fhci_hcd *fhci = (struct fhci_hcd *)data;
+
+	disable_irq(fhci->timer->irq);
+	disable_irq(fhci_to_hcd(fhci)->irq);
+	spin_lock(&fhci->lock);
+
+	td = fhci_remove_td_from_done_list(fhci->hc_list);
+	while (td != NULL) {
+		urb = td->urb;
+		urb_priv = urb->hcpriv;
+		ed = td->ed;
+
+		/* update URB's length and status from TD */
+		fhci_done_td(urb, td);
+		urb_priv->tds_cnt++;
+
+		/*
+		 * if all this urb's TDs are done, call complete()
+		 * Interrupt transfers are the onley special case:
+		 * they are reissued,until "deleted" by usb_unlink_urb
+		 * (real work done in a SOF intr, by process_del_list)
+		 */
+		if (urb_priv->tds_cnt == urb_priv->num_of_tds) {
+			fhci_urb_complete_free(fhci, urb);
+		} else if (urb_priv->state == URB_DEL &&
+				ed->state == FHCI_ED_SKIP) {
+			fhci_del_ed_list(fhci, ed);
+			ed->state = FHCI_ED_OPER;
+		} else if (ed->state == FHCI_ED_HALTED) {
+			urb_priv->state = URB_DEL;
+			ed->state = FHCI_ED_URB_DEL;
+			fhci_del_ed_list(fhci, ed);
+			ed->state = FHCI_ED_OPER;
+		}
+
+		td = fhci_remove_td_from_done_list(fhci->hc_list);
+	}
+
+	spin_unlock(&fhci->lock);
+	enable_irq(fhci->timer->irq);
+	enable_irq(fhci_to_hcd(fhci)->irq);
+}
+
+DECLARE_TASKLET(fhci_tasklet, process_done_list, 0);
+
+/* transfer complted callback */
+u32 fhci_transfer_confirm_callback(struct fhci_hcd *fhci)
+{
+	if (!fhci->process_done_task->state)
+		tasklet_schedule(fhci->process_done_task);
+	return 0;
+}
+
+/*
+ * adds urb to the endpoint descriptor list
+ * arguments:
+ * fhci		data structure for the Low level host controller
+ * ep		USB Host endpoint data structure
+ * urb		USB request block data structure
+ */
+void fhci_queue_urb(struct fhci_hcd *fhci, struct urb *urb)
+{
+	struct ed *ed = urb->ep->hcpriv;
+	struct urb_priv *urb_priv = urb->hcpriv;
+	u32 data_len = urb->transfer_buffer_length;
+	int urb_state = 0;
+	int toggle = 0;
+	struct td *td;
+	u8 *data;
+	u16 cnt = 0;
+
+	if (ed == NULL) {
+		ed = fhci_get_empty_ed(fhci);
+		ed->dev_addr = usb_pipedevice(urb->pipe);
+		ed->ep_addr = usb_pipeendpoint(urb->pipe);
+		switch (usb_pipetype(urb->pipe)) {
+		case PIPE_CONTROL:
+			ed->mode = FHCI_TF_CTRL;
+			break;
+		case PIPE_BULK:
+			ed->mode = FHCI_TF_BULK;
+			break;
+		case PIPE_INTERRUPT:
+			ed->mode = FHCI_TF_INTR;
+			break;
+		case PIPE_ISOCHRONOUS:
+			ed->mode = FHCI_TF_ISO;
+			break;
+		default:
+			break;
+		}
+		ed->speed = (urb->dev->speed == USB_SPEED_LOW) ?
+			FHCI_LOW_SPEED : FHCI_FULL_SPEED;
+		ed->max_pkt_size = usb_maxpacket(urb->dev,
+			urb->pipe, usb_pipeout(urb->pipe));
+		urb->ep->hcpriv = ed;
+		fhci_dbg(fhci, "new ep speed=%d max_pkt_size=%d\n",
+			 ed->speed, ed->max_pkt_size);
+	}
+
+	/* for ISO transfer calculate start frame index */
+	if (ed->mode == FHCI_TF_ISO && urb->transfer_flags & URB_ISO_ASAP)
+		urb->start_frame = ed->td_head ? ed->last_iso + 1 :
+						 get_frame_num(fhci);
+
+	/*
+	 * OHCI handles the DATA toggle itself,we just use the USB
+	 * toggle bits
+	 */
+	if (usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe),
+			  usb_pipeout(urb->pipe)))
+		toggle = USB_TD_TOGGLE_CARRY;
+	else {
+		toggle = USB_TD_TOGGLE_DATA0;
+		usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
+			      usb_pipeout(urb->pipe), 1);
+	}
+
+	urb_priv->tds_cnt = 0;
+	urb_priv->ed = ed;
+	if (data_len > 0)
+		data = urb->transfer_buffer;
+	else
+		data = NULL;
+
+	switch (ed->mode) {
+	case FHCI_TF_BULK:
+		if (urb->transfer_flags & URB_ZERO_PACKET &&
+				urb->transfer_buffer_length > 0 &&
+				((urb->transfer_buffer_length %
+				usb_maxpacket(urb->dev, urb->pipe,
+				usb_pipeout(urb->pipe))) == 0))
+			urb_state = US_BULK0;
+		while (data_len > 4096) {
+			td = fhci_td_fill(fhci, urb, urb_priv, ed, cnt,
+				usb_pipeout(urb->pipe) ? FHCI_TA_OUT :
+							 FHCI_TA_IN,
+				cnt ? USB_TD_TOGGLE_CARRY :
+				      toggle,
+				data, 4096, 0, 0, true);
+			data += 4096;
+			data_len -= 4096;
+			cnt++;
+		}
+
+		td = fhci_td_fill(fhci, urb, urb_priv, ed, cnt,
+			usb_pipeout(urb->pipe) ? FHCI_TA_OUT : FHCI_TA_IN,
+			cnt ? USB_TD_TOGGLE_CARRY : toggle,
+			data, data_len, 0, 0, true);
+		cnt++;
+
+		if (urb->transfer_flags & URB_ZERO_PACKET &&
+				cnt < urb_priv->num_of_tds) {
+			td = fhci_td_fill(fhci, urb, urb_priv, ed, cnt,
+				usb_pipeout(urb->pipe) ? FHCI_TA_OUT :
+							 FHCI_TA_IN,
+				USB_TD_TOGGLE_CARRY, NULL, 0, 0, 0, true);
+			cnt++;
+		}
+		break;
+	case FHCI_TF_INTR:
+		urb->start_frame = get_frame_num(fhci) + 1;
+		td = fhci_td_fill(fhci, urb, urb_priv, ed, cnt++,
+			usb_pipeout(urb->pipe) ? FHCI_TA_OUT : FHCI_TA_IN,
+			USB_TD_TOGGLE_DATA0, data, data_len,
+			urb->interval, urb->start_frame, true);
+		break;
+	case FHCI_TF_CTRL:
+		ed->dev_addr = usb_pipedevice(urb->pipe);
+		ed->max_pkt_size = usb_maxpacket(urb->dev, urb->pipe,
+			usb_pipeout(urb->pipe));
+		td = fhci_td_fill(fhci, urb, urb_priv, ed, cnt++, FHCI_TA_SETUP,
+			USB_TD_TOGGLE_DATA0, urb->setup_packet, 8, 0, 0, true);
+
+		if (data_len > 0) {
+			td = fhci_td_fill(fhci, urb, urb_priv, ed, cnt++,
+				usb_pipeout(urb->pipe) ? FHCI_TA_OUT :
+							 FHCI_TA_IN,
+				USB_TD_TOGGLE_DATA1, data, data_len, 0, 0,
+				true);
+		}
+		td = fhci_td_fill(fhci, urb, urb_priv, ed, cnt++,
+			usb_pipeout(urb->pipe) ? FHCI_TA_IN : FHCI_TA_OUT,
+			USB_TD_TOGGLE_DATA1, data, 0, 0, 0, true);
+		urb_state = US_CTRL_SETUP;
+		break;
+	case FHCI_TF_ISO:
+		for (cnt = 0; cnt < urb->number_of_packets; cnt++) {
+			u16 frame = urb->start_frame;
+
+			/*
+			 * FIXME scheduling should handle frame counter
+			 * roll-around ... exotic case (and OHCI has
+			 * a 2^16 iso range, vs other HCs max of 2^10)
+			 */
+			frame += cnt * urb->interval;
+			frame &= 0x07ff;
+			td = fhci_td_fill(fhci, urb, urb_priv, ed, cnt,
+				usb_pipeout(urb->pipe) ? FHCI_TA_OUT :
+							 FHCI_TA_IN,
+				USB_TD_TOGGLE_DATA0,
+				data + urb->iso_frame_desc[cnt].offset,
+				urb->iso_frame_desc[cnt].length,
+				urb->interval, frame, true);
+		}
+		break;
+	default:
+		break;
+	}
+
+	/*
+	 * set the state of URB
+	 * control pipe:3 states -- setup,data,status
+	 * interrupt and bulk pipe:1 state -- data
+	 */
+	urb->pipe &= ~0x1f;
+	urb->pipe |= urb_state & 0x1f;
+
+	urb_priv->state = URB_INPROGRESS;
+
+	if (!ed->td_head) {
+		ed->state = FHCI_ED_OPER;
+		switch (ed->mode) {
+		case FHCI_TF_CTRL:
+			list_add(&ed->node, &fhci->hc_list->ctrl_list);
+			break;
+		case FHCI_TF_BULK:
+			list_add(&ed->node, &fhci->hc_list->bulk_list);
+			break;
+		case FHCI_TF_INTR:
+			list_add(&ed->node, &fhci->hc_list->intr_list);
+			break;
+		case FHCI_TF_ISO:
+			list_add(&ed->node, &fhci->hc_list->iso_list);
+			break;
+		default:
+			break;
+		}
+	}
+
+	fhci_add_tds_to_ed(ed, urb_priv->tds, urb_priv->num_of_tds);
+	fhci->active_urbs++;
+}
diff -urN host/fhci-tds.c host.new/fhci-tds.c
--- host/fhci-tds.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/fhci-tds.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,626 @@
+/*
+ * Freescale QUICC Engine USB Host Controller Driver
+ *
+ * Copyright (c) Freescale Semicondutor, Inc. 2006.
+ *               Shlomi Gridish <gridish@freescale.com>
+ *               Jerry Huang <Chang-Ming.Huang@freescale.com>
+ * Copyright (c) Logic Product Development, Inc. 2007
+ *               Peter Barada <peterb@logicpd.com>
+ * Copyright (c) MontaVista Software, Inc. 2008.
+ *               Anton Vorontsov <avorontsov@ru.mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/io.h>
+#include <linux/usb.h>
+#include "../core/hcd.h"
+#include "fhci.h"
+
+#define DUMMY_BD_BUFFER  0xdeadbeef
+#define DUMMY2_BD_BUFFER 0xbaadf00d
+
+/* Transaction Descriptors bits */
+#define TD_R		0x8000 /* ready bit */
+#define TD_W		0x2000 /* wrap bit */
+#define TD_I		0x1000 /* interrupt on completion */
+#define TD_L		0x0800 /* last */
+#define TD_TC		0x0400 /* transmit CRC */
+#define TD_CNF		0x0200 /* CNF - Must be always 1 */
+#define TD_LSP		0x0100 /* Low-speed transaction */
+#define TD_PID		0x00c0 /* packet id */
+#define TD_RXER		0x0020 /* Rx error or not */
+
+#define TD_NAK		0x0010 /* No ack. */
+#define TD_STAL		0x0008 /* Stall recieved */
+#define TD_TO		0x0004 /* time out */
+#define TD_UN		0x0002 /* underrun */
+#define TD_NO		0x0010 /* Rx Non Octet Aligned Packet */
+#define TD_AB		0x0008 /* Frame Aborted */
+#define TD_CR		0x0004 /* CRC Error */
+#define TD_OV		0x0002 /* Overrun */
+#define TD_BOV		0x0001 /* Buffer Overrun */
+
+#define TD_ERRORS	(TD_NAK | TD_STAL | TD_TO | TD_UN | \
+			 TD_NO | TD_AB | TD_CR | TD_OV | TD_BOV)
+
+#define TD_PID_DATA0	0x0080 /* Data 0 toggle */
+#define TD_PID_DATA1	0x00c0 /* Data 1 toggle */
+#define TD_PID_TOGGLE	0x00c0 /* Data 0/1 toggle mask */
+
+#define TD_TOK_SETUP	0x0000
+#define TD_TOK_OUT	0x4000
+#define TD_TOK_IN	0x8000
+#define TD_ISO		0x1000
+#define TD_ENDP		0x0780
+#define TD_ADDR		0x007f
+
+#define TD_ENDP_SHIFT 7
+
+struct usb_td {
+	__be16 status;
+	__be16 length;
+	__be32 buf_ptr;
+	__be16 extra;
+	__be16 reserved;
+};
+
+static struct usb_td __iomem *next_bd(struct usb_td __iomem *base,
+				      struct usb_td __iomem *td,
+				      u16 status)
+{
+	if (status & TD_W)
+		return base;
+	else
+		return ++td;
+}
+
+void fhci_push_dummy_bd(struct endpoint *ep)
+{
+	if (ep->already_pushed_dummy_bd == false) {
+		u16 td_status = in_be16(&ep->empty_td->status);
+
+		out_be32(&ep->empty_td->buf_ptr, DUMMY_BD_BUFFER);
+		/* get the next TD in the ring */
+		ep->empty_td = next_bd(ep->td_base, ep->empty_td, td_status);
+		ep->already_pushed_dummy_bd = true;
+	}
+}
+
+/* destroy an USB endpoint */
+void fhci_ep0_free(struct fhci_usb *usb)
+{
+	struct endpoint *ep;
+	int size;
+
+	ep = usb->ep0;
+	if (ep) {
+		if (ep->td_base)
+			cpm_muram_free(cpm_muram_offset(ep->td_base));
+
+		if (ep->conf_frame_Q) {
+			size = cq_howmany(ep->conf_frame_Q);
+			for (; size; size--) {
+				struct packet *pkt = cq_get(ep->conf_frame_Q);
+
+				kfree(pkt);
+			}
+			cq_delete(ep->conf_frame_Q);
+		}
+
+		if (ep->empty_frame_Q) {
+			size = cq_howmany(ep->empty_frame_Q);
+			for (; size; size--) {
+				struct packet *pkt = cq_get(ep->empty_frame_Q);
+
+				kfree(pkt);
+			}
+			cq_delete(ep->empty_frame_Q);
+		}
+
+		if (ep->dummy_packets_Q) {
+			size = cq_howmany(ep->dummy_packets_Q);
+			for (; size; size--) {
+				u8 *buff = cq_get(ep->dummy_packets_Q);
+
+				kfree(buff);
+			}
+			cq_delete(ep->dummy_packets_Q);
+		}
+
+		kfree(ep);
+		usb->ep0 = NULL;
+	}
+}
+
+/*
+ * create the endpoint structure
+ *
+ * arguments:
+ * usb		A pointer to the data structure of the USB
+ * data_mem	The data memory partition(BUS)
+ * ring_len	TD ring length
+ */
+u32 fhci_create_ep(struct fhci_usb *usb, enum fhci_mem_alloc data_mem,
+			   u32 ring_len)
+{
+	struct endpoint *ep;
+	struct usb_td __iomem *td;
+	unsigned long ep_offset;
+	char *err_for = "enpoint PRAM";
+	int ep_mem_size;
+	u32 i;
+
+	/* we need at least 3 TDs in the ring */
+	if (!(ring_len > 2)) {
+		fhci_err(usb->fhci, "illegal TD ring length parameters\n");
+		return -EINVAL;
+	}
+
+	ep = kzalloc(sizeof(*ep), GFP_KERNEL);
+	if (!ep)
+		return -ENOMEM;
+
+	ep_mem_size = ring_len * sizeof(*td) + sizeof(struct fhci_ep_pram);
+	ep_offset = cpm_muram_alloc(ep_mem_size, 32);
+	if (IS_ERR_VALUE(ep_offset))
+		goto err;
+	ep->td_base = cpm_muram_addr(ep_offset);
+
+	/* zero all queue pointers */
+	ep->conf_frame_Q = cq_new(ring_len + 2);
+	ep->empty_frame_Q = cq_new(ring_len + 2);
+	ep->dummy_packets_Q = cq_new(ring_len + 2);
+	if (!ep->conf_frame_Q || !ep->empty_frame_Q || !ep->dummy_packets_Q) {
+		err_for = "frame_queues";
+		goto err;
+	}
+
+	for (i = 0; i < (ring_len + 1); i++) {
+		struct packet *pkt;
+		u8 *buff;
+
+		pkt = kmalloc(sizeof(*pkt), GFP_KERNEL);
+		if (!pkt) {
+			err_for = "frame";
+			goto err;
+		}
+
+		buff = kmalloc(1028 * sizeof(*buff), GFP_KERNEL);
+		if (!buff) {
+			kfree(pkt);
+			err_for = "buffer";
+			goto err;
+		}
+		cq_put(ep->empty_frame_Q, pkt);
+		cq_put(ep->dummy_packets_Q, buff);
+	}
+
+	/* we put the endpoint parameter RAM right behind the TD ring */
+	ep->ep_pram_ptr = (void __iomem *)ep->td_base + sizeof(*td) * ring_len;
+
+	ep->conf_td = ep->td_base;
+	ep->empty_td = ep->td_base;
+
+	ep->already_pushed_dummy_bd = false;
+
+	/* initialize tds */
+	td = ep->td_base;
+	for (i = 0; i < ring_len; i++) {
+		out_be32(&td->buf_ptr, 0);
+		out_be16(&td->status, 0);
+		out_be16(&td->length, 0);
+		out_be16(&td->extra, 0);
+		td++;
+	}
+	td--;
+	out_be16(&td->status, TD_W); /* for last TD set Wrap bit */
+	out_be16(&td->length, 0);
+
+	/* endpoint structure has been created */
+	usb->ep0 = ep;
+
+	return 0;
+err:
+	fhci_ep0_free(usb);
+	kfree(ep);
+	fhci_err(usb->fhci, "no memory for the %s\n", err_for);
+	return -ENOMEM;
+}
+
+/*
+ * initialize the endpoint register according to the given parameters
+ *
+ * artuments:
+ * usb		A pointer to the data strucutre of the USB
+ * ep		A pointer to the endpoint structre
+ * data_mem	The data memory partition(BUS)
+ */
+void fhci_init_ep_registers(struct fhci_usb *usb, struct endpoint *ep,
+			    enum fhci_mem_alloc data_mem)
+{
+	u8 rt;
+
+	/* set the endpoint registers according to the endpoint */
+	out_be16(&usb->fhci->regs->usb_ep[0],
+		 USB_TRANS_CTR | USB_EP_MF | USB_EP_RTE);
+	out_be16(&usb->fhci->pram->ep_ptr[0],
+		 cpm_muram_offset(ep->ep_pram_ptr));
+
+	rt = (BUS_MODE_BO_BE | BUS_MODE_GBL);
+#ifdef MULTI_DATA_BUS
+	if (data_mem == MEM_SECONDARY)
+		rt |= BUS_MODE_DTB;
+#endif
+	out_8(&ep->ep_pram_ptr->rx_func_code, rt);
+	out_8(&ep->ep_pram_ptr->tx_func_code, rt);
+	out_be16(&ep->ep_pram_ptr->rx_buff_len, 1028);
+	out_be16(&ep->ep_pram_ptr->rx_base, 0);
+	out_be16(&ep->ep_pram_ptr->tx_base, cpm_muram_offset(ep->td_base));
+	out_be16(&ep->ep_pram_ptr->rx_bd_ptr, 0);
+	out_be16(&ep->ep_pram_ptr->tx_bd_ptr, cpm_muram_offset(ep->td_base));
+	out_be32(&ep->ep_pram_ptr->tx_state, 0);
+}
+
+/*
+ * Collect the submitted frames and inform the application about them
+ * It is also prepearing the TDs for new frames. If the Tx interrupts
+ * are diabled, the application should call that routine to get
+ * confirmation about the submitted frames. Otherwise, the routine is
+ * called frome the interrupt service routine during the Tx interrupt.
+ * In that case the application is informed by calling the application
+ * specific 'fhci_transaction_confirm' routine
+ */
+static void fhci_td_transaction_confirm(struct fhci_usb *usb)
+{
+	struct endpoint *ep = usb->ep0;
+	struct packet *pkt;
+	struct usb_td __iomem *td;
+	u16 extra_data;
+	u16 td_status;
+	u16 td_length;
+	u32 buf;
+
+	/*
+	 * collect transmitted BDs from the chip. The routine clears all BDs
+	 * with R bit = 0 and the pointer to data buffer is not NULL, that is
+	 * BDs which point to the transmitted data buffer
+	 */
+	while (1) {
+		td = ep->conf_td;
+		td_status = in_be16(&td->status);
+		td_length = in_be16(&td->length);
+		buf = in_be32(&td->buf_ptr);
+		extra_data = in_be16(&td->extra);
+
+		/* check if the TD is empty */
+		if (!(!(td_status & TD_R) && ((td_status & ~TD_W) || buf)))
+			break;
+		/* check if it is a dummy buffer */
+		else if ((buf == DUMMY_BD_BUFFER) && !(td_status & ~TD_W))
+			break;
+
+		/* mark TD as empty */
+		clrbits16(&td->status, ~TD_W);
+		out_be16(&td->length, 0);
+		out_be32(&td->buf_ptr, 0);
+		out_be16(&td->extra, 0);
+		/* advance the TD pointer */
+		ep->conf_td = next_bd(ep->td_base, ep->conf_td, td_status);
+
+		/* check if it is a dummy buffer(type2) */
+		if ((buf == DUMMY2_BD_BUFFER) && !(td_status & ~TD_W))
+			continue;
+
+		pkt = cq_get(ep->conf_frame_Q);
+		if (!pkt)
+			fhci_err(usb->fhci, "no frame to confirm\n");
+
+		if (td_status & TD_ERRORS) {
+			if (td_status & TD_RXER) {
+				if (td_status & TD_CR)
+					pkt->status = USB_TD_RX_ER_CRC;
+				else if (td_status & TD_AB)
+					pkt->status = USB_TD_RX_ER_BITSTUFF;
+				else if (td_status & TD_OV)
+					pkt->status = USB_TD_RX_ER_OVERUN;
+				else if (td_status & TD_BOV)
+					pkt->status = USB_TD_RX_DATA_OVERUN;
+				else if (td_status & TD_NO)
+					pkt->status = USB_TD_RX_ER_NONOCT;
+				else
+					fhci_err(usb->fhci, "illegal error "
+						 "occured\n");
+			} else if (td_status & TD_NAK)
+				pkt->status = USB_TD_TX_ER_NAK;
+			else if (td_status & TD_TO)
+				pkt->status = USB_TD_TX_ER_TIMEOUT;
+			else if (td_status & TD_UN)
+				pkt->status = USB_TD_TX_ER_UNDERUN;
+			else if (td_status & TD_STAL)
+				pkt->status = USB_TD_TX_ER_STALL;
+			else
+				fhci_err(usb->fhci, "illegal error occured\n");
+		} else if ((extra_data & TD_TOK_IN) &&
+				pkt->len > td_length - CRC_SIZE) {
+			pkt->status = USB_TD_RX_DATA_UNDERUN;
+		}
+
+		if (extra_data & TD_TOK_IN)
+			pkt->len = td_length - CRC_SIZE;
+		else if (pkt->info & PKT_ZLP)
+			pkt->len = 0;
+		else
+			pkt->len = td_length;
+
+		fhci_transaction_confirm(usb, pkt);
+	}
+}
+
+/*
+ * Submitting a data frame to a specified endpoint of a USB device
+ * The frame is put in the driver's transmit queue for this endpoint
+ *
+ * Arguments:
+ * usb          A pointer to the USB structure
+ * pkt          A pointer to the user frame structure
+ * trans_type   Transaction tyep - IN,OUT or SETUP
+ * dest_addr    Device address - 0~127
+ * dest_ep      Endpoint number of the device - 0~16
+ * trans_mode   Pipe type - ISO,Interrupt,bulk or control
+ * dest_speed   USB speed - Low speed or FULL speed
+ * data_toggle  Data sequence toggle - 0 or 1
+ */
+u32 fhci_host_transaction(struct fhci_usb *usb,
+			  struct packet *pkt,
+			  enum fhci_ta_type trans_type,
+			  u8 dest_addr,
+			  u8 dest_ep,
+			  enum fhci_tf_mode trans_mode,
+			  enum fhci_speed dest_speed, u8 data_toggle)
+{
+	struct endpoint *ep = usb->ep0;
+	struct usb_td __iomem *td;
+	u16 extra_data;
+	u16 td_status;
+
+	fhci_usb_disable_interrupt(usb);
+	/* start from the next BD that should be filled */
+	td = ep->empty_td;
+	td_status = in_be16(&td->status);
+
+	if (td_status & TD_R && in_be16(&td->length)) {
+		/* if the TD is not free */
+		fhci_usb_enable_interrupt(usb);
+		return -1;
+	}
+
+	/* get the next TD in the ring */
+	ep->empty_td = next_bd(ep->td_base, ep->empty_td, td_status);
+	fhci_usb_enable_interrupt(usb);
+	pkt->priv_data = td;
+	out_be32(&td->buf_ptr, virt_to_phys(pkt->data));
+	/* sets up transaction parameters - addr,endp,dir,and type */
+	extra_data = (dest_ep << TD_ENDP_SHIFT) | dest_addr;
+	switch (trans_type) {
+	case FHCI_TA_IN:
+		extra_data |= TD_TOK_IN;
+		break;
+	case FHCI_TA_OUT:
+		extra_data |= TD_TOK_OUT;
+		break;
+	case FHCI_TA_SETUP:
+		extra_data |= TD_TOK_SETUP;
+		break;
+	}
+	if (trans_mode == FHCI_TF_ISO)
+		extra_data |= TD_ISO;
+	out_be16(&td->extra, extra_data);
+
+	/* sets up the buffer descriptor */
+	td_status = ((td_status & TD_W) | TD_R | TD_L | TD_I | TD_CNF);
+	if (!(pkt->info & PKT_NO_CRC))
+		td_status |= TD_TC;
+
+	switch (trans_type) {
+	case FHCI_TA_IN:
+		if (data_toggle)
+			pkt->info |= PKT_PID_DATA1;
+		else
+			pkt->info |= PKT_PID_DATA0;
+		break;
+	default:
+		if (data_toggle) {
+			td_status |= TD_PID_DATA1;
+			pkt->info |= PKT_PID_DATA1;
+		} else {
+			td_status |= TD_PID_DATA0;
+			pkt->info |= PKT_PID_DATA0;
+		}
+		break;
+	}
+
+	if ((dest_speed == FHCI_LOW_SPEED) &&
+	    (usb->port_status == FHCI_PORT_FULL))
+		td_status |= TD_LSP;
+
+	out_be16(&td->status, td_status);
+
+	/* set up buffer length */
+	if (trans_type == FHCI_TA_IN)
+		out_be16(&td->length, pkt->len + CRC_SIZE);
+	else
+		out_be16(&td->length, pkt->len);
+
+	/* put the frame to the confirmation queue */
+	cq_put(ep->conf_frame_Q, pkt);
+
+	if (cq_howmany(ep->conf_frame_Q) == 1)
+		out_8(&usb->fhci->regs->usb_comm, USB_CMD_STR_FIFO);
+
+	return 0;
+}
+
+/* Reset the Tx BD ring */
+void fhci_flush_bds(struct fhci_usb *usb)
+{
+	u16 extra_data;
+	u16 td_status;
+	u32 buf;
+	struct usb_td __iomem *td;
+	struct endpoint *ep = usb->ep0;
+
+	td = ep->td_base;
+	while (1) {
+		td_status = in_be16(&td->status);
+		buf = in_be32(&td->buf_ptr);
+		extra_data = in_be16(&td->extra);
+
+		/* if the TD is not empty - we'll confirm it as Timeout */
+		if (td_status & TD_R)
+			out_be16(&td->status, (td_status & ~TD_R) | TD_TO);
+		/* if this TD is dummy - let's skip this TD */
+		else if (in_be32(&td->buf_ptr) == DUMMY_BD_BUFFER)
+			out_be32(&td->buf_ptr, DUMMY2_BD_BUFFER);
+		/* if this is the last TD - break */
+		if (td_status & TD_W)
+			break;
+
+		td++;
+	}
+
+	fhci_td_transaction_confirm(usb);
+
+	td = ep->td_base;
+	do {
+		out_be16(&td->status, 0);
+		out_be16(&td->length, 0);
+		out_be32(&td->buf_ptr, 0);
+		out_be16(&td->extra, 0);
+		td++;
+	} while (!(in_be16(&td->status) & TD_W));
+	out_be16(&td->status, TD_W); /* for last TD set Wrap bit */
+	out_be16(&td->length, 0);
+	out_be32(&td->buf_ptr, 0);
+	out_be16(&td->extra, 0);
+
+	out_be16(&ep->ep_pram_ptr->tx_bd_ptr,
+		 in_be16(&ep->ep_pram_ptr->tx_base));
+	out_be32(&ep->ep_pram_ptr->tx_state, 0);
+	out_be16(&ep->ep_pram_ptr->tx_cnt, 0);
+	ep->empty_td = ep->td_base;
+	ep->conf_td = ep->td_base;
+}
+
+/*
+ * Flush all transmitted packets from TDs in the actual frame.
+ * This routine is called when something wrong with the controller and
+ * we want to get rid of the actual frame and start again next frame
+ */
+void fhci_flush_actual_frame(struct fhci_usb *usb)
+{
+	u8 mode;
+	u16 tb_ptr;
+	u16 extra_data;
+	u16 td_status;
+	u32 buf_ptr;
+	struct usb_td __iomem *td;
+	struct endpoint *ep = usb->ep0;
+
+	/* disable the USB controller */
+	mode = in_8(&usb->fhci->regs->usb_mod);
+	out_8(&usb->fhci->regs->usb_mod, mode & ~USB_MODE_EN);
+
+	tb_ptr = in_be16(&ep->ep_pram_ptr->tx_bd_ptr);
+	td = cpm_muram_addr(tb_ptr);
+	td_status = in_be16(&td->status);
+	buf_ptr = in_be32(&td->buf_ptr);
+	extra_data = in_be16(&td->extra);
+	do {
+		if (td_status & TD_R) {
+			out_be16(&td->status, (td_status & ~TD_R) | TD_TO);
+		} else {
+			out_be32(&td->buf_ptr, 0);
+			ep->already_pushed_dummy_bd = false;
+			break;
+		}
+
+		/* advance the TD pointer */
+		td = next_bd(ep->td_base, td, td_status);
+		td_status = in_be16(&td->status);
+		buf_ptr = in_be32(&td->buf_ptr);
+		extra_data = in_be16(&td->extra);
+	} while ((td_status & TD_R) || buf_ptr);
+
+	fhci_td_transaction_confirm(usb);
+
+	out_be16(&ep->ep_pram_ptr->tx_bd_ptr,
+		 in_be16(&ep->ep_pram_ptr->tx_base));
+	out_be32(&ep->ep_pram_ptr->tx_state, 0);
+	out_be16(&ep->ep_pram_ptr->tx_cnt, 0);
+	ep->empty_td = ep->td_base;
+	ep->conf_td = ep->td_base;
+
+	usb->actual_frame->frame_status = FRAME_TIMER_END_TRANSMISSION;
+
+	/* reset the event register */
+	out_be16(&usb->fhci->regs->usb_event, 0xffff);
+	/* enable the USB controller */
+	out_8(&usb->fhci->regs->usb_mod, mode | USB_MODE_EN);
+}
+
+/* handles Tx confirm and Tx error interrupt */
+void fhci_tx_conf_interrupt(struct fhci_usb *usb)
+{
+	fhci_td_transaction_confirm(usb);
+
+	/*
+	 * Schedule another transaction to this frame only if we have
+	 * already confirmed all transaction in the frame.
+	 */
+	if (((fhci_get_sof_timer_count(usb) < usb->max_frame_usage) ||
+	     (usb->actual_frame->frame_status & FRAME_END_TRANSMISSION)) &&
+	    (list_empty(&usb->actual_frame->tds_list)))
+		fhci_schedule_transactions(usb);
+}
+
+void fhci_host_transmit_actual_frame(struct fhci_usb *usb)
+{
+	u16 tb_ptr;
+	u16 td_status;
+	struct usb_td __iomem *td;
+	struct endpoint *ep = usb->ep0;
+
+	tb_ptr = in_be16(&ep->ep_pram_ptr->tx_bd_ptr);
+	td = cpm_muram_addr(tb_ptr);
+
+	if (in_be32(&td->buf_ptr) == DUMMY_BD_BUFFER) {
+		struct usb_td __iomem *old_td = td;
+
+		ep->already_pushed_dummy_bd = false;
+		td_status = in_be16(&td->status);
+		/* gets the next TD in the ring */
+		td = next_bd(ep->td_base, td, td_status);
+		tb_ptr = cpm_muram_offset(td);
+		out_be16(&ep->ep_pram_ptr->tx_bd_ptr, tb_ptr);
+
+		/* start transmit only if we have something in the TDs */
+		if (in_be16(&td->status) & TD_R)
+			out_8(&usb->fhci->regs->usb_comm, USB_CMD_STR_FIFO);
+
+		if (in_be32(&ep->conf_td->buf_ptr) == DUMMY_BD_BUFFER) {
+			out_be32(&old_td->buf_ptr, 0);
+			ep->conf_td = next_bd(ep->td_base, ep->conf_td,
+					      td_status);
+		} else {
+			out_be32(&old_td->buf_ptr, DUMMY2_BD_BUFFER);
+		}
+	}
+}
diff -urN host/fhci.h host.new/fhci.h
--- host/fhci.h	1970-01-01 01:00:00.000000000 +0100
+++ host.new/fhci.h	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,607 @@
+/*
+ * Freescale QUICC Engine USB Host Controller Driver
+ *
+ * Copyright (c) Freescale Semicondutor, Inc. 2006.
+ *               Shlomi Gridish <gridish@freescale.com>
+ *               Jerry Huang <Chang-Ming.Huang@freescale.com>
+ * Copyright (c) Logic Product Development, Inc. 2007
+ *               Peter Barada <peterb@logicpd.com>
+ * Copyright (c) MontaVista Software, Inc. 2008.
+ *               Anton Vorontsov <avorontsov@ru.mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __FHCI_H
+#define __FHCI_H
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/io.h>
+#include <linux/usb.h>
+#include <asm/qe.h>
+#include "../core/hcd.h"
+
+#define USB_CLOCK	48000000
+
+#define FHCI_PRAM_SIZE 0x100
+
+#define MAX_EDS		32
+#define MAX_TDS		32
+
+
+/* CRC16 field size */
+#define CRC_SIZE 2
+
+/* USB protocol overhead for each frame transmitted from the host */
+#define PROTOCOL_OVERHEAD 7
+
+/* Packet structure, info field */
+#define PKT_PID_DATA0		0x80000000 /* PID - Data toggle zero */
+#define PKT_PID_DATA1		0x40000000 /* PID - Data toggle one  */
+#define PKT_PID_SETUP		0x20000000 /* PID - Setup bit */
+#define PKT_SETUP_STATUS	0x10000000 /* Setup status bit */
+#define PKT_SETADDR_STATUS	0x08000000 /* Set address status bit */
+#define PKT_SET_HOST_LAST	0x04000000 /* Last data packet */
+#define PKT_HOST_DATA		0x02000000 /* Data packet */
+#define PKT_FIRST_IN_FRAME	0x01000000 /* First packet in the frame */
+#define PKT_TOKEN_FRAME		0x00800000 /* Token packet */
+#define PKT_ZLP			0x00400000 /* Zero length packet */
+#define PKT_IN_TOKEN_FRAME	0x00200000 /* IN token packet */
+#define PKT_OUT_TOKEN_FRAME	0x00100000 /* OUT token packet */
+#define PKT_SETUP_TOKEN_FRAME	0x00080000 /* SETUP token packet */
+#define PKT_STALL_FRAME		0x00040000 /* STALL packet */
+#define PKT_NACK_FRAME		0x00020000 /* NACK packet */
+#define PKT_NO_PID		0x00010000 /* No PID */
+#define PKT_NO_CRC		0x00008000 /* don't append CRC */
+#define PKT_HOST_COMMAND	0x00004000 /* Host command packet */
+#define PKT_DUMMY_PACKET	0x00002000 /* Dummy packet, used for mmm */
+#define PKT_LOW_SPEED_PACKET	0x00001000 /* Low-Speed packet */
+
+#define TRANS_OK		(0)
+#define TRANS_INPROGRESS	(-1)
+#define TRANS_DISCARD		(-2)
+#define TRANS_FAIL		(-3)
+
+#define PS_INT		0
+#define PS_DISCONNECTED	1
+#define PS_CONNECTED	2
+#define PS_READY	3
+#define PS_MISSING	4
+
+/* Transfer Descriptor status field */
+#define USB_TD_OK		0x00000000 /* TD transmited or received ok */
+#define USB_TD_INPROGRESS	0x80000000 /* TD is being transmitted */
+#define USB_TD_RX_ER_NONOCT	0x40000000 /* Tx Non Octet Aligned Packet */
+#define USB_TD_RX_ER_BITSTUFF	0x20000000 /* Frame Aborted-Received pkt */
+#define USB_TD_RX_ER_CRC	0x10000000 /* CRC error */
+#define USB_TD_RX_ER_OVERUN	0x08000000 /* Over - run occured */
+#define USB_TD_RX_ER_PID	0x04000000 /* wrong PID received */
+#define USB_TD_RX_DATA_UNDERUN	0x02000000 /* shorter than expected */
+#define USB_TD_RX_DATA_OVERUN	0x01000000 /* longer than expected */
+#define USB_TD_TX_ER_NAK	0x00800000 /* NAK handshake */
+#define USB_TD_TX_ER_STALL	0x00400000 /* STALL handshake */
+#define USB_TD_TX_ER_TIMEOUT	0x00200000 /* transmit time out */
+#define USB_TD_TX_ER_UNDERUN	0x00100000 /* transmit underrun */
+
+#define USB_TD_ERROR (USB_TD_RX_ER_NONOCT | USB_TD_RX_ER_BITSTUFF | \
+		USB_TD_RX_ER_CRC | USB_TD_RX_ER_OVERUN | USB_TD_RX_ER_PID | \
+		USB_TD_RX_DATA_UNDERUN | USB_TD_RX_DATA_OVERUN | \
+		USB_TD_TX_ER_NAK | USB_TD_TX_ER_STALL | \
+		USB_TD_TX_ER_TIMEOUT | USB_TD_TX_ER_UNDERUN)
+
+/* Transfer Descriptor toggle field */
+#define USB_TD_TOGGLE_DATA0	0
+#define USB_TD_TOGGLE_DATA1	1
+#define USB_TD_TOGGLE_CARRY	2
+
+/* #define MULTI_DATA_BUS */
+
+/* Bus mode register RBMR/TBMR */
+#define BUS_MODE_GBL	0x20	/* Global snooping */
+#define BUS_MODE_BO	0x18	/* Byte ordering */
+#define BUS_MODE_BO_BE	0x10	/* Byte ordering - Big-endian */
+#define BUS_MODE_DTB	0x02	/* Data bus */
+
+/* FHCI QE USB Register Description */
+
+/* USB Mode Register bit define */
+#define USB_MODE_EN		0x01
+#define USB_MODE_HOST		0x02
+#define USB_MODE_TEST		0x04
+#define USB_MODE_SFTE		0x08
+#define USB_MODE_RESUME		0x40
+#define USB_MODE_LSS		0x80
+
+/* USB Slave Address Register Mask */
+#define USB_SLVADDR_MASK	0x7F
+
+/* USB Endpoint register define */
+#define USB_EPNUM_MASK		0xF000
+#define USB_EPNUM_SHIFT		12
+
+#define USB_TRANS_MODE_SHIFT	8
+#define USB_TRANS_CTR		0x0000
+#define USB_TRANS_INT		0x0100
+#define USB_TRANS_BULK		0x0200
+#define USB_TRANS_ISO		0x0300
+
+#define USB_EP_MF		0x0020
+#define USB_EP_RTE		0x0010
+
+#define USB_THS_SHIFT		2
+#define USB_THS_MASK		0x000c
+#define USB_THS_NORMAL		0x0
+#define USB_THS_IGNORE_IN	0x0004
+#define USB_THS_NACK		0x0008
+#define USB_THS_STALL		0x000c
+
+#define USB_RHS_SHIFT   	0
+#define USB_RHS_MASK		0x0003
+#define USB_RHS_NORMAL  	0x0
+#define USB_RHS_IGNORE_OUT	0x0001
+#define USB_RHS_NACK		0x0002
+#define USB_RHS_STALL		0x0003
+
+#define USB_RTHS_MASK		0x000f
+
+/* USB Command Register define */
+#define USB_CMD_STR_FIFO	0x80
+#define USB_CMD_FLUSH_FIFO	0x40
+#define USB_CMD_ISFT		0x20
+#define USB_CMD_DSFT		0x10
+#define USB_CMD_EP_MASK		0x03
+
+/* USB Event and Mask Register define */
+#define USB_E_MSF_MASK		0x0800
+#define USB_E_SFT_MASK		0x0400
+#define USB_E_RESET_MASK	0x0200
+#define USB_E_IDLE_MASK		0x0100
+#define USB_E_TXE4_MASK		0x0080
+#define USB_E_TXE3_MASK		0x0040
+#define USB_E_TXE2_MASK		0x0020
+#define USB_E_TXE1_MASK		0x0010
+#define USB_E_SOF_MASK		0x0008
+#define USB_E_BSY_MASK		0x0004
+#define USB_E_TXB_MASK		0x0002
+#define USB_E_RXB_MASK		0x0001
+
+/* Freescale USB Host controller registers */
+struct fhci_regs {
+	u8 usb_mod;		/* mode register */
+	u8 usb_addr;		/* address register */
+	u8 usb_comm;		/* command register */
+	u8 reserved1[1];
+	__be16 usb_ep[4];	/* endpoint register */
+	u8 reserved2[4];
+	__be16 usb_event;	/* event register */
+	u8 reserved3[2];
+	__be16 usb_mask;	/* mask register */
+	u8 reserved4[1];
+	u8 usb_status;		/* status register */
+	__be16 usb_sof_tmr;	/* Start Of Frame timer */
+	u8 reserved5[2];
+	__be16 usb_frame_num;	/* frame number register */
+	u8 reserved6[1];
+};
+
+/* Freescale USB HOST */
+struct fhci_pram {
+	__be16 ep_ptr[4];	/* Endpoint porter reg */
+	__be32 rx_state;	/* Rx internal state */
+	__be32 rx_ptr;		/* Rx internal data pointer */
+	__be16 frame_num;	/* Frame number */
+	__be16 rx_cnt;		/* Rx byte count */
+	__be32 rx_temp;		/* Rx temp */
+	__be32 rx_data_temp;	/* Rx data temp */
+	__be16 rx_u_ptr;	/* Rx microcode return address temp */
+	u8 reserved1[2];	/* reserved area */
+	__be32 sof_tbl;		/* SOF lookup table pointer */
+	u8 sof_u_crc_temp;	/* SOF micorcode CRC5 temp reg */
+	u8 reserved2[0xdb];
+};
+
+/* Freescale USB Endpoint*/
+struct fhci_ep_pram {
+	__be16 rx_base;		/* Rx BD base address */
+	__be16 tx_base;		/* Tx BD base address */
+	u8 rx_func_code;	/* Rx function code */
+	u8 tx_func_code;	/* Tx function code */
+	__be16 rx_buff_len;	/* Rx buffer length */
+	__be16 rx_bd_ptr;	/* Rx BD pointer */
+	__be16 tx_bd_ptr;	/* Tx BD pointer */
+	__be32 tx_state;	/* Tx internal state */
+	__be32 tx_ptr;		/* Tx internal data pointer */
+	__be16 tx_crc;		/* temp transmit CRC */
+	__be16 tx_cnt;		/* Tx byte count */
+	__be32 tx_temp;		/* Tx temp */
+	__be16 tx_u_ptr;	/* Tx microcode return address temp */
+	__be16 reserved;
+};
+
+struct fhci_controller_list {
+	struct list_head ctrl_list;	/* control endpoints */
+	struct list_head bulk_list;	/* bulk endpoints */
+	struct list_head iso_list;	/* isochronous endpoints */
+	struct list_head intr_list;	/* interruput endpoints */
+	struct list_head done_list;	/* done transfers */
+};
+
+struct virtual_root_hub {
+	int dev_num;	/* USB address of the root hub */
+	u32 feature;	/* indicates what feature has been set */
+	struct usb_hub_status hub;
+	struct usb_port_status port;
+};
+
+enum fhci_gpios {
+	GPIO_USBOE = 0,
+	GPIO_USBTP,
+	GPIO_USBTN,
+	GPIO_USBRP,
+	GPIO_USBRN,
+	/* these are optional */
+	GPIO_SPEED,
+	GPIO_POWER,
+	NUM_GPIOS,
+};
+
+enum fhci_pins {
+	PIN_USBOE = 0,
+	PIN_USBTP,
+	PIN_USBTN,
+	NUM_PINS,
+};
+
+struct fhci_hcd {
+	enum qe_clock fullspeed_clk;
+	enum qe_clock lowspeed_clk;
+	struct qe_pin *pins[NUM_PINS];
+	int gpios[NUM_GPIOS];
+	bool alow_gpios[NUM_GPIOS];
+
+	struct fhci_regs __iomem *regs;	/* I/O memory used to communicate */
+	struct fhci_pram __iomem *pram;	/* Parameter RAM */
+	struct gtm_timer *timer;
+
+	spinlock_t lock;
+	struct fhci_usb *usb_lld; /* Low-level driver */
+	struct virtual_root_hub *vroot_hub; /* the virtual root hub */
+	int active_urbs;
+	struct fhci_controller_list *hc_list;
+	struct tasklet_struct *process_done_task; /* tasklet for done list */
+
+	struct list_head empty_eds;
+	struct list_head empty_tds;
+
+#ifdef CONFIG_FHCI_DEBUG
+	int usb_irq_stat[13];
+	struct dentry *dfs_root;
+	struct dentry *dfs_regs;
+	struct dentry *dfs_irq_stat;
+#endif
+};
+
+#define USB_FRAME_USAGE 90
+#define FRAME_TIME_USAGE (USB_FRAME_USAGE*10)	/* frame time usage */
+#define SW_FIX_TIME_BETWEEN_TRANSACTION 150	/* SW */
+#define MAX_BYTES_PER_FRAME (USB_FRAME_USAGE*15)
+#define MAX_PERIODIC_FRAME_USAGE 90
+
+/* transaction type */
+enum fhci_ta_type {
+	FHCI_TA_IN = 0,	/* input transaction */
+	FHCI_TA_OUT,	/* output transaction */
+	FHCI_TA_SETUP,	/* setup transaction */
+};
+
+/* transfer mode */
+enum fhci_tf_mode {
+	FHCI_TF_CTRL = 0,
+	FHCI_TF_ISO,
+	FHCI_TF_BULK,
+	FHCI_TF_INTR,
+};
+
+enum fhci_speed {
+	FHCI_FULL_SPEED,
+	FHCI_LOW_SPEED,
+};
+
+/* endpoint state */
+enum fhci_ed_state {
+	FHCI_ED_NEW = 0, /* pipe is new */
+	FHCI_ED_OPER,    /* pipe is operating */
+	FHCI_ED_URB_DEL, /* pipe is in hold because urb is being deleted */
+	FHCI_ED_SKIP,    /* skip this pipe */
+	FHCI_ED_HALTED,  /* pipe is halted */
+};
+
+enum fhci_port_status {
+	FHCI_PORT_POWER_OFF = 0,
+	FHCI_PORT_DISABLED,
+	FHCI_PORT_DISCONNECTING,
+	FHCI_PORT_WAITING,	/* waiting for connection */
+	FHCI_PORT_FULL,		/* full speed connected */
+	FHCI_PORT_LOW,		/* low speed connected */
+};
+
+enum fhci_mem_alloc {
+	MEM_CACHABLE_SYS = 0x00000001,	/* primary DDR,cachable */
+	MEM_NOCACHE_SYS = 0x00000004,	/* primary DDR,non-cachable */
+	MEM_SECONDARY = 0x00000002,	/* either secondary DDR or SDRAM */
+	MEM_PRAM = 0x00000008,		/* multi-user RAM identifier */
+};
+
+/* USB default parameters*/
+#define DEFAULT_RING_LEN	8
+#define DEFAULT_DATA_MEM	MEM_CACHABLE_SYS
+
+struct ed {
+	u8 dev_addr;		/* device address */
+	u8 ep_addr;		/* endpoint address */
+	enum fhci_tf_mode mode;	/* USB transfer mode */
+	enum fhci_speed speed;
+	unsigned int max_pkt_size;
+	enum fhci_ed_state state;
+	struct list_head td_list; /* a list of all queued TD to this pipe */
+	struct list_head node;
+
+	/* read only parameters, should be cleared upon initialization */
+	u8 toggle_carry;	/* toggle carry from the last TD submitted */
+	u32 last_iso;		/* time stamp of last queued ISO transfer */
+	struct td *td_head;	/* a pointer to the current TD handled */
+};
+
+struct td {
+	void *data;		 /* a pointer to the data buffer */
+	unsigned int len;	 /* length of the data to be submitted */
+	unsigned int actual_len; /* actual bytes transfered on this td */
+	enum fhci_ta_type type;	 /* transaction type */
+	u8 toggle;		 /* toggle for next trans. within this TD */
+	u16 iso_index;		 /* ISO transaction index */
+	u16 start_frame;	 /* start frame time stamp */
+	u16 interval;		 /* interval between trans. (for ISO/Intr) */
+	u32 status;		 /* status of the TD */
+	struct ed *ed;		 /* a handle to the corresponding ED */
+	struct urb *urb;	 /* a handle to the corresponding URB */
+	bool ioc;		 /* Inform On Completion */
+	struct list_head node;
+
+	/* read only parameters should be cleared upon initialization */
+	struct packet *pkt;
+	int nak_cnt;
+	int error_cnt;
+	struct list_head frame_lh;
+};
+
+struct packet {
+	u8 *data;	/* packet data */
+	u32 len;	/* packet length */
+	u32 status;	/* status of the packet - equivalent to the status
+			 * field for the corresponding structure td */
+	u32 info;	/* packet information */
+	void __iomem *priv_data; /* private data of the driver (TDs or BDs) */
+};
+
+/* struct for each URB */
+#define URB_INPROGRESS	0
+#define URB_DEL		1
+
+/* URB states (state field) */
+#define US_BULK		0
+#define US_BULK0	1
+
+/* three setup states */
+#define US_CTRL_SETUP	2
+#define US_CTRL_DATA	1
+#define US_CTRL_ACK	0
+
+#define EP_ZERO	0
+
+struct urb_priv {
+	int num_of_tds;
+	int tds_cnt;
+	int state;
+
+	struct td **tds;
+	struct ed *ed;
+	struct timer_list time_out;
+};
+
+struct endpoint {
+	/* Pointer to ep parameter RAM */
+	struct fhci_ep_pram __iomem *ep_pram_ptr;
+
+	/* Host transactions */
+	struct usb_td __iomem *td_base; /* first TD in the ring */
+	struct usb_td __iomem *conf_td; /* next TD for confirm after transac */
+	struct usb_td __iomem *empty_td;/* next TD for new transaction req. */
+	struct kfifo *empty_frame_Q;  /* Empty frames list to use */
+	struct kfifo *conf_frame_Q;   /* frames passed to TDs,waiting for tx */
+	struct kfifo *dummy_packets_Q;/* dummy packets for the CRC overun */
+
+	bool already_pushed_dummy_bd;
+};
+
+/* struct for each 1mSec frame time */
+#define FRAME_IS_TRANSMITTED		0x00
+#define FRAME_TIMER_END_TRANSMISSION	0x01
+#define FRAME_DATA_END_TRANSMISSION	0x02
+#define FRAME_END_TRANSMISSION		0x03
+#define FRAME_IS_PREPARED		0x04
+
+struct fhci_time_frame {
+	u16 frame_num;	 /* frame number */
+	u16 total_bytes; /* total bytes submitted within this frame */
+	u8 frame_status; /* flag that indicates to stop fill this frame */
+	struct list_head tds_list; /* all tds of this frame */
+};
+
+/* internal driver structure*/
+struct fhci_usb {
+	u16 saved_msk;		 /* saving of the USB mask register */
+	struct endpoint *ep0;	 /* pointer for endpoint0 structure */
+	int intr_nesting_cnt;	 /* interrupt nesting counter */
+	u16 max_frame_usage;	 /* max frame time usage,in micro-sec */
+	u16 max_bytes_per_frame; /* max byte can be tx in one time frame */
+	u32 sw_transaction_time; /* sw complete trans time,in micro-sec */
+	struct fhci_time_frame *actual_frame;
+	struct fhci_controller_list *hc_list;	/* main structure for hc */
+	struct virtual_root_hub *vroot_hub;
+	enum fhci_port_status port_status;	/* v_rh port status */
+
+	u32 (*transfer_confirm)(struct fhci_hcd *fhci);
+
+	struct fhci_hcd *fhci;
+};
+
+/*
+ * Various helpers and prototypes below.
+ */
+
+static inline u16 get_frame_num(struct fhci_hcd *fhci)
+{
+	return in_be16(&fhci->pram->frame_num) & 0x07ff;
+}
+
+#define fhci_dbg(fhci, fmt, args...) \
+		dev_dbg(fhci_to_hcd(fhci)->self.controller, fmt, ##args)
+#define fhci_vdbg(fhci, fmt, args...) \
+		dev_vdbg(fhci_to_hcd(fhci)->self.controller, fmt, ##args)
+#define fhci_err(fhci, fmt, args...) \
+		dev_err(fhci_to_hcd(fhci)->self.controller, fmt, ##args)
+#define fhci_info(fhci, fmt, args...) \
+		dev_info(fhci_to_hcd(fhci)->self.controller, fmt, ##args)
+#define fhci_warn(fhci, fmt, args...) \
+		dev_warn(fhci_to_hcd(fhci)->self.controller, fmt, ##args)
+
+static inline struct fhci_hcd *hcd_to_fhci(struct usb_hcd *hcd)
+{
+	return (struct fhci_hcd *)hcd->hcd_priv;
+}
+
+static inline struct usb_hcd *fhci_to_hcd(struct fhci_hcd *fhci)
+{
+	return container_of((void *)fhci, struct usb_hcd, hcd_priv);
+}
+
+/* fifo of pointers */
+static inline struct kfifo *cq_new(int size)
+{
+	return kfifo_alloc(size * sizeof(void *), GFP_KERNEL, NULL);
+}
+
+static inline void cq_delete(struct kfifo *kfifo)
+{
+	kfifo_free(kfifo);
+}
+
+static inline unsigned int cq_howmany(struct kfifo *kfifo)
+{
+	return __kfifo_len(kfifo) / sizeof(void *);
+}
+
+static inline int cq_put(struct kfifo *kfifo, void *p)
+{
+	return __kfifo_put(kfifo, (void *)&p, sizeof(p));
+}
+
+static inline void *cq_get(struct kfifo *kfifo)
+{
+	void *p = NULL;
+
+	__kfifo_get(kfifo, (void *)&p, sizeof(p));
+	return p;
+}
+
+/* fhci-hcd.c */
+void fhci_start_sof_timer(struct fhci_hcd *fhci);
+void fhci_stop_sof_timer(struct fhci_hcd *fhci);
+u16 fhci_get_sof_timer_count(struct fhci_usb *usb);
+void fhci_usb_enable_interrupt(struct fhci_usb *usb);
+void fhci_usb_disable_interrupt(struct fhci_usb *usb);
+int fhci_ioports_check_bus_state(struct fhci_hcd *fhci);
+
+/* fhci-mem.c */
+void fhci_recycle_empty_td(struct fhci_hcd *fhci, struct td *td);
+void fhci_recycle_empty_ed(struct fhci_hcd *fhci, struct ed *ed);
+struct ed *fhci_get_empty_ed(struct fhci_hcd *fhci);
+struct td *fhci_td_fill(struct fhci_hcd *fhci, struct urb *urb,
+			struct urb_priv *urb_priv, struct ed *ed, u16 index,
+			enum fhci_ta_type type, int toggle, u8 *data, u32 len,
+			u16 interval, u16 start_frame, bool ioc);
+void fhci_add_tds_to_ed(struct ed *ed, struct td **td_list, int number);
+
+/* fhci-hub.c */
+void fhci_config_transceiver(struct fhci_hcd *fhci,
+			enum fhci_port_status status);
+void fhci_port_disable(struct fhci_hcd *fhci);
+void fhci_port_enable(void *lld);
+void fhci_io_port_generate_reset(struct fhci_hcd *fhci);
+void fhci_port_reset(void *lld);
+int fhci_hub_status_data(struct usb_hcd *hcd, char *buf);
+int fhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
+		     u16 wIndex, char *buf, u16 wLength);
+
+/* fhci-tds.c */
+void fhci_flush_bds(struct fhci_usb *usb);
+void fhci_flush_actual_frame(struct fhci_usb *usb);
+u32 fhci_host_transaction(struct fhci_usb *usb, struct packet *pkt,
+			  enum fhci_ta_type trans_type, u8 dest_addr,
+			  u8 dest_ep, enum fhci_tf_mode trans_mode,
+			  enum fhci_speed dest_speed, u8 data_toggle);
+void fhci_host_transmit_actual_frame(struct fhci_usb *usb);
+void fhci_tx_conf_interrupt(struct fhci_usb *usb);
+void fhci_push_dummy_bd(struct endpoint *ep);
+u32 fhci_create_ep(struct fhci_usb *usb, enum fhci_mem_alloc data_mem,
+		   u32 ring_len);
+void fhci_init_ep_registers(struct fhci_usb *usb,
+			    struct endpoint *ep,
+			    enum fhci_mem_alloc data_mem);
+void fhci_ep0_free(struct fhci_usb *usb);
+
+/* fhci-sched.c */
+extern struct tasklet_struct fhci_tasklet;
+void fhci_transaction_confirm(struct fhci_usb *usb, struct packet *pkt);
+void fhci_flush_all_transmissions(struct fhci_usb *usb);
+void fhci_schedule_transactions(struct fhci_usb *usb);
+void fhci_device_connected_interrupt(struct fhci_hcd *fhci);
+void fhci_device_disconnected_interrupt(struct fhci_hcd *fhci);
+void fhci_queue_urb(struct fhci_hcd *fhci, struct urb *urb);
+u32 fhci_transfer_confirm_callback(struct fhci_hcd *fhci);
+irqreturn_t fhci_irq(struct usb_hcd *hcd);
+irqreturn_t fhci_frame_limit_timer_irq(int irq, void *_hcd);
+
+/* fhci-q.h */
+void fhci_urb_complete_free(struct fhci_hcd *fhci, struct urb *urb);
+struct td *fhci_remove_td_from_ed(struct ed *ed);
+struct td *fhci_remove_td_from_frame(struct fhci_time_frame *frame);
+void fhci_move_td_from_ed_to_done_list(struct fhci_usb *usb, struct ed *ed);
+struct td *fhci_peek_td_from_frame(struct fhci_time_frame *frame);
+void fhci_add_td_to_frame(struct fhci_time_frame *frame, struct td *td);
+struct td *fhci_remove_td_from_done_list(struct fhci_controller_list *p_list);
+void fhci_done_td(struct urb *urb, struct td *td);
+void fhci_del_ed_list(struct fhci_hcd *fhci, struct ed *ed);
+
+#ifdef CONFIG_FHCI_DEBUG
+
+void fhci_dbg_isr(struct fhci_hcd *fhci, int usb_er);
+void fhci_dfs_destroy(struct fhci_hcd *fhci);
+void fhci_dfs_create(struct fhci_hcd *fhci);
+
+#else
+
+static inline void fhci_dbg_isr(struct fhci_hcd *fhci, int usb_er) {}
+static inline void fhci_dfs_destroy(struct fhci_hcd *fhci) {}
+static inline void fhci_dfs_create(struct fhci_hcd *fhci) {}
+
+#endif /* CONFIG_FHCI_DEBUG */
+
+#endif /* __FHCI_H */
diff -urN host/hwa-hc.c host.new/hwa-hc.c
--- host/hwa-hc.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/hwa-hc.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,875 @@
+/*
+ * Host Wire Adapter:
+ * Driver glue, HWA-specific functions, bridges to WAHC and WUSBHC
+ *
+ * Copyright (C) 2005-2006 Intel Corporation
+ * Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ *
+ * The HWA driver is a simple layer that forwards requests to the WAHC
+ * (Wire Adater Host Controller) or WUSBHC (Wireless USB Host
+ * Controller) layers.
+ *
+ * Host Wire Adapter is the 'WUSB 1.0 standard' name for Wireless-USB
+ * Host Controller that is connected to your system via USB (a USB
+ * dongle that implements a USB host...). There is also a Device Wired
+ * Adaptor, DWA (Wireless USB hub) that uses the same mechanism for
+ * transferring data (it is after all a USB host connected via
+ * Wireless USB), we have a common layer called Wire Adapter Host
+ * Controller that does all the hard work. The WUSBHC (Wireless USB
+ * Host Controller) is the part common to WUSB Host Controllers, the
+ * HWA and the PCI-based one, that is implemented following the WHCI
+ * spec. All these layers are implemented in ../wusbcore.
+ *
+ * The main functions are hwahc_op_urb_{en,de}queue(), that pass the
+ * job of converting a URB to a Wire Adapter
+ *
+ * Entry points:
+ *
+ *   hwahc_driver_*()   Driver initialization, registration and
+ *                      teardown.
+ *
+ *   hwahc_probe()	New device came up, create an instance for
+ *                      it [from device enumeration].
+ *
+ *   hwahc_disconnect()	Remove device instance [from device
+ *                      enumeration].
+ *
+ *   [__]hwahc_op_*()   Host-Wire-Adaptor specific functions for
+ *                      starting/stopping/etc (some might be made also
+ *                      DWA).
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/completion.h>
+#include "../wusbcore/wa-hc.h"
+#include "../wusbcore/wusbhc.h"
+
+struct hwahc {
+	struct wusbhc wusbhc;	/* has to be 1st */
+	struct wahc wa;
+};
+
+/*
+ * FIXME should be wusbhc
+ *
+ * NOTE: we need to cache the Cluster ID because later...there is no
+ *       way to get it :)
+ */
+static int __hwahc_set_cluster_id(struct hwahc *hwahc, u8 cluster_id)
+{
+	int result;
+	struct wusbhc *wusbhc = &hwahc->wusbhc;
+	struct wahc *wa = &hwahc->wa;
+	struct device *dev = &wa->usb_iface->dev;
+
+	result = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),
+			WUSB_REQ_SET_CLUSTER_ID,
+			USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+			cluster_id,
+			wa->usb_iface->cur_altsetting->desc.bInterfaceNumber,
+			NULL, 0, 1000 /* FIXME: arbitrary */);
+	if (result < 0)
+		dev_err(dev, "Cannot set WUSB Cluster ID to 0x%02x: %d\n",
+			cluster_id, result);
+	else
+		wusbhc->cluster_id = cluster_id;
+	dev_info(dev, "Wireless USB Cluster ID set to 0x%02x\n", cluster_id);
+	return result;
+}
+
+static int __hwahc_op_set_num_dnts(struct wusbhc *wusbhc, u8 interval, u8 slots)
+{
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+	struct wahc *wa = &hwahc->wa;
+
+	return usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),
+			WUSB_REQ_SET_NUM_DNTS,
+			USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+			interval << 8 | slots,
+			wa->usb_iface->cur_altsetting->desc.bInterfaceNumber,
+			NULL, 0, 1000 /* FIXME: arbitrary */);
+}
+
+/*
+ * Reset a WUSB host controller and wait for it to complete doing it.
+ *
+ * @usb_hcd:	Pointer to WUSB Host Controller instance.
+ *
+ */
+static int hwahc_op_reset(struct usb_hcd *usb_hcd)
+{
+	int result;
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+	struct device *dev = &hwahc->wa.usb_iface->dev;
+
+	mutex_lock(&wusbhc->mutex);
+	wa_nep_disarm(&hwahc->wa);
+	result = __wa_set_feature(&hwahc->wa, WA_RESET);
+	if (result < 0) {
+		dev_err(dev, "error commanding HC to reset: %d\n", result);
+		goto error_unlock;
+	}
+	result = __wa_wait_status(&hwahc->wa, WA_STATUS_RESETTING, 0);
+	if (result < 0) {
+		dev_err(dev, "error waiting for HC to reset: %d\n", result);
+		goto error_unlock;
+	}
+error_unlock:
+	mutex_unlock(&wusbhc->mutex);
+	return result;
+}
+
+/*
+ * FIXME: break this function up
+ */
+static int hwahc_op_start(struct usb_hcd *usb_hcd)
+{
+	u8 addr;
+	int result;
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+
+	result = -ENOSPC;
+	mutex_lock(&wusbhc->mutex);
+	addr = wusb_cluster_id_get();
+	if (addr == 0)
+		goto error_cluster_id_get;
+	result = __hwahc_set_cluster_id(hwahc, addr);
+	if (result < 0)
+		goto error_set_cluster_id;
+
+	usb_hcd->uses_new_polling = 1;
+	usb_hcd->poll_rh = 1;
+	usb_hcd->state = HC_STATE_RUNNING;
+	result = 0;
+out:
+	mutex_unlock(&wusbhc->mutex);
+	return result;
+
+error_set_cluster_id:
+	wusb_cluster_id_put(wusbhc->cluster_id);
+error_cluster_id_get:
+	goto out;
+
+}
+
+static int hwahc_op_suspend(struct usb_hcd *usb_hcd, pm_message_t msg)
+{
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+	dev_err(wusbhc->dev, "%s (%p [%p], 0x%lx) UNIMPLEMENTED\n", __func__,
+		usb_hcd, hwahc, *(unsigned long *) &msg);
+	return -ENOSYS;
+}
+
+static int hwahc_op_resume(struct usb_hcd *usb_hcd)
+{
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+
+	dev_err(wusbhc->dev, "%s (%p [%p]) UNIMPLEMENTED\n", __func__,
+		usb_hcd, hwahc);
+	return -ENOSYS;
+}
+
+/*
+ * No need to abort pipes, as when this is called, all the children
+ * has been disconnected and that has done it [through
+ * usb_disable_interface() -> usb_disable_endpoint() ->
+ * hwahc_op_ep_disable() - >rpipe_ep_disable()].
+ */
+static void hwahc_op_stop(struct usb_hcd *usb_hcd)
+{
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+
+	mutex_lock(&wusbhc->mutex);
+	wusb_cluster_id_put(wusbhc->cluster_id);
+	mutex_unlock(&wusbhc->mutex);
+}
+
+static int hwahc_op_get_frame_number(struct usb_hcd *usb_hcd)
+{
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+
+	dev_err(wusbhc->dev, "%s (%p [%p]) UNIMPLEMENTED\n", __func__,
+		usb_hcd, hwahc);
+	return -ENOSYS;
+}
+
+static int hwahc_op_urb_enqueue(struct usb_hcd *usb_hcd, struct urb *urb,
+				gfp_t gfp)
+{
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+
+	return wa_urb_enqueue(&hwahc->wa, urb->ep, urb, gfp);
+}
+
+static int hwahc_op_urb_dequeue(struct usb_hcd *usb_hcd, struct urb *urb,
+				int status)
+{
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+
+	return wa_urb_dequeue(&hwahc->wa, urb);
+}
+
+/*
+ * Release resources allocated for an endpoint
+ *
+ * If there is an associated rpipe to this endpoint, go ahead and put it.
+ */
+static void hwahc_op_endpoint_disable(struct usb_hcd *usb_hcd,
+				      struct usb_host_endpoint *ep)
+{
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+
+	rpipe_ep_disable(&hwahc->wa, ep);
+}
+
+static int __hwahc_op_wusbhc_start(struct wusbhc *wusbhc)
+{
+	int result;
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+	struct device *dev = &hwahc->wa.usb_iface->dev;
+
+	result = __wa_set_feature(&hwahc->wa, WA_ENABLE);
+	if (result < 0) {
+		dev_err(dev, "error commanding HC to start: %d\n", result);
+		goto error_stop;
+	}
+	result = __wa_wait_status(&hwahc->wa, WA_ENABLE, WA_ENABLE);
+	if (result < 0) {
+		dev_err(dev, "error waiting for HC to start: %d\n", result);
+		goto error_stop;
+	}
+	result = wa_nep_arm(&hwahc->wa, GFP_KERNEL);
+	if (result < 0) {
+		dev_err(dev, "cannot listen to notifications: %d\n", result);
+		goto error_stop;
+	}
+	return result;
+
+error_stop:
+	__wa_clear_feature(&hwahc->wa, WA_ENABLE);
+	return result;
+}
+
+static void __hwahc_op_wusbhc_stop(struct wusbhc *wusbhc, int delay)
+{
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+	struct wahc *wa = &hwahc->wa;
+	u8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;
+	int ret;
+
+	ret = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),
+			      WUSB_REQ_CHAN_STOP,
+			      USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+			      delay * 1000,
+			      iface_no,
+			      NULL, 0, 1000 /* FIXME: arbitrary */);
+	if (ret == 0)
+		msleep(delay);
+
+	wa_nep_disarm(&hwahc->wa);
+	__wa_stop(&hwahc->wa);
+}
+
+/*
+ * Set the UWB MAS allocation for the WUSB cluster
+ *
+ * @stream_index: stream to use (-1 for cancelling the allocation)
+ * @mas: mas bitmap to use
+ */
+static int __hwahc_op_bwa_set(struct wusbhc *wusbhc, s8 stream_index,
+			      const struct uwb_mas_bm *mas)
+{
+	int result;
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+	struct wahc *wa = &hwahc->wa;
+	struct device *dev = &wa->usb_iface->dev;
+	u8 mas_le[UWB_NUM_MAS/8];
+
+	/* Set the stream index */
+	result = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),
+			WUSB_REQ_SET_STREAM_IDX,
+			USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+			stream_index,
+			wa->usb_iface->cur_altsetting->desc.bInterfaceNumber,
+			NULL, 0, 1000 /* FIXME: arbitrary */);
+	if (result < 0) {
+		dev_err(dev, "Cannot set WUSB stream index: %d\n", result);
+		goto out;
+	}
+	uwb_mas_bm_copy_le(mas_le, mas);
+	/* Set the MAS allocation */
+	result = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),
+			WUSB_REQ_SET_WUSB_MAS,
+			USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+			0, wa->usb_iface->cur_altsetting->desc.bInterfaceNumber,
+			mas_le, 32, 1000 /* FIXME: arbitrary */);
+	if (result < 0)
+		dev_err(dev, "Cannot set WUSB MAS allocation: %d\n", result);
+out:
+	return result;
+}
+
+/*
+ * Add an IE to the host's MMC
+ *
+ * @interval:    See WUSB1.0[8.5.3.1]
+ * @repeat_cnt:  See WUSB1.0[8.5.3.1]
+ * @handle:      See WUSB1.0[8.5.3.1]
+ * @wuie:        Pointer to the header of the WUSB IE data to add.
+ *               MUST BE allocated in a kmalloc buffer (no stack or
+ *               vmalloc).
+ *
+ * NOTE: the format of the WUSB IEs for MMCs are different to the
+ *       normal MBOA MAC IEs (IE Id + Length in MBOA MAC vs. Length +
+ *       Id in WUSB IEs). Standards...you gotta love'em.
+ */
+static int __hwahc_op_mmcie_add(struct wusbhc *wusbhc, u8 interval,
+				u8 repeat_cnt, u8 handle,
+				struct wuie_hdr *wuie)
+{
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+	struct wahc *wa = &hwahc->wa;
+	u8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;
+
+	return usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),
+			WUSB_REQ_ADD_MMC_IE,
+			USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+			interval << 8 | repeat_cnt,
+			handle << 8 | iface_no,
+			wuie, wuie->bLength, 1000 /* FIXME: arbitrary */);
+}
+
+/*
+ * Remove an IE to the host's MMC
+ *
+ * @handle:      See WUSB1.0[8.5.3.1]
+ */
+static int __hwahc_op_mmcie_rm(struct wusbhc *wusbhc, u8 handle)
+{
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+	struct wahc *wa = &hwahc->wa;
+	u8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;
+	return usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),
+			WUSB_REQ_REMOVE_MMC_IE,
+			USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+			0, handle << 8 | iface_no,
+			NULL, 0, 1000 /* FIXME: arbitrary */);
+}
+
+/*
+ * Update device information for a given fake port
+ *
+ * @port_idx: Fake port to which device is connected (wusbhc index, not
+ *            USB port number).
+ */
+static int __hwahc_op_dev_info_set(struct wusbhc *wusbhc,
+				   struct wusb_dev *wusb_dev)
+{
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+	struct wahc *wa = &hwahc->wa;
+	u8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;
+	struct hwa_dev_info *dev_info;
+	int ret;
+
+	/* fill out the Device Info buffer and send it */
+	dev_info = kzalloc(sizeof(struct hwa_dev_info), GFP_KERNEL);
+	if (!dev_info)
+		return -ENOMEM;
+	uwb_mas_bm_copy_le(dev_info->bmDeviceAvailability,
+			   &wusb_dev->availability);
+	dev_info->bDeviceAddress = wusb_dev->addr;
+
+	/*
+	 * If the descriptors haven't been read yet, use a default PHY
+	 * rate of 53.3 Mbit/s only.  The correct value will be used
+	 * when this will be called again as part of the
+	 * authentication process (which occurs after the descriptors
+	 * have been read).
+	 */
+	if (wusb_dev->wusb_cap_descr)
+		dev_info->wPHYRates = wusb_dev->wusb_cap_descr->wPHYRates;
+	else
+		dev_info->wPHYRates = cpu_to_le16(USB_WIRELESS_PHY_53);
+
+	ret = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),
+			WUSB_REQ_SET_DEV_INFO,
+			USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+			0, wusb_dev->port_idx << 8 | iface_no,
+			dev_info, sizeof(struct hwa_dev_info),
+			1000 /* FIXME: arbitrary */);
+	kfree(dev_info);
+	return ret;
+}
+
+/*
+ * Set host's idea of which encryption (and key) method to use when
+ * talking to ad evice on a given port.
+ *
+ * If key is NULL, it means disable encryption for that "virtual port"
+ * (used when we disconnect).
+ */
+static int __hwahc_dev_set_key(struct wusbhc *wusbhc, u8 port_idx, u32 tkid,
+			       const void *key, size_t key_size,
+			       u8 key_idx)
+{
+	int result = -ENOMEM;
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+	struct wahc *wa = &hwahc->wa;
+	u8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;
+	struct usb_key_descriptor *keyd;
+	size_t keyd_len;
+
+	keyd_len = sizeof(*keyd) + key_size;
+	keyd = kzalloc(keyd_len, GFP_KERNEL);
+	if (keyd == NULL)
+		return -ENOMEM;
+
+	keyd->bLength = keyd_len;
+	keyd->bDescriptorType = USB_DT_KEY;
+	keyd->tTKID[0] = (tkid >>  0) & 0xff;
+	keyd->tTKID[1] = (tkid >>  8) & 0xff;
+	keyd->tTKID[2] = (tkid >> 16) & 0xff;
+	memcpy(keyd->bKeyData, key, key_size);
+
+	result = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),
+			USB_REQ_SET_DESCRIPTOR,
+			USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+			USB_DT_KEY << 8 | key_idx,
+			port_idx << 8 | iface_no,
+			keyd, keyd_len, 1000 /* FIXME: arbitrary */);
+
+	kzfree(keyd); /* clear keys etc. */
+	return result;
+}
+
+/*
+ * Set host's idea of which encryption (and key) method to use when
+ * talking to ad evice on a given port.
+ *
+ * If key is NULL, it means disable encryption for that "virtual port"
+ * (used when we disconnect).
+ */
+static int __hwahc_op_set_ptk(struct wusbhc *wusbhc, u8 port_idx, u32 tkid,
+			      const void *key, size_t key_size)
+{
+	int result = -ENOMEM;
+	struct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+	struct wahc *wa = &hwahc->wa;
+	u8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;
+	u8 encryption_value;
+
+	/* Tell the host which key to use to talk to the device */
+	if (key) {
+		u8 key_idx = wusb_key_index(0, WUSB_KEY_INDEX_TYPE_PTK,
+					    WUSB_KEY_INDEX_ORIGINATOR_HOST);
+
+		result = __hwahc_dev_set_key(wusbhc, port_idx, tkid,
+					     key, key_size, key_idx);
+		if (result < 0)
+			goto error_set_key;
+		encryption_value = wusbhc->ccm1_etd->bEncryptionValue;
+	} else {
+		/* FIXME: this should come from wusbhc->etd[UNSECURE].value */
+		encryption_value = 0;
+	}
+
+	/* Set the encryption type for commmunicating with the device */
+	result = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),
+			USB_REQ_SET_ENCRYPTION,
+			USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+			encryption_value, port_idx << 8 | iface_no,
+			NULL, 0, 1000 /* FIXME: arbitrary */);
+	if (result < 0)
+		dev_err(wusbhc->dev, "Can't set host's WUSB encryption for "
+			"port index %u to %s (value %d): %d\n", port_idx,
+			wusb_et_name(wusbhc->ccm1_etd->bEncryptionType),
+			wusbhc->ccm1_etd->bEncryptionValue, result);
+error_set_key:
+	return result;
+}
+
+/*
+ * Set host's GTK key
+ */
+static int __hwahc_op_set_gtk(struct wusbhc *wusbhc, u32 tkid,
+			      const void *key, size_t key_size)
+{
+	u8 key_idx = wusb_key_index(0, WUSB_KEY_INDEX_TYPE_GTK,
+				    WUSB_KEY_INDEX_ORIGINATOR_HOST);
+
+	return __hwahc_dev_set_key(wusbhc, 0, tkid, key, key_size, key_idx);
+}
+
+/*
+ * Get the Wire Adapter class-specific descriptor
+ *
+ * NOTE: this descriptor comes with the big bundled configuration
+ *       descriptor that includes the interfaces' and endpoints', so
+ *       we just look for it in the cached copy kept by the USB stack.
+ *
+ * NOTE2: We convert LE fields to CPU order.
+ */
+static int wa_fill_descr(struct wahc *wa)
+{
+	int result;
+	struct device *dev = &wa->usb_iface->dev;
+	char *itr;
+	struct usb_device *usb_dev = wa->usb_dev;
+	struct usb_descriptor_header *hdr;
+	struct usb_wa_descriptor *wa_descr;
+	size_t itr_size, actconfig_idx;
+
+	actconfig_idx = (usb_dev->actconfig - usb_dev->config) /
+			sizeof(usb_dev->config[0]);
+	itr = usb_dev->rawdescriptors[actconfig_idx];
+	itr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);
+	while (itr_size >= sizeof(*hdr)) {
+		hdr = (struct usb_descriptor_header *) itr;
+		dev_dbg(dev, "Extra device descriptor: "
+			"type %02x/%u bytes @ %zu (%zu left)\n",
+			hdr->bDescriptorType, hdr->bLength,
+			(itr - usb_dev->rawdescriptors[actconfig_idx]),
+			itr_size);
+		if (hdr->bDescriptorType == USB_DT_WIRE_ADAPTER)
+			goto found;
+		itr += hdr->bLength;
+		itr_size -= hdr->bLength;
+	}
+	dev_err(dev, "cannot find Wire Adapter Class descriptor\n");
+	return -ENODEV;
+
+found:
+	result = -EINVAL;
+	if (hdr->bLength > itr_size) {	/* is it available? */
+		dev_err(dev, "incomplete Wire Adapter Class descriptor "
+			"(%zu bytes left, %u needed)\n",
+			itr_size, hdr->bLength);
+		goto error;
+	}
+	if (hdr->bLength < sizeof(*wa->wa_descr)) {
+		dev_err(dev, "short Wire Adapter Class descriptor\n");
+		goto error;
+	}
+	wa->wa_descr = wa_descr = (struct usb_wa_descriptor *) hdr;
+	/* Make LE fields CPU order */
+	wa_descr->bcdWAVersion = le16_to_cpu(wa_descr->bcdWAVersion);
+	wa_descr->wNumRPipes = le16_to_cpu(wa_descr->wNumRPipes);
+	wa_descr->wRPipeMaxBlock = le16_to_cpu(wa_descr->wRPipeMaxBlock);
+	if (wa_descr->bcdWAVersion > 0x0100)
+		dev_warn(dev, "Wire Adapter v%d.%d newer than groked v1.0\n",
+			 wa_descr->bcdWAVersion & 0xff00 >> 8,
+			 wa_descr->bcdWAVersion & 0x00ff);
+	result = 0;
+error:
+	return result;
+}
+
+static struct hc_driver hwahc_hc_driver = {
+	.description = "hwa-hcd",
+	.product_desc = "Wireless USB HWA host controller",
+	.hcd_priv_size = sizeof(struct hwahc) - sizeof(struct usb_hcd),
+	.irq = NULL,			/* FIXME */
+	.flags = HCD_USB2,		/* FIXME */
+	.reset = hwahc_op_reset,
+	.start = hwahc_op_start,
+	.pci_suspend = hwahc_op_suspend,
+	.pci_resume = hwahc_op_resume,
+	.stop = hwahc_op_stop,
+	.get_frame_number = hwahc_op_get_frame_number,
+	.urb_enqueue = hwahc_op_urb_enqueue,
+	.urb_dequeue = hwahc_op_urb_dequeue,
+	.endpoint_disable = hwahc_op_endpoint_disable,
+
+	.hub_status_data = wusbhc_rh_status_data,
+	.hub_control = wusbhc_rh_control,
+	.bus_suspend = wusbhc_rh_suspend,
+	.bus_resume = wusbhc_rh_resume,
+	.start_port_reset = wusbhc_rh_start_port_reset,
+};
+
+static int hwahc_security_create(struct hwahc *hwahc)
+{
+	int result;
+	struct wusbhc *wusbhc = &hwahc->wusbhc;
+	struct usb_device *usb_dev = hwahc->wa.usb_dev;
+	struct device *dev = &usb_dev->dev;
+	struct usb_security_descriptor *secd;
+	struct usb_encryption_descriptor *etd;
+	void *itr, *top;
+	size_t itr_size, needed, bytes;
+	u8 index;
+	char buf[64];
+
+	/* Find the host's security descriptors in the config descr bundle */
+	index = (usb_dev->actconfig - usb_dev->config) /
+		sizeof(usb_dev->config[0]);
+	itr = usb_dev->rawdescriptors[index];
+	itr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);
+	top = itr + itr_size;
+	result = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],
+			le16_to_cpu(usb_dev->actconfig->desc.wTotalLength),
+			USB_DT_SECURITY, (void **) &secd);
+	if (result == -1) {
+		dev_warn(dev, "BUG? WUSB host has no security descriptors\n");
+		return 0;
+	}
+	needed = sizeof(*secd);
+	if (top - (void *)secd < needed) {
+		dev_err(dev, "BUG? Not enough data to process security "
+			"descriptor header (%zu bytes left vs %zu needed)\n",
+			top - (void *) secd, needed);
+		return 0;
+	}
+	needed = le16_to_cpu(secd->wTotalLength);
+	if (top - (void *)secd < needed) {
+		dev_err(dev, "BUG? Not enough data to process security "
+			"descriptors (%zu bytes left vs %zu needed)\n",
+			top - (void *) secd, needed);
+		return 0;
+	}
+	/* Walk over the sec descriptors and store CCM1's on wusbhc */
+	itr = (void *) secd + sizeof(*secd);
+	top = (void *) secd + le16_to_cpu(secd->wTotalLength);
+	index = 0;
+	bytes = 0;
+	while (itr < top) {
+		etd = itr;
+		if (top - itr < sizeof(*etd)) {
+			dev_err(dev, "BUG: bad host security descriptor; "
+				"not enough data (%zu vs %zu left)\n",
+				top - itr, sizeof(*etd));
+			break;
+		}
+		if (etd->bLength < sizeof(*etd)) {
+			dev_err(dev, "BUG: bad host encryption descriptor; "
+				"descriptor is too short "
+				"(%zu vs %zu needed)\n",
+				(size_t)etd->bLength, sizeof(*etd));
+			break;
+		}
+		itr += etd->bLength;
+		bytes += snprintf(buf + bytes, sizeof(buf) - bytes,
+				  "%s (0x%02x) ",
+				  wusb_et_name(etd->bEncryptionType),
+				  etd->bEncryptionValue);
+		wusbhc->ccm1_etd = etd;
+	}
+	dev_info(dev, "supported encryption types: %s\n", buf);
+	if (wusbhc->ccm1_etd == NULL) {
+		dev_err(dev, "E: host doesn't support CCM-1 crypto\n");
+		return 0;
+	}
+	/* Pretty print what we support */
+	return 0;
+}
+
+static void hwahc_security_release(struct hwahc *hwahc)
+{
+	/* nothing to do here so far... */
+}
+
+static int hwahc_create(struct hwahc *hwahc, struct usb_interface *iface)
+{
+	int result;
+	struct device *dev = &iface->dev;
+	struct wusbhc *wusbhc = &hwahc->wusbhc;
+	struct wahc *wa = &hwahc->wa;
+	struct usb_device *usb_dev = interface_to_usbdev(iface);
+
+	wa->usb_dev = usb_get_dev(usb_dev);	/* bind the USB device */
+	wa->usb_iface = usb_get_intf(iface);
+	wusbhc->dev = dev;
+	wusbhc->uwb_rc = uwb_rc_get_by_grandpa(iface->dev.parent);
+	if (wusbhc->uwb_rc == NULL) {
+		result = -ENODEV;
+		dev_err(dev, "Cannot get associated UWB Host Controller\n");
+		goto error_rc_get;
+	}
+	result = wa_fill_descr(wa);	/* Get the device descriptor */
+	if (result < 0)
+		goto error_fill_descriptor;
+	if (wa->wa_descr->bNumPorts > USB_MAXCHILDREN) {
+		dev_err(dev, "FIXME: USB_MAXCHILDREN too low for WUSB "
+			"adapter (%u ports)\n", wa->wa_descr->bNumPorts);
+		wusbhc->ports_max = USB_MAXCHILDREN;
+	} else {
+		wusbhc->ports_max = wa->wa_descr->bNumPorts;
+	}
+	wusbhc->mmcies_max = wa->wa_descr->bNumMMCIEs;
+	wusbhc->start = __hwahc_op_wusbhc_start;
+	wusbhc->stop = __hwahc_op_wusbhc_stop;
+	wusbhc->mmcie_add = __hwahc_op_mmcie_add;
+	wusbhc->mmcie_rm = __hwahc_op_mmcie_rm;
+	wusbhc->dev_info_set = __hwahc_op_dev_info_set;
+	wusbhc->bwa_set = __hwahc_op_bwa_set;
+	wusbhc->set_num_dnts = __hwahc_op_set_num_dnts;
+	wusbhc->set_ptk = __hwahc_op_set_ptk;
+	wusbhc->set_gtk = __hwahc_op_set_gtk;
+	result = hwahc_security_create(hwahc);
+	if (result < 0) {
+		dev_err(dev, "Can't initialize security: %d\n", result);
+		goto error_security_create;
+	}
+	wa->wusb = wusbhc;	/* FIXME: ugly, need to fix */
+	result = wusbhc_create(&hwahc->wusbhc);
+	if (result < 0) {
+		dev_err(dev, "Can't create WUSB HC structures: %d\n", result);
+		goto error_wusbhc_create;
+	}
+	result = wa_create(&hwahc->wa, iface);
+	if (result < 0)
+		goto error_wa_create;
+	return 0;
+
+error_wa_create:
+	wusbhc_destroy(&hwahc->wusbhc);
+error_wusbhc_create:
+	/* WA Descr fill allocs no resources */
+error_security_create:
+error_fill_descriptor:
+	uwb_rc_put(wusbhc->uwb_rc);
+error_rc_get:
+	usb_put_intf(iface);
+	usb_put_dev(usb_dev);
+	return result;
+}
+
+static void hwahc_destroy(struct hwahc *hwahc)
+{
+	struct wusbhc *wusbhc = &hwahc->wusbhc;
+
+	mutex_lock(&wusbhc->mutex);
+	__wa_destroy(&hwahc->wa);
+	wusbhc_destroy(&hwahc->wusbhc);
+	hwahc_security_release(hwahc);
+	hwahc->wusbhc.dev = NULL;
+	uwb_rc_put(wusbhc->uwb_rc);
+	usb_put_intf(hwahc->wa.usb_iface);
+	usb_put_dev(hwahc->wa.usb_dev);
+	mutex_unlock(&wusbhc->mutex);
+}
+
+static void hwahc_init(struct hwahc *hwahc)
+{
+	wa_init(&hwahc->wa);
+}
+
+static int hwahc_probe(struct usb_interface *usb_iface,
+		       const struct usb_device_id *id)
+{
+	int result;
+	struct usb_hcd *usb_hcd;
+	struct wusbhc *wusbhc;
+	struct hwahc *hwahc;
+	struct device *dev = &usb_iface->dev;
+
+	result = -ENOMEM;
+	usb_hcd = usb_create_hcd(&hwahc_hc_driver, &usb_iface->dev, "wusb-hwa");
+	if (usb_hcd == NULL) {
+		dev_err(dev, "unable to allocate instance\n");
+		goto error_alloc;
+	}
+	usb_hcd->wireless = 1;
+	usb_hcd->flags |= HCD_FLAG_SAW_IRQ;
+	wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+	hwahc_init(hwahc);
+	result = hwahc_create(hwahc, usb_iface);
+	if (result < 0) {
+		dev_err(dev, "Cannot initialize internals: %d\n", result);
+		goto error_hwahc_create;
+	}
+	result = usb_add_hcd(usb_hcd, 0, 0);
+	if (result < 0) {
+		dev_err(dev, "Cannot add HCD: %d\n", result);
+		goto error_add_hcd;
+	}
+	result = wusbhc_b_create(&hwahc->wusbhc);
+	if (result < 0) {
+		dev_err(dev, "Cannot setup phase B of WUSBHC: %d\n", result);
+		goto error_wusbhc_b_create;
+	}
+	return 0;
+
+error_wusbhc_b_create:
+	usb_remove_hcd(usb_hcd);
+error_add_hcd:
+	hwahc_destroy(hwahc);
+error_hwahc_create:
+	usb_put_hcd(usb_hcd);
+error_alloc:
+	return result;
+}
+
+static void hwahc_disconnect(struct usb_interface *usb_iface)
+{
+	struct usb_hcd *usb_hcd;
+	struct wusbhc *wusbhc;
+	struct hwahc *hwahc;
+
+	usb_hcd = usb_get_intfdata(usb_iface);
+	wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	hwahc = container_of(wusbhc, struct hwahc, wusbhc);
+
+	wusbhc_b_destroy(&hwahc->wusbhc);
+	usb_remove_hcd(usb_hcd);
+	hwahc_destroy(hwahc);
+	usb_put_hcd(usb_hcd);
+}
+
+static struct usb_device_id hwahc_id_table[] = {
+	/* FIXME: use class labels for this */
+	{ USB_INTERFACE_INFO(0xe0, 0x02, 0x01), },
+	{},
+};
+MODULE_DEVICE_TABLE(usb, hwahc_id_table);
+
+static struct usb_driver hwahc_driver = {
+	.name =		"hwa-hc",
+	.probe =	hwahc_probe,
+	.disconnect =	hwahc_disconnect,
+	.id_table =	hwahc_id_table,
+};
+
+static int __init hwahc_driver_init(void)
+{
+	return usb_register(&hwahc_driver);
+}
+module_init(hwahc_driver_init);
+
+static void __exit hwahc_driver_exit(void)
+{
+	usb_deregister(&hwahc_driver);
+}
+module_exit(hwahc_driver_exit);
+
+
+MODULE_AUTHOR("Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>");
+MODULE_DESCRIPTION("Host Wired Adapter USB Host Control Driver");
+MODULE_LICENSE("GPL");
diff -urN host/isp116x-hcd.c host.new/isp116x-hcd.c
--- host/isp116x-hcd.c	2009-02-24 19:00:15.339973502 +0100
+++ host.new/isp116x-hcd.c	2009-03-28 17:46:02.000000000 +0100
@@ -94,6 +94,10 @@
 	u16 w;
 	int quot = len % 4;
 
+	/* buffer is already in 'usb data order', which is LE. */
+	/* When reading buffer as u16, we have to take care byte order */
+	/* doesn't get mixed up */
+
 	if ((unsigned long)dp2 & 1) {
 		/* not aligned */
 		for (; len > 1; len -= 2) {
@@ -105,8 +109,11 @@
 			isp116x_write_data16(isp116x, (u16) * dp);
 	} else {
 		/* aligned */
-		for (; len > 1; len -= 2)
-			isp116x_raw_write_data16(isp116x, *dp2++);
+		for (; len > 1; len -= 2) {
+			/* Keep byte order ! */
+			isp116x_raw_write_data16(isp116x, cpu_to_le16(*dp2++));
+		}
+
 		if (len)
 			isp116x_write_data16(isp116x, 0xff & *((u8 *) dp2));
 	}
@@ -124,6 +131,10 @@
 	u16 w;
 	int quot = len % 4;
 
+	/* buffer is already in 'usb data order', which is LE. */
+	/* When reading buffer as u16, we have to take care byte order */
+	/* doesn't get mixed up */
+
 	if ((unsigned long)dp2 & 1) {
 		/* not aligned */
 		for (; len > 1; len -= 2) {
@@ -131,12 +142,16 @@
 			*dp++ = w & 0xff;
 			*dp++ = (w >> 8) & 0xff;
 		}
+
 		if (len)
 			*dp = 0xff & isp116x_read_data16(isp116x);
 	} else {
 		/* aligned */
-		for (; len > 1; len -= 2)
-			*dp2++ = isp116x_raw_read_data16(isp116x);
+		for (; len > 1; len -= 2) {
+			/* Keep byte order! */
+			*dp2++ = le16_to_cpu(isp116x_raw_read_data16(isp116x));
+		}
+
 		if (len)
 			*(u8 *) dp2 = 0xff & isp116x_read_data16(isp116x);
 	}
@@ -277,12 +292,11 @@
   processed urbs.
 */
 static void finish_request(struct isp116x *isp116x, struct isp116x_ep *ep,
-			   struct urb *urb)
+			   struct urb *urb, int status)
 __releases(isp116x->lock) __acquires(isp116x->lock)
 {
 	unsigned i;
 
-	urb->hcpriv = NULL;
 	ep->error_count = 0;
 
 	if (usb_pipecontrol(urb->pipe))
@@ -290,8 +304,9 @@
 
 	urb_dbg(urb, "Finish");
 
+	usb_hcd_unlink_urb_from_ep(isp116x_to_hcd(isp116x), urb);
 	spin_unlock(&isp116x->lock);
-	usb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb);
+	usb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb, status);
 	spin_lock(&isp116x->lock);
 
 	/* take idle endpoints out of the schedule */
@@ -445,12 +460,7 @@
 			if (PTD_GET_ACTIVE(ptd)
 			    || (cc != TD_CC_NOERROR && cc < 0x0E))
 				break;
-			if ((urb->transfer_flags & URB_SHORT_NOT_OK) &&
-					urb->actual_length <
-						urb->transfer_buffer_length)
-				status = -EREMOTEIO;
-			else
-				status = 0;
+			status = 0;
 			ep->nextpid = 0;
 			break;
 		default:
@@ -458,14 +468,8 @@
 		}
 
  done:
-		if (status != -EINPROGRESS) {
-			spin_lock(&urb->lock);
-			if (urb->status == -EINPROGRESS)
-				urb->status = status;
-			spin_unlock(&urb->lock);
-		}
-		if (urb->status != -EINPROGRESS)
-			finish_request(isp116x, ep, urb);
+		if (status != -EINPROGRESS || urb->unlinked)
+			finish_request(isp116x, ep, urb, status);
 	}
 }
 
@@ -673,7 +677,7 @@
 /*-----------------------------------------------------------------*/
 
 static int isp116x_urb_enqueue(struct usb_hcd *hcd,
-			       struct usb_host_endpoint *hep, struct urb *urb,
+			       struct urb *urb,
 			       gfp_t mem_flags)
 {
 	struct isp116x *isp116x = hcd_to_isp116x(hcd);
@@ -682,6 +686,7 @@
 	int is_out = !usb_pipein(pipe);
 	int type = usb_pipetype(pipe);
 	int epnum = usb_pipeendpoint(pipe);
+	struct usb_host_endpoint *hep = urb->ep;
 	struct isp116x_ep *ep = NULL;
 	unsigned long flags;
 	int i;
@@ -705,7 +710,12 @@
 	if (!HC_IS_RUNNING(hcd->state)) {
 		kfree(ep);
 		ret = -ENODEV;
-		goto fail;
+		goto fail_not_linked;
+	}
+	ret = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (ret) {
+		kfree(ep);
+		goto fail_not_linked;
 	}
 
 	if (hep->hcpriv)
@@ -762,7 +772,7 @@
 		break;
 	case PIPE_INTERRUPT:
 		urb->interval = ep->period;
-		ep->length = min((int)ep->maxpacket,
+		ep->length = min_t(u32, ep->maxpacket,
 				 urb->transfer_buffer_length);
 
 		/* urb submitted for already existing endpoint */
@@ -808,16 +818,13 @@
 		}
 	}
 
-	/* in case of unlink-during-submit */
-	if (urb->status != -EINPROGRESS) {
-		finish_request(isp116x, ep, urb);
-		ret = 0;
-		goto fail;
-	}
 	urb->hcpriv = hep;
 	start_atl_transfers(isp116x);
 
       fail:
+	if (ret)
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+      fail_not_linked:
 	spin_unlock_irqrestore(&isp116x->lock, flags);
 	return ret;
 }
@@ -825,20 +832,21 @@
 /*
    Dequeue URBs.
 */
-static int isp116x_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int isp116x_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
+		int status)
 {
 	struct isp116x *isp116x = hcd_to_isp116x(hcd);
 	struct usb_host_endpoint *hep;
 	struct isp116x_ep *ep, *ep_act;
 	unsigned long flags;
+	int rc;
 
 	spin_lock_irqsave(&isp116x->lock, flags);
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto done;
+
 	hep = urb->hcpriv;
-	/* URB already unlinked (or never linked)? */
-	if (!hep) {
-		spin_unlock_irqrestore(&isp116x->lock, flags);
-		return 0;
-	}
 	ep = hep->hcpriv;
 	WARN_ON(hep != ep->hep);
 
@@ -855,10 +863,10 @@
 			}
 
 	if (urb)
-		finish_request(isp116x, ep, urb);
-
+		finish_request(isp116x, ep, urb, status);
+ done:
 	spin_unlock_irqrestore(&isp116x->lock, flags);
-	return 0;
+	return rc;
 }
 
 static void isp116x_endpoint_disable(struct usb_hcd *hcd,
@@ -874,7 +882,7 @@
 	for (i = 0; i < 100 && !list_empty(&hep->urb_list); i++)
 		msleep(3);
 	if (!list_empty(&hep->urb_list))
-		WARN("ep %p not empty?\n", ep);
+		WARNING("ep %p not empty?\n", ep);
 
 	kfree(ep);
 	hep->hcpriv = NULL;
@@ -918,14 +926,12 @@
 		buf[0] = 0;
 
 	for (i = 0; i < ports; i++) {
-		u32 status = isp116x->rhport[i] =
-		    isp116x_read_reg32(isp116x, i ? HCRHPORT2 : HCRHPORT1);
+		u32 status = isp116x_read_reg32(isp116x, i ? HCRHPORT2 : HCRHPORT1);
 
 		if (status & (RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC
 			      | RH_PS_OCIC | RH_PS_PRSC)) {
 			changed = 1;
 			buf[0] |= 1 << (i + 1);
-			continue;
 		}
 	}
 	spin_unlock_irqrestore(&isp116x->lock, flags);
@@ -1039,7 +1045,9 @@
 		DBG("GetPortStatus\n");
 		if (!wIndex || wIndex > ports)
 			goto error;
-		tmp = isp116x->rhport[--wIndex];
+		spin_lock_irqsave(&isp116x->lock, flags);
+		tmp = isp116x_read_reg32(isp116x, (--wIndex) ? HCRHPORT2 : HCRHPORT1);
+		spin_unlock_irqrestore(&isp116x->lock, flags);
 		*(__le32 *) buf = cpu_to_le32(tmp);
 		DBG("GetPortStatus: port[%d]  %08x\n", wIndex + 1, tmp);
 		break;
@@ -1088,8 +1096,6 @@
 		spin_lock_irqsave(&isp116x->lock, flags);
 		isp116x_write_reg32(isp116x, wIndex
 				    ? HCRHPORT2 : HCRHPORT1, tmp);
-		isp116x->rhport[wIndex] =
-		    isp116x_read_reg32(isp116x, wIndex ? HCRHPORT2 : HCRHPORT1);
 		spin_unlock_irqrestore(&isp116x->lock, flags);
 		break;
 	case SetPortFeature:
@@ -1103,24 +1109,22 @@
 			spin_lock_irqsave(&isp116x->lock, flags);
 			isp116x_write_reg32(isp116x, wIndex
 					    ? HCRHPORT2 : HCRHPORT1, RH_PS_PSS);
+			spin_unlock_irqrestore(&isp116x->lock, flags);
 			break;
 		case USB_PORT_FEAT_POWER:
 			DBG("USB_PORT_FEAT_POWER\n");
 			spin_lock_irqsave(&isp116x->lock, flags);
 			isp116x_write_reg32(isp116x, wIndex
 					    ? HCRHPORT2 : HCRHPORT1, RH_PS_PPS);
+			spin_unlock_irqrestore(&isp116x->lock, flags);
 			break;
 		case USB_PORT_FEAT_RESET:
 			DBG("USB_PORT_FEAT_RESET\n");
 			root_port_reset(isp116x, wIndex);
-			spin_lock_irqsave(&isp116x->lock, flags);
 			break;
 		default:
 			goto error;
 		}
-		isp116x->rhport[wIndex] =
-		    isp116x_read_reg32(isp116x, wIndex ? HCRHPORT2 : HCRHPORT1);
-		spin_unlock_irqrestore(&isp116x->lock, flags);
 		break;
 
 	default:
@@ -1411,7 +1415,7 @@
 		spin_unlock_irqrestore(&isp116x->lock, flags);
 		val &= (~HCCONTROL_HCFS & ~HCCONTROL_RWE);
 		val |= HCCONTROL_USB_SUSPEND;
-		if (device_may_wakeup(&hcd->self.root_hub->dev))
+		if (hcd->self.root_hub->do_remote_wakeup)
 			val |= HCCONTROL_RWE;
 		/* Wait for usb transfers to finish */
 		msleep(2);
@@ -1453,11 +1457,6 @@
 		break;
 	case HCCONTROL_USB_OPER:
 		spin_unlock_irq(&isp116x->lock);
-		/* Without setting power_state here the
-		   SUSPENDED state won't be removed from
-		   sysfs/usbN/power.state as a response to remote
-		   wakeup. Maybe in the future. */
-		hcd->self.root_hub->dev.power.power_state = PMSG_ON;
 		return 0;
 	default:
 		/* HCCONTROL_USB_RESET: this may happen, when during
@@ -1471,7 +1470,6 @@
 		if ((isp116x->rhdesca & RH_A_NDP) == 2)
 			isp116x_hub_control(hcd, SetPortFeature,
 					    USB_PORT_FEAT_POWER, 2, NULL, 0);
-		hcd->self.root_hub->dev.power.power_state = PMSG_ON;
 		return 0;
 	}
 
@@ -1497,8 +1495,6 @@
 	isp116x_write_reg32(isp116x, HCCONTROL,
 			    (val & ~HCCONTROL_HCFS) | HCCONTROL_USB_OPER);
 	spin_unlock_irq(&isp116x->lock);
-	/* see analogous comment above */
-	hcd->self.root_hub->dev.power.power_state = PMSG_ON;
 	hcd->state = HC_STATE_RUNNING;
 
 	return 0;
@@ -1566,11 +1562,12 @@
 {
 	struct usb_hcd *hcd;
 	struct isp116x *isp116x;
-	struct resource *addr, *data;
+	struct resource *addr, *data, *ires;
 	void __iomem *addr_reg;
 	void __iomem *data_reg;
 	int irq;
 	int ret = 0;
+	unsigned long irqflags;
 
 	if (pdev->num_resources < 3) {
 		ret = -ENODEV;
@@ -1579,12 +1576,16 @@
 
 	data = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	addr = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-	irq = platform_get_irq(pdev, 0);
-	if (!addr || !data || irq < 0) {
+	ires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+
+	if (!addr || !data || !ires) {
 		ret = -ENODEV;
 		goto err1;
 	}
 
+	irq = ires->start;
+	irqflags = ires->flags & IRQF_TRIGGER_MASK;
+
 	if (pdev->dev.dma_mask) {
 		DBG("DMA not supported\n");
 		ret = -EINVAL;
@@ -1611,7 +1612,7 @@
 	}
 
 	/* allocate and initialize hcd */
-	hcd = usb_create_hcd(&isp116x_hc_driver, &pdev->dev, pdev->dev.bus_id);
+	hcd = usb_create_hcd(&isp116x_hc_driver, &pdev->dev, dev_name(&pdev->dev));
 	if (!hcd) {
 		ret = -ENOMEM;
 		goto err5;
@@ -1638,7 +1639,7 @@
 		goto err6;
 	}
 
-	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED);
+	ret = usb_add_hcd(hcd, irq, irqflags | IRQF_DISABLED);
 	if (ret)
 		goto err6;
 
@@ -1674,7 +1675,6 @@
 static int isp116x_suspend(struct platform_device *dev, pm_message_t state)
 {
 	VDBG("%s: state %x\n", __func__, state.event);
-	dev->dev.power.power_state = state;
 	return 0;
 }
 
@@ -1683,8 +1683,7 @@
 */
 static int isp116x_resume(struct platform_device *dev)
 {
-	VDBG("%s:  state %x\n", __func__, dev->power.power_state.event);
-	dev->dev.power.power_state = PMSG_ON;
+	VDBG("%s\n", __func__);
 	return 0;
 }
 
@@ -1695,14 +1694,18 @@
 
 #endif
 
+/* work with hotplug and coldplug */
+MODULE_ALIAS("platform:isp116x-hcd");
+
 static struct platform_driver isp116x_driver = {
 	.probe = isp116x_probe,
 	.remove = isp116x_remove,
 	.suspend = isp116x_suspend,
 	.resume = isp116x_resume,
 	.driver = {
-		   .name = (char *)hcd_name,
-		   },
+		.name = (char *)hcd_name,
+		.owner	= THIS_MODULE,
+	},
 };
 
 /*-----------------------------------------------------------------*/
diff -urN host/isp116x.h host.new/isp116x.h
--- host/isp116x.h	2009-02-24 19:00:15.355972688 +0100
+++ host.new/isp116x.h	2009-03-28 17:46:02.000000000 +0100
@@ -270,7 +270,6 @@
 	u32 rhdesca;
 	u32 rhdescb;
 	u32 rhstatus;
-	u32 rhport[2];
 
 	/* async schedule: control, bulk */
 	struct list_head async;
@@ -339,7 +338,7 @@
 #endif
 
 #define ERR(stuff...)		printk(KERN_ERR "116x: " stuff)
-#define WARN(stuff...)		printk(KERN_WARNING "116x: " stuff)
+#define WARNING(stuff...)	printk(KERN_WARNING "116x: " stuff)
 #define INFO(stuff...)		printk(KERN_INFO "116x: " stuff)
 
 /* ------------------------------------------------- */
@@ -564,7 +563,7 @@
 */
 static inline void dump_ptd(struct ptd *ptd)
 {
-	printk("td: %x %d%c%d %d,%d,%d  %x %x%x%x\n",
+	printk(KERN_WARNING "td: %x %d%c%d %d,%d,%d  %x %x%x%x\n",
 	       PTD_GET_CC(ptd), PTD_GET_FA(ptd),
 	       PTD_DIR_STR(ptd), PTD_GET_EP(ptd),
 	       PTD_GET_COUNT(ptd), PTD_GET_LEN(ptd), PTD_GET_MPS(ptd),
@@ -577,7 +576,7 @@
 	int k;
 
 	if (PTD_GET_DIR(ptd) != PTD_DIR_IN && PTD_GET_LEN(ptd)) {
-		printk("-> ");
+		printk(KERN_WARNING "-> ");
 		for (k = 0; k < PTD_GET_LEN(ptd); ++k)
 			printk("%02x ", ((u8 *) buf)[k]);
 		printk("\n");
@@ -589,13 +588,13 @@
 	int k;
 
 	if (PTD_GET_DIR(ptd) == PTD_DIR_IN && PTD_GET_COUNT(ptd)) {
-		printk("<- ");
+		printk(KERN_WARNING "<- ");
 		for (k = 0; k < PTD_GET_COUNT(ptd); ++k)
 			printk("%02x ", ((u8 *) buf)[k]);
 		printk("\n");
 	}
 	if (PTD_GET_LAST(ptd))
-		printk("-\n");
+		printk(KERN_WARNING "-\n");
 }
 
 #else
diff -urN host/isp1760-hcd.c host.new/isp1760-hcd.c
--- host/isp1760-hcd.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/isp1760-hcd.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,2301 @@
+/*
+ * Driver for the NXP ISP1760 chip
+ *
+ * However, the code might contain some bugs. What doesn't work for sure is:
+ * - ISO
+ * - OTG
+ e The interrupt line is configured as active low, level.
+ *
+ * (c) 2007 Sebastian Siewior <bigeasy@linutronix.de>
+ *
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/usb.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <asm/unaligned.h>
+
+#include "../core/hcd.h"
+#include "isp1760-hcd.h"
+
+static struct kmem_cache *qtd_cachep;
+static struct kmem_cache *qh_cachep;
+
+struct isp1760_hcd {
+	u32 hcs_params;
+	spinlock_t		lock;
+	struct inter_packet_info atl_ints[32];
+	struct inter_packet_info int_ints[32];
+	struct memory_chunk memory_pool[BLOCKS];
+
+	/* periodic schedule support */
+#define	DEFAULT_I_TDPS		1024
+	unsigned		periodic_size;
+	unsigned		i_thresh;
+	unsigned long		reset_done;
+	unsigned long		next_statechange;
+	unsigned int		devflags;
+};
+
+static inline struct isp1760_hcd *hcd_to_priv(struct usb_hcd *hcd)
+{
+	return (struct isp1760_hcd *) (hcd->hcd_priv);
+}
+static inline struct usb_hcd *priv_to_hcd(struct isp1760_hcd *priv)
+{
+	return container_of((void *) priv, struct usb_hcd, hcd_priv);
+}
+
+/* Section 2.2 Host Controller Capability Registers */
+#define HC_LENGTH(p)		(((p)>>00)&0x00ff)	/* bits 7:0 */
+#define HC_VERSION(p)		(((p)>>16)&0xffff)	/* bits 31:16 */
+#define HCS_INDICATOR(p)	((p)&(1 << 16))	/* true: has port indicators */
+#define HCS_PPC(p)		((p)&(1 << 4))	/* true: port power control */
+#define HCS_N_PORTS(p)		(((p)>>0)&0xf)	/* bits 3:0, ports on HC */
+#define HCC_ISOC_CACHE(p)       ((p)&(1 << 7))  /* true: can cache isoc frame */
+#define HCC_ISOC_THRES(p)       (((p)>>4)&0x7)  /* bits 6:4, uframes cached */
+
+/* Section 2.3 Host Controller Operational Registers */
+#define CMD_LRESET	(1<<7)		/* partial reset (no ports, etc) */
+#define CMD_RESET	(1<<1)		/* reset HC not bus */
+#define CMD_RUN		(1<<0)		/* start/stop HC */
+#define STS_PCD		(1<<2)		/* port change detect */
+#define FLAG_CF		(1<<0)		/* true: we'll support "high speed" */
+
+#define PORT_OWNER	(1<<13)		/* true: companion hc owns this port */
+#define PORT_POWER	(1<<12)		/* true: has power (see PPC) */
+#define PORT_USB11(x) (((x) & (3 << 10)) == (1 << 10))	/* USB 1.1 device */
+#define PORT_RESET	(1<<8)		/* reset port */
+#define PORT_SUSPEND	(1<<7)		/* suspend port */
+#define PORT_RESUME	(1<<6)		/* resume it */
+#define PORT_PE		(1<<2)		/* port enable */
+#define PORT_CSC	(1<<1)		/* connect status change */
+#define PORT_CONNECT	(1<<0)		/* device connected */
+#define PORT_RWC_BITS   (PORT_CSC)
+
+struct isp1760_qtd {
+	struct isp1760_qtd *hw_next;
+	u8 packet_type;
+	u8 toggle;
+
+	void *data_buffer;
+	/* the rest is HCD-private */
+	struct list_head qtd_list;
+	struct urb *urb;
+	size_t length;
+
+	/* isp special*/
+	u32 status;
+#define URB_COMPLETE_NOTIFY	(1 << 0)
+#define URB_ENQUEUED		(1 << 1)
+#define URB_TYPE_ATL		(1 << 2)
+#define URB_TYPE_INT		(1 << 3)
+};
+
+struct isp1760_qh {
+	/* first part defined by EHCI spec */
+	struct list_head qtd_list;
+	struct isp1760_hcd *priv;
+
+	/* periodic schedule info */
+	unsigned short period;		/* polling interval */
+	struct usb_device *dev;
+
+	u32 toggle;
+	u32 ping;
+};
+
+#define ehci_port_speed(priv, portsc) (1 << USB_PORT_FEAT_HIGHSPEED)
+
+static unsigned int isp1760_readl(__u32 __iomem *regs)
+{
+	return readl(regs);
+}
+
+static void isp1760_writel(const unsigned int val, __u32 __iomem *regs)
+{
+	writel(val, regs);
+}
+
+/*
+ * The next two copy via MMIO data to/from the device. memcpy_{to|from}io()
+ * doesn't quite work because some people have to enforce 32-bit access
+ */
+static void priv_read_copy(struct isp1760_hcd *priv, u32 *src,
+		__u32 __iomem *dst, u32 len)
+{
+	u32 val;
+	u8 *buff8;
+
+	if (!src) {
+		printk(KERN_ERR "ERROR: buffer: %p len: %d\n", src, len);
+		return;
+	}
+
+	while (len >= 4) {
+		*src = __raw_readl(dst);
+		len -= 4;
+		src++;
+		dst++;
+	}
+
+	if (!len)
+		return;
+
+	/* in case we have 3, 2 or 1 by left. The dst buffer may not be fully
+	 * allocated.
+	 */
+	val = isp1760_readl(dst);
+
+	buff8 = (u8 *)src;
+	while (len) {
+
+		*buff8 = val;
+		val >>= 8;
+		len--;
+		buff8++;
+	}
+}
+
+static void priv_write_copy(const struct isp1760_hcd *priv, const u32 *src,
+		__u32 __iomem *dst, u32 len)
+{
+	while (len >= 4) {
+		__raw_writel(*src, dst);
+		len -= 4;
+		src++;
+		dst++;
+	}
+
+	if (!len)
+		return;
+	/* in case we have 3, 2 or 1 by left. The buffer is allocated and the
+	 * extra bytes should not be read by the HW
+	 */
+
+	__raw_writel(*src, dst);
+}
+
+/* memory management of the 60kb on the chip from 0x1000 to 0xffff */
+static void init_memory(struct isp1760_hcd *priv)
+{
+	int i;
+	u32 payload;
+
+	payload = 0x1000;
+	for (i = 0; i < BLOCK_1_NUM; i++) {
+		priv->memory_pool[i].start = payload;
+		priv->memory_pool[i].size = BLOCK_1_SIZE;
+		priv->memory_pool[i].free = 1;
+		payload += priv->memory_pool[i].size;
+	}
+
+
+	for (i = BLOCK_1_NUM; i < BLOCK_1_NUM + BLOCK_2_NUM; i++) {
+		priv->memory_pool[i].start = payload;
+		priv->memory_pool[i].size = BLOCK_2_SIZE;
+		priv->memory_pool[i].free = 1;
+		payload += priv->memory_pool[i].size;
+	}
+
+
+	for (i = BLOCK_1_NUM + BLOCK_2_NUM; i < BLOCKS; i++) {
+		priv->memory_pool[i].start = payload;
+		priv->memory_pool[i].size = BLOCK_3_SIZE;
+		priv->memory_pool[i].free = 1;
+		payload += priv->memory_pool[i].size;
+	}
+
+	BUG_ON(payload - priv->memory_pool[i - 1].size > PAYLOAD_SIZE);
+}
+
+static u32 alloc_mem(struct isp1760_hcd *priv, u32 size)
+{
+	int i;
+
+	if (!size)
+		return ISP1760_NULL_POINTER;
+
+	for (i = 0; i < BLOCKS; i++) {
+		if (priv->memory_pool[i].size >= size &&
+				priv->memory_pool[i].free) {
+
+			priv->memory_pool[i].free = 0;
+			return priv->memory_pool[i].start;
+		}
+	}
+
+	printk(KERN_ERR "ISP1760 MEM: can not allocate %d bytes of memory\n",
+			size);
+	printk(KERN_ERR "Current memory map:\n");
+	for (i = 0; i < BLOCKS; i++) {
+		printk(KERN_ERR "Pool %2d size %4d status: %d\n",
+				i, priv->memory_pool[i].size,
+				priv->memory_pool[i].free);
+	}
+	/* XXX maybe -ENOMEM could be possible */
+	BUG();
+	return 0;
+}
+
+static void free_mem(struct isp1760_hcd *priv, u32 mem)
+{
+	int i;
+
+	if (mem == ISP1760_NULL_POINTER)
+		return;
+
+	for (i = 0; i < BLOCKS; i++) {
+		if (priv->memory_pool[i].start == mem) {
+
+			BUG_ON(priv->memory_pool[i].free);
+
+			priv->memory_pool[i].free = 1;
+			return ;
+		}
+	}
+
+	printk(KERN_ERR "Trying to free not-here-allocated memory :%08x\n",
+			mem);
+	BUG();
+}
+
+static void isp1760_init_regs(struct usb_hcd *hcd)
+{
+	isp1760_writel(0, hcd->regs + HC_BUFFER_STATUS_REG);
+	isp1760_writel(NO_TRANSFER_ACTIVE, hcd->regs +
+			HC_ATL_PTD_SKIPMAP_REG);
+	isp1760_writel(NO_TRANSFER_ACTIVE, hcd->regs +
+			HC_INT_PTD_SKIPMAP_REG);
+	isp1760_writel(NO_TRANSFER_ACTIVE, hcd->regs +
+			HC_ISO_PTD_SKIPMAP_REG);
+
+	isp1760_writel(~NO_TRANSFER_ACTIVE, hcd->regs +
+			HC_ATL_PTD_DONEMAP_REG);
+	isp1760_writel(~NO_TRANSFER_ACTIVE, hcd->regs +
+			HC_INT_PTD_DONEMAP_REG);
+	isp1760_writel(~NO_TRANSFER_ACTIVE, hcd->regs +
+			HC_ISO_PTD_DONEMAP_REG);
+}
+
+static int handshake(struct isp1760_hcd *priv, void __iomem *ptr,
+		      u32 mask, u32 done, int usec)
+{
+	u32 result;
+
+	do {
+		result = isp1760_readl(ptr);
+		if (result == ~0)
+			return -ENODEV;
+		result &= mask;
+		if (result == done)
+			return 0;
+		udelay(1);
+		usec--;
+	} while (usec > 0);
+	return -ETIMEDOUT;
+}
+
+/* reset a non-running (STS_HALT == 1) controller */
+static int ehci_reset(struct isp1760_hcd *priv)
+{
+	int retval;
+	struct usb_hcd *hcd = priv_to_hcd(priv);
+	u32 command = isp1760_readl(hcd->regs + HC_USBCMD);
+
+	command |= CMD_RESET;
+	isp1760_writel(command, hcd->regs + HC_USBCMD);
+	hcd->state = HC_STATE_HALT;
+	priv->next_statechange = jiffies;
+	retval = handshake(priv, hcd->regs + HC_USBCMD,
+			    CMD_RESET, 0, 250 * 1000);
+	return retval;
+}
+
+static void qh_destroy(struct isp1760_qh *qh)
+{
+	BUG_ON(!list_empty(&qh->qtd_list));
+	kmem_cache_free(qh_cachep, qh);
+}
+
+static struct isp1760_qh *isp1760_qh_alloc(struct isp1760_hcd *priv,
+		gfp_t flags)
+{
+	struct isp1760_qh *qh;
+
+	qh = kmem_cache_zalloc(qh_cachep, flags);
+	if (!qh)
+		return qh;
+
+	INIT_LIST_HEAD(&qh->qtd_list);
+	qh->priv = priv;
+	return qh;
+}
+
+/* magic numbers that can affect system performance */
+#define	EHCI_TUNE_CERR		3	/* 0-3 qtd retries; 0 == don't stop */
+#define	EHCI_TUNE_RL_HS		4	/* nak throttle; see 4.9 */
+#define	EHCI_TUNE_RL_TT		0
+#define	EHCI_TUNE_MULT_HS	1	/* 1-3 transactions/uframe; 4.10.3 */
+#define	EHCI_TUNE_MULT_TT	1
+#define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
+
+/* one-time init, only for memory state */
+static int priv_init(struct usb_hcd *hcd)
+{
+	struct isp1760_hcd		*priv = hcd_to_priv(hcd);
+	u32			hcc_params;
+
+	spin_lock_init(&priv->lock);
+
+	/*
+	 * hw default: 1K periodic list heads, one per frame.
+	 * periodic_size can shrink by USBCMD update if hcc_params allows.
+	 */
+	priv->periodic_size = DEFAULT_I_TDPS;
+
+	/* controllers may cache some of the periodic schedule ... */
+	hcc_params = isp1760_readl(hcd->regs + HC_HCCPARAMS);
+	/* full frame cache */
+	if (HCC_ISOC_CACHE(hcc_params))
+		priv->i_thresh = 8;
+	else /* N microframes cached */
+		priv->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
+
+	return 0;
+}
+
+static int isp1760_hc_setup(struct usb_hcd *hcd)
+{
+	struct isp1760_hcd *priv = hcd_to_priv(hcd);
+	int result;
+	u32 scratch, hwmode;
+
+	/* Setup HW Mode Control: This assumes a level active-low interrupt */
+	hwmode = HW_DATA_BUS_32BIT;
+
+	if (priv->devflags & ISP1760_FLAG_BUS_WIDTH_16)
+		hwmode &= ~HW_DATA_BUS_32BIT;
+	if (priv->devflags & ISP1760_FLAG_ANALOG_OC)
+		hwmode |= HW_ANA_DIGI_OC;
+	if (priv->devflags & ISP1760_FLAG_DACK_POL_HIGH)
+		hwmode |= HW_DACK_POL_HIGH;
+	if (priv->devflags & ISP1760_FLAG_DREQ_POL_HIGH)
+		hwmode |= HW_DREQ_POL_HIGH;
+
+	/*
+	 * We have to set this first in case we're in 16-bit mode.
+	 * Write it twice to ensure correct upper bits if switching
+	 * to 16-bit mode.
+	 */
+	isp1760_writel(hwmode, hcd->regs + HC_HW_MODE_CTRL);
+	isp1760_writel(hwmode, hcd->regs + HC_HW_MODE_CTRL);
+
+	isp1760_writel(0xdeadbabe, hcd->regs + HC_SCRATCH_REG);
+	/* Change bus pattern */
+	scratch = isp1760_readl(hcd->regs + HC_CHIP_ID_REG);
+	scratch = isp1760_readl(hcd->regs + HC_SCRATCH_REG);
+	if (scratch != 0xdeadbabe) {
+		printk(KERN_ERR "ISP1760: Scratch test failed.\n");
+		return -ENODEV;
+	}
+
+	/* pre reset */
+	isp1760_init_regs(hcd);
+
+	/* reset */
+	isp1760_writel(SW_RESET_RESET_ALL, hcd->regs + HC_RESET_REG);
+	mdelay(100);
+
+	isp1760_writel(SW_RESET_RESET_HC, hcd->regs + HC_RESET_REG);
+	mdelay(100);
+
+	result = ehci_reset(priv);
+	if (result)
+		return result;
+
+	/* Step 11 passed */
+
+	isp1760_info(priv, "bus width: %d, oc: %s\n",
+			   (priv->devflags & ISP1760_FLAG_BUS_WIDTH_16) ?
+			   16 : 32, (priv->devflags & ISP1760_FLAG_ANALOG_OC) ?
+			   "analog" : "digital");
+
+	/* ATL reset */
+	isp1760_writel(hwmode | ALL_ATX_RESET, hcd->regs + HC_HW_MODE_CTRL);
+	mdelay(10);
+	isp1760_writel(hwmode, hcd->regs + HC_HW_MODE_CTRL);
+
+	isp1760_writel(INTERRUPT_ENABLE_MASK, hcd->regs + HC_INTERRUPT_REG);
+	isp1760_writel(INTERRUPT_ENABLE_MASK, hcd->regs + HC_INTERRUPT_ENABLE);
+
+	/*
+	 * PORT 1 Control register of the ISP1760 is the OTG control
+	 * register on ISP1761. Since there is no OTG or device controller
+	 * support in this driver, we use port 1 as a "normal" USB host port on
+	 * both chips.
+	 */
+	isp1760_writel(PORT1_POWER | PORT1_INIT2,
+		       hcd->regs + HC_PORT1_CTRL);
+	mdelay(10);
+
+	priv->hcs_params = isp1760_readl(hcd->regs + HC_HCSPARAMS);
+
+	return priv_init(hcd);
+}
+
+static void isp1760_init_maps(struct usb_hcd *hcd)
+{
+	/*set last maps, for iso its only 1, else 32 tds bitmap*/
+	isp1760_writel(0x80000000, hcd->regs + HC_ATL_PTD_LASTPTD_REG);
+	isp1760_writel(0x80000000, hcd->regs + HC_INT_PTD_LASTPTD_REG);
+	isp1760_writel(0x00000001, hcd->regs + HC_ISO_PTD_LASTPTD_REG);
+}
+
+static void isp1760_enable_interrupts(struct usb_hcd *hcd)
+{
+	isp1760_writel(0, hcd->regs + HC_ATL_IRQ_MASK_AND_REG);
+	isp1760_writel(0, hcd->regs + HC_ATL_IRQ_MASK_OR_REG);
+	isp1760_writel(0, hcd->regs + HC_INT_IRQ_MASK_AND_REG);
+	isp1760_writel(0, hcd->regs + HC_INT_IRQ_MASK_OR_REG);
+	isp1760_writel(0, hcd->regs + HC_ISO_IRQ_MASK_AND_REG);
+	isp1760_writel(0xffffffff, hcd->regs + HC_ISO_IRQ_MASK_OR_REG);
+	/* step 23 passed */
+}
+
+static int isp1760_run(struct usb_hcd *hcd)
+{
+	struct isp1760_hcd *priv = hcd_to_priv(hcd);
+	int retval;
+	u32 temp;
+	u32 command;
+	u32 chipid;
+
+	hcd->uses_new_polling = 1;
+	hcd->poll_rh = 0;
+
+	hcd->state = HC_STATE_RUNNING;
+	isp1760_enable_interrupts(hcd);
+	temp = isp1760_readl(hcd->regs + HC_HW_MODE_CTRL);
+	isp1760_writel(temp | HW_GLOBAL_INTR_EN, hcd->regs + HC_HW_MODE_CTRL);
+
+	command = isp1760_readl(hcd->regs + HC_USBCMD);
+	command &= ~(CMD_LRESET|CMD_RESET);
+	command |= CMD_RUN;
+	isp1760_writel(command, hcd->regs + HC_USBCMD);
+
+	retval = handshake(priv, hcd->regs + HC_USBCMD,	CMD_RUN, CMD_RUN,
+			250 * 1000);
+	if (retval)
+		return retval;
+
+	/*
+	 * XXX
+	 * Spec says to write FLAG_CF as last config action, priv code grabs
+	 * the semaphore while doing so.
+	 */
+	down_write(&ehci_cf_port_reset_rwsem);
+	isp1760_writel(FLAG_CF, hcd->regs + HC_CONFIGFLAG);
+
+	retval = handshake(priv, hcd->regs + HC_CONFIGFLAG, FLAG_CF, FLAG_CF,
+			250 * 1000);
+	up_write(&ehci_cf_port_reset_rwsem);
+	if (retval)
+		return retval;
+
+	chipid = isp1760_readl(hcd->regs + HC_CHIP_ID_REG);
+	isp1760_info(priv, "USB ISP %04x HW rev. %d started\n",	chipid & 0xffff,
+			chipid >> 16);
+
+	/* PTD Register Init Part 2, Step 28 */
+	/* enable INTs */
+	isp1760_init_maps(hcd);
+
+	/* GRR this is run-once init(), being done every time the HC starts.
+	 * So long as they're part of class devices, we can't do it init()
+	 * since the class device isn't created that early.
+	 */
+	return 0;
+}
+
+static u32 base_to_chip(u32 base)
+{
+	return ((base - 0x400) >> 3);
+}
+
+static void transform_into_atl(struct isp1760_hcd *priv, struct isp1760_qh *qh,
+			struct isp1760_qtd *qtd, struct urb *urb,
+			u32 payload, struct ptd *ptd)
+{
+	u32 dw0;
+	u32 dw1;
+	u32 dw2;
+	u32 dw3;
+	u32 maxpacket;
+	u32 multi;
+	u32 pid_code;
+	u32 rl = RL_COUNTER;
+	u32 nak = NAK_COUNTER;
+
+	/* according to 3.6.2, max packet len can not be > 0x400 */
+	maxpacket = usb_maxpacket(urb->dev, urb->pipe, usb_pipeout(urb->pipe));
+	multi =  1 + ((maxpacket >> 11) & 0x3);
+	maxpacket &= 0x7ff;
+
+	/* DW0 */
+	dw0 = PTD_VALID;
+	dw0 |= PTD_LENGTH(qtd->length);
+	dw0 |= PTD_MAXPACKET(maxpacket);
+	dw0 |= PTD_ENDPOINT(usb_pipeendpoint(urb->pipe));
+	dw1 = usb_pipeendpoint(urb->pipe) >> 1;
+
+	/* DW1 */
+	dw1 |= PTD_DEVICE_ADDR(usb_pipedevice(urb->pipe));
+
+	pid_code = qtd->packet_type;
+	dw1 |= PTD_PID_TOKEN(pid_code);
+
+	if (usb_pipebulk(urb->pipe))
+		dw1 |= PTD_TRANS_BULK;
+	else if  (usb_pipeint(urb->pipe))
+		dw1 |= PTD_TRANS_INT;
+
+	if (urb->dev->speed != USB_SPEED_HIGH) {
+		/* split transaction */
+
+		dw1 |= PTD_TRANS_SPLIT;
+		if (urb->dev->speed == USB_SPEED_LOW)
+			dw1 |= PTD_SE_USB_LOSPEED;
+
+		dw1 |= PTD_PORT_NUM(urb->dev->ttport);
+		dw1 |= PTD_HUB_NUM(urb->dev->tt->hub->devnum);
+
+		/* SE bit for Split INT transfers */
+		if (usb_pipeint(urb->pipe) &&
+				(urb->dev->speed == USB_SPEED_LOW))
+			dw1 |= 2 << 16;
+
+		dw3 = 0;
+		rl = 0;
+		nak = 0;
+	} else {
+		dw0 |= PTD_MULTI(multi);
+		if (usb_pipecontrol(urb->pipe) || usb_pipebulk(urb->pipe))
+			dw3 = qh->ping;
+		else
+			dw3 = 0;
+	}
+	/* DW2 */
+	dw2 = 0;
+	dw2 |= PTD_DATA_START_ADDR(base_to_chip(payload));
+	dw2 |= PTD_RL_CNT(rl);
+	dw3 |= PTD_NAC_CNT(nak);
+
+	/* DW3 */
+	if (usb_pipecontrol(urb->pipe))
+		dw3 |= PTD_DATA_TOGGLE(qtd->toggle);
+	else
+		dw3 |= qh->toggle;
+
+
+	dw3 |= PTD_ACTIVE;
+	/* Cerr */
+	dw3 |= PTD_CERR(ERR_COUNTER);
+
+	memset(ptd, 0, sizeof(*ptd));
+
+	ptd->dw0 = cpu_to_le32(dw0);
+	ptd->dw1 = cpu_to_le32(dw1);
+	ptd->dw2 = cpu_to_le32(dw2);
+	ptd->dw3 = cpu_to_le32(dw3);
+}
+
+static void transform_add_int(struct isp1760_hcd *priv, struct isp1760_qh *qh,
+			struct isp1760_qtd *qtd, struct urb *urb,
+			u32 payload, struct ptd *ptd)
+{
+	u32 maxpacket;
+	u32 multi;
+	u32 numberofusofs;
+	u32 i;
+	u32 usofmask, usof;
+	u32 period;
+
+	maxpacket = usb_maxpacket(urb->dev, urb->pipe, usb_pipeout(urb->pipe));
+	multi =  1 + ((maxpacket >> 11) & 0x3);
+	maxpacket &= 0x7ff;
+	/* length of the data per uframe */
+	maxpacket = multi * maxpacket;
+
+	numberofusofs = urb->transfer_buffer_length / maxpacket;
+	if (urb->transfer_buffer_length % maxpacket)
+		numberofusofs += 1;
+
+	usofmask = 1;
+	usof = 0;
+	for (i = 0; i < numberofusofs; i++) {
+		usof |= usofmask;
+		usofmask <<= 1;
+	}
+
+	if (urb->dev->speed != USB_SPEED_HIGH) {
+		/* split */
+		ptd->dw5 = cpu_to_le32(0x1c);
+
+		if (qh->period >= 32)
+			period = qh->period / 2;
+		else
+			period = qh->period;
+
+	} else {
+
+		if (qh->period >= 8)
+			period = qh->period/8;
+		else
+			period = qh->period;
+
+		if (period >= 32)
+			period  = 16;
+
+		if (qh->period >= 8) {
+			/* millisecond period */
+			period = (period << 3);
+		} else {
+			/* usof based tranmsfers */
+			/* minimum 4 usofs */
+			usof = 0x11;
+		}
+	}
+
+	ptd->dw2 |= cpu_to_le32(period);
+	ptd->dw4 = cpu_to_le32(usof);
+}
+
+static void transform_into_int(struct isp1760_hcd *priv, struct isp1760_qh *qh,
+			struct isp1760_qtd *qtd, struct urb *urb,
+			u32 payload, struct ptd *ptd)
+{
+	transform_into_atl(priv, qh, qtd, urb, payload, ptd);
+	transform_add_int(priv, qh, qtd, urb,  payload, ptd);
+}
+
+static int qtd_fill(struct isp1760_qtd *qtd, void *databuffer, size_t len,
+		u32 token)
+{
+	int count;
+
+	qtd->data_buffer = databuffer;
+	qtd->packet_type = GET_QTD_TOKEN_TYPE(token);
+	qtd->toggle = GET_DATA_TOGGLE(token);
+
+	if (len > HC_ATL_PL_SIZE)
+		count = HC_ATL_PL_SIZE;
+	else
+		count = len;
+
+	qtd->length = count;
+	return count;
+}
+
+static int check_error(struct ptd *ptd)
+{
+	int error = 0;
+	u32 dw3;
+
+	dw3 = le32_to_cpu(ptd->dw3);
+	if (dw3 & DW3_HALT_BIT)
+		error = -EPIPE;
+
+	if (dw3 & DW3_ERROR_BIT) {
+		printk(KERN_ERR "error bit is set in DW3\n");
+		error = -EPIPE;
+	}
+
+	if (dw3 & DW3_QTD_ACTIVE) {
+		printk(KERN_ERR "transfer active bit is set DW3\n");
+		printk(KERN_ERR "nak counter: %d, rl: %d\n", (dw3 >> 19) & 0xf,
+				(le32_to_cpu(ptd->dw2) >> 25) & 0xf);
+	}
+
+	return error;
+}
+
+static void check_int_err_status(u32 dw4)
+{
+	u32 i;
+
+	dw4 >>= 8;
+
+	for (i = 0; i < 8; i++) {
+		switch (dw4 & 0x7) {
+		case INT_UNDERRUN:
+			printk(KERN_ERR "ERROR: under run , %d\n", i);
+			break;
+
+		case INT_EXACT:
+			printk(KERN_ERR "ERROR: transaction error, %d\n", i);
+			break;
+
+		case INT_BABBLE:
+			printk(KERN_ERR "ERROR: babble error, %d\n", i);
+			break;
+		}
+		dw4 >>= 3;
+	}
+}
+
+static void enqueue_one_qtd(struct isp1760_qtd *qtd, struct isp1760_hcd *priv,
+		u32 payload)
+{
+	u32 token;
+	struct usb_hcd *hcd = priv_to_hcd(priv);
+
+	token = qtd->packet_type;
+
+	if (qtd->length && (qtd->length <= HC_ATL_PL_SIZE)) {
+		switch (token) {
+		case IN_PID:
+			break;
+		case OUT_PID:
+		case SETUP_PID:
+			priv_write_copy(priv, qtd->data_buffer,
+					hcd->regs + payload,
+					qtd->length);
+		}
+	}
+}
+
+static void enqueue_one_atl_qtd(u32 atl_regs, u32 payload,
+		struct isp1760_hcd *priv, struct isp1760_qh *qh,
+		struct urb *urb, u32 slot, struct isp1760_qtd *qtd)
+{
+	struct ptd ptd;
+	struct usb_hcd *hcd = priv_to_hcd(priv);
+
+	transform_into_atl(priv, qh, qtd, urb, payload, &ptd);
+	priv_write_copy(priv, (u32 *)&ptd, hcd->regs + atl_regs, sizeof(ptd));
+	enqueue_one_qtd(qtd, priv, payload);
+
+	priv->atl_ints[slot].urb = urb;
+	priv->atl_ints[slot].qh = qh;
+	priv->atl_ints[slot].qtd = qtd;
+	priv->atl_ints[slot].data_buffer = qtd->data_buffer;
+	priv->atl_ints[slot].payload = payload;
+	qtd->status |= URB_ENQUEUED | URB_TYPE_ATL;
+	qtd->status |= slot << 16;
+}
+
+static void enqueue_one_int_qtd(u32 int_regs, u32 payload,
+		struct isp1760_hcd *priv, struct isp1760_qh *qh,
+		struct urb *urb, u32 slot,  struct isp1760_qtd *qtd)
+{
+	struct ptd ptd;
+	struct usb_hcd *hcd = priv_to_hcd(priv);
+
+	transform_into_int(priv, qh, qtd, urb, payload, &ptd);
+	priv_write_copy(priv, (u32 *)&ptd, hcd->regs + int_regs, sizeof(ptd));
+	enqueue_one_qtd(qtd, priv, payload);
+
+	priv->int_ints[slot].urb = urb;
+	priv->int_ints[slot].qh = qh;
+	priv->int_ints[slot].qtd = qtd;
+	priv->int_ints[slot].data_buffer = qtd->data_buffer;
+	priv->int_ints[slot].payload = payload;
+	qtd->status |= URB_ENQUEUED | URB_TYPE_INT;
+	qtd->status |= slot << 16;
+}
+
+static void enqueue_an_ATL_packet(struct usb_hcd *hcd, struct isp1760_qh *qh,
+				  struct isp1760_qtd *qtd)
+{
+	struct isp1760_hcd *priv = hcd_to_priv(hcd);
+	u32 skip_map, or_map;
+	u32 queue_entry;
+	u32 slot;
+	u32 atl_regs, payload;
+	u32 buffstatus;
+
+	/*
+	 * When this function is called from the interrupt handler to enqueue
+	 * a follow-up packet, the SKIP register gets written and read back
+	 * almost immediately. With ISP1761, this register requires a delay of
+	 * 195ns between a write and subsequent read (see section 15.1.1.3).
+	 */
+	ndelay(195);
+	skip_map = isp1760_readl(hcd->regs + HC_ATL_PTD_SKIPMAP_REG);
+
+	BUG_ON(!skip_map);
+	slot = __ffs(skip_map);
+	queue_entry = 1 << slot;
+
+	atl_regs = ATL_REGS_OFFSET + slot * sizeof(struct ptd);
+
+	payload = alloc_mem(priv, qtd->length);
+
+	enqueue_one_atl_qtd(atl_regs, payload, priv, qh, qtd->urb, slot, qtd);
+
+	or_map = isp1760_readl(hcd->regs + HC_ATL_IRQ_MASK_OR_REG);
+	or_map |= queue_entry;
+	isp1760_writel(or_map, hcd->regs + HC_ATL_IRQ_MASK_OR_REG);
+
+	skip_map &= ~queue_entry;
+	isp1760_writel(skip_map, hcd->regs + HC_ATL_PTD_SKIPMAP_REG);
+
+	buffstatus = isp1760_readl(hcd->regs + HC_BUFFER_STATUS_REG);
+	buffstatus |= ATL_BUFFER;
+	isp1760_writel(buffstatus, hcd->regs + HC_BUFFER_STATUS_REG);
+}
+
+static void enqueue_an_INT_packet(struct usb_hcd *hcd, struct isp1760_qh *qh,
+				  struct isp1760_qtd *qtd)
+{
+	struct isp1760_hcd *priv = hcd_to_priv(hcd);
+	u32 skip_map, or_map;
+	u32 queue_entry;
+	u32 slot;
+	u32 int_regs, payload;
+	u32 buffstatus;
+
+	/*
+	 * When this function is called from the interrupt handler to enqueue
+	 * a follow-up packet, the SKIP register gets written and read back
+	 * almost immediately. With ISP1761, this register requires a delay of
+	 * 195ns between a write and subsequent read (see section 15.1.1.3).
+	 */
+	ndelay(195);
+	skip_map = isp1760_readl(hcd->regs + HC_INT_PTD_SKIPMAP_REG);
+
+	BUG_ON(!skip_map);
+	slot = __ffs(skip_map);
+	queue_entry = 1 << slot;
+
+	int_regs = INT_REGS_OFFSET + slot * sizeof(struct ptd);
+
+	payload = alloc_mem(priv, qtd->length);
+
+	enqueue_one_int_qtd(int_regs, payload, priv, qh, qtd->urb, slot, qtd);
+
+	or_map = isp1760_readl(hcd->regs + HC_INT_IRQ_MASK_OR_REG);
+	or_map |= queue_entry;
+	isp1760_writel(or_map, hcd->regs + HC_INT_IRQ_MASK_OR_REG);
+
+	skip_map &= ~queue_entry;
+	isp1760_writel(skip_map, hcd->regs + HC_INT_PTD_SKIPMAP_REG);
+
+	buffstatus = isp1760_readl(hcd->regs + HC_BUFFER_STATUS_REG);
+	buffstatus |= INT_BUFFER;
+	isp1760_writel(buffstatus, hcd->regs + HC_BUFFER_STATUS_REG);
+}
+
+static void isp1760_urb_done(struct isp1760_hcd *priv, struct urb *urb, int status)
+__releases(priv->lock)
+__acquires(priv->lock)
+{
+	if (!urb->unlinked) {
+		if (status == -EINPROGRESS)
+			status = 0;
+	}
+
+	/* complete() can reenter this HCD */
+	usb_hcd_unlink_urb_from_ep(priv_to_hcd(priv), urb);
+	spin_unlock(&priv->lock);
+	usb_hcd_giveback_urb(priv_to_hcd(priv), urb, status);
+	spin_lock(&priv->lock);
+}
+
+static void isp1760_qtd_free(struct isp1760_qtd *qtd)
+{
+	kmem_cache_free(qtd_cachep, qtd);
+}
+
+static struct isp1760_qtd *clean_this_qtd(struct isp1760_qtd *qtd)
+{
+	struct isp1760_qtd *tmp_qtd;
+
+	tmp_qtd = qtd->hw_next;
+	list_del(&qtd->qtd_list);
+	isp1760_qtd_free(qtd);
+	return tmp_qtd;
+}
+
+/*
+ * Remove this QTD from the QH list and free its memory. If this QTD
+ * isn't the last one than remove also his successor(s).
+ * Returns the QTD which is part of an new URB and should be enqueued.
+ */
+static struct isp1760_qtd *clean_up_qtdlist(struct isp1760_qtd *qtd)
+{
+	struct isp1760_qtd *tmp_qtd;
+	int last_one;
+
+	do {
+		tmp_qtd = qtd->hw_next;
+		last_one = qtd->status & URB_COMPLETE_NOTIFY;
+		list_del(&qtd->qtd_list);
+		isp1760_qtd_free(qtd);
+		qtd = tmp_qtd;
+	} while (!last_one && qtd);
+
+	return qtd;
+}
+
+static void do_atl_int(struct usb_hcd *usb_hcd)
+{
+	struct isp1760_hcd *priv = hcd_to_priv(usb_hcd);
+	u32 done_map, skip_map;
+	struct ptd ptd;
+	struct urb *urb = NULL;
+	u32 atl_regs_base;
+	u32 atl_regs;
+	u32 queue_entry;
+	u32 payload;
+	u32 length;
+	u32 or_map;
+	u32 status = -EINVAL;
+	int error;
+	struct isp1760_qtd *qtd;
+	struct isp1760_qh *qh;
+	u32 rl;
+	u32 nakcount;
+
+	done_map = isp1760_readl(usb_hcd->regs +
+			HC_ATL_PTD_DONEMAP_REG);
+	skip_map = isp1760_readl(usb_hcd->regs +
+			HC_ATL_PTD_SKIPMAP_REG);
+
+	or_map = isp1760_readl(usb_hcd->regs + HC_ATL_IRQ_MASK_OR_REG);
+	or_map &= ~done_map;
+	isp1760_writel(or_map, usb_hcd->regs + HC_ATL_IRQ_MASK_OR_REG);
+
+	atl_regs_base = ATL_REGS_OFFSET;
+	while (done_map) {
+		u32 dw1;
+		u32 dw2;
+		u32 dw3;
+
+		status = 0;
+
+		queue_entry = __ffs(done_map);
+		done_map &= ~(1 << queue_entry);
+		skip_map |= 1 << queue_entry;
+
+		atl_regs = atl_regs_base + queue_entry * sizeof(struct ptd);
+
+		urb = priv->atl_ints[queue_entry].urb;
+		qtd = priv->atl_ints[queue_entry].qtd;
+		qh = priv->atl_ints[queue_entry].qh;
+		payload = priv->atl_ints[queue_entry].payload;
+
+		if (!qh) {
+			printk(KERN_ERR "qh is 0\n");
+			continue;
+		}
+		isp1760_writel(atl_regs + ISP_BANK(0), usb_hcd->regs +
+				HC_MEMORY_REG);
+		isp1760_writel(payload  + ISP_BANK(1), usb_hcd->regs +
+				HC_MEMORY_REG);
+		/*
+		 * write bank1 address twice to ensure the 90ns delay (time
+		 * between BANK0 write and the priv_read_copy() call is at
+		 * least 3*t_WHWL + 2*t_w11 = 3*25ns + 2*17ns = 109ns)
+		 */
+		isp1760_writel(payload  + ISP_BANK(1), usb_hcd->regs +
+				HC_MEMORY_REG);
+
+		priv_read_copy(priv, (u32 *)&ptd, usb_hcd->regs + atl_regs +
+				ISP_BANK(0), sizeof(ptd));
+
+		dw1 = le32_to_cpu(ptd.dw1);
+		dw2 = le32_to_cpu(ptd.dw2);
+		dw3 = le32_to_cpu(ptd.dw3);
+		rl = (dw2 >> 25) & 0x0f;
+		nakcount = (dw3 >> 19) & 0xf;
+
+		/* Transfer Error, *but* active and no HALT -> reload */
+		if ((dw3 & DW3_ERROR_BIT) && (dw3 & DW3_QTD_ACTIVE) &&
+				!(dw3 & DW3_HALT_BIT)) {
+
+			/* according to ppriv code, we have to
+			 * reload this one if trasfered bytes != requested bytes
+			 * else act like everything went smooth..
+			 * XXX This just doesn't feel right and hasn't
+			 * triggered so far.
+			 */
+
+			length = PTD_XFERRED_LENGTH(dw3);
+			printk(KERN_ERR "Should reload now.... transfered %d "
+					"of %zu\n", length, qtd->length);
+			BUG();
+		}
+
+		if (!nakcount && (dw3 & DW3_QTD_ACTIVE)) {
+			u32 buffstatus;
+
+			/* XXX
+			 * NAKs are handled in HW by the chip. Usually if the
+			 * device is not able to send data fast enough.
+			 * This did not trigger for a long time now.
+			 */
+			printk(KERN_ERR "Reloading ptd %p/%p... qh %p readed: "
+					"%d of %zu done: %08x cur: %08x\n", qtd,
+					urb, qh, PTD_XFERRED_LENGTH(dw3),
+					qtd->length, done_map,
+					(1 << queue_entry));
+
+			/* RL counter = ERR counter */
+			dw3 &= ~(0xf << 19);
+			dw3 |= rl << 19;
+			dw3 &= ~(3 << (55 - 32));
+			dw3 |= ERR_COUNTER << (55 - 32);
+
+			/*
+			 * It is not needed to write skip map back because it
+			 * is unchanged. Just make sure that this entry is
+			 * unskipped once it gets written to the HW.
+			 */
+			skip_map &= ~(1 << queue_entry);
+			or_map = isp1760_readl(usb_hcd->regs +
+					HC_ATL_IRQ_MASK_OR_REG);
+			or_map |= 1 << queue_entry;
+			isp1760_writel(or_map, usb_hcd->regs +
+					HC_ATL_IRQ_MASK_OR_REG);
+
+			ptd.dw3 = cpu_to_le32(dw3);
+			priv_write_copy(priv, (u32 *)&ptd, usb_hcd->regs +
+					atl_regs, sizeof(ptd));
+
+			ptd.dw0 |= cpu_to_le32(PTD_VALID);
+			priv_write_copy(priv, (u32 *)&ptd, usb_hcd->regs +
+					atl_regs, sizeof(ptd));
+
+			buffstatus = isp1760_readl(usb_hcd->regs +
+					HC_BUFFER_STATUS_REG);
+			buffstatus |= ATL_BUFFER;
+			isp1760_writel(buffstatus, usb_hcd->regs +
+					HC_BUFFER_STATUS_REG);
+			continue;
+		}
+
+		error = check_error(&ptd);
+		if (error) {
+			status = error;
+			priv->atl_ints[queue_entry].qh->toggle = 0;
+			priv->atl_ints[queue_entry].qh->ping = 0;
+			urb->status = -EPIPE;
+
+#if 0
+			printk(KERN_ERR "Error in %s().\n", __func__);
+			printk(KERN_ERR "IN dw0: %08x dw1: %08x dw2: %08x "
+					"dw3: %08x dw4: %08x dw5: %08x dw6: "
+					"%08x dw7: %08x\n",
+					ptd.dw0, ptd.dw1, ptd.dw2, ptd.dw3,
+					ptd.dw4, ptd.dw5, ptd.dw6, ptd.dw7);
+#endif
+		} else {
+			if (usb_pipetype(urb->pipe) == PIPE_BULK) {
+				priv->atl_ints[queue_entry].qh->toggle = dw3 &
+					(1 << 25);
+				priv->atl_ints[queue_entry].qh->ping = dw3 &
+					(1 << 26);
+			}
+		}
+
+		length = PTD_XFERRED_LENGTH(dw3);
+		if (length) {
+			switch (DW1_GET_PID(dw1)) {
+			case IN_PID:
+				priv_read_copy(priv,
+					priv->atl_ints[queue_entry].data_buffer,
+					usb_hcd->regs + payload + ISP_BANK(1),
+					length);
+
+			case OUT_PID:
+
+				urb->actual_length += length;
+
+			case SETUP_PID:
+				break;
+			}
+		}
+
+		priv->atl_ints[queue_entry].data_buffer = NULL;
+		priv->atl_ints[queue_entry].urb = NULL;
+		priv->atl_ints[queue_entry].qtd = NULL;
+		priv->atl_ints[queue_entry].qh = NULL;
+
+		free_mem(priv, payload);
+
+		isp1760_writel(skip_map, usb_hcd->regs +
+				HC_ATL_PTD_SKIPMAP_REG);
+
+		if (urb->status == -EPIPE) {
+			/* HALT was received */
+
+			qtd = clean_up_qtdlist(qtd);
+			isp1760_urb_done(priv, urb, urb->status);
+
+		} else if (usb_pipebulk(urb->pipe) && (length < qtd->length)) {
+			/* short BULK received */
+
+			if (urb->transfer_flags & URB_SHORT_NOT_OK) {
+				urb->status = -EREMOTEIO;
+				isp1760_dbg(priv, "short bulk, %d instead %zu "
+					"with URB_SHORT_NOT_OK flag.\n",
+					length, qtd->length);
+			}
+
+			if (urb->status == -EINPROGRESS)
+				urb->status = 0;
+
+			qtd = clean_up_qtdlist(qtd);
+
+			isp1760_urb_done(priv, urb, urb->status);
+
+		} else if (qtd->status & URB_COMPLETE_NOTIFY) {
+			/* that was the last qtd of that URB */
+
+			if (urb->status == -EINPROGRESS)
+				urb->status = 0;
+
+			qtd = clean_this_qtd(qtd);
+			isp1760_urb_done(priv, urb, urb->status);
+
+		} else {
+			/* next QTD of this URB */
+
+			qtd = clean_this_qtd(qtd);
+			BUG_ON(!qtd);
+		}
+
+		if (qtd)
+			enqueue_an_ATL_packet(usb_hcd, qh, qtd);
+
+		skip_map = isp1760_readl(usb_hcd->regs +
+				HC_ATL_PTD_SKIPMAP_REG);
+	}
+}
+
+static void do_intl_int(struct usb_hcd *usb_hcd)
+{
+	struct isp1760_hcd *priv = hcd_to_priv(usb_hcd);
+	u32 done_map, skip_map;
+	struct ptd ptd;
+	struct urb *urb = NULL;
+	u32 int_regs;
+	u32 int_regs_base;
+	u32 payload;
+	u32 length;
+	u32 or_map;
+	int error;
+	u32 queue_entry;
+	struct isp1760_qtd *qtd;
+	struct isp1760_qh *qh;
+
+	done_map = isp1760_readl(usb_hcd->regs +
+			HC_INT_PTD_DONEMAP_REG);
+	skip_map = isp1760_readl(usb_hcd->regs +
+			HC_INT_PTD_SKIPMAP_REG);
+
+	or_map = isp1760_readl(usb_hcd->regs + HC_INT_IRQ_MASK_OR_REG);
+	or_map &= ~done_map;
+	isp1760_writel(or_map, usb_hcd->regs + HC_INT_IRQ_MASK_OR_REG);
+
+	int_regs_base = INT_REGS_OFFSET;
+
+	while (done_map) {
+		u32 dw1;
+		u32 dw3;
+
+		queue_entry = __ffs(done_map);
+		done_map &= ~(1 << queue_entry);
+		skip_map |= 1 << queue_entry;
+
+		int_regs = int_regs_base + queue_entry * sizeof(struct ptd);
+		urb = priv->int_ints[queue_entry].urb;
+		qtd = priv->int_ints[queue_entry].qtd;
+		qh = priv->int_ints[queue_entry].qh;
+		payload = priv->int_ints[queue_entry].payload;
+
+		if (!qh) {
+			printk(KERN_ERR "(INT) qh is 0\n");
+			continue;
+		}
+
+		isp1760_writel(int_regs + ISP_BANK(0), usb_hcd->regs +
+				HC_MEMORY_REG);
+		isp1760_writel(payload  + ISP_BANK(1), usb_hcd->regs +
+				HC_MEMORY_REG);
+		/*
+		 * write bank1 address twice to ensure the 90ns delay (time
+		 * between BANK0 write and the priv_read_copy() call is at
+		 * least 3*t_WHWL + 2*t_w11 = 3*25ns + 2*17ns = 92ns)
+		 */
+		isp1760_writel(payload  + ISP_BANK(1), usb_hcd->regs +
+				HC_MEMORY_REG);
+
+		priv_read_copy(priv, (u32 *)&ptd, usb_hcd->regs + int_regs +
+				ISP_BANK(0), sizeof(ptd));
+		dw1 = le32_to_cpu(ptd.dw1);
+		dw3 = le32_to_cpu(ptd.dw3);
+		check_int_err_status(le32_to_cpu(ptd.dw4));
+
+		error = check_error(&ptd);
+		if (error) {
+#if 0
+			printk(KERN_ERR "Error in %s().\n", __func__);
+			printk(KERN_ERR "IN dw0: %08x dw1: %08x dw2: %08x "
+					"dw3: %08x dw4: %08x dw5: %08x dw6: "
+					"%08x dw7: %08x\n",
+					ptd.dw0, ptd.dw1, ptd.dw2, ptd.dw3,
+					ptd.dw4, ptd.dw5, ptd.dw6, ptd.dw7);
+#endif
+			urb->status = -EPIPE;
+			priv->int_ints[queue_entry].qh->toggle = 0;
+			priv->int_ints[queue_entry].qh->ping = 0;
+
+		} else {
+			priv->int_ints[queue_entry].qh->toggle =
+				dw3 & (1 << 25);
+			priv->int_ints[queue_entry].qh->ping = dw3 & (1 << 26);
+		}
+
+		if (urb->dev->speed != USB_SPEED_HIGH)
+			length = PTD_XFERRED_LENGTH_LO(dw3);
+		else
+			length = PTD_XFERRED_LENGTH(dw3);
+
+		if (length) {
+			switch (DW1_GET_PID(dw1)) {
+			case IN_PID:
+				priv_read_copy(priv,
+					priv->int_ints[queue_entry].data_buffer,
+					usb_hcd->regs + payload + ISP_BANK(1),
+					length);
+			case OUT_PID:
+
+				urb->actual_length += length;
+
+			case SETUP_PID:
+				break;
+			}
+		}
+
+		priv->int_ints[queue_entry].data_buffer = NULL;
+		priv->int_ints[queue_entry].urb = NULL;
+		priv->int_ints[queue_entry].qtd = NULL;
+		priv->int_ints[queue_entry].qh = NULL;
+
+		isp1760_writel(skip_map, usb_hcd->regs +
+				HC_INT_PTD_SKIPMAP_REG);
+		free_mem(priv, payload);
+
+		if (urb->status == -EPIPE) {
+			/* HALT received */
+
+			 qtd = clean_up_qtdlist(qtd);
+			 isp1760_urb_done(priv, urb, urb->status);
+
+		} else if (qtd->status & URB_COMPLETE_NOTIFY) {
+
+			if (urb->status == -EINPROGRESS)
+				urb->status = 0;
+
+			qtd = clean_this_qtd(qtd);
+			isp1760_urb_done(priv, urb, urb->status);
+
+		} else {
+			/* next QTD of this URB */
+
+			qtd = clean_this_qtd(qtd);
+			BUG_ON(!qtd);
+		}
+
+		if (qtd)
+			enqueue_an_INT_packet(usb_hcd, qh, qtd);
+
+		skip_map = isp1760_readl(usb_hcd->regs +
+				HC_INT_PTD_SKIPMAP_REG);
+	}
+}
+
+#define max_packet(wMaxPacketSize) ((wMaxPacketSize) & 0x07ff)
+static struct isp1760_qh *qh_make(struct isp1760_hcd *priv, struct urb *urb,
+		gfp_t flags)
+{
+	struct isp1760_qh *qh;
+	int is_input, type;
+
+	qh = isp1760_qh_alloc(priv, flags);
+	if (!qh)
+		return qh;
+
+	/*
+	 * init endpoint/device data for this QH
+	 */
+	is_input = usb_pipein(urb->pipe);
+	type = usb_pipetype(urb->pipe);
+
+	if (type == PIPE_INTERRUPT) {
+
+		if (urb->dev->speed == USB_SPEED_HIGH) {
+
+			qh->period = urb->interval >> 3;
+			if (qh->period == 0 && urb->interval != 1) {
+				/* NOTE interval 2 or 4 uframes could work.
+				 * But interval 1 scheduling is simpler, and
+				 * includes high bandwidth.
+				 */
+				printk(KERN_ERR "intr period %d uframes, NYET!",
+						urb->interval);
+				qh_destroy(qh);
+				return NULL;
+			}
+		} else {
+			qh->period = urb->interval;
+		}
+	}
+
+	/* support for tt scheduling, and access to toggles */
+	qh->dev = urb->dev;
+
+	if (!usb_pipecontrol(urb->pipe))
+		usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe), !is_input,
+				1);
+	return qh;
+}
+
+/*
+ * For control/bulk/interrupt, return QH with these TDs appended.
+ * Allocates and initializes the QH if necessary.
+ * Returns null if it can't allocate a QH it needs to.
+ * If the QH has TDs (urbs) already, that's great.
+ */
+static struct isp1760_qh *qh_append_tds(struct isp1760_hcd *priv,
+		struct urb *urb, struct list_head *qtd_list, int epnum,
+		void **ptr)
+{
+	struct isp1760_qh *qh;
+	struct isp1760_qtd *qtd;
+	struct isp1760_qtd *prev_qtd;
+
+	qh = (struct isp1760_qh *)*ptr;
+	if (!qh) {
+		/* can't sleep here, we have priv->lock... */
+		qh = qh_make(priv, urb, GFP_ATOMIC);
+		if (!qh)
+			return qh;
+		*ptr = qh;
+	}
+
+	qtd = list_entry(qtd_list->next, struct isp1760_qtd,
+			qtd_list);
+	if (!list_empty(&qh->qtd_list))
+		prev_qtd = list_entry(qh->qtd_list.prev,
+				struct isp1760_qtd, qtd_list);
+	else
+		prev_qtd = NULL;
+
+	list_splice(qtd_list, qh->qtd_list.prev);
+	if (prev_qtd) {
+		BUG_ON(prev_qtd->hw_next);
+		prev_qtd->hw_next = qtd;
+	}
+
+	urb->hcpriv = qh;
+	return qh;
+}
+
+static void qtd_list_free(struct isp1760_hcd *priv, struct urb *urb,
+		struct list_head *qtd_list)
+{
+	struct list_head *entry, *temp;
+
+	list_for_each_safe(entry, temp, qtd_list) {
+		struct isp1760_qtd	*qtd;
+
+		qtd = list_entry(entry, struct isp1760_qtd, qtd_list);
+		list_del(&qtd->qtd_list);
+		isp1760_qtd_free(qtd);
+	}
+}
+
+static int isp1760_prepare_enqueue(struct isp1760_hcd *priv, struct urb *urb,
+		struct list_head *qtd_list, gfp_t mem_flags, packet_enqueue *p)
+{
+	struct isp1760_qtd         *qtd;
+	int                     epnum;
+	unsigned long           flags;
+	struct isp1760_qh          *qh = NULL;
+	int                     rc;
+	int qh_busy;
+
+	qtd = list_entry(qtd_list->next, struct isp1760_qtd, qtd_list);
+	epnum = urb->ep->desc.bEndpointAddress;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &priv_to_hcd(priv)->flags)) {
+		rc = -ESHUTDOWN;
+		goto done;
+	}
+	rc = usb_hcd_link_urb_to_ep(priv_to_hcd(priv), urb);
+	if (rc)
+		goto done;
+
+	qh = urb->ep->hcpriv;
+	if (qh)
+		qh_busy = !list_empty(&qh->qtd_list);
+	else
+		qh_busy = 0;
+
+	qh = qh_append_tds(priv, urb, qtd_list, epnum, &urb->ep->hcpriv);
+	if (!qh) {
+		usb_hcd_unlink_urb_from_ep(priv_to_hcd(priv), urb);
+		rc = -ENOMEM;
+		goto done;
+	}
+
+	if (!qh_busy)
+		p(priv_to_hcd(priv), qh, qtd);
+
+done:
+	spin_unlock_irqrestore(&priv->lock, flags);
+	if (!qh)
+		qtd_list_free(priv, urb, qtd_list);
+	return rc;
+}
+
+static struct isp1760_qtd *isp1760_qtd_alloc(struct isp1760_hcd *priv,
+		gfp_t flags)
+{
+	struct isp1760_qtd *qtd;
+
+	qtd = kmem_cache_zalloc(qtd_cachep, flags);
+	if (qtd)
+		INIT_LIST_HEAD(&qtd->qtd_list);
+
+	return qtd;
+}
+
+/*
+ * create a list of filled qtds for this URB; won't link into qh.
+ */
+static struct list_head *qh_urb_transaction(struct isp1760_hcd *priv,
+		struct urb *urb, struct list_head *head, gfp_t flags)
+{
+	struct isp1760_qtd *qtd, *qtd_prev;
+	void *buf;
+	int len, maxpacket;
+	int is_input;
+	u32 token;
+
+	/*
+	 * URBs map to sequences of QTDs:  one logical transaction
+	 */
+	qtd = isp1760_qtd_alloc(priv, flags);
+	if (!qtd)
+		return NULL;
+
+	list_add_tail(&qtd->qtd_list, head);
+	qtd->urb = urb;
+	urb->status = -EINPROGRESS;
+
+	token = 0;
+	/* for split transactions, SplitXState initialized to zero */
+
+	len = urb->transfer_buffer_length;
+	is_input = usb_pipein(urb->pipe);
+	if (usb_pipecontrol(urb->pipe)) {
+		/* SETUP pid */
+		qtd_fill(qtd, urb->setup_packet,
+				sizeof(struct usb_ctrlrequest),
+				token | SETUP_PID);
+
+		/* ... and always at least one more pid */
+		token ^= DATA_TOGGLE;
+		qtd_prev = qtd;
+		qtd = isp1760_qtd_alloc(priv, flags);
+		if (!qtd)
+			goto cleanup;
+		qtd->urb = urb;
+		qtd_prev->hw_next = qtd;
+		list_add_tail(&qtd->qtd_list, head);
+
+		/* for zero length DATA stages, STATUS is always IN */
+		if (len == 0)
+			token |= IN_PID;
+	}
+
+	/*
+	 * data transfer stage:  buffer setup
+	 */
+	buf = urb->transfer_buffer;
+
+	if (is_input)
+		token |= IN_PID;
+	else
+		token |= OUT_PID;
+
+	maxpacket = max_packet(usb_maxpacket(urb->dev, urb->pipe, !is_input));
+
+	/*
+	 * buffer gets wrapped in one or more qtds;
+	 * last one may be "short" (including zero len)
+	 * and may serve as a control status ack
+	 */
+	for (;;) {
+		int this_qtd_len;
+
+		if (!buf && len) {
+			/* XXX This looks like usb storage / SCSI bug */
+			printk(KERN_ERR "buf is null, dma is %08lx len is %d\n",
+					(long unsigned)urb->transfer_dma, len);
+			WARN_ON(1);
+		}
+
+		this_qtd_len = qtd_fill(qtd, buf, len, token);
+		len -= this_qtd_len;
+		buf += this_qtd_len;
+
+		/* qh makes control packets use qtd toggle; maybe switch it */
+		if ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)
+			token ^= DATA_TOGGLE;
+
+		if (len <= 0)
+			break;
+
+		qtd_prev = qtd;
+		qtd = isp1760_qtd_alloc(priv, flags);
+		if (!qtd)
+			goto cleanup;
+		qtd->urb = urb;
+		qtd_prev->hw_next = qtd;
+		list_add_tail(&qtd->qtd_list, head);
+	}
+
+	/*
+	 * control requests may need a terminating data "status" ack;
+	 * bulk ones may need a terminating short packet (zero length).
+	 */
+	if (urb->transfer_buffer_length != 0) {
+		int one_more = 0;
+
+		if (usb_pipecontrol(urb->pipe)) {
+			one_more = 1;
+			/* "in" <--> "out"  */
+			token ^= IN_PID;
+			/* force DATA1 */
+			token |= DATA_TOGGLE;
+		} else if (usb_pipebulk(urb->pipe)
+				&& (urb->transfer_flags & URB_ZERO_PACKET)
+				&& !(urb->transfer_buffer_length % maxpacket)) {
+			one_more = 1;
+		}
+		if (one_more) {
+			qtd_prev = qtd;
+			qtd = isp1760_qtd_alloc(priv, flags);
+			if (!qtd)
+				goto cleanup;
+			qtd->urb = urb;
+			qtd_prev->hw_next = qtd;
+			list_add_tail(&qtd->qtd_list, head);
+
+			/* never any data in such packets */
+			qtd_fill(qtd, NULL, 0, token);
+		}
+	}
+
+	qtd->status = URB_COMPLETE_NOTIFY;
+	return head;
+
+cleanup:
+	qtd_list_free(priv, urb, head);
+	return NULL;
+}
+
+static int isp1760_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
+		gfp_t mem_flags)
+{
+	struct isp1760_hcd *priv = hcd_to_priv(hcd);
+	struct list_head qtd_list;
+	packet_enqueue *pe;
+
+	INIT_LIST_HEAD(&qtd_list);
+
+	switch (usb_pipetype(urb->pipe)) {
+	case PIPE_CONTROL:
+	case PIPE_BULK:
+
+		if (!qh_urb_transaction(priv, urb, &qtd_list, mem_flags))
+			return -ENOMEM;
+		pe =  enqueue_an_ATL_packet;
+		break;
+
+	case PIPE_INTERRUPT:
+		if (!qh_urb_transaction(priv, urb, &qtd_list, mem_flags))
+			return -ENOMEM;
+		pe = enqueue_an_INT_packet;
+		break;
+
+	case PIPE_ISOCHRONOUS:
+		printk(KERN_ERR "PIPE_ISOCHRONOUS ain't supported\n");
+	default:
+		return -EPIPE;
+	}
+
+	return isp1760_prepare_enqueue(priv, urb, &qtd_list, mem_flags, pe);
+}
+
+static int isp1760_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
+		int status)
+{
+	struct isp1760_hcd *priv = hcd_to_priv(hcd);
+	struct inter_packet_info *ints;
+	u32 i;
+	u32 reg_base, or_reg, skip_reg;
+	unsigned long flags;
+	struct ptd ptd;
+
+	switch (usb_pipetype(urb->pipe)) {
+	case PIPE_ISOCHRONOUS:
+		return -EPIPE;
+		break;
+
+	case PIPE_INTERRUPT:
+		ints = priv->int_ints;
+		reg_base = INT_REGS_OFFSET;
+		or_reg = HC_INT_IRQ_MASK_OR_REG;
+		skip_reg = HC_INT_PTD_SKIPMAP_REG;
+		break;
+
+	default:
+		ints = priv->atl_ints;
+		reg_base = ATL_REGS_OFFSET;
+		or_reg = HC_ATL_IRQ_MASK_OR_REG;
+		skip_reg = HC_ATL_PTD_SKIPMAP_REG;
+		break;
+	}
+
+	memset(&ptd, 0, sizeof(ptd));
+	spin_lock_irqsave(&priv->lock, flags);
+
+	for (i = 0; i < 32; i++) {
+		if (ints->urb == urb) {
+			u32 skip_map;
+			u32 or_map;
+			struct isp1760_qtd *qtd;
+
+			skip_map = isp1760_readl(hcd->regs + skip_reg);
+			skip_map |= 1 << i;
+			isp1760_writel(skip_map, hcd->regs + skip_reg);
+
+			or_map = isp1760_readl(hcd->regs + or_reg);
+			or_map &= ~(1 << i);
+			isp1760_writel(or_map, hcd->regs + or_reg);
+
+			priv_write_copy(priv, (u32 *)&ptd, hcd->regs + reg_base
+					+ i * sizeof(ptd), sizeof(ptd));
+			qtd = ints->qtd;
+
+			clean_up_qtdlist(qtd);
+
+			free_mem(priv, ints->payload);
+
+			ints->urb = NULL;
+			ints->qh = NULL;
+			ints->qtd = NULL;
+			ints->data_buffer = NULL;
+			ints->payload = 0;
+
+			isp1760_urb_done(priv, urb, status);
+			break;
+		}
+		ints++;
+	}
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return 0;
+}
+
+static irqreturn_t isp1760_irq(struct usb_hcd *usb_hcd)
+{
+	struct isp1760_hcd *priv = hcd_to_priv(usb_hcd);
+	u32 imask;
+	irqreturn_t irqret = IRQ_NONE;
+
+	spin_lock(&priv->lock);
+
+	if (!(usb_hcd->state & HC_STATE_RUNNING))
+		goto leave;
+
+	imask = isp1760_readl(usb_hcd->regs + HC_INTERRUPT_REG);
+	if (unlikely(!imask))
+		goto leave;
+
+	isp1760_writel(imask, usb_hcd->regs + HC_INTERRUPT_REG);
+	if (imask & HC_ATL_INT)
+		do_atl_int(usb_hcd);
+
+	if (imask & HC_INTL_INT)
+		do_intl_int(usb_hcd);
+
+	irqret = IRQ_HANDLED;
+leave:
+	spin_unlock(&priv->lock);
+	return irqret;
+}
+
+static int isp1760_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	struct isp1760_hcd *priv = hcd_to_priv(hcd);
+	u32 temp, status = 0;
+	u32 mask;
+	int retval = 1;
+	unsigned long flags;
+
+	/* if !USB_SUSPEND, root hub timers won't get shut down ... */
+	if (!HC_IS_RUNNING(hcd->state))
+		return 0;
+
+	/* init status to no-changes */
+	buf[0] = 0;
+	mask = PORT_CSC;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	temp = isp1760_readl(hcd->regs + HC_PORTSC1);
+
+	if (temp & PORT_OWNER) {
+		if (temp & PORT_CSC) {
+			temp &= ~PORT_CSC;
+			isp1760_writel(temp, hcd->regs + HC_PORTSC1);
+			goto done;
+		}
+	}
+
+	/*
+	 * Return status information even for ports with OWNER set.
+	 * Otherwise khubd wouldn't see the disconnect event when a
+	 * high-speed device is switched over to the companion
+	 * controller by the user.
+	 */
+
+	if ((temp & mask) != 0
+			|| ((temp & PORT_RESUME) != 0
+				&& time_after_eq(jiffies,
+					priv->reset_done))) {
+		buf [0] |= 1 << (0 + 1);
+		status = STS_PCD;
+	}
+	/* FIXME autosuspend idle root hubs */
+done:
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return status ? retval : 0;
+}
+
+static void isp1760_hub_descriptor(struct isp1760_hcd *priv,
+		struct usb_hub_descriptor *desc)
+{
+	int ports = HCS_N_PORTS(priv->hcs_params);
+	u16 temp;
+
+	desc->bDescriptorType = 0x29;
+	/* priv 1.0, 2.3.9 says 20ms max */
+	desc->bPwrOn2PwrGood = 10;
+	desc->bHubContrCurrent = 0;
+
+	desc->bNbrPorts = ports;
+	temp = 1 + (ports / 8);
+	desc->bDescLength = 7 + 2 * temp;
+
+	/* two bitmaps:  ports removable, and usb 1.0 legacy PortPwrCtrlMask */
+	memset(&desc->bitmap[0], 0, temp);
+	memset(&desc->bitmap[temp], 0xff, temp);
+
+	/* per-port overcurrent reporting */
+	temp = 0x0008;
+	if (HCS_PPC(priv->hcs_params))
+		/* per-port power control */
+		temp |= 0x0001;
+	else
+		/* no power switching */
+		temp |= 0x0002;
+	desc->wHubCharacteristics = cpu_to_le16(temp);
+}
+
+#define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
+
+static int check_reset_complete(struct isp1760_hcd *priv, int index,
+		u32 __iomem *status_reg, int port_status)
+{
+	if (!(port_status & PORT_CONNECT))
+		return port_status;
+
+	/* if reset finished and it's still not enabled -- handoff */
+	if (!(port_status & PORT_PE)) {
+
+		printk(KERN_ERR "port %d full speed --> companion\n",
+			index + 1);
+
+		port_status |= PORT_OWNER;
+		port_status &= ~PORT_RWC_BITS;
+		isp1760_writel(port_status, status_reg);
+
+	} else
+		printk(KERN_ERR "port %d high speed\n", index + 1);
+
+	return port_status;
+}
+
+static int isp1760_hub_control(struct usb_hcd *hcd, u16 typeReq,
+		u16 wValue, u16 wIndex, char *buf, u16 wLength)
+{
+	struct isp1760_hcd *priv = hcd_to_priv(hcd);
+	int ports = HCS_N_PORTS(priv->hcs_params);
+	u32 __iomem *status_reg = hcd->regs + HC_PORTSC1;
+	u32 temp, status;
+	unsigned long flags;
+	int retval = 0;
+	unsigned selector;
+
+	/*
+	 * FIXME:  support SetPortFeatures USB_PORT_FEAT_INDICATOR.
+	 * HCS_INDICATOR may say we can change LEDs to off/amber/green.
+	 * (track current state ourselves) ... blink for diagnostics,
+	 * power, "this is the one", etc.  EHCI spec supports this.
+	 */
+
+	spin_lock_irqsave(&priv->lock, flags);
+	switch (typeReq) {
+	case ClearHubFeature:
+		switch (wValue) {
+		case C_HUB_LOCAL_POWER:
+		case C_HUB_OVER_CURRENT:
+			/* no hub-wide feature/status flags */
+			break;
+		default:
+			goto error;
+		}
+		break;
+	case ClearPortFeature:
+		if (!wIndex || wIndex > ports)
+			goto error;
+		wIndex--;
+		temp = isp1760_readl(status_reg);
+
+		/*
+		 * Even if OWNER is set, so the port is owned by the
+		 * companion controller, khubd needs to be able to clear
+		 * the port-change status bits (especially
+		 * USB_PORT_FEAT_C_CONNECTION).
+		 */
+
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			isp1760_writel(temp & ~PORT_PE, status_reg);
+			break;
+		case USB_PORT_FEAT_C_ENABLE:
+			/* XXX error? */
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			if (temp & PORT_RESET)
+				goto error;
+
+			if (temp & PORT_SUSPEND) {
+				if ((temp & PORT_PE) == 0)
+					goto error;
+				/* resume signaling for 20 msec */
+				temp &= ~(PORT_RWC_BITS);
+				isp1760_writel(temp | PORT_RESUME,
+						status_reg);
+				priv->reset_done = jiffies +
+					msecs_to_jiffies(20);
+			}
+			break;
+		case USB_PORT_FEAT_C_SUSPEND:
+			/* we auto-clear this feature */
+			break;
+		case USB_PORT_FEAT_POWER:
+			if (HCS_PPC(priv->hcs_params))
+				isp1760_writel(temp & ~PORT_POWER, status_reg);
+			break;
+		case USB_PORT_FEAT_C_CONNECTION:
+			isp1760_writel(temp | PORT_CSC,
+					status_reg);
+			break;
+		case USB_PORT_FEAT_C_OVER_CURRENT:
+			/* XXX error ?*/
+			break;
+		case USB_PORT_FEAT_C_RESET:
+			/* GetPortStatus clears reset */
+			break;
+		default:
+			goto error;
+		}
+		isp1760_readl(hcd->regs + HC_USBCMD);
+		break;
+	case GetHubDescriptor:
+		isp1760_hub_descriptor(priv, (struct usb_hub_descriptor *)
+			buf);
+		break;
+	case GetHubStatus:
+		/* no hub-wide feature/status flags */
+		memset(buf, 0, 4);
+		break;
+	case GetPortStatus:
+		if (!wIndex || wIndex > ports)
+			goto error;
+		wIndex--;
+		status = 0;
+		temp = isp1760_readl(status_reg);
+
+		/* wPortChange bits */
+		if (temp & PORT_CSC)
+			status |= 1 << USB_PORT_FEAT_C_CONNECTION;
+
+
+		/* whoever resumes must GetPortStatus to complete it!! */
+		if (temp & PORT_RESUME) {
+			printk(KERN_ERR "Port resume should be skipped.\n");
+
+			/* Remote Wakeup received? */
+			if (!priv->reset_done) {
+				/* resume signaling for 20 msec */
+				priv->reset_done = jiffies
+						+ msecs_to_jiffies(20);
+				/* check the port again */
+				mod_timer(&priv_to_hcd(priv)->rh_timer,
+						priv->reset_done);
+			}
+
+			/* resume completed? */
+			else if (time_after_eq(jiffies,
+					priv->reset_done)) {
+				status |= 1 << USB_PORT_FEAT_C_SUSPEND;
+				priv->reset_done = 0;
+
+				/* stop resume signaling */
+				temp = isp1760_readl(status_reg);
+				isp1760_writel(
+					temp & ~(PORT_RWC_BITS | PORT_RESUME),
+					status_reg);
+				retval = handshake(priv, status_reg,
+					   PORT_RESUME, 0, 2000 /* 2msec */);
+				if (retval != 0) {
+					isp1760_err(priv,
+						"port %d resume error %d\n",
+						wIndex + 1, retval);
+					goto error;
+				}
+				temp &= ~(PORT_SUSPEND|PORT_RESUME|(3<<10));
+			}
+		}
+
+		/* whoever resets must GetPortStatus to complete it!! */
+		if ((temp & PORT_RESET)
+				&& time_after_eq(jiffies,
+					priv->reset_done)) {
+			status |= 1 << USB_PORT_FEAT_C_RESET;
+			priv->reset_done = 0;
+
+			/* force reset to complete */
+			isp1760_writel(temp & ~PORT_RESET,
+					status_reg);
+			/* REVISIT:  some hardware needs 550+ usec to clear
+			 * this bit; seems too long to spin routinely...
+			 */
+			retval = handshake(priv, status_reg,
+					PORT_RESET, 0, 750);
+			if (retval != 0) {
+				isp1760_err(priv, "port %d reset error %d\n",
+						wIndex + 1, retval);
+				goto error;
+			}
+
+			/* see what we found out */
+			temp = check_reset_complete(priv, wIndex, status_reg,
+					isp1760_readl(status_reg));
+		}
+		/*
+		 * Even if OWNER is set, there's no harm letting khubd
+		 * see the wPortStatus values (they should all be 0 except
+		 * for PORT_POWER anyway).
+		 */
+
+		if (temp & PORT_OWNER)
+			printk(KERN_ERR "Warning: PORT_OWNER is set\n");
+
+		if (temp & PORT_CONNECT) {
+			status |= 1 << USB_PORT_FEAT_CONNECTION;
+			/* status may be from integrated TT */
+			status |= ehci_port_speed(priv, temp);
+		}
+		if (temp & PORT_PE)
+			status |= 1 << USB_PORT_FEAT_ENABLE;
+		if (temp & (PORT_SUSPEND|PORT_RESUME))
+			status |= 1 << USB_PORT_FEAT_SUSPEND;
+		if (temp & PORT_RESET)
+			status |= 1 << USB_PORT_FEAT_RESET;
+		if (temp & PORT_POWER)
+			status |= 1 << USB_PORT_FEAT_POWER;
+
+		put_unaligned(cpu_to_le32(status), (__le32 *) buf);
+		break;
+	case SetHubFeature:
+		switch (wValue) {
+		case C_HUB_LOCAL_POWER:
+		case C_HUB_OVER_CURRENT:
+			/* no hub-wide feature/status flags */
+			break;
+		default:
+			goto error;
+		}
+		break;
+	case SetPortFeature:
+		selector = wIndex >> 8;
+		wIndex &= 0xff;
+		if (!wIndex || wIndex > ports)
+			goto error;
+		wIndex--;
+		temp = isp1760_readl(status_reg);
+		if (temp & PORT_OWNER)
+			break;
+
+/*		temp &= ~PORT_RWC_BITS; */
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			isp1760_writel(temp | PORT_PE, status_reg);
+			break;
+
+		case USB_PORT_FEAT_SUSPEND:
+			if ((temp & PORT_PE) == 0
+					|| (temp & PORT_RESET) != 0)
+				goto error;
+
+			isp1760_writel(temp | PORT_SUSPEND, status_reg);
+			break;
+		case USB_PORT_FEAT_POWER:
+			if (HCS_PPC(priv->hcs_params))
+				isp1760_writel(temp | PORT_POWER,
+						status_reg);
+			break;
+		case USB_PORT_FEAT_RESET:
+			if (temp & PORT_RESUME)
+				goto error;
+			/* line status bits may report this as low speed,
+			 * which can be fine if this root hub has a
+			 * transaction translator built in.
+			 */
+			if ((temp & (PORT_PE|PORT_CONNECT)) == PORT_CONNECT
+					&& PORT_USB11(temp)) {
+				temp |= PORT_OWNER;
+			} else {
+				temp |= PORT_RESET;
+				temp &= ~PORT_PE;
+
+				/*
+				 * caller must wait, then call GetPortStatus
+				 * usb 2.0 spec says 50 ms resets on root
+				 */
+				priv->reset_done = jiffies +
+					msecs_to_jiffies(50);
+			}
+			isp1760_writel(temp, status_reg);
+			break;
+		default:
+			goto error;
+		}
+		isp1760_readl(hcd->regs + HC_USBCMD);
+		break;
+
+	default:
+error:
+		/* "stall" on error */
+		retval = -EPIPE;
+	}
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return retval;
+}
+
+static void isp1760_endpoint_disable(struct usb_hcd *usb_hcd,
+		struct usb_host_endpoint *ep)
+{
+	struct isp1760_hcd *priv = hcd_to_priv(usb_hcd);
+	struct isp1760_qh *qh;
+	struct isp1760_qtd *qtd;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	qh = ep->hcpriv;
+	if (!qh)
+		goto out;
+
+	ep->hcpriv = NULL;
+	do {
+		/* more than entry might get removed */
+		if (list_empty(&qh->qtd_list))
+			break;
+
+		qtd = list_first_entry(&qh->qtd_list, struct isp1760_qtd,
+				qtd_list);
+
+		if (qtd->status & URB_ENQUEUED) {
+
+			spin_unlock_irqrestore(&priv->lock, flags);
+			isp1760_urb_dequeue(usb_hcd, qtd->urb, -ECONNRESET);
+			spin_lock_irqsave(&priv->lock, flags);
+		} else {
+			struct urb *urb;
+
+			urb = qtd->urb;
+			clean_up_qtdlist(qtd);
+			isp1760_urb_done(priv, urb, -ECONNRESET);
+		}
+	} while (1);
+
+	qh_destroy(qh);
+	/* remove requests and leak them.
+	 * ATL are pretty fast done, INT could take a while...
+	 * The latter shoule be removed
+	 */
+out:
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static int isp1760_get_frame(struct usb_hcd *hcd)
+{
+	struct isp1760_hcd *priv = hcd_to_priv(hcd);
+	u32 fr;
+
+	fr = isp1760_readl(hcd->regs + HC_FRINDEX);
+	return (fr >> 3) % priv->periodic_size;
+}
+
+static void isp1760_stop(struct usb_hcd *hcd)
+{
+	struct isp1760_hcd *priv = hcd_to_priv(hcd);
+	u32 temp;
+
+	isp1760_hub_control(hcd, ClearPortFeature, USB_PORT_FEAT_POWER,	1,
+			NULL, 0);
+	mdelay(20);
+
+	spin_lock_irq(&priv->lock);
+	ehci_reset(priv);
+	/* Disable IRQ */
+	temp = isp1760_readl(hcd->regs + HC_HW_MODE_CTRL);
+	isp1760_writel(temp &= ~HW_GLOBAL_INTR_EN, hcd->regs + HC_HW_MODE_CTRL);
+	spin_unlock_irq(&priv->lock);
+
+	isp1760_writel(0, hcd->regs + HC_CONFIGFLAG);
+}
+
+static void isp1760_shutdown(struct usb_hcd *hcd)
+{
+	u32 command, temp;
+
+	isp1760_stop(hcd);
+	temp = isp1760_readl(hcd->regs + HC_HW_MODE_CTRL);
+	isp1760_writel(temp &= ~HW_GLOBAL_INTR_EN, hcd->regs + HC_HW_MODE_CTRL);
+
+	command = isp1760_readl(hcd->regs + HC_USBCMD);
+	command &= ~CMD_RUN;
+	isp1760_writel(command, hcd->regs + HC_USBCMD);
+}
+
+static const struct hc_driver isp1760_hc_driver = {
+	.description		= "isp1760-hcd",
+	.product_desc		= "NXP ISP1760 USB Host Controller",
+	.hcd_priv_size		= sizeof(struct isp1760_hcd),
+	.irq			= isp1760_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+	.reset			= isp1760_hc_setup,
+	.start			= isp1760_run,
+	.stop			= isp1760_stop,
+	.shutdown		= isp1760_shutdown,
+	.urb_enqueue		= isp1760_urb_enqueue,
+	.urb_dequeue		= isp1760_urb_dequeue,
+	.endpoint_disable	= isp1760_endpoint_disable,
+	.get_frame_number	= isp1760_get_frame,
+	.hub_status_data	= isp1760_hub_status_data,
+	.hub_control		= isp1760_hub_control,
+};
+
+int __init init_kmem_once(void)
+{
+	qtd_cachep = kmem_cache_create("isp1760_qtd",
+			sizeof(struct isp1760_qtd), 0, SLAB_TEMPORARY |
+			SLAB_MEM_SPREAD, NULL);
+
+	if (!qtd_cachep)
+		return -ENOMEM;
+
+	qh_cachep = kmem_cache_create("isp1760_qh", sizeof(struct isp1760_qh),
+			0, SLAB_TEMPORARY | SLAB_MEM_SPREAD, NULL);
+
+	if (!qh_cachep) {
+		kmem_cache_destroy(qtd_cachep);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+void deinit_kmem_cache(void)
+{
+	kmem_cache_destroy(qtd_cachep);
+	kmem_cache_destroy(qh_cachep);
+}
+
+struct usb_hcd *isp1760_register(phys_addr_t res_start, resource_size_t res_len,
+				 int irq, unsigned long irqflags,
+				 struct device *dev, const char *busname,
+				 unsigned int devflags)
+{
+	struct usb_hcd *hcd;
+	struct isp1760_hcd *priv;
+	int ret;
+
+	if (usb_disabled())
+		return ERR_PTR(-ENODEV);
+
+	/* prevent usb-core allocating DMA pages */
+	dev->dma_mask = NULL;
+
+	hcd = usb_create_hcd(&isp1760_hc_driver, dev, dev_name(dev));
+	if (!hcd)
+		return ERR_PTR(-ENOMEM);
+
+	priv = hcd_to_priv(hcd);
+	priv->devflags = devflags;
+	init_memory(priv);
+	hcd->regs = ioremap(res_start, res_len);
+	if (!hcd->regs) {
+		ret = -EIO;
+		goto err_put;
+	}
+
+	hcd->irq = irq;
+	hcd->rsrc_start = res_start;
+	hcd->rsrc_len = res_len;
+
+	ret = usb_add_hcd(hcd, irq, irqflags);
+	if (ret)
+		goto err_unmap;
+
+	return hcd;
+
+err_unmap:
+	 iounmap(hcd->regs);
+
+err_put:
+	 usb_put_hcd(hcd);
+
+	 return ERR_PTR(ret);
+}
+
+MODULE_DESCRIPTION("Driver for the ISP1760 USB-controller from NXP");
+MODULE_AUTHOR("Sebastian Siewior <bigeasy@linuxtronix.de>");
+MODULE_LICENSE("GPL v2");
diff -urN host/isp1760-hcd.h host.new/isp1760-hcd.h
--- host/isp1760-hcd.h	1970-01-01 01:00:00.000000000 +0100
+++ host.new/isp1760-hcd.h	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,227 @@
+#ifndef _ISP1760_HCD_H_
+#define _ISP1760_HCD_H_
+
+/* exports for if */
+struct usb_hcd *isp1760_register(phys_addr_t res_start, resource_size_t res_len,
+				 int irq, unsigned long irqflags,
+				 struct device *dev, const char *busname,
+				 unsigned int devflags);
+int init_kmem_once(void);
+void deinit_kmem_cache(void);
+
+/* EHCI capability registers */
+#define HC_CAPLENGTH		0x00
+#define HC_HCSPARAMS		0x04
+#define HC_HCCPARAMS		0x08
+
+/* EHCI operational registers */
+#define HC_USBCMD		0x20
+#define HC_USBSTS		0x24
+#define HC_FRINDEX		0x2c
+#define HC_CONFIGFLAG		0x60
+#define HC_PORTSC1		0x64
+#define HC_ISO_PTD_DONEMAP_REG	0x130
+#define HC_ISO_PTD_SKIPMAP_REG	0x134
+#define HC_ISO_PTD_LASTPTD_REG	0x138
+#define HC_INT_PTD_DONEMAP_REG	0x140
+#define HC_INT_PTD_SKIPMAP_REG	0x144
+#define HC_INT_PTD_LASTPTD_REG	0x148
+#define HC_ATL_PTD_DONEMAP_REG	0x150
+#define HC_ATL_PTD_SKIPMAP_REG	0x154
+#define HC_ATL_PTD_LASTPTD_REG	0x158
+
+/* Configuration Register */
+#define HC_HW_MODE_CTRL		0x300
+#define ALL_ATX_RESET		(1 << 31)
+#define HW_ANA_DIGI_OC		(1 << 15)
+#define HW_DATA_BUS_32BIT	(1 << 8)
+#define HW_DACK_POL_HIGH	(1 << 6)
+#define HW_DREQ_POL_HIGH	(1 << 5)
+#define HW_INTR_HIGH_ACT	(1 << 2)
+#define HW_INTR_EDGE_TRIG	(1 << 1)
+#define HW_GLOBAL_INTR_EN	(1 << 0)
+
+#define HC_CHIP_ID_REG		0x304
+#define HC_SCRATCH_REG		0x308
+
+#define HC_RESET_REG		0x30c
+#define SW_RESET_RESET_HC	(1 << 1)
+#define SW_RESET_RESET_ALL	(1 << 0)
+
+#define HC_BUFFER_STATUS_REG	0x334
+#define ATL_BUFFER		0x1
+#define INT_BUFFER		0x2
+#define ISO_BUFFER		0x4
+#define BUFFER_MAP		0x7
+
+#define HC_MEMORY_REG		0x33c
+#define ISP_BANK(x)		((x) << 16)
+
+#define HC_PORT1_CTRL		0x374
+#define PORT1_POWER		(3 << 3)
+#define PORT1_INIT1		(1 << 7)
+#define PORT1_INIT2		(1 << 23)
+#define HW_OTG_CTRL_SET		0x374
+#define HW_OTG_CTRL_CLR		0x376
+
+/* Interrupt Register */
+#define HC_INTERRUPT_REG	0x310
+
+#define HC_INTERRUPT_ENABLE	0x314
+#define INTERRUPT_ENABLE_MASK	(HC_INTL_INT | HC_ATL_INT | HC_EOT_INT)
+
+#define HC_ISO_INT		(1 << 9)
+#define HC_ATL_INT		(1 << 8)
+#define HC_INTL_INT		(1 << 7)
+#define HC_EOT_INT		(1 << 3)
+#define HC_SOT_INT		(1 << 1)
+
+#define HC_ISO_IRQ_MASK_OR_REG	0x318
+#define HC_INT_IRQ_MASK_OR_REG	0x31C
+#define HC_ATL_IRQ_MASK_OR_REG	0x320
+#define HC_ISO_IRQ_MASK_AND_REG	0x324
+#define HC_INT_IRQ_MASK_AND_REG	0x328
+#define HC_ATL_IRQ_MASK_AND_REG	0x32C
+
+/* Register sets */
+#define HC_BEGIN_OF_ATL		0x0c00
+#define HC_BEGIN_OF_INT		0x0800
+#define HC_BEGIN_OF_ISO		0x0400
+#define HC_BEGIN_OF_PAYLOAD	0x1000
+
+/* urb state*/
+#define DELETE_URB		(0x0008)
+#define NO_TRANSFER_ACTIVE	(0xffffffff)
+
+#define ATL_REGS_OFFSET		(0xc00)
+#define INT_REGS_OFFSET		(0x800)
+
+/* Philips Transfer Descriptor (PTD) */
+struct ptd {
+	__le32 dw0;
+	__le32 dw1;
+	__le32 dw2;
+	__le32 dw3;
+	__le32 dw4;
+	__le32 dw5;
+	__le32 dw6;
+	__le32 dw7;
+};
+
+struct inter_packet_info {
+	void *data_buffer;
+	u32 payload;
+#define PTD_FIRE_NEXT		(1 << 0)
+#define PTD_URB_FINISHED	(1 << 1)
+	struct urb *urb;
+	struct isp1760_qh *qh;
+	struct isp1760_qtd *qtd;
+};
+
+
+typedef void (packet_enqueue)(struct usb_hcd *hcd, struct isp1760_qh *qh,
+		struct isp1760_qtd *qtd);
+
+#define isp1760_dbg(priv, fmt, args...) \
+	dev_dbg(priv_to_hcd(priv)->self.controller, fmt, ##args)
+
+#define isp1760_info(priv, fmt, args...) \
+	dev_info(priv_to_hcd(priv)->self.controller, fmt, ##args)
+
+#define isp1760_err(priv, fmt, args...) \
+	dev_err(priv_to_hcd(priv)->self.controller, fmt, ##args)
+
+/*
+ * Device flags that can vary from board to board.  All of these
+ * indicate the most "atypical" case, so that a devflags of 0 is
+ * a sane default configuration.
+ */
+#define ISP1760_FLAG_BUS_WIDTH_16	0x00000002 /* 16-bit data bus width */
+#define ISP1760_FLAG_OTG_EN		0x00000004 /* Port 1 supports OTG */
+#define ISP1760_FLAG_ANALOG_OC		0x00000008 /* Analog overcurrent */
+#define ISP1760_FLAG_DACK_POL_HIGH	0x00000010 /* DACK active high */
+#define ISP1760_FLAG_DREQ_POL_HIGH	0x00000020 /* DREQ active high */
+#define ISP1760_FLAG_ISP1761		0x00000040 /* Chip is ISP1761 */
+
+/* chip memory management */
+struct memory_chunk {
+	unsigned int start;
+	unsigned int size;
+	unsigned int free;
+};
+
+/*
+ * 60kb divided in:
+ * - 32 blocks @ 256  bytes
+ * - 20 blocks @ 1024 bytes
+ * -  4 blocks @ 8192 bytes
+ */
+
+#define BLOCK_1_NUM 32
+#define BLOCK_2_NUM 20
+#define BLOCK_3_NUM 4
+
+#define BLOCK_1_SIZE 256
+#define BLOCK_2_SIZE 1024
+#define BLOCK_3_SIZE 8192
+#define BLOCKS (BLOCK_1_NUM + BLOCK_2_NUM + BLOCK_3_NUM)
+#define PAYLOAD_SIZE 0xf000
+
+/* I saw if some reloads if the pointer was negative */
+#define ISP1760_NULL_POINTER	(0x400)
+
+/* ATL */
+/* DW0 */
+#define PTD_VALID			1
+#define PTD_LENGTH(x)			(((u32) x) << 3)
+#define PTD_MAXPACKET(x)		(((u32) x) << 18)
+#define PTD_MULTI(x)			(((u32) x) << 29)
+#define PTD_ENDPOINT(x)			(((u32)	x) << 31)
+/* DW1 */
+#define PTD_DEVICE_ADDR(x)		(((u32) x) << 3)
+#define PTD_PID_TOKEN(x)		(((u32) x) << 10)
+#define PTD_TRANS_BULK			((u32) 2 << 12)
+#define PTD_TRANS_INT			((u32) 3 << 12)
+#define PTD_TRANS_SPLIT			((u32) 1 << 14)
+#define PTD_SE_USB_LOSPEED		((u32) 2 << 16)
+#define PTD_PORT_NUM(x)			(((u32) x) << 18)
+#define PTD_HUB_NUM(x)			(((u32) x) << 25)
+#define PTD_PING(x)			(((u32) x) << 26)
+/* DW2 */
+#define PTD_RL_CNT(x)			(((u32) x) << 25)
+#define PTD_DATA_START_ADDR(x)		(((u32) x) << 8)
+#define BASE_ADDR			0x1000
+/* DW3 */
+#define PTD_CERR(x)			(((u32) x) << 23)
+#define PTD_NAC_CNT(x)			(((u32) x) << 19)
+#define PTD_ACTIVE			((u32) 1 << 31)
+#define PTD_DATA_TOGGLE(x)		(((u32) x) << 25)
+
+#define DW3_HALT_BIT			(1 << 30)
+#define DW3_ERROR_BIT			(1 << 28)
+#define DW3_QTD_ACTIVE			(1 << 31)
+
+#define INT_UNDERRUN			(1 << 2)
+#define INT_BABBLE			(1 << 1)
+#define INT_EXACT			(1 << 0)
+
+#define DW1_GET_PID(x)			(((x) >> 10) & 0x3)
+#define PTD_XFERRED_LENGTH(x)		((x) & 0x7fff)
+#define PTD_XFERRED_LENGTH_LO(x)	((x) & 0x7ff)
+
+#define SETUP_PID	(2)
+#define IN_PID		(1)
+#define OUT_PID		(0)
+#define GET_QTD_TOKEN_TYPE(x)	((x) & 0x3)
+
+#define DATA_TOGGLE		(1 << 31)
+#define GET_DATA_TOGGLE(x)	((x) >> 31)
+
+/* Errata 1 */
+#define RL_COUNTER	(0)
+#define NAK_COUNTER	(0)
+#define ERR_COUNTER	(2)
+
+#define HC_ATL_PL_SIZE	(8192)
+
+#endif
diff -urN host/isp1760-if.c host.new/isp1760-if.c
--- host/isp1760-if.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/isp1760-if.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,407 @@
+/*
+ * Glue code for the ISP1760 driver and bus
+ * Currently there is support for
+ * - OpenFirmware
+ * - PCI
+ *
+ * (c) 2007 Sebastian Siewior <bigeasy@linutronix.de>
+ *
+ */
+
+#include <linux/usb.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+
+#include "../core/hcd.h"
+#include "isp1760-hcd.h"
+
+#ifdef CONFIG_PPC_OF
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#endif
+
+#ifdef CONFIG_PCI
+#include <linux/pci.h>
+#endif
+
+#ifdef CONFIG_PPC_OF
+static int of_isp1760_probe(struct of_device *dev,
+		const struct of_device_id *match)
+{
+	struct usb_hcd *hcd;
+	struct device_node *dp = dev->node;
+	struct resource *res;
+	struct resource memory;
+	struct of_irq oirq;
+	int virq;
+	u64 res_len;
+	int ret;
+	const unsigned int *prop;
+	unsigned int devflags = 0;
+
+	ret = of_address_to_resource(dp, 0, &memory);
+	if (ret)
+		return -ENXIO;
+
+	res = request_mem_region(memory.start, memory.end - memory.start + 1,
+			dev_name(&dev->dev));
+	if (!res)
+		return -EBUSY;
+
+	res_len = memory.end - memory.start + 1;
+
+	if (of_irq_map_one(dp, 0, &oirq)) {
+		ret = -ENODEV;
+		goto release_reg;
+	}
+
+	virq = irq_create_of_mapping(oirq.controller, oirq.specifier,
+			oirq.size);
+
+	if (of_device_is_compatible(dp, "nxp,usb-isp1761"))
+		devflags |= ISP1760_FLAG_ISP1761;
+
+	/* Some systems wire up only 16 of the 32 data lines */
+	prop = of_get_property(dp, "bus-width", NULL);
+	if (prop && *prop == 16)
+		devflags |= ISP1760_FLAG_BUS_WIDTH_16;
+
+	if (of_get_property(dp, "port1-otg", NULL) != NULL)
+		devflags |= ISP1760_FLAG_OTG_EN;
+
+	if (of_get_property(dp, "analog-oc", NULL) != NULL)
+		devflags |= ISP1760_FLAG_ANALOG_OC;
+
+	if (of_get_property(dp, "dack-polarity", NULL) != NULL)
+		devflags |= ISP1760_FLAG_DACK_POL_HIGH;
+
+	if (of_get_property(dp, "dreq-polarity", NULL) != NULL)
+		devflags |= ISP1760_FLAG_DREQ_POL_HIGH;
+
+	hcd = isp1760_register(memory.start, res_len, virq,
+		IRQF_SHARED | IRQF_DISABLED, &dev->dev, dev_name(&dev->dev),
+		devflags);
+	if (IS_ERR(hcd)) {
+		ret = PTR_ERR(hcd);
+		goto release_reg;
+	}
+
+	dev_set_drvdata(&dev->dev, hcd);
+	return ret;
+
+release_reg:
+	release_mem_region(memory.start, memory.end - memory.start + 1);
+	return ret;
+}
+
+static int of_isp1760_remove(struct of_device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(&dev->dev);
+
+	dev_set_drvdata(&dev->dev, NULL);
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+	return 0;
+}
+
+static struct of_device_id of_isp1760_match[] = {
+	{
+		.compatible = "nxp,usb-isp1760",
+	},
+	{
+		.compatible = "nxp,usb-isp1761",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, of_isp1760_match);
+
+static struct of_platform_driver isp1760_of_driver = {
+	.name           = "nxp-isp1760",
+	.match_table    = of_isp1760_match,
+	.probe          = of_isp1760_probe,
+	.remove         = of_isp1760_remove,
+};
+#endif
+
+#ifdef CONFIG_PCI
+static int __devinit isp1761_pci_probe(struct pci_dev *dev,
+		const struct pci_device_id *id)
+{
+	u8 latency, limit;
+	__u32 reg_data;
+	int retry_count;
+	struct usb_hcd *hcd;
+	unsigned int devflags = 0;
+	int ret_status = 0;
+
+	resource_size_t pci_mem_phy0;
+	resource_size_t memlength;
+
+	u8 __iomem *chip_addr;
+	u8 __iomem *iobase;
+	resource_size_t nxp_pci_io_base;
+	resource_size_t iolength;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	if (pci_enable_device(dev) < 0)
+		return -ENODEV;
+
+	if (!dev->irq)
+		return -ENODEV;
+
+	/* Grab the PLX PCI mem maped port start address we need  */
+	nxp_pci_io_base = pci_resource_start(dev, 0);
+	iolength = pci_resource_len(dev, 0);
+
+	if (!request_mem_region(nxp_pci_io_base, iolength, "ISP1761 IO MEM")) {
+		printk(KERN_ERR "request region #1\n");
+		return -EBUSY;
+	}
+
+	iobase = ioremap_nocache(nxp_pci_io_base, iolength);
+	if (!iobase) {
+		printk(KERN_ERR "ioremap #1\n");
+		ret_status = -ENOMEM;
+		goto cleanup1;
+	}
+	/* Grab the PLX PCI shared memory of the ISP 1761 we need  */
+	pci_mem_phy0 = pci_resource_start(dev, 3);
+	memlength = pci_resource_len(dev, 3);
+	if (memlength < 0xffff) {
+		printk(KERN_ERR "memory length for this resource is wrong\n");
+		ret_status = -ENOMEM;
+		goto cleanup2;
+	}
+
+	if (!request_mem_region(pci_mem_phy0, memlength, "ISP-PCI")) {
+		printk(KERN_ERR "host controller already in use\n");
+		ret_status = -EBUSY;
+		goto cleanup2;
+	}
+
+	/* map available memory */
+	chip_addr = ioremap_nocache(pci_mem_phy0,memlength);
+	if (!chip_addr) {
+		printk(KERN_ERR "Error ioremap failed\n");
+		ret_status = -ENOMEM;
+		goto cleanup3;
+	}
+
+	/* bad pci latencies can contribute to overruns */
+	pci_read_config_byte(dev, PCI_LATENCY_TIMER, &latency);
+	if (latency) {
+		pci_read_config_byte(dev, PCI_MAX_LAT, &limit);
+		if (limit && limit < latency)
+			pci_write_config_byte(dev, PCI_LATENCY_TIMER, limit);
+	}
+
+	/* Try to check whether we can access Scratch Register of
+	 * Host Controller or not. The initial PCI access is retried until
+	 * local init for the PCI bridge is completed
+	 */
+	retry_count = 20;
+	reg_data = 0;
+	while ((reg_data != 0xFACE) && retry_count) {
+		/*by default host is in 16bit mode, so
+		 * io operations at this stage must be 16 bit
+		 * */
+		writel(0xface, chip_addr + HC_SCRATCH_REG);
+		udelay(100);
+		reg_data = readl(chip_addr + HC_SCRATCH_REG) & 0x0000ffff;
+		retry_count--;
+	}
+
+	iounmap(chip_addr);
+
+	/* Host Controller presence is detected by writing to scratch register
+	 * and reading back and checking the contents are same or not
+	 */
+	if (reg_data != 0xFACE) {
+		dev_err(&dev->dev, "scratch register mismatch %x\n", reg_data);
+		ret_status = -ENOMEM;
+		goto cleanup3;
+	}
+
+	pci_set_master(dev);
+
+	/* configure PLX PCI chip to pass interrupts */
+#define PLX_INT_CSR_REG 0x68
+	reg_data = readl(iobase + PLX_INT_CSR_REG);
+	reg_data |= 0x900;
+	writel(reg_data, iobase + PLX_INT_CSR_REG);
+
+	dev->dev.dma_mask = NULL;
+	hcd = isp1760_register(pci_mem_phy0, memlength, dev->irq,
+		IRQF_SHARED | IRQF_DISABLED, &dev->dev, dev_name(&dev->dev),
+		devflags);
+	if (IS_ERR(hcd)) {
+		ret_status = -ENODEV;
+		goto cleanup3;
+	}
+
+	/* done with PLX IO access */
+	iounmap(iobase);
+	release_mem_region(nxp_pci_io_base, iolength);
+
+	pci_set_drvdata(dev, hcd);
+	return 0;
+
+cleanup3:
+	release_mem_region(pci_mem_phy0, memlength);
+cleanup2:
+	iounmap(iobase);
+cleanup1:
+	release_mem_region(nxp_pci_io_base, iolength);
+	return ret_status;
+}
+
+static void isp1761_pci_remove(struct pci_dev *dev)
+{
+	struct usb_hcd *hcd;
+
+	hcd = pci_get_drvdata(dev);
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+
+	pci_disable_device(dev);
+}
+
+static void isp1761_pci_shutdown(struct pci_dev *dev)
+{
+	printk(KERN_ERR "ips1761_pci_shutdown\n");
+}
+
+static const struct pci_device_id isp1760_plx [] = {
+	{
+		.class          = PCI_CLASS_BRIDGE_OTHER << 8,
+		.class_mask     = ~0,
+		.vendor		= PCI_VENDOR_ID_PLX,
+		.device		= 0x5406,
+		.subvendor	= PCI_VENDOR_ID_PLX,
+		.subdevice	= 0x9054,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, isp1760_plx);
+
+static struct pci_driver isp1761_pci_driver = {
+	.name =         "isp1760",
+	.id_table =     isp1760_plx,
+	.probe =        isp1761_pci_probe,
+	.remove =       isp1761_pci_remove,
+	.shutdown =     isp1761_pci_shutdown,
+};
+#endif
+
+static int __devinit isp1760_plat_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct usb_hcd *hcd;
+	struct resource *mem_res;
+	struct resource *irq_res;
+	resource_size_t mem_size;
+	unsigned long irqflags = IRQF_SHARED | IRQF_DISABLED;
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_res) {
+		pr_warning("isp1760: Memory resource not available\n");
+		ret = -ENODEV;
+		goto out;
+	}
+	mem_size = resource_size(mem_res);
+	if (!request_mem_region(mem_res->start, mem_size, "isp1760")) {
+		pr_warning("isp1760: Cannot reserve the memory resource\n");
+		ret = -EBUSY;
+		goto out;
+	}
+
+	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!irq_res) {
+		pr_warning("isp1760: IRQ resource not available\n");
+		return -ENODEV;
+	}
+	irqflags |= irq_res->flags & IRQF_TRIGGER_MASK;
+
+	hcd = isp1760_register(mem_res->start, mem_size, irq_res->start,
+			       irqflags, &pdev->dev, dev_name(&pdev->dev), 0);
+	if (IS_ERR(hcd)) {
+		pr_warning("isp1760: Failed to register the HCD device\n");
+		ret = -ENODEV;
+		goto cleanup;
+	}
+
+	pr_info("ISP1760 USB device initialised\n");
+	return ret;
+
+cleanup:
+	release_mem_region(mem_res->start, mem_size);
+out:
+	return ret;
+}
+
+static int __devexit isp1760_plat_remove(struct platform_device *pdev)
+{
+	struct resource *mem_res;
+	resource_size_t mem_size;
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mem_size = resource_size(mem_res);
+	release_mem_region(mem_res->start, mem_size);
+
+	return 0;
+}
+
+static struct platform_driver isp1760_plat_driver = {
+	.probe	= isp1760_plat_probe,
+	.remove	= isp1760_plat_remove,
+	.driver	= {
+		.name	= "isp1760",
+	},
+};
+
+static int __init isp1760_init(void)
+{
+	int ret, any_ret = -ENODEV;
+
+	init_kmem_once();
+
+	ret = platform_driver_register(&isp1760_plat_driver);
+	if (!ret)
+		any_ret = 0;
+#ifdef CONFIG_PPC_OF
+	ret = of_register_platform_driver(&isp1760_of_driver);
+	if (!ret)
+		any_ret = 0;
+#endif
+#ifdef CONFIG_PCI
+	ret = pci_register_driver(&isp1761_pci_driver);
+	if (!ret)
+		any_ret = 0;
+#endif
+
+	if (any_ret)
+		deinit_kmem_cache();
+	return any_ret;
+}
+module_init(isp1760_init);
+
+static void __exit isp1760_exit(void)
+{
+	platform_driver_unregister(&isp1760_plat_driver);
+#ifdef CONFIG_PPC_OF
+	of_unregister_platform_driver(&isp1760_of_driver);
+#endif
+#ifdef CONFIG_PCI
+	pci_unregister_driver(&isp1761_pci_driver);
+#endif
+	deinit_kmem_cache();
+}
+module_exit(isp1760_exit);
diff -urN host/ohci-at91.c host.new/ohci-at91.c
--- host/ohci-at91.c	2009-02-24 19:00:15.367972078 +0100
+++ host.new/ohci-at91.c	2009-03-28 17:46:02.000000000 +0100
@@ -15,10 +15,11 @@
 #include <linux/clk.h>
 #include <linux/platform_device.h>
 
-#include <asm/mach-types.h>
-#include <asm/hardware.h>
-#include <asm/arch/board.h>
-#include <asm/arch/cpu.h>
+#include <mach/hardware.h>
+#include <asm/gpio.h>
+
+#include <mach/board.h>
+#include <mach/cpu.h>
 
 #ifndef CONFIG_ARCH_AT91
 #error "CONFIG_ARCH_AT91 must be defined."
@@ -89,7 +90,7 @@
 
 /*-------------------------------------------------------------------------*/
 
-static int usb_hcd_at91_remove (struct usb_hcd *, struct platform_device *);
+static void usb_hcd_at91_remove (struct usb_hcd *, struct platform_device *);
 
 /* configure so an HC device and id are always provided */
 /* always called with process context; sleeping is OK */
@@ -182,13 +183,14 @@
  * context, "rmmod" or something similar.
  *
  */
-static int usb_hcd_at91_remove(struct usb_hcd *hcd,
+static void usb_hcd_at91_remove(struct usb_hcd *hcd,
 				struct platform_device *pdev)
 {
 	usb_remove_hcd(hcd);
 	at91_stop_hc(pdev);
 	iounmap(hcd->regs);
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
 
 	if (cpu_is_at91sam9261())
 		clk_put(hclk);
@@ -197,7 +199,6 @@
 	fclk = iclk = hclk = NULL;
 
 	dev_set_drvdata(&pdev->dev, NULL);
-	return 0;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -259,7 +260,6 @@
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
@@ -271,14 +271,44 @@
 
 static int ohci_hcd_at91_drv_probe(struct platform_device *pdev)
 {
+	struct at91_usbh_data	*pdata = pdev->dev.platform_data;
+	int			i;
+
+	if (pdata) {
+		/* REVISIT make the driver support per-port power switching,
+		 * and also overcurrent detection.  Here we assume the ports
+		 * are always powered while this driver is active, and use
+		 * active-low power switches.
+		 */
+		for (i = 0; i < pdata->ports; i++) {
+			if (pdata->vbus_pin[i] <= 0)
+				continue;
+			gpio_request(pdata->vbus_pin[i], "ohci_vbus");
+			gpio_direction_output(pdata->vbus_pin[i], 0);
+		}
+	}
+
 	device_init_wakeup(&pdev->dev, 1);
 	return usb_hcd_at91_probe(&ohci_at91_hc_driver, pdev);
 }
 
 static int ohci_hcd_at91_drv_remove(struct platform_device *pdev)
 {
+	struct at91_usbh_data	*pdata = pdev->dev.platform_data;
+	int			i;
+
+	if (pdata) {
+		for (i = 0; i < pdata->ports; i++) {
+			if (pdata->vbus_pin[i] <= 0)
+				continue;
+			gpio_direction_output(pdata->vbus_pin[i], 1);
+			gpio_free(pdata->vbus_pin[i]);
+		}
+	}
+
 	device_init_wakeup(&pdev->dev, 0);
-	return usb_hcd_at91_remove(platform_get_drvdata(pdev), pdev);
+	usb_hcd_at91_remove(platform_get_drvdata(pdev), pdev);
+	return 0;
 }
 
 #ifdef CONFIG_PM
@@ -317,6 +347,7 @@
 	if (!clocked)
 		at91_start_clock();
 
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 #else
@@ -324,7 +355,7 @@
 #define ohci_hcd_at91_drv_resume  NULL
 #endif
 
-MODULE_ALIAS("at91_ohci");
+MODULE_ALIAS("platform:at91_ohci");
 
 static struct platform_driver ohci_hcd_at91_driver = {
 	.probe		= ohci_hcd_at91_drv_probe,
@@ -337,4 +368,3 @@
 		.owner	= THIS_MODULE,
 	},
 };
-
diff -urN host/ohci-au1xxx.c host.new/ohci-au1xxx.c
--- host/ohci-au1xxx.c	2009-02-24 19:00:15.383971265 +0100
+++ host.new/ohci-au1xxx.c	2009-03-28 17:46:02.000000000 +0100
@@ -8,7 +8,7 @@
  * Bus Glue for AMD Alchemy Au1xxx
  *
  * Written by Christopher Hoover <ch@hpl.hp.com>
- * Based on fragments of previous driver by Rusell King et al.
+ * Based on fragments of previous driver by Russell King et al.
  *
  * Modified for LH7A404 from ohci-sa1111.c
  *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
@@ -34,7 +34,8 @@
 #ifdef __LITTLE_ENDIAN
 #define USBH_ENABLE_INIT (USBH_ENABLE_CE | USBH_ENABLE_E | USBH_ENABLE_C)
 #elif __BIG_ENDIAN
-#define USBH_ENABLE_INIT (USBH_ENABLE_CE | USBH_ENABLE_E | USBH_ENABLE_C | USBH_ENABLE_BE)
+#define USBH_ENABLE_INIT (USBH_ENABLE_CE | USBH_ENABLE_E | USBH_ENABLE_C | \
+			  USBH_ENABLE_BE)
 #else
 #error not byte order defined
 #endif
@@ -46,213 +47,87 @@
 #define USB_MCFG_RDCOMB   (1<<30)
 #define USB_MCFG_SSDEN    (1<<23)
 #define USB_MCFG_OHCCLKEN (1<<16)
+#ifdef CONFIG_DMA_COHERENT
 #define USB_MCFG_UCAM     (1<<7)
+#else
+#define USB_MCFG_UCAM     (0)
+#endif
 #define USB_MCFG_OBMEN    (1<<1)
 #define USB_MCFG_OMEMEN   (1<<0)
 
 #define USBH_ENABLE_CE    USB_MCFG_OHCCLKEN
-#ifdef CONFIG_DMA_COHERENT
-#define USBH_ENABLE_INIT  (USB_MCFG_OHCCLKEN \
-                         | USB_MCFG_PFEN | USB_MCFG_RDCOMB \
-                         | USB_MCFG_SSDEN | USB_MCFG_UCAM \
-                         | USB_MCFG_OBMEN | USB_MCFG_OMEMEN)
-#else
-#define USBH_ENABLE_INIT  (USB_MCFG_OHCCLKEN \
-                         | USB_MCFG_PFEN | USB_MCFG_RDCOMB \
-                         | USB_MCFG_SSDEN \
-                         | USB_MCFG_OBMEN | USB_MCFG_OMEMEN)
-#endif
+
+#define USBH_ENABLE_INIT  (USB_MCFG_PFEN  | USB_MCFG_RDCOMB 	|	\
+			   USBH_ENABLE_CE | USB_MCFG_SSDEN	|	\
+			   USB_MCFG_UCAM  |				\
+			   USB_MCFG_OBMEN | USB_MCFG_OMEMEN)
+
 #define USBH_DISABLE      (USB_MCFG_OBMEN | USB_MCFG_OMEMEN)
 
 #endif  /* Au1200 */
 
 extern int usb_disabled(void);
 
-/*-------------------------------------------------------------------------*/
-
-static void au1xxx_start_ohc(struct platform_device *dev)
+static void au1xxx_start_ohc(void)
 {
-	printk(KERN_DEBUG __FILE__
-		": starting Au1xxx OHCI USB Controller\n");
-
 	/* enable host controller */
-
 #ifndef CONFIG_SOC_AU1200
-
 	au_writel(USBH_ENABLE_CE, USB_HOST_CONFIG);
+	au_sync();
 	udelay(1000);
-	au_writel(USBH_ENABLE_INIT, USB_HOST_CONFIG);
-	udelay(1000);
-
-#else   /* Au1200 */
 
-	/* write HW defaults again in case Yamon cleared them */
-	if (au_readl(USB_HOST_CONFIG) == 0) {
-		au_writel(0x00d02000, USB_HOST_CONFIG);
-		au_readl(USB_HOST_CONFIG);
-		udelay(1000);
-	}
-	au_writel(USBH_ENABLE_CE | au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
+	au_writel(au_readl(USB_HOST_CONFIG) | USBH_ENABLE_INIT, USB_HOST_CONFIG);
+	au_sync();
 	udelay(1000);
-	au_writel(USBH_ENABLE_INIT | au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
-	udelay(1000);
-
-#endif  /* Au1200 */
 
-#ifndef CONFIG_SOC_AU1200
 	/* wait for reset complete (read register twice; see au1500 errata) */
 	while (au_readl(USB_HOST_CONFIG),
 		!(au_readl(USB_HOST_CONFIG) & USBH_ENABLE_RD))
-#endif
 		udelay(1000);
 
-	printk(KERN_DEBUG __FILE__
-	": Clock to USB host has been enabled \n");
-}
-
-static void au1xxx_stop_ohc(struct platform_device *dev)
-{
-	printk(KERN_DEBUG __FILE__
-	       ": stopping Au1xxx OHCI USB Controller\n");
-
-#ifndef CONFIG_SOC_AU1200
-
-	/* Disable clock */
-	au_writel(au_readl(USB_HOST_CONFIG) & ~USBH_ENABLE_CE, USB_HOST_CONFIG);
-
 #else   /* Au1200 */
-
-	/* Disable mem */
-	au_writel(~USBH_DISABLE & au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
+	au_writel(au_readl(USB_HOST_CONFIG) | USBH_ENABLE_CE, USB_HOST_CONFIG);
+	au_sync();
 	udelay(1000);
-	/* Disable clock */
-	au_writel(~USBH_ENABLE_CE & au_readl(USB_HOST_CONFIG), USB_HOST_CONFIG);
-	au_readl(USB_HOST_CONFIG);
+
+	au_writel(au_readl(USB_HOST_CONFIG) | USBH_ENABLE_INIT, USB_HOST_CONFIG);
+	au_sync();
+	udelay(2000);
 #endif  /* Au1200 */
 }
 
-
-/*-------------------------------------------------------------------------*/
-
-/* configure so an HC device and id are always provided */
-/* always called with process context; sleeping is OK */
-
-
-/**
- * usb_ohci_au1xxx_probe - initialize Au1xxx-based HCDs
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller, and
- * then invokes the start() method for the HCD associated with it
- * through the hotplug entry's driver_data.
- *
- */
-static int usb_ohci_au1xxx_probe(const struct hc_driver *driver,
-			  struct platform_device *dev)
+static void au1xxx_stop_ohc(void)
 {
-	int retval;
-	struct usb_hcd *hcd;
-
-#if defined(CONFIG_SOC_AU1200) && defined(CONFIG_DMA_COHERENT)
-	/* Au1200 AB USB does not support coherent memory */
-	if (!(read_c0_prid() & 0xff)) {
-		pr_info("%s: this is chip revision AB !!\n",
-			dev->name);
-		pr_info("%s: update your board or re-configure the kernel\n",
-			dev->name);
-		return -ENODEV;
-	}
+#ifdef CONFIG_SOC_AU1200
+	/* Disable mem */
+	au_writel(au_readl(USB_HOST_CONFIG) & ~USBH_DISABLE, USB_HOST_CONFIG);
+	au_sync();
+	udelay(1000);
 #endif
-
-	if (dev->resource[1].flags != IORESOURCE_IRQ) {
-		pr_debug("resource[1] is not IORESOURCE_IRQ\n");
-		return -ENOMEM;
-	}
-
-	hcd = usb_create_hcd(driver, &dev->dev, "au1xxx");
-	if (!hcd)
-		return -ENOMEM;
-	hcd->rsrc_start = dev->resource[0].start;
-	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
-
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		pr_debug("request_mem_region failed\n");
-		retval = -EBUSY;
-		goto err1;
-	}
-
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
-	if (!hcd->regs) {
-		pr_debug("ioremap failed\n");
-		retval = -ENOMEM;
-		goto err2;
-	}
-
-	au1xxx_start_ohc(dev);
-	ohci_hcd_init(hcd_to_ohci(hcd));
-
-	retval = usb_add_hcd(hcd, dev->resource[1].start, IRQF_DISABLED | IRQF_SHARED);
-	if (retval == 0)
-		return retval;
-
-	au1xxx_stop_ohc(dev);
-	iounmap(hcd->regs);
- err2:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
- err1:
-	usb_put_hcd(hcd);
-	return retval;
-}
-
-
-/* may be called without controller electrically present */
-/* may be called with controller, bus, and devices active */
-
-/**
- * usb_hcd_au1xxx_remove - shutdown processing for Au1xxx-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_hcd_au1xxx_probe(), first invoking
- * the HCD's stop() method.  It is always called from a thread
- * context, normally "rmmod", "apmd", or something similar.
- *
- */
-static void usb_ohci_au1xxx_remove(struct usb_hcd *hcd, struct platform_device *dev)
-{
-	usb_remove_hcd(hcd);
-	au1xxx_stop_ohc(dev);
-	iounmap(hcd->regs);
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-	usb_put_hcd(hcd);
+	/* Disable clock */
+	au_writel(au_readl(USB_HOST_CONFIG) & ~USBH_ENABLE_CE, USB_HOST_CONFIG);
+	au_sync();
 }
 
-/*-------------------------------------------------------------------------*/
-
-static int __devinit
-ohci_au1xxx_start (struct usb_hcd *hcd)
+static int __devinit ohci_au1xxx_start(struct usb_hcd *hcd)
 {
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ret;
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+	int ret;
 
-	ohci_dbg (ohci, "ohci_au1xxx_start, ohci:%p", ohci);
+	ohci_dbg(ohci, "ohci_au1xxx_start, ohci:%p", ohci);
 
-	if ((ret = ohci_init (ohci)) < 0)
+	if ((ret = ohci_init(ohci)) < 0)
 		return ret;
 
-	if ((ret = ohci_run (ohci)) < 0) {
+	if ((ret = ohci_run(ohci)) < 0) {
 		err ("can't start %s", hcd->self.bus_name);
-		ohci_stop (hcd);
+		ohci_stop(hcd);
 		return ret;
 	}
 
 	return 0;
 }
 
-/*-------------------------------------------------------------------------*/
-
 static const struct hc_driver ohci_au1xxx_hc_driver = {
 	.description =		hcd_name,
 	.product_desc =		"Au1xxx OHCI",
@@ -288,7 +163,6 @@
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
@@ -296,18 +170,66 @@
 	.start_port_reset =	ohci_start_port_reset,
 };
 
-/*-------------------------------------------------------------------------*/
-
 static int ohci_hcd_au1xxx_drv_probe(struct platform_device *pdev)
 {
 	int ret;
-
-	pr_debug ("In ohci_hcd_au1xxx_drv_probe");
+	struct usb_hcd *hcd;
 
 	if (usb_disabled())
 		return -ENODEV;
 
-	ret = usb_ohci_au1xxx_probe(&ohci_au1xxx_hc_driver, pdev);
+#if defined(CONFIG_SOC_AU1200) && defined(CONFIG_DMA_COHERENT)
+	/* Au1200 AB USB does not support coherent memory */
+	if (!(read_c0_prid() & 0xff)) {
+		printk(KERN_INFO "%s: this is chip revision AB !!\n",
+			pdev->name);
+		printk(KERN_INFO "%s: update your board or re-configure "
+				 "the kernel\n", pdev->name);
+		return -ENODEV;
+	}
+#endif
+
+	if (pdev->resource[1].flags != IORESOURCE_IRQ) {
+		pr_debug("resource[1] is not IORESOURCE_IRQ\n");
+		return -ENOMEM;
+	}
+
+	hcd = usb_create_hcd(&ohci_au1xxx_hc_driver, &pdev->dev, "au1xxx");
+	if (!hcd)
+		return -ENOMEM;
+
+	hcd->rsrc_start = pdev->resource[0].start;
+	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		pr_debug("ioremap failed\n");
+		ret = -ENOMEM;
+		goto err2;
+	}
+
+	au1xxx_start_ohc();
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	ret = usb_add_hcd(hcd, pdev->resource[1].start,
+			  IRQF_DISABLED | IRQF_SHARED);
+	if (ret == 0) {
+		platform_set_drvdata(pdev, hcd);
+		return ret;
+	}
+
+	au1xxx_stop_ohc();
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
 	return ret;
 }
 
@@ -315,33 +237,82 @@
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 
-	usb_ohci_au1xxx_remove(hcd, pdev);
+	usb_remove_hcd(hcd);
+	au1xxx_stop_ohc();
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+	platform_set_drvdata(pdev, NULL);
+
 	return 0;
 }
-	/*TBD*/
-/*static int ohci_hcd_au1xxx_drv_suspend(struct platform_device *dev)
+
+#ifdef CONFIG_PM
+static int ohci_hcd_au1xxx_drv_suspend(struct platform_device *pdev,
+					pm_message_t message)
 {
-	struct usb_hcd *hcd = platform_get_drvdata(dev);
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+	unsigned long flags;
+	int rc;
+
+	rc = 0;
+
+	/* Root hub was already suspended. Disable irq emission and
+	 * mark HW unaccessible, bail out if RH has been resumed. Use
+	 * the spinlock to properly synchronize with possible pending
+	 * RH suspend or resume activity.
+	 *
+	 * This is still racy as hcd->state is manipulated outside of
+	 * any locks =P But that will be a different fix.
+	 */
+	spin_lock_irqsave(&ohci->lock, flags);
+	if (hcd->state != HC_STATE_SUSPENDED) {
+		rc = -EINVAL;
+		goto bail;
+	}
+	ohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
+	(void)ohci_readl(ohci, &ohci->regs->intrdisable);
 
-	return 0;
+	/* make sure snapshot being resumed re-enumerates everything */
+	if (message.event == PM_EVENT_PRETHAW)
+		ohci_usb_reset(ohci);
+
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	au1xxx_stop_ohc();
+bail:
+	spin_unlock_irqrestore(&ohci->lock, flags);
+
+	return rc;
 }
-static int ohci_hcd_au1xxx_drv_resume(struct platform_device *dev)
+
+static int ohci_hcd_au1xxx_drv_resume(struct platform_device *pdev)
 {
-	struct usb_hcd *hcd = platform_get_drvdata(dev);
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	au1xxx_start_ohc();
+
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+	ohci_finish_controller_resume(hcd);
 
 	return 0;
 }
-*/
+#else
+#define ohci_hcd_au1xxx_drv_suspend NULL
+#define ohci_hcd_au1xxx_drv_resume NULL
+#endif
 
 static struct platform_driver ohci_hcd_au1xxx_driver = {
 	.probe		= ohci_hcd_au1xxx_drv_probe,
 	.remove		= ohci_hcd_au1xxx_drv_remove,
 	.shutdown	= usb_hcd_platform_shutdown,
-	/*.suspend	= ohci_hcd_au1xxx_drv_suspend, */
-	/*.resume	= ohci_hcd_au1xxx_drv_resume, */
+	.suspend	= ohci_hcd_au1xxx_drv_suspend,
+	.resume		= ohci_hcd_au1xxx_drv_resume,
 	.driver		= {
 		.name	= "au1xxx-ohci",
 		.owner	= THIS_MODULE,
 	},
 };
 
+MODULE_ALIAS("platform:au1xxx-ohci");
diff -urN host/ohci-dbg.c host.new/ohci-dbg.c
--- host/ohci-dbg.c	2009-02-24 19:00:15.411969841 +0100
+++ host.new/ohci-dbg.c	2009-03-28 17:46:02.000000000 +0100
@@ -24,7 +24,7 @@
  * small: 0) header + data packets 1) just header
  */
 static void __maybe_unused
-urb_print (struct urb * urb, char * str, int small)
+urb_print(struct urb * urb, char * str, int small, int status)
 {
 	unsigned int pipe= urb->pipe;
 
@@ -34,7 +34,7 @@
 	}
 
 #ifndef	OHCI_VERBOSE_DEBUG
-	if (urb->status != 0)
+	if (status != 0)
 #endif
 	dbg("%s %p dev=%d ep=%d%s-%s flags=%x len=%d/%d stat=%d",
 		    str,
@@ -46,7 +46,7 @@
 		    urb->transfer_flags,
 		    urb->actual_length,
 		    urb->transfer_buffer_length,
-		    urb->status);
+		    status);
 
 #ifdef	OHCI_VERBOSE_DEBUG
 	if (!small) {
@@ -66,7 +66,7 @@
 						urb->transfer_buffer_length: urb->actual_length;
 			for (i = 0; i < 16 && i < len; i++)
 				printk (" %02x", ((__u8 *) urb->transfer_buffer) [i]);
-			printk ("%s stat:%d\n", i < len? "...": "", urb->status);
+			printk ("%s stat:%d\n", i < len? "...": "", status);
 		}
 	}
 #endif
@@ -401,6 +401,42 @@
 
 #else
 
+static int debug_async_open(struct inode *, struct file *);
+static int debug_periodic_open(struct inode *, struct file *);
+static int debug_registers_open(struct inode *, struct file *);
+static int debug_async_open(struct inode *, struct file *);
+static ssize_t debug_output(struct file*, char __user*, size_t, loff_t*);
+static int debug_close(struct inode *, struct file *);
+
+static const struct file_operations debug_async_fops = {
+	.owner		= THIS_MODULE,
+	.open		= debug_async_open,
+	.read		= debug_output,
+	.release	= debug_close,
+};
+static const struct file_operations debug_periodic_fops = {
+	.owner		= THIS_MODULE,
+	.open		= debug_periodic_open,
+	.read		= debug_output,
+	.release	= debug_close,
+};
+static const struct file_operations debug_registers_fops = {
+	.owner		= THIS_MODULE,
+	.open		= debug_registers_open,
+	.read		= debug_output,
+	.release	= debug_close,
+};
+
+static struct dentry *ohci_debug_root;
+
+struct debug_buffer {
+	ssize_t (*fill_func)(struct debug_buffer *);	/* fill method */
+	struct device *dev;
+	struct mutex mutex;	/* protect filling of buffer */
+	size_t count;		/* number of characters filled into buffer */
+	char *page;
+};
+
 static ssize_t
 show_list (struct ohci_hcd *ohci, char *buf, size_t count, struct ed *ed)
 {
@@ -467,8 +503,7 @@
 	return count - size;
 }
 
-static ssize_t
-show_async (struct class_device *class_dev, char *buf)
+static ssize_t fill_async_buffer(struct debug_buffer *buf)
 {
 	struct usb_bus		*bus;
 	struct usb_hcd		*hcd;
@@ -476,25 +511,23 @@
 	size_t			temp;
 	unsigned long		flags;
 
-	bus = class_get_devdata(class_dev);
+	bus = dev_get_drvdata(buf->dev);
 	hcd = bus_to_hcd(bus);
 	ohci = hcd_to_ohci(hcd);
 
 	/* display control and bulk lists together, for simplicity */
 	spin_lock_irqsave (&ohci->lock, flags);
-	temp = show_list (ohci, buf, PAGE_SIZE, ohci->ed_controltail);
-	temp += show_list (ohci, buf + temp, PAGE_SIZE - temp, ohci->ed_bulktail);
+	temp = show_list(ohci, buf->page, buf->count, ohci->ed_controltail);
+	temp += show_list(ohci, buf->page + temp, buf->count - temp,
+			  ohci->ed_bulktail);
 	spin_unlock_irqrestore (&ohci->lock, flags);
 
 	return temp;
 }
-static CLASS_DEVICE_ATTR (async, S_IRUGO, show_async, NULL);
-
 
 #define DBG_SCHED_LIMIT 64
 
-static ssize_t
-show_periodic (struct class_device *class_dev, char *buf)
+static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 {
 	struct usb_bus		*bus;
 	struct usb_hcd		*hcd;
@@ -509,10 +542,10 @@
 		return 0;
 	seen_count = 0;
 
-	bus = class_get_devdata(class_dev);
+	bus = (struct usb_bus *)dev_get_drvdata(buf->dev);
 	hcd = bus_to_hcd(bus);
 	ohci = hcd_to_ohci(hcd);
-	next = buf;
+	next = buf->page;
 	size = PAGE_SIZE;
 
 	temp = scnprintf (next, size, "size = %d\n", NUM_INTS);
@@ -589,13 +622,9 @@
 
 	return PAGE_SIZE - size;
 }
-static CLASS_DEVICE_ATTR (periodic, S_IRUGO, show_periodic, NULL);
-
-
 #undef DBG_SCHED_LIMIT
 
-static ssize_t
-show_registers (struct class_device *class_dev, char *buf)
+static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 {
 	struct usb_bus		*bus;
 	struct usb_hcd		*hcd;
@@ -606,11 +635,11 @@
 	char			*next;
 	u32			rdata;
 
-	bus = class_get_devdata(class_dev);
+	bus = (struct usb_bus *)dev_get_drvdata(buf->dev);
 	hcd = bus_to_hcd(bus);
 	ohci = hcd_to_ohci(hcd);
 	regs = ohci->regs;
-	next = buf;
+	next = buf->page;
 	size = PAGE_SIZE;
 
 	spin_lock_irqsave (&ohci->lock, flags);
@@ -620,13 +649,13 @@
 	ohci_dbg_sw (ohci, &next, &size,
 		"bus %s, device %s\n"
 		"%s\n"
-		"%s version " DRIVER_VERSION "\n",
+		"%s\n",
 		hcd->self.controller->bus->name,
-		hcd->self.controller->bus_id,
+		dev_name(hcd->self.controller),
 		hcd->product_desc,
 		hcd_name);
 
-	if (bus->controller->power.power_state.event) {
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {
 		size -= scnprintf (next, size,
 			"SUSPENDED (no register access)\n");
 		goto done;
@@ -677,29 +706,155 @@
 
 done:
 	spin_unlock_irqrestore (&ohci->lock, flags);
+
 	return PAGE_SIZE - size;
 }
-static CLASS_DEVICE_ATTR (registers, S_IRUGO, show_registers, NULL);
 
+static struct debug_buffer *alloc_buffer(struct device *dev,
+				ssize_t (*fill_func)(struct debug_buffer *))
+{
+	struct debug_buffer *buf;
+
+	buf = kzalloc(sizeof(struct debug_buffer), GFP_KERNEL);
+
+	if (buf) {
+		buf->dev = dev;
+		buf->fill_func = fill_func;
+		mutex_init(&buf->mutex);
+	}
+
+	return buf;
+}
+
+static int fill_buffer(struct debug_buffer *buf)
+{
+	int ret = 0;
+
+	if (!buf->page)
+		buf->page = (char *)get_zeroed_page(GFP_KERNEL);
+
+	if (!buf->page) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = buf->fill_func(buf);
+
+	if (ret >= 0) {
+		buf->count = ret;
+		ret = 0;
+	}
+
+out:
+	return ret;
+}
+
+static ssize_t debug_output(struct file *file, char __user *user_buf,
+			size_t len, loff_t *offset)
+{
+	struct debug_buffer *buf = file->private_data;
+	int ret = 0;
+
+	mutex_lock(&buf->mutex);
+	if (buf->count == 0) {
+		ret = fill_buffer(buf);
+		if (ret != 0) {
+			mutex_unlock(&buf->mutex);
+			goto out;
+		}
+	}
+	mutex_unlock(&buf->mutex);
+
+	ret = simple_read_from_buffer(user_buf, len, offset,
+				      buf->page, buf->count);
+
+out:
+	return ret;
+
+}
+
+static int debug_close(struct inode *inode, struct file *file)
+{
+	struct debug_buffer *buf = file->private_data;
+
+	if (buf) {
+		if (buf->page)
+			free_page((unsigned long)buf->page);
+		kfree(buf);
+	}
+
+	return 0;
+}
+static int debug_async_open(struct inode *inode, struct file *file)
+{
+	file->private_data = alloc_buffer(inode->i_private, fill_async_buffer);
+
+	return file->private_data ? 0 : -ENOMEM;
+}
+
+static int debug_periodic_open(struct inode *inode, struct file *file)
+{
+	file->private_data = alloc_buffer(inode->i_private,
+					  fill_periodic_buffer);
+
+	return file->private_data ? 0 : -ENOMEM;
+}
 
+static int debug_registers_open(struct inode *inode, struct file *file)
+{
+	file->private_data = alloc_buffer(inode->i_private,
+					  fill_registers_buffer);
+
+	return file->private_data ? 0 : -ENOMEM;
+}
 static inline void create_debug_files (struct ohci_hcd *ohci)
 {
-	struct class_device *cldev = ohci_to_hcd(ohci)->self.class_dev;
-	int retval;
+	struct usb_bus *bus = &ohci_to_hcd(ohci)->self;
+	struct device *dev = bus->dev;
+
+	ohci->debug_dir = debugfs_create_dir(bus->bus_name, ohci_debug_root);
+	if (!ohci->debug_dir)
+		goto dir_error;
+
+	ohci->debug_async = debugfs_create_file("async", S_IRUGO,
+						ohci->debug_dir, dev,
+						&debug_async_fops);
+	if (!ohci->debug_async)
+		goto async_error;
+
+	ohci->debug_periodic = debugfs_create_file("periodic", S_IRUGO,
+						   ohci->debug_dir, dev,
+						   &debug_periodic_fops);
+	if (!ohci->debug_periodic)
+		goto periodic_error;
+
+	ohci->debug_registers = debugfs_create_file("registers", S_IRUGO,
+						    ohci->debug_dir, dev,
+						    &debug_registers_fops);
+	if (!ohci->debug_registers)
+		goto registers_error;
 
-	retval = class_device_create_file(cldev, &class_device_attr_async);
-	retval = class_device_create_file(cldev, &class_device_attr_periodic);
-	retval = class_device_create_file(cldev, &class_device_attr_registers);
 	ohci_dbg (ohci, "created debug files\n");
+	return;
+
+registers_error:
+	debugfs_remove(ohci->debug_periodic);
+periodic_error:
+	debugfs_remove(ohci->debug_async);
+async_error:
+	debugfs_remove(ohci->debug_dir);
+dir_error:
+	ohci->debug_periodic = NULL;
+	ohci->debug_async = NULL;
+	ohci->debug_dir = NULL;
 }
 
 static inline void remove_debug_files (struct ohci_hcd *ohci)
 {
-	struct class_device *cldev = ohci_to_hcd(ohci)->self.class_dev;
-
-	class_device_remove_file(cldev, &class_device_attr_async);
-	class_device_remove_file(cldev, &class_device_attr_periodic);
-	class_device_remove_file(cldev, &class_device_attr_registers);
+	debugfs_remove(ohci->debug_registers);
+	debugfs_remove(ohci->debug_periodic);
+	debugfs_remove(ohci->debug_async);
+	debugfs_remove(ohci->debug_dir);
 }
 
 #endif
diff -urN host/ohci-ep93xx.c host.new/ohci-ep93xx.c
--- host/ohci-ep93xx.c	2009-02-24 19:00:15.411969841 +0100
+++ host.new/ohci-ep93xx.c	2009-03-28 17:46:02.000000000 +0100
@@ -28,8 +28,7 @@
 #include <linux/signal.h>
 #include <linux/platform_device.h>
 
-#include <asm/mach-types.h>
-#include <asm/hardware.h>
+#include <mach/hardware.h>
 
 static struct clk *usb_host_clock;
 
@@ -135,7 +134,6 @@
 	.get_frame_number	= ohci_get_frame,
 	.hub_status_data	= ohci_hub_status_data,
 	.hub_control		= ohci_hub_control,
-	.hub_irq_enable		= ohci_rhsc_enable,
 #ifdef CONFIG_PM
 	.bus_suspend		= ohci_bus_suspend,
 	.bus_resume		= ohci_bus_resume,
@@ -177,7 +175,6 @@
 
 	ep93xx_stop_hc(&pdev->dev);
 	hcd->state = HC_STATE_SUSPENDED;
-	pdev->dev.power.power_state = PMSG_SUSPEND;
 
 	return 0;
 }
@@ -193,9 +190,8 @@
 	ohci->next_statechange = jiffies;
 
 	ep93xx_start_hc(&pdev->dev);
-	pdev->dev.power.power_state = PMSG_ON;
-	usb_hcd_resume_root_hub(hcd);
 
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 #endif
@@ -211,6 +207,8 @@
 #endif
 	.driver		= {
 		.name	= "ep93xx-ohci",
+		.owner	= THIS_MODULE,
 	},
 };
 
+MODULE_ALIAS("platform:ep93xx-ohci");
diff -urN host/ohci-hcd.c host.new/ohci-hcd.c
--- host/ohci-hcd.c	2009-02-24 19:00:15.427969028 +0100
+++ host.new/ohci-hcd.c	2009-03-28 17:46:02.000000000 +0100
@@ -36,6 +36,7 @@
 #include <linux/dmapool.h>
 #include <linux/reboot.h>
 #include <linux/workqueue.h>
+#include <linux/debugfs.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -45,7 +46,6 @@
 
 #include "../core/hcd.h"
 
-#define DRIVER_VERSION "2006 August 04"
 #define DRIVER_AUTHOR "Roman Weissgaerber, David Brownell"
 #define DRIVER_DESC "USB 1.1 'Open' Host Controller (OHCI) Driver"
 
@@ -80,8 +80,25 @@
 static void ohci_dump (struct ohci_hcd *ohci, int verbose);
 static int ohci_init (struct ohci_hcd *ohci);
 static void ohci_stop (struct usb_hcd *hcd);
+
+#if defined(CONFIG_PM) || defined(CONFIG_PCI)
 static int ohci_restart (struct ohci_hcd *ohci);
-static void ohci_quirk_nec_worker (struct work_struct *work);
+#endif
+
+#ifdef CONFIG_PCI
+static void quirk_amd_pll(int state);
+static void amd_iso_dev_put(void);
+#else
+static inline void quirk_amd_pll(int state)
+{
+	return;
+}
+static inline void amd_iso_dev_put(void)
+{
+	return;
+}
+#endif
+
 
 #include "ohci-hub.c"
 #include "ohci-dbg.c"
@@ -118,7 +135,6 @@
  */
 static int ohci_urb_enqueue (
 	struct usb_hcd	*hcd,
-	struct usb_host_endpoint *ep,
 	struct urb	*urb,
 	gfp_t		mem_flags
 ) {
@@ -131,11 +147,11 @@
 	int		retval = 0;
 
 #ifdef OHCI_VERBOSE_DEBUG
-	urb_print (urb, "SUB", usb_pipein (pipe));
+	urb_print(urb, "SUB", usb_pipein(pipe), -EINPROGRESS);
 #endif
 
 	/* every endpoint has a ed, locate and maybe (re)initialize it */
-	if (! (ed = ed_get (ohci, ep, urb->dev, pipe, urb->interval)))
+	if (! (ed = ed_get (ohci, urb->ep, urb->dev, pipe, urb->interval)))
 		return -ENOMEM;
 
 	/* for the private part of the URB we need the number of TDs (size) */
@@ -200,22 +216,17 @@
 		retval = -ENODEV;
 		goto fail;
 	}
-
-	/* in case of unlink-during-submit */
-	spin_lock (&urb->lock);
-	if (urb->status != -EINPROGRESS) {
-		spin_unlock (&urb->lock);
-		urb->hcpriv = urb_priv;
-		finish_urb (ohci, urb);
-		retval = 0;
+	retval = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (retval)
 		goto fail;
-	}
 
 	/* schedule the ed if needed */
 	if (ed->state == ED_IDLE) {
 		retval = ed_schedule (ohci, ed);
-		if (retval < 0)
-			goto fail0;
+		if (retval < 0) {
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
+			goto fail;
+		}
 		if (ed->type == PIPE_ISOCHRONOUS) {
 			u16	frame = ohci_frame_no(ohci);
 
@@ -239,8 +250,6 @@
 	urb->hcpriv = urb_priv;
 	td_submit_urb (ohci, urb);
 
-fail0:
-	spin_unlock (&urb->lock);
 fail:
 	if (retval)
 		urb_free_priv (ohci, urb_priv);
@@ -249,22 +258,26 @@
 }
 
 /*
- * decouple the URB from the HC queues (TDs, urb_priv); it's
- * already marked using urb->status.  reporting is always done
+ * decouple the URB from the HC queues (TDs, urb_priv).
+ * reporting is always done
  * asynchronously, and we might be dealing with an urb that's
  * partially transferred, or an ED with other urbs being unlinked.
  */
-static int ohci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
+static int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 	unsigned long		flags;
+	int			rc;
 
 #ifdef OHCI_VERBOSE_DEBUG
-	urb_print (urb, "UNLINK", 1);
+	urb_print(urb, "UNLINK", 1, status);
 #endif
 
 	spin_lock_irqsave (&ohci->lock, flags);
-	if (HC_IS_RUNNING(hcd->state)) {
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc) {
+		;	/* Do nothing */
+	} else if (HC_IS_RUNNING(hcd->state)) {
 		urb_priv_t  *urb_priv;
 
 		/* Unless an IRQ completed the unlink while it was being
@@ -282,10 +295,10 @@
 		 * any more ... just clean up every urb's memory.
 		 */
 		if (urb->hcpriv)
-			finish_urb (ohci, urb);
+			finish_urb(ohci, urb, status);
 	}
 	spin_unlock_irqrestore (&ohci->lock, flags);
-	return 0;
+	return rc;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -314,6 +327,8 @@
 	if (!HC_IS_RUNNING (hcd->state)) {
 sanitize:
 		ed->state = ED_IDLE;
+		if (quirk_zfmicro(ohci) && ed->type == PIPE_INTERRUPT)
+			ohci->eds_scheduled--;
 		finish_unlinks (ohci, 0);
 	}
 
@@ -321,7 +336,12 @@
 	case ED_UNLINK:		/* wait for hw to finish? */
 		/* major IRQ delivery trouble loses INTR_SF too... */
 		if (limit-- == 0) {
-			ohci_warn (ohci, "IRQ INTR_SF lossage\n");
+			ohci_warn(ohci, "ED unlink timeout\n");
+			if (quirk_zfmicro(ohci)) {
+				ohci_warn(ohci, "Attempting ZF TD recovery\n");
+				ohci->ed_to_check = ed;
+				ohci->zf_delay = 2;
+			}
 			goto sanitize;
 		}
 		spin_unlock_irqrestore (&ohci->lock, flags);
@@ -379,6 +399,93 @@
 	(void) ohci_readl (ohci, &ohci->regs->control);
 }
 
+static int check_ed(struct ohci_hcd *ohci, struct ed *ed)
+{
+	return (hc32_to_cpu(ohci, ed->hwINFO) & ED_IN) != 0
+		&& (hc32_to_cpu(ohci, ed->hwHeadP) & TD_MASK)
+			== (hc32_to_cpu(ohci, ed->hwTailP) & TD_MASK)
+		&& !list_empty(&ed->td_list);
+}
+
+/* ZF Micro watchdog timer callback. The ZF Micro chipset sometimes completes
+ * an interrupt TD but neglects to add it to the donelist.  On systems with
+ * this chipset, we need to periodically check the state of the queues to look
+ * for such "lost" TDs.
+ */
+static void unlink_watchdog_func(unsigned long _ohci)
+{
+	unsigned long	flags;
+	unsigned	max;
+	unsigned	seen_count = 0;
+	unsigned	i;
+	struct ed	**seen = NULL;
+	struct ohci_hcd	*ohci = (struct ohci_hcd *) _ohci;
+
+	spin_lock_irqsave(&ohci->lock, flags);
+	max = ohci->eds_scheduled;
+	if (!max)
+		goto done;
+
+	if (ohci->ed_to_check)
+		goto out;
+
+	seen = kcalloc(max, sizeof *seen, GFP_ATOMIC);
+	if (!seen)
+		goto out;
+
+	for (i = 0; i < NUM_INTS; i++) {
+		struct ed	*ed = ohci->periodic[i];
+
+		while (ed) {
+			unsigned	temp;
+
+			/* scan this branch of the periodic schedule tree */
+			for (temp = 0; temp < seen_count; temp++) {
+				if (seen[temp] == ed) {
+					/* we've checked it and what's after */
+					ed = NULL;
+					break;
+				}
+			}
+			if (!ed)
+				break;
+			seen[seen_count++] = ed;
+			if (!check_ed(ohci, ed)) {
+				ed = ed->ed_next;
+				continue;
+			}
+
+			/* HC's TD list is empty, but HCD sees at least one
+			 * TD that's not been sent through the donelist.
+			 */
+			ohci->ed_to_check = ed;
+			ohci->zf_delay = 2;
+
+			/* The HC may wait until the next frame to report the
+			 * TD as done through the donelist and INTR_WDH.  (We
+			 * just *assume* it's not a multi-TD interrupt URB;
+			 * those could defer the IRQ more than one frame, using
+			 * DI...)  Check again after the next INTR_SF.
+			 */
+			ohci_writel(ohci, OHCI_INTR_SF,
+					&ohci->regs->intrstatus);
+			ohci_writel(ohci, OHCI_INTR_SF,
+					&ohci->regs->intrenable);
+
+			/* flush those writes */
+			(void) ohci_readl(ohci, &ohci->regs->control);
+
+			goto out;
+		}
+	}
+out:
+	kfree(seen);
+	if (ohci->eds_scheduled)
+		mod_timer(&ohci->unlink_watchdog, round_jiffies(jiffies + HZ));
+done:
+	spin_unlock_irqrestore(&ohci->lock, flags);
+}
+
 /*-------------------------------------------------------------------------*
  * HC functions
  *-------------------------------------------------------------------------*/
@@ -390,6 +497,9 @@
 	int ret;
 	struct usb_hcd *hcd = ohci_to_hcd(ohci);
 
+	if (distrust_firmware)
+		ohci->flags |= OHCI_QUIRK_HUB_POWER;
+
 	disable (ohci);
 	ohci->regs = hcd->regs;
 
@@ -479,14 +589,14 @@
 		/* also: power/overcurrent flags in roothub.a */
 	}
 
-	/* Reset USB nearly "by the book".  RemoteWakeupConnected was
-	 * saved if boot firmware (BIOS/SMM/...) told us it's connected,
-	 * or if bus glue did the same (e.g. for PCI add-in cards with
-	 * PCI PM support).
+	/* Reset USB nearly "by the book".  RemoteWakeupConnected has
+	 * to be checked in case boot firmware (BIOS/SMM/...) has set up
+	 * wakeup in a way the bus isn't aware of (e.g., legacy PCI PM).
+	 * If the bus glue detected wakeup capability then it should
+	 * already be enabled; if so we'll just enable it again.
 	 */
-	if ((ohci->hc_control & OHCI_CTRL_RWC) != 0
-			&& !device_may_wakeup(hcd->self.controller))
-		device_init_wakeup(hcd->self.controller, 1);
+	if ((ohci->hc_control & OHCI_CTRL_RWC) != 0)
+		device_set_wakeup_capable(hcd->self.controller, 1);
 
 	switch (ohci->hc_control & OHCI_CTRL_HCFS) {
 	case OHCI_USB_OPER:
@@ -596,7 +706,8 @@
 		temp |= RH_A_NOCP;
 		temp &= ~(RH_A_POTPGT | RH_A_NPS);
 		ohci_writel (ohci, temp, &ohci->regs->roothub.a);
-	} else if ((ohci->flags & OHCI_QUIRK_AMD756) || distrust_firmware) {
+	} else if ((ohci->flags & OHCI_QUIRK_AMD756) ||
+			(ohci->flags & OHCI_QUIRK_HUB_POWER)) {
 		/* hub power always on; required for AMD-756 and some
 		 * Mac platforms.  ganged overcurrent reporting, if any.
 		 */
@@ -616,6 +727,15 @@
 	mdelay ((temp >> 23) & 0x1fe);
 	hcd->state = HC_STATE_RUNNING;
 
+	if (quirk_zfmicro(ohci)) {
+		/* Create timer to watch for bad queue state on ZF Micro */
+		setup_timer(&ohci->unlink_watchdog, unlink_watchdog_func,
+				(unsigned long) ohci);
+
+		ohci->eds_scheduled = 0;
+		ohci->ed_to_check = NULL;
+	}
+
 	ohci_dump (ohci, 1);
 
 	return 0;
@@ -629,29 +749,33 @@
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 	struct ohci_regs __iomem *regs = ohci->regs;
- 	int			ints; 
+	int			ints;
 
-	/* we can eliminate a (slow) ohci_readl()
-	   if _only_ WDH caused this irq */
-	if ((ohci->hcca->done_head != 0)
-			&& ! (hc32_to_cpup (ohci, &ohci->hcca->done_head)
-				& 0x01)) {
-		ints =  OHCI_INTR_WDH;
+	/* Read interrupt status (and flush pending writes).  We ignore the
+	 * optimization of checking the LSB of hcca->done_head; it doesn't
+	 * work on all systems (edge triggering for OHCI can be a factor).
+	 */
+	ints = ohci_readl(ohci, &regs->intrstatus);
 
-	/* cardbus/... hardware gone before remove() */
-	} else if ((ints = ohci_readl (ohci, &regs->intrstatus)) == ~(u32)0) {
+	/* Check for an all 1's result which is a typical consequence
+	 * of dead, unclocked, or unplugged (CardBus...) devices
+	 */
+	if (ints == ~(u32)0) {
 		disable (ohci);
 		ohci_dbg (ohci, "device removed!\n");
 		return IRQ_HANDLED;
+	}
+
+	/* We only care about interrupts that are enabled */
+	ints &= ohci_readl(ohci, &regs->intrenable);
 
 	/* interrupt for some other device? */
-	} else if ((ints &= ohci_readl (ohci, &regs->intrenable)) == 0) {
+	if (ints == 0)
 		return IRQ_NOTMINE;
-	}
 
 	if (ints & OHCI_INTR_UE) {
 		// e.g. due to PCI Master/Target Abort
-		if (ohci->flags & OHCI_QUIRK_NEC) {
+		if (quirk_nec(ohci)) {
 			/* Workaround for a silicon bug in some NEC chips used
 			 * in Apple's PowerBooks. Adapted from Darwin code.
 			 */
@@ -704,13 +828,34 @@
 	}
 
 	if (ints & OHCI_INTR_WDH) {
-		if (HC_IS_RUNNING(hcd->state))
-			ohci_writel (ohci, OHCI_INTR_WDH, &regs->intrdisable);
 		spin_lock (&ohci->lock);
 		dl_done_list (ohci);
 		spin_unlock (&ohci->lock);
-		if (HC_IS_RUNNING(hcd->state))
-			ohci_writel (ohci, OHCI_INTR_WDH, &regs->intrenable);
+	}
+
+	if (quirk_zfmicro(ohci) && (ints & OHCI_INTR_SF)) {
+		spin_lock(&ohci->lock);
+		if (ohci->ed_to_check) {
+			struct ed *ed = ohci->ed_to_check;
+
+			if (check_ed(ohci, ed)) {
+				/* HC thinks the TD list is empty; HCD knows
+				 * at least one TD is outstanding
+				 */
+				if (--ohci->zf_delay == 0) {
+					struct td *td = list_entry(
+						ed->td_list.next,
+						struct td, td_list);
+					ohci_warn(ohci,
+						  "Reclaiming orphan TD %p\n",
+						  td);
+					takeback_td(ohci, td);
+					ohci->ed_to_check = NULL;
+				}
+			} else
+				ohci->ed_to_check = NULL;
+		}
+		spin_unlock(&ohci->lock);
 	}
 
 	/* could track INTR_SO to reduce available PCI/... bandwidth */
@@ -721,7 +866,9 @@
 	spin_lock (&ohci->lock);
 	if (ohci->ed_rm_list)
 		finish_unlinks (ohci, ohci_frame_no(ohci));
-	if ((ints & OHCI_INTR_SF) != 0 && !ohci->ed_rm_list
+	if ((ints & OHCI_INTR_SF) != 0
+			&& !ohci->ed_rm_list
+			&& !ohci->ed_to_check
 			&& HC_IS_RUNNING(hcd->state))
 		ohci_writel (ohci, OHCI_INTR_SF, &regs->intrdisable);
 	spin_unlock (&ohci->lock);
@@ -751,6 +898,11 @@
 	free_irq(hcd->irq, hcd);
 	hcd->irq = -1;
 
+	if (quirk_zfmicro(ohci))
+		del_timer(&ohci->unlink_watchdog);
+	if (quirk_amdiso(ohci))
+		amd_iso_dev_put();
+
 	remove_debug_files (ohci);
 	ohci_mem_cleanup (ohci);
 	if (ohci->hcca) {
@@ -764,6 +916,8 @@
 
 /*-------------------------------------------------------------------------*/
 
+#if defined(CONFIG_PM) || defined(CONFIG_PCI)
+
 /* must not be called from interrupt context */
 static int ohci_restart (struct ohci_hcd *ohci)
 {
@@ -798,9 +952,8 @@
 					ed, ed->state);
 		}
 
-		spin_lock (&urb->lock);
-		urb->status = -ESHUTDOWN;
-		spin_unlock (&urb->lock);
+		if (!urb->unlinked)
+			urb->unlinked = -ESHUTDOWN;
 	}
 	finish_unlinks (ohci, 0);
 	spin_unlock_irq(&ohci->lock);
@@ -826,33 +979,12 @@
 	return 0;
 }
 
-/*-------------------------------------------------------------------------*/
-
-/* NEC workaround */
-static void ohci_quirk_nec_worker(struct work_struct *work)
-{
-	struct ohci_hcd *ohci = container_of(work, struct ohci_hcd, nec_work);
-	int status;
-
-	status = ohci_init(ohci);
-	if (status != 0) {
-		ohci_err(ohci, "Restarting NEC controller failed "
-			 "in ohci_init, %d\n", status);
-		return;
-	}
-
-	status = ohci_restart(ohci);
-	if (status != 0)
-		ohci_err(ohci, "Restarting NEC controller failed "
-			 "in ohci_restart, %d\n", status);
-}
+#endif
 
 /*-------------------------------------------------------------------------*/
 
-#define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
-
 MODULE_AUTHOR (DRIVER_AUTHOR);
-MODULE_DESCRIPTION (DRIVER_INFO);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE ("GPL");
 
 #ifdef CONFIG_PCI
@@ -860,12 +992,12 @@
 #define PCI_DRIVER		ohci_pci_driver
 #endif
 
-#ifdef CONFIG_SA1111
+#if defined(CONFIG_ARCH_SA1100) && defined(CONFIG_SA1111)
 #include "ohci-sa1111.c"
 #define SA1111_DRIVER		ohci_hcd_sa1111_driver
 #endif
 
-#ifdef CONFIG_ARCH_S3C2410
+#if defined(CONFIG_ARCH_S3C2410) || defined(CONFIG_ARCH_S3C64XX)
 #include "ohci-s3c2410.c"
 #define PLATFORM_DRIVER		ohci_hcd_s3c2410_driver
 #endif
@@ -880,7 +1012,7 @@
 #define PLATFORM_DRIVER		ohci_hcd_lh7a404_driver
 #endif
 
-#ifdef CONFIG_PXA27x
+#if defined(CONFIG_PXA27x) || defined(CONFIG_PXA3xx)
 #include "ohci-pxa27x.c"
 #define PLATFORM_DRIVER		ohci_hcd_pxa27x_driver
 #endif
@@ -915,6 +1047,14 @@
 #define PLATFORM_DRIVER		usb_hcd_pnx4008_driver
 #endif
 
+#if defined(CONFIG_CPU_SUBTYPE_SH7720) || \
+    defined(CONFIG_CPU_SUBTYPE_SH7721) || \
+    defined(CONFIG_CPU_SUBTYPE_SH7763) || \
+    defined(CONFIG_CPU_SUBTYPE_SH7786)
+#include "ohci-sh.c"
+#define PLATFORM_DRIVER		ohci_hcd_sh_driver
+#endif
+
 
 #ifdef CONFIG_USB_OHCI_HCD_PPC_OF
 #include "ohci-ppc-of.c"
@@ -926,11 +1066,29 @@
 #define PS3_SYSTEM_BUS_DRIVER	ps3_ohci_driver
 #endif
 
+#ifdef CONFIG_USB_OHCI_HCD_SSB
+#include "ohci-ssb.c"
+#define SSB_OHCI_DRIVER		ssb_ohci_driver
+#endif
+
+#ifdef CONFIG_MFD_SM501
+#include "ohci-sm501.c"
+#define SM501_OHCI_DRIVER	ohci_hcd_sm501_driver
+#endif
+
+#ifdef CONFIG_MFD_TC6393XB
+#include "ohci-tmio.c"
+#define TMIO_OHCI_DRIVER	ohci_hcd_tmio_driver
+#endif
+
 #if	!defined(PCI_DRIVER) &&		\
 	!defined(PLATFORM_DRIVER) &&	\
 	!defined(OF_PLATFORM_DRIVER) &&	\
 	!defined(SA1111_DRIVER) &&	\
-	!defined(PS3_SYSTEM_BUS_DRIVER)
+	!defined(PS3_SYSTEM_BUS_DRIVER) && \
+	!defined(SM501_OHCI_DRIVER) && \
+	!defined(TMIO_OHCI_DRIVER) && \
+	!defined(SSB_OHCI_DRIVER)
 #error "missing bus glue for ohci-hcd"
 #endif
 
@@ -941,9 +1099,18 @@
 	if (usb_disabled())
 		return -ENODEV;
 
-	printk (KERN_DEBUG "%s: " DRIVER_INFO "\n", hcd_name);
+	printk(KERN_INFO "%s: " DRIVER_DESC "\n", hcd_name);
 	pr_debug ("%s: block sizes: ed %Zd td %Zd\n", hcd_name,
 		sizeof (struct ed), sizeof (struct td));
+	set_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
+
+#ifdef DEBUG
+	ohci_debug_root = debugfs_create_dir("ohci", NULL);
+	if (!ohci_debug_root) {
+		retval = -ENOENT;
+		goto error_debug;
+	}
+#endif
 
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	retval = ps3_ohci_driver_register(&PS3_SYSTEM_BUS_DRIVER);
@@ -975,10 +1142,41 @@
 		goto error_pci;
 #endif
 
+#ifdef SSB_OHCI_DRIVER
+	retval = ssb_driver_register(&SSB_OHCI_DRIVER);
+	if (retval)
+		goto error_ssb;
+#endif
+
+#ifdef SM501_OHCI_DRIVER
+	retval = platform_driver_register(&SM501_OHCI_DRIVER);
+	if (retval < 0)
+		goto error_sm501;
+#endif
+
+#ifdef TMIO_OHCI_DRIVER
+	retval = platform_driver_register(&TMIO_OHCI_DRIVER);
+	if (retval < 0)
+		goto error_tmio;
+#endif
+
 	return retval;
 
 	/* Error path */
+#ifdef TMIO_OHCI_DRIVER
+	platform_driver_unregister(&TMIO_OHCI_DRIVER);
+ error_tmio:
+#endif
+#ifdef SM501_OHCI_DRIVER
+	platform_driver_unregister(&SM501_OHCI_DRIVER);
+ error_sm501:
+#endif
+#ifdef SSB_OHCI_DRIVER
+	ssb_driver_unregister(&SSB_OHCI_DRIVER);
+ error_ssb:
+#endif
 #ifdef PCI_DRIVER
+	pci_unregister_driver(&PCI_DRIVER);
  error_pci:
 #endif
 #ifdef SA1111_DRIVER
@@ -997,12 +1195,28 @@
 	ps3_ohci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
  error_ps3:
 #endif
+#ifdef DEBUG
+	debugfs_remove(ohci_debug_root);
+	ohci_debug_root = NULL;
+ error_debug:
+#endif
+
+	clear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
 	return retval;
 }
 module_init(ohci_hcd_mod_init);
 
 static void __exit ohci_hcd_mod_exit(void)
 {
+#ifdef TMIO_OHCI_DRIVER
+	platform_driver_unregister(&TMIO_OHCI_DRIVER);
+#endif
+#ifdef SM501_OHCI_DRIVER
+	platform_driver_unregister(&SM501_OHCI_DRIVER);
+#endif
+#ifdef SSB_OHCI_DRIVER
+	ssb_driver_unregister(&SSB_OHCI_DRIVER);
+#endif
 #ifdef PCI_DRIVER
 	pci_unregister_driver(&PCI_DRIVER);
 #endif
@@ -1018,6 +1232,10 @@
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	ps3_ohci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
 #endif
+#ifdef DEBUG
+	debugfs_remove(ohci_debug_root);
+#endif
+	clear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
 }
 module_exit(ohci_hcd_mod_exit);
 
Files host/ohci-hcd.o and host.new/ohci-hcd.o differ
diff -urN host/ohci-hub.c host.new/ohci-hub.c
--- host/ohci-hub.c	2009-02-24 19:00:15.427969028 +0100
+++ host.new/ohci-hub.c	2009-03-28 17:46:02.000000000 +0100
@@ -36,18 +36,6 @@
 
 /*-------------------------------------------------------------------------*/
 
-/* hcd->hub_irq_enable() */
-static void ohci_rhsc_enable (struct usb_hcd *hcd)
-{
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-
-	spin_lock_irq(&ohci->lock);
-	if (!ohci->autostop)
-		del_timer(&hcd->rh_timer);	/* Prevent next poll */
-	ohci_writel(ohci, OHCI_INTR_RHSC, &ohci->regs->intrenable);
-	spin_unlock_irq(&ohci->lock);
-}
-
 #define OHCI_SCHED_ENABLES \
 	(OHCI_CTRL_CLE|OHCI_CTRL_BLE|OHCI_CTRL_PLE|OHCI_CTRL_IE)
 
@@ -103,11 +91,11 @@
 	finish_unlinks (ohci, ohci_frame_no(ohci));
 
 	/* maybe resume can wake root hub */
-	if (device_may_wakeup(&ohci_to_hcd(ohci)->self.root_hub->dev) ||
-			autostop)
+	if (ohci_to_hcd(ohci)->self.root_hub->do_remote_wakeup || autostop) {
 		ohci->hc_control |= OHCI_CTRL_RWE;
-	else {
-		ohci_writel (ohci, OHCI_INTR_RHSC, &ohci->regs->intrdisable);
+	} else {
+		ohci_writel(ohci, OHCI_INTR_RHSC | OHCI_INTR_RD,
+				&ohci->regs->intrdisable);
 		ohci->hc_control &= ~OHCI_CTRL_RWE;
 	}
 
@@ -326,23 +314,79 @@
 	return rc;
 }
 
+/* Carry out the final steps of resuming the controller device */
+static void ohci_finish_controller_resume(struct usb_hcd *hcd)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci(hcd);
+	int			port;
+	bool			need_reinit = false;
+
+	/* See if the controller is already running or has been reset */
+	ohci->hc_control = ohci_readl(ohci, &ohci->regs->control);
+	if (ohci->hc_control & (OHCI_CTRL_IR | OHCI_SCHED_ENABLES)) {
+		need_reinit = true;
+	} else {
+		switch (ohci->hc_control & OHCI_CTRL_HCFS) {
+		case OHCI_USB_OPER:
+		case OHCI_USB_RESET:
+			need_reinit = true;
+		}
+	}
+
+	/* If needed, reinitialize and suspend the root hub */
+	if (need_reinit) {
+		spin_lock_irq(&ohci->lock);
+		hcd->state = HC_STATE_RESUMING;
+		ohci_rh_resume(ohci);
+		hcd->state = HC_STATE_QUIESCING;
+		ohci_rh_suspend(ohci, 0);
+		hcd->state = HC_STATE_SUSPENDED;
+		spin_unlock_irq(&ohci->lock);
+	}
+
+	/* Normally just turn on port power and enable interrupts */
+	else {
+		ohci_dbg(ohci, "powerup ports\n");
+		for (port = 0; port < ohci->num_ports; port++)
+			ohci_writel(ohci, RH_PS_PPS,
+					&ohci->regs->roothub.portstatus[port]);
+
+		ohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrenable);
+		ohci_readl(ohci, &ohci->regs->intrenable);
+		msleep(20);
+	}
+}
+
 /* Carry out polling-, autostop-, and autoresume-related state changes */
 static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
-		int any_connected)
+		int any_connected, int rhsc_status)
 {
 	int	poll_rh = 1;
+	int	rhsc_enable;
 
-	switch (ohci->hc_control & OHCI_CTRL_HCFS) {
+	/* Some broken controllers never turn off RHCS in the interrupt
+	 * status register.  For their sake we won't re-enable RHSC
+	 * interrupts if the interrupt bit is already active.
+	 */
+	rhsc_enable = ohci_readl(ohci, &ohci->regs->intrenable) &
+			OHCI_INTR_RHSC;
 
+	switch (ohci->hc_control & OHCI_CTRL_HCFS) {
 	case OHCI_USB_OPER:
-		/* keep on polling until we know a device is connected
-		 * and RHSC is enabled */
+		/* If no status changes are pending, enable RHSC interrupts. */
+		if (!rhsc_enable && !rhsc_status && !changed) {
+			rhsc_enable = OHCI_INTR_RHSC;
+			ohci_writel(ohci, rhsc_enable, &ohci->regs->intrenable);
+		}
+
+		/* Keep on polling until we know a device is connected
+		 * and RHSC is enabled, or until we autostop.
+		 */
 		if (!ohci->autostop) {
 			if (any_connected ||
 					!device_may_wakeup(&ohci_to_hcd(ohci)
 						->self.root_hub->dev)) {
-				if (ohci_readl(ohci, &ohci->regs->intrenable) &
-						OHCI_INTR_RHSC)
+				if (rhsc_enable)
 					poll_rh = 0;
 			} else {
 				ohci->autostop = 1;
@@ -361,21 +405,39 @@
 					&& !(ohci->hc_control &
 						OHCI_SCHED_ENABLES)) {
 				ohci_rh_suspend(ohci, 1);
+				if (rhsc_enable)
+					poll_rh = 0;
 			}
 		}
 		break;
 
-	/* if there is a port change, autostart or ask to be resumed */
 	case OHCI_USB_SUSPEND:
 	case OHCI_USB_RESUME:
+		/* if there is a port change, autostart or ask to be resumed */
 		if (changed) {
 			if (ohci->autostop)
 				ohci_rh_resume(ohci);
 			else
 				usb_hcd_resume_root_hub(ohci_to_hcd(ohci));
-		} else {
-			/* everything is idle, no need for polling */
+
+		/* If remote wakeup is disabled, stop polling */
+		} else if (!ohci->autostop &&
+				!ohci_to_hcd(ohci)->self.root_hub->
+					do_remote_wakeup) {
 			poll_rh = 0;
+
+		} else {
+			/* If no status changes are pending,
+			 * enable RHSC interrupts
+			 */
+			if (!rhsc_enable && !rhsc_status) {
+				rhsc_enable = OHCI_INTR_RHSC;
+				ohci_writel(ohci, rhsc_enable,
+						&ohci->regs->intrenable);
+			}
+			/* Keep polling until RHSC is enabled */
+			if (rhsc_enable)
+				poll_rh = 0;
 		}
 		break;
 	}
@@ -393,14 +455,22 @@
  * autostop isn't used when CONFIG_PM is turned off.
  */
 static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
-		int any_connected)
+		int any_connected, int rhsc_status)
 {
-	int	poll_rh = 1;
-
-	/* keep on polling until RHSC is enabled */
+	/* If RHSC is enabled, don't poll */
 	if (ohci_readl(ohci, &ohci->regs->intrenable) & OHCI_INTR_RHSC)
-		poll_rh = 0;
-	return poll_rh;
+		return 0;
+
+	/* If status changes are pending, continue polling.
+	 * Conversely, if no status changes are pending but the RHSC
+	 * status bit was set, then RHSC may be broken so continue polling.
+	 */
+	if (changed || rhsc_status)
+		return 1;
+
+	/* It's safe to re-enable RHSC interrupts */
+	ohci_writel(ohci, OHCI_INTR_RHSC, &ohci->regs->intrenable);
+	return 0;
 }
 
 #endif	/* CONFIG_PM */
@@ -415,6 +485,7 @@
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	int		i, changed = 0, length = 1;
 	int		any_connected = 0;
+	int		rhsc_status;
 	unsigned long	flags;
 
 	spin_lock_irqsave (&ohci->lock, flags);
@@ -440,6 +511,11 @@
 		length++;
 	}
 
+	/* Clear the RHSC status flag before reading the port statuses */
+	ohci_writel(ohci, OHCI_INTR_RHSC, &ohci->regs->intrstatus);
+	rhsc_status = ohci_readl(ohci, &ohci->regs->intrstatus) &
+			OHCI_INTR_RHSC;
+
 	/* look at each port */
 	for (i = 0; i < ohci->num_ports; i++) {
 		u32	status = roothub_portstatus (ohci, i);
@@ -458,7 +534,7 @@
 	}
 
 	hcd->poll_rh = ohci_root_hub_state_changes(ohci, changed,
-			any_connected);
+			any_connected, rhsc_status);
 
 done:
 	spin_unlock_irqrestore (&ohci->lock, flags);
@@ -529,8 +605,6 @@
 	return 0;
 }
 
-static void start_hnp(struct ohci_hcd *ohci);
-
 #else
 
 #define	ohci_start_port_reset		NULL
@@ -561,17 +635,21 @@
 static inline int root_port_reset (struct ohci_hcd *ohci, unsigned port)
 {
 	__hc32 __iomem *portstat = &ohci->regs->roothub.portstatus [port];
-	u32	temp;
+	u32	temp = 0;
 	u16	now = ohci_readl(ohci, &ohci->regs->fmnumber);
 	u16	reset_done = now + PORT_RESET_MSEC;
+	int	limit_1 = DIV_ROUND_UP(PORT_RESET_MSEC, PORT_RESET_HW_MSEC);
 
 	/* build a "continuous enough" reset signal, with up to
 	 * 3msec gap between pulses.  scheduler HZ==100 must work;
 	 * this might need to be deadline-scheduled.
 	 */
 	do {
+		int limit_2;
+
 		/* spin until any current reset finishes */
-		for (;;) {
+		limit_2 = PORT_RESET_HW_MSEC * 2;
+		while (--limit_2 >= 0) {
 			temp = ohci_readl (ohci, portstat);
 			/* handle e.g. CardBus eject */
 			if (temp == ~(u32)0)
@@ -581,6 +659,17 @@
 			udelay (500);
 		}
 
+		/* timeout (a hardware error) has been observed when
+		 * EHCI sets CF while this driver is resetting a port;
+		 * presumably other disconnect paths might do it too.
+		 */
+		if (limit_2 < 0) {
+			ohci_dbg(ohci,
+				"port[%d] reset timeout, stat %08x\n",
+				port, temp);
+			break;
+		}
+
 		if (!(temp & RH_PS_CCS))
 			break;
 		if (temp & RH_PS_PRSC)
@@ -590,8 +679,11 @@
 		ohci_writel (ohci, RH_PS_PRS, portstat);
 		msleep(PORT_RESET_HW_MSEC);
 		now = ohci_readl(ohci, &ohci->regs->fmnumber);
-	} while (tick_before(now, reset_done));
-	/* caller synchronizes using PRSC */
+	} while (tick_before(now, reset_done) && --limit_1 >= 0);
+
+	/* caller synchronizes using PRSC ... and handles PRS
+	 * still being set when this returns.
+	 */
 
 	return 0;
 }
@@ -666,14 +758,14 @@
 		break;
 	case GetHubStatus:
 		temp = roothub_status (ohci) & ~(RH_HS_CRWE | RH_HS_DRWE);
-		put_unaligned(cpu_to_le32 (temp), (__le32 *) buf);
+		put_unaligned_le32(temp, buf);
 		break;
 	case GetPortStatus:
 		if (!wIndex || wIndex > ports)
 			goto error;
 		wIndex--;
 		temp = roothub_portstatus (ohci, wIndex);
-		put_unaligned(cpu_to_le32 (temp), (__le32 *) buf);
+		put_unaligned_le32(temp, buf);
 
 #ifndef	OHCI_VERBOSE_DEBUG
 	if (*(u16*)(buf+2))	/* only if wPortChange is interesting */
@@ -699,7 +791,7 @@
 #ifdef	CONFIG_USB_OTG
 			if (hcd->self.otg_port == (wIndex + 1)
 					&& hcd->self.b_hnp_enable)
-				start_hnp(ohci);
+				ohci->start_hnp(ohci);
 			else
 #endif
 			ohci_writel (ohci, RH_PS_PSS,
diff -urN host/ohci-lh7a404.c host.new/ohci-lh7a404.c
--- host/ohci-lh7a404.c	2009-02-24 19:00:15.435968621 +0100
+++ host.new/ohci-lh7a404.c	2009-03-28 17:46:02.000000000 +0100
@@ -8,7 +8,7 @@
  * Bus Glue for Sharp LH7A404
  *
  * Written by Christopher Hoover <ch@hpl.hp.com>
- * Based on fragments of previous driver by Rusell King et al.
+ * Based on fragments of previous driver by Russell King et al.
  *
  * Modified for LH7A404 from ohci-sa1111.c
  *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
@@ -19,7 +19,7 @@
 #include <linux/platform_device.h>
 #include <linux/signal.h>
 
-#include <asm/hardware.h>
+#include <mach/hardware.h>
 
 
 extern int usb_disabled(void);
@@ -193,7 +193,6 @@
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
@@ -251,3 +250,4 @@
 	},
 };
 
+MODULE_ALIAS("platform:lh7a404-ohci");
diff -urN host/ohci-mem.c host.new/ohci-mem.c
--- host/ohci-mem.c	2009-02-24 19:00:15.435968621 +0100
+++ host.new/ohci-mem.c	2009-03-28 17:46:02.000000000 +0100
@@ -28,7 +28,6 @@
 	ohci->next_statechange = jiffies;
 	spin_lock_init (&ohci->lock);
 	INIT_LIST_HEAD (&ohci->pending);
-	INIT_WORK (&ohci->nec_work, ohci_quirk_nec_worker);
 }
 
 /*-------------------------------------------------------------------------*/
diff -urN host/ohci-omap.c host.new/ohci-omap.c
--- host/ohci-omap.c	2009-02-24 19:00:15.455967605 +0100
+++ host.new/ohci-omap.c	2009-03-28 17:46:02.000000000 +0100
@@ -18,16 +18,16 @@
 #include <linux/jiffies.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
+#include <linux/gpio.h>
 
-#include <asm/hardware.h>
+#include <mach/hardware.h>
 #include <asm/io.h>
 #include <asm/mach-types.h>
 
-#include <asm/arch/mux.h>
-#include <asm/arch/irqs.h>
-#include <asm/arch/gpio.h>
-#include <asm/arch/fpga.h>
-#include <asm/arch/usb.h>
+#include <mach/mux.h>
+#include <mach/irqs.h>
+#include <mach/fpga.h>
+#include <mach/usb.h>
 
 
 /* OMAP-1510 OHCI has its own MMU for DMA */
@@ -47,7 +47,7 @@
 #endif
 
 #ifdef CONFIG_TPS65010
-#include <asm/arch/tps65010.h>
+#include <linux/i2c/tps65010.h>
 #else
 
 #define LOW	0
@@ -169,13 +169,16 @@
 {
 	const unsigned	port = ohci_to_hcd(ohci)->self.otg_port - 1;
 	unsigned long	flags;
+	u32 l;
 
 	otg_start_hnp(ohci->transceiver);
 
 	local_irq_save(flags);
 	ohci->transceiver->state = OTG_STATE_A_SUSPEND;
 	writel (RH_PS_PSS, &ohci->regs->roothub.portstatus [port]);
-	OTG_CTRL_REG &= ~OTG_A_BUSREQ;
+	l = omap_readl(OTG_CTRL);
+	l &= ~OTG_A_BUSREQ;
+	omap_writel(l, OTG_CTRL);
 	local_irq_restore(flags);
 }
 
@@ -205,7 +208,7 @@
 	if (cpu_is_omap16xx())
 		ocpi_enable();
 
-#ifdef	CONFIG_ARCH_OMAP_OTG
+#ifdef	CONFIG_USB_OTG
 	if (need_transceiver) {
 		ohci->transceiver = otg_get_transceiver();
 		if (ohci->transceiver) {
@@ -222,12 +225,13 @@
 			dev_err(hcd->self.controller, "can't find transceiver\n");
 			return -ENODEV;
 		}
+		ohci->start_hnp = start_hnp;
 	}
 #endif
 
 	omap_ohci_clock_power(1);
 
-	if (cpu_is_omap1510()) {
+	if (cpu_is_omap15xx()) {
 		omap_1510_local_bus_power(1);
 		omap_1510_local_bus_init();
 	}
@@ -250,14 +254,14 @@
 
 			/* gpio9 for overcurrent detction */
 			omap_cfg_reg(W8_1610_GPIO9);
-			omap_request_gpio(9);
-			omap_set_gpio_direction(9, 1 /* IN */);
+			gpio_request(9, "OHCI overcurrent");
+			gpio_direction_input(9);
 
 			/* for paranoia's sake:  disable USB.PUEN */
 			omap_cfg_reg(W4_USB_HIGHZ);
 		}
 		ohci_writel(ohci, rh, &ohci->regs->roothub.a);
-		distrust_firmware = 0;
+		ohci->flags &= ~OHCI_QUIRK_HUB_POWER;
 	} else if (machine_is_nokia770()) {
 		/* We require a self-powered hub, which should have
 		 * plenty of power. */
@@ -311,14 +315,14 @@
 		return -ENODEV;
 	}
 
-	usb_host_ck = clk_get(0, "usb_hhc_ck");
+	usb_host_ck = clk_get(&pdev->dev, "usb_hhc_ck");
 	if (IS_ERR(usb_host_ck))
 		return PTR_ERR(usb_host_ck);
 
-	if (!cpu_is_omap1510())
-		usb_dc_ck = clk_get(0, "usb_dc_ck");
+	if (!cpu_is_omap15xx())
+		usb_dc_ck = clk_get(&pdev->dev, "usb_dc_ck");
 	else
-		usb_dc_ck = clk_get(0, "lb_ck");
+		usb_dc_ck = clk_get(&pdev->dev, "lb_ck");
 
 	if (IS_ERR(usb_dc_ck)) {
 		clk_put(usb_host_ck);
@@ -326,7 +330,7 @@
 	}
 
 
-	hcd = usb_create_hcd (driver, &pdev->dev, pdev->dev.bus_id);
+	hcd = usb_create_hcd (driver, &pdev->dev, dev_name(&pdev->dev));
 	if (!hcd) {
 		retval = -ENOMEM;
 		goto err0;
@@ -340,7 +344,12 @@
 		goto err1;
 	}
 
-	hcd->regs = (void __iomem *) (int) IO_ADDRESS(hcd->rsrc_start);
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		dev_err(&pdev->dev, "can't ioremap OHCI HCD\n");
+		retval = -ENOMEM;
+		goto err2;
+	}
 
 	ohci = hcd_to_ohci(hcd);
 	ohci_hcd_init(ohci);
@@ -351,11 +360,11 @@
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
 		retval = -ENXIO;
-		goto err2;
+		goto err3;
 	}
 	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED);
 	if (retval)
-		goto err2;
+		goto err3;
 
 	host_initialized = 1;
 
@@ -363,6 +372,8 @@
 		omap_ohci_clock_power(0);
 
 	return 0;
+err3:
+	iounmap(hcd->regs);
 err2:
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 err1:
@@ -396,7 +407,8 @@
 		put_device(ohci->transceiver->dev);
 	}
 	if (machine_is_omap_osk())
-		omap_free_gpio(9);
+		gpio_free(9);
+	iounmap(hcd->regs);
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 	usb_put_hcd(hcd);
 	clk_put(usb_dc_ck);
@@ -466,7 +478,6 @@
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
@@ -505,21 +516,20 @@
 
 	omap_ohci_clock_power(0);
 	ohci_to_hcd(ohci)->state = HC_STATE_SUSPENDED;
-	dev->dev.power.power_state = PMSG_SUSPEND;
 	return 0;
 }
 
 static int ohci_omap_resume(struct platform_device *dev)
 {
-	struct ohci_hcd	*ohci = hcd_to_ohci(platform_get_drvdata(dev));
+	struct usb_hcd	*hcd = platform_get_drvdata(dev);
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
 
 	if (time_before(jiffies, ohci->next_statechange))
 		msleep(5);
 	ohci->next_statechange = jiffies;
 
 	omap_ohci_clock_power(1);
-	dev->dev.power.power_state = PMSG_ON;
-	usb_hcd_resume_root_hub(platform_get_drvdata(dev));
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 
@@ -544,3 +554,4 @@
 	},
 };
 
+MODULE_ALIAS("platform:ohci");
diff -urN host/ohci-pci.c host.new/ohci-pci.c
--- host/ohci-pci.c	2009-02-24 19:00:15.455967605 +0100
+++ host.new/ohci-pci.c	2009-03-28 17:46:02.000000000 +0100
@@ -18,6 +18,28 @@
 #error "This file is PCI bus glue.  CONFIG_PCI must be defined."
 #endif
 
+#include <linux/pci.h>
+#include <linux/io.h>
+
+
+/* constants used to work around PM-related transfer
+ * glitches in some AMD 700 series southbridges
+ */
+#define AB_REG_BAR	0xf0
+#define AB_INDX(addr)	((addr) + 0x00)
+#define AB_DATA(addr)	((addr) + 0x04)
+#define AX_INDXC	0X30
+#define AX_DATAC	0x34
+
+#define NB_PCIE_INDX_ADDR	0xe0
+#define NB_PCIE_INDX_DATA	0xe4
+#define PCIE_P_CNTL		0x10040
+#define BIF_NB			0x10002
+
+static struct pci_dev *amd_smbus_dev;
+static struct pci_dev *amd_hb_dev;
+static int amd_ohci_iso_count;
+
 /*-------------------------------------------------------------------------*/
 
 static int broken_suspend(struct usb_hcd *hcd)
@@ -84,7 +106,7 @@
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 
 	ohci->flags |= OHCI_QUIRK_ZFMICRO;
-	ohci_dbg (ohci, "enabled Compaq ZFMicro chipset quirk\n");
+	ohci_dbg(ohci, "enabled Compaq ZFMicro chipset quirks\n");
 
 	return 0;
 }
@@ -113,16 +135,133 @@
 
 /* Check for NEC chip and apply quirk for allegedly lost interrupts.
  */
+
+static void ohci_quirk_nec_worker(struct work_struct *work)
+{
+	struct ohci_hcd *ohci = container_of(work, struct ohci_hcd, nec_work);
+	int status;
+
+	status = ohci_init(ohci);
+	if (status != 0) {
+		ohci_err(ohci, "Restarting NEC controller failed in %s, %d\n",
+			 "ohci_init", status);
+		return;
+	}
+
+	status = ohci_restart(ohci);
+	if (status != 0)
+		ohci_err(ohci, "Restarting NEC controller failed in %s, %d\n",
+			 "ohci_restart", status);
+}
+
 static int ohci_quirk_nec(struct usb_hcd *hcd)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 
 	ohci->flags |= OHCI_QUIRK_NEC;
+	INIT_WORK(&ohci->nec_work, ohci_quirk_nec_worker);
 	ohci_dbg (ohci, "enabled NEC chipset lost interrupt quirk\n");
 
 	return 0;
 }
 
+static int ohci_quirk_amd700(struct usb_hcd *hcd)
+{
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	u8 rev = 0;
+
+	if (!amd_smbus_dev)
+		amd_smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI,
+				PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
+	if (!amd_smbus_dev)
+		return 0;
+
+	pci_read_config_byte(amd_smbus_dev, PCI_REVISION_ID, &rev);
+	if ((rev > 0x3b) || (rev < 0x30)) {
+		pci_dev_put(amd_smbus_dev);
+		amd_smbus_dev = NULL;
+		return 0;
+	}
+
+	amd_ohci_iso_count++;
+
+	if (!amd_hb_dev)
+		amd_hb_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x9600, NULL);
+
+	ohci->flags |= OHCI_QUIRK_AMD_ISO;
+	ohci_dbg(ohci, "enabled AMD ISO transfers quirk\n");
+
+	return 0;
+}
+
+/*
+ * The hardware normally enables the A-link power management feature, which
+ * lets the system lower the power consumption in idle states.
+ *
+ * Assume the system is configured to have USB 1.1 ISO transfers going
+ * to or from a USB device.  Without this quirk, that stream may stutter
+ * or have breaks occasionally.  For transfers going to speakers, this
+ * makes a very audible mess...
+ *
+ * That audio playback corruption is due to the audio stream getting
+ * interrupted occasionally when the link goes in lower power state
+ * This USB quirk prevents the link going into that lower power state
+ * during audio playback or other ISO operations.
+ */
+static void quirk_amd_pll(int on)
+{
+	u32 addr;
+	u32 val;
+	u32 bit = (on > 0) ? 1 : 0;
+
+	pci_read_config_dword(amd_smbus_dev, AB_REG_BAR, &addr);
+
+	/* BIT names/meanings are NDA-protected, sorry ... */
+
+	outl(AX_INDXC, AB_INDX(addr));
+	outl(0x40, AB_DATA(addr));
+	outl(AX_DATAC, AB_INDX(addr));
+	val = inl(AB_DATA(addr));
+	val &= ~((1 << 3) | (1 << 4) | (1 << 9));
+	val |= (bit << 3) | ((!bit) << 4) | ((!bit) << 9);
+	outl(val, AB_DATA(addr));
+
+	if (amd_hb_dev) {
+		addr = PCIE_P_CNTL;
+		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_ADDR, addr);
+
+		pci_read_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, &val);
+		val &= ~(1 | (1 << 3) | (1 << 4) | (1 << 9) | (1 << 12));
+		val |= bit | (bit << 3) | (bit << 12);
+		val |= ((!bit) << 4) | ((!bit) << 9);
+		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, val);
+
+		addr = BIF_NB;
+		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_ADDR, addr);
+
+		pci_read_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, &val);
+		val &= ~(1 << 8);
+		val |= bit << 8;
+		pci_write_config_dword(amd_hb_dev, NB_PCIE_INDX_DATA, val);
+	}
+}
+
+static void amd_iso_dev_put(void)
+{
+	amd_ohci_iso_count--;
+	if (amd_ohci_iso_count == 0) {
+		if (amd_smbus_dev) {
+			pci_dev_put(amd_smbus_dev);
+			amd_smbus_dev = NULL;
+		}
+		if (amd_hb_dev) {
+			pci_dev_put(amd_hb_dev);
+			amd_hb_dev = NULL;
+		}
+	}
+
+}
+
 /* List of quirks for OHCI */
 static const struct pci_device_id ohci_pci_quirks[] = {
 	{
@@ -161,6 +300,19 @@
 		PCI_DEVICE(PCI_VENDOR_ID_ITE, 0x8152),
 		.driver_data = (unsigned long) broken_suspend,
 	},
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_ATI, 0x4397),
+		.driver_data = (unsigned long)ohci_quirk_amd700,
+	},
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_ATI, 0x4398),
+		.driver_data = (unsigned long)ohci_quirk_amd700,
+	},
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_ATI, 0x4399),
+		.driver_data = (unsigned long)ohci_quirk_amd700,
+	},
+
 	/* FIXME for some of the early AMD 760 southbridges, OHCI
 	 * won't work at all.  blacklist them.
 	 */
@@ -203,9 +355,9 @@
 
 		/* RWC may not be set for add-in PCI cards, since boot
 		 * firmware probably ignored them.  This transfers PCI
-		 * PM wakeup capabilities (once the PCI layer is fixed).
+		 * PM wakeup capabilities.
 		 */
-		if (device_may_wakeup(&pdev->dev))
+		if (device_can_wakeup(&pdev->dev))
 			ohci->hc_control |= OHCI_CTRL_RWC;
 	}
 #endif /* CONFIG_PM */
@@ -218,42 +370,6 @@
 	return ret;
 }
 
-#if	defined(CONFIG_USB_PERSIST) && (defined(CONFIG_USB_EHCI_HCD) || \
-		defined(CONFIG_USB_EHCI_HCD_MODULE))
-
-/* Following a power loss, we must prepare to regain control of the ports
- * we used to own.  This means turning on the port power before ehci-hcd
- * tries to switch ownership.
- *
- * This isn't a 100% perfect solution.  On most systems the OHCI controllers
- * lie at lower PCI addresses than the EHCI controller, so they will be
- * discovered (and hence resumed) first.  But there is no guarantee things
- * will always work this way.  If the EHCI controller is resumed first and
- * the OHCI ports are unpowered, then the handover will fail.
- */
-static void prepare_for_handover(struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
-	int		port;
-
-	/* Here we "know" root ports should always stay powered */
-	ohci_dbg(ohci, "powerup ports\n");
-	for (port = 0; port < ohci->num_ports; port++)
-		ohci_writel(ohci, RH_PS_PPS,
-				&ohci->regs->roothub.portstatus[port]);
-
-	/* Flush those writes */
-	ohci_readl(ohci, &ohci->regs->control);
-	msleep(20);
-}
-
-#else
-
-static inline void prepare_for_handover(struct usb_hcd *hcd)
-{ }
-
-#endif	/* CONFIG_USB_PERSIST etc. */
-
 #ifdef	CONFIG_PM
 
 static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
@@ -293,10 +409,7 @@
 static int ohci_pci_resume (struct usb_hcd *hcd)
 {
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-
-	/* FIXME: we should try to detect loss of VBUS power here */
-	prepare_for_handover(hcd);
-
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 
@@ -325,9 +438,8 @@
 	.shutdown =		ohci_shutdown,
 
 #ifdef	CONFIG_PM
-	/* these suspend/resume entries are for upstream PCI glue ONLY */
-	.suspend =		ohci_pci_suspend,
-	.resume =		ohci_pci_resume,
+	.pci_suspend =		ohci_pci_suspend,
+	.pci_resume =		ohci_pci_resume,
 #endif
 
 	/*
@@ -347,7 +459,6 @@
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff -urN host/ohci-pnx4008.c host.new/ohci-pnx4008.c
--- host/ohci-pnx4008.c	2009-02-24 19:00:15.467966995 +0100
+++ host.new/ohci-pnx4008.c	2009-03-28 17:46:02.000000000 +0100
@@ -21,13 +21,12 @@
 #include <linux/platform_device.h>
 #include <linux/i2c.h>
 
-#include <asm/hardware.h>
+#include <mach/hardware.h>
 #include <asm/io.h>
-#include <asm/mach-types.h>
 
-#include <asm/arch/platform.h>
-#include <asm/arch/irqs.h>
-#include <asm/arch/gpio.h>
+#include <mach/platform.h>
+#include <mach/irqs.h>
+#include <mach/gpio.h>
 
 #define USB_CTRL	IO_ADDRESS(PNX4008_PWRMAN_BASE + 0x64)
 
@@ -107,68 +106,34 @@
 
 static struct clk *usb_clk;
 
-static int isp1301_probe(struct i2c_adapter *adap);
-static int isp1301_detach(struct i2c_client *client);
-static int isp1301_command(struct i2c_client *client, unsigned int cmd,
-			   void *arg);
-
-static unsigned short normal_i2c[] =
+static const unsigned short normal_i2c[] =
     { ISP1301_I2C_ADDR, ISP1301_I2C_ADDR + 1, I2C_CLIENT_END };
-static unsigned short dummy_i2c_addrlist[] = { I2C_CLIENT_END };
-
-static struct i2c_client_address_data addr_data = {
-	.normal_i2c = normal_i2c,
-	.probe = dummy_i2c_addrlist,
-	.ignore = dummy_i2c_addrlist,
-};
-
-struct i2c_driver isp1301_driver = {
-	.id = I2C_DRIVERID_I2CDEV,	/* Fake Id */
-	.class = I2C_CLASS_HWMON,
-	.attach_adapter = isp1301_probe,
-	.detach_client = isp1301_detach,
-	.command = isp1301_command
-};
 
-static int isp1301_attach(struct i2c_adapter *adap, int addr, int kind)
+static int isp1301_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
 {
-	struct i2c_client *c;
-
-	c = kzalloc(sizeof(*c), GFP_KERNEL);
-
-	if (!c)
-		return -ENOMEM;
-
-	strcpy(c->name, "isp1301");
-	c->flags = 0;
-	c->addr = addr;
-	c->adapter = adap;
-	c->driver = &isp1301_driver;
-
-	isp1301_i2c_client = c;
-
-	return i2c_attach_client(c);
-}
-
-static int isp1301_probe(struct i2c_adapter *adap)
-{
-	return i2c_probe(adap, &addr_data, isp1301_attach);
-}
-
-static int isp1301_detach(struct i2c_client *client)
-{
-	i2c_detach_client(client);
-	kfree(isp1301_i2c_client);
 	return 0;
 }
 
-/* No commands defined */
-static int isp1301_command(struct i2c_client *client, unsigned int cmd,
-			   void *arg)
+static int isp1301_remove(struct i2c_client *client)
 {
 	return 0;
 }
 
+const struct i2c_device_id isp1301_id[] = {
+	{ "isp1301_pnx", 0 },
+	{ }
+};
+
+struct i2c_driver isp1301_driver = {
+	.driver = {
+		.name = "isp1301_pnx",
+	},
+	.probe = isp1301_probe,
+	.remove = isp1301_remove,
+	.id_table = isp1301_id,
+};
+
 static void i2c_write(u8 buf, u8 subaddr)
 {
 	char tmpbuf[2];
@@ -281,7 +246,6 @@
 	 */
 	.hub_status_data = ohci_hub_status_data,
 	.hub_control = ohci_hub_control,
-	.hub_irq_enable = ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend = ohci_bus_suspend,
 	.bus_resume = ohci_bus_resume,
@@ -333,10 +297,12 @@
 	struct usb_hcd *hcd = 0;
 	struct ohci_hcd *ohci;
 	const struct hc_driver *driver = &ohci_pnx4008_hc_driver;
+	struct i2c_adapter *i2c_adap;
+	struct i2c_board_info i2c_info;
 
 	int ret = 0, irq;
 
-	dev_dbg(&pdev->dev, "%s: " DRIVER_INFO " (pnx4008)\n", hcd_name);
+	dev_dbg(&pdev->dev, "%s: " DRIVER_DESC " (pnx4008)\n", hcd_name);
 	if (usb_disabled()) {
 		err("USB is disabled");
 		ret = -ENODEV;
@@ -356,9 +322,20 @@
 
 	ret = i2c_add_driver(&isp1301_driver);
 	if (ret < 0) {
-		err("failed to connect I2C to ISP1301 USB Transceiver");
+		err("failed to add ISP1301 driver");
 		goto out;
 	}
+	i2c_adap = i2c_get_adapter(2);
+	memset(&i2c_info, 0, sizeof(struct i2c_board_info));
+	strlcpy(i2c_info.name, "isp1301_pnx", I2C_NAME_SIZE);
+	isp1301_i2c_client = i2c_new_probed_device(i2c_adap, &i2c_info,
+						   normal_i2c);
+	i2c_put_adapter(i2c_adap);
+	if (!isp1301_i2c_client) {
+		err("failed to connect I2C to ISP1301 USB Transceiver");
+		ret = -ENODEV;
+		goto out_i2c_driver;
+	}
 
 	isp1301_configure();
 
@@ -390,7 +367,7 @@
 	while ((__raw_readl(USB_OTG_CLK_STAT) & USB_CLOCK_MASK) !=
 	       USB_CLOCK_MASK) ;
 
-	hcd = usb_create_hcd (driver, &pdev->dev, pdev->dev.bus_id);
+	hcd = usb_create_hcd (driver, &pdev->dev, dev_name(&pdev->dev));
 	if (!hcd) {
 		err("Failed to allocate HC buffer");
 		ret = -ENOMEM;
@@ -434,6 +411,9 @@
 out2:
 	clk_put(usb_clk);
 out1:
+	i2c_unregister_client(isp1301_i2c_client);
+	isp1301_i2c_client = NULL;
+out_i2c_driver:
 	i2c_del_driver(&isp1301_driver);
 out:
 	return ret;
@@ -450,6 +430,8 @@
 	pnx4008_unset_usb_bits();
 	clk_disable(usb_clk);
 	clk_put(usb_clk);
+	i2c_unregister_client(isp1301_i2c_client);
+	isp1301_i2c_client = NULL;
 	i2c_del_driver(&isp1301_driver);
 
 	platform_set_drvdata(pdev, NULL);
@@ -457,9 +439,13 @@
 	return 0;
 }
 
+/* work with hotplug and coldplug */
+MODULE_ALIAS("platform:usb-ohci");
+
 static struct platform_driver usb_hcd_pnx4008_driver = {
 	.driver = {
 		.name = "usb-ohci",
+		.owner	= THIS_MODULE,
 	},
 	.probe = usb_hcd_pnx4008_probe,
 	.remove = usb_hcd_pnx4008_remove,
diff -urN host/ohci-pnx8550.c host.new/ohci-pnx8550.c
--- host/ohci-pnx8550.c	2009-02-24 19:00:15.471966791 +0100
+++ host.new/ohci-pnx8550.c	2009-03-28 17:46:02.000000000 +0100
@@ -201,7 +201,6 @@
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
@@ -230,11 +229,12 @@
 	return 0;
 }
 
-MODULE_ALIAS("pnx8550-ohci");
+MODULE_ALIAS("platform:pnx8550-ohci");
 
 static struct platform_driver ohci_hcd_pnx8550_driver = {
 	.driver = {
-		.name		= "pnx8550-ohci",
+		.name	= "pnx8550-ohci",
+		.owner	= THIS_MODULE,
 	},
 	.probe		= ohci_hcd_pnx8550_drv_probe,
 	.remove		= ohci_hcd_pnx8550_drv_remove,
diff -urN host/ohci-ppc-of.c host.new/ohci-ppc-of.c
--- host/ohci-ppc-of.c	2009-02-24 19:00:15.475966588 +0100
+++ host.new/ohci-ppc-of.c	2009-03-28 17:46:02.000000000 +0100
@@ -14,8 +14,8 @@
  */
 
 #include <linux/signal.h>
+#include <linux/of_platform.h>
 
-#include <asm/of_platform.h>
 #include <asm/prom.h>
 
 
@@ -72,7 +72,6 @@
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
@@ -92,6 +91,7 @@
 
 	int rv;
 	int is_bigendian;
+	struct device_node *np;
 
 	if (usb_disabled())
 		return -ENODEV;
@@ -134,15 +134,44 @@
 	}
 
 	ohci = hcd_to_ohci(hcd);
-	if (is_bigendian)
+	if (is_bigendian) {
 		ohci->flags |= OHCI_QUIRK_BE_MMIO | OHCI_QUIRK_BE_DESC;
+		if (of_device_is_compatible(dn, "fsl,mpc5200-ohci"))
+			ohci->flags |= OHCI_QUIRK_FRAME_NO;
+		if (of_device_is_compatible(dn, "mpc5200-ohci"))
+			ohci->flags |= OHCI_QUIRK_FRAME_NO;
+	}
 
 	ohci_hcd_init(ohci);
 
-	rv = usb_add_hcd(hcd, irq, 0);
+	rv = usb_add_hcd(hcd, irq, IRQF_DISABLED);
 	if (rv == 0)
 		return 0;
 
+	/* by now, 440epx is known to show usb_23 erratum */
+	np = of_find_compatible_node(NULL, NULL, "ibm,usb-ehci-440epx");
+
+	/* Work around - At this point ohci_run has executed, the
+	* controller is running, everything, the root ports, etc., is
+	* set up.  If the ehci driver is loaded, put the ohci core in
+	* the suspended state.  The ehci driver will bring it out of
+	* suspended state when / if a non-high speed USB device is
+	* attached to the USB Host port.  If the ehci driver is not
+	* loaded, do nothing. request_mem_region is used to test if
+	* the ehci driver is loaded.
+	*/
+	if (np !=  NULL) {
+		if (!of_address_to_resource(np, 0, &res)) {
+			if (!request_mem_region(res.start, 0x4, hcd_name)) {
+				writel_be((readl_be(&ohci->regs->control) |
+					OHCI_USB_SUSPEND), &ohci->regs->control);
+					(void) readl_be(&ohci->regs->control);
+			} else
+				release_mem_region(res.start, 0x4);
+		} else
+		    pr_debug(__FILE__ ": cannot get ehci offset from fdt\n");
+	}
+
 	iounmap(hcd->regs);
 err_ioremap:
 	irq_dispose_mapping(irq);
diff -urN host/ohci-ppc-soc.c host.new/ohci-ppc-soc.c
--- host/ohci-ppc-soc.c	2009-02-24 19:00:15.475966588 +0100
+++ host.new/ohci-ppc-soc.c	2009-03-28 17:46:02.000000000 +0100
@@ -73,6 +73,11 @@
 
 	ohci = hcd_to_ohci(hcd);
 	ohci->flags |= OHCI_QUIRK_BE_MMIO | OHCI_QUIRK_BE_DESC;
+
+#ifdef CONFIG_PPC_MPC52xx
+	/* MPC52xx doesn't need frame_no shift */
+	ohci->flags |= OHCI_QUIRK_FRAME_NO;
+#endif
 	ohci_hcd_init(ohci);
 
 	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED);
@@ -167,7 +172,6 @@
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
@@ -208,3 +212,4 @@
 	},
 };
 
+MODULE_ALIAS("platform:ppc-soc-ohci");
diff -urN host/ohci-ps3.c host.new/ohci-ps3.c
--- host/ohci-ps3.c	2009-02-24 19:00:15.491965775 +0100
+++ host.new/ohci-ps3.c	2009-03-28 17:46:02.000000000 +0100
@@ -68,7 +68,6 @@
 	.get_frame_number	= ohci_get_frame,
 	.hub_status_data	= ohci_hub_status_data,
 	.hub_control		= ohci_hub_control,
-	.hub_irq_enable		= ohci_rhsc_enable,
 	.start_port_reset	= ohci_start_port_reset,
 #if defined(CONFIG_PM)
 	.bus_suspend 		= ohci_bus_suspend,
@@ -127,10 +126,9 @@
 		goto fail_irq;
 	}
 
-	dev->core.power.power_state = PMSG_ON;
 	dev->core.dma_mask = &dummy_mask; /* FIXME: for improper usb code */
 
-	hcd = usb_create_hcd(&ps3_ohci_hc_driver, &dev->core, dev->core.bus_id);
+	hcd = usb_create_hcd(&ps3_ohci_hc_driver, &dev->core, dev_name(&dev->core));
 
 	if (!hcd) {
 		dev_dbg(&dev->core, "%s:%d: usb_create_hcd failed\n", __func__,
@@ -194,7 +192,7 @@
 	return result;
 }
 
-static int ps3_ohci_remove (struct ps3_system_bus_device *dev)
+static int ps3_ohci_remove(struct ps3_system_bus_device *dev)
 {
 	unsigned int tmp;
 	struct usb_hcd *hcd =
@@ -207,6 +205,7 @@
 
 	tmp = hcd->irq;
 
+	ohci_shutdown(hcd);
 	usb_remove_hcd(hcd);
 
 	ps3_system_bus_set_driver_data(dev, NULL);
diff -urN host/ohci-pxa27x.c host.new/ohci-pxa27x.c
--- host/ohci-pxa27x.c	2009-02-24 19:00:15.491965775 +0100
+++ host.new/ohci-pxa27x.c	2009-03-28 17:46:02.000000000 +0100
@@ -22,15 +22,91 @@
 #include <linux/device.h>
 #include <linux/signal.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <mach/ohci.h>
 
-#include <asm/mach-types.h>
-#include <asm/hardware.h>
-#include <asm/arch/pxa-regs.h>
-#include <asm/arch/ohci.h>
+/*
+ * UHC: USB Host Controller (OHCI-like) register definitions
+ */
+#define UHCREV		(0x0000) /* UHC HCI Spec Revision */
+#define UHCHCON		(0x0004) /* UHC Host Control Register */
+#define UHCCOMS		(0x0008) /* UHC Command Status Register */
+#define UHCINTS		(0x000C) /* UHC Interrupt Status Register */
+#define UHCINTE		(0x0010) /* UHC Interrupt Enable */
+#define UHCINTD		(0x0014) /* UHC Interrupt Disable */
+#define UHCHCCA		(0x0018) /* UHC Host Controller Comm. Area */
+#define UHCPCED		(0x001C) /* UHC Period Current Endpt Descr */
+#define UHCCHED		(0x0020) /* UHC Control Head Endpt Descr */
+#define UHCCCED		(0x0024) /* UHC Control Current Endpt Descr */
+#define UHCBHED		(0x0028) /* UHC Bulk Head Endpt Descr */
+#define UHCBCED		(0x002C) /* UHC Bulk Current Endpt Descr */
+#define UHCDHEAD	(0x0030) /* UHC Done Head */
+#define UHCFMI		(0x0034) /* UHC Frame Interval */
+#define UHCFMR		(0x0038) /* UHC Frame Remaining */
+#define UHCFMN		(0x003C) /* UHC Frame Number */
+#define UHCPERS		(0x0040) /* UHC Periodic Start */
+#define UHCLS		(0x0044) /* UHC Low Speed Threshold */
+
+#define UHCRHDA		(0x0048) /* UHC Root Hub Descriptor A */
+#define UHCRHDA_NOCP	(1 << 12)	/* No over current protection */
+#define UHCRHDA_OCPM	(1 << 11)	/* Over Current Protection Mode */
+#define UHCRHDA_POTPGT(x) \
+			(((x) & 0xff) << 24) /* Power On To Power Good Time */
+
+#define UHCRHDB		(0x004C) /* UHC Root Hub Descriptor B */
+#define UHCRHS		(0x0050) /* UHC Root Hub Status */
+#define UHCRHPS1	(0x0054) /* UHC Root Hub Port 1 Status */
+#define UHCRHPS2	(0x0058) /* UHC Root Hub Port 2 Status */
+#define UHCRHPS3	(0x005C) /* UHC Root Hub Port 3 Status */
+
+#define UHCSTAT		(0x0060) /* UHC Status Register */
+#define UHCSTAT_UPS3	(1 << 16)	/* USB Power Sense Port3 */
+#define UHCSTAT_SBMAI	(1 << 15)	/* System Bus Master Abort Interrupt*/
+#define UHCSTAT_SBTAI	(1 << 14)	/* System Bus Target Abort Interrupt*/
+#define UHCSTAT_UPRI	(1 << 13)	/* USB Port Resume Interrupt */
+#define UHCSTAT_UPS2	(1 << 12)	/* USB Power Sense Port 2 */
+#define UHCSTAT_UPS1	(1 << 11)	/* USB Power Sense Port 1 */
+#define UHCSTAT_HTA	(1 << 10)	/* HCI Target Abort */
+#define UHCSTAT_HBA	(1 << 8)	/* HCI Buffer Active */
+#define UHCSTAT_RWUE	(1 << 7)	/* HCI Remote Wake Up Event */
+
+#define UHCHR           (0x0064) /* UHC Reset Register */
+#define UHCHR_SSEP3	(1 << 11)	/* Sleep Standby Enable for Port3 */
+#define UHCHR_SSEP2	(1 << 10)	/* Sleep Standby Enable for Port2 */
+#define UHCHR_SSEP1	(1 << 9)	/* Sleep Standby Enable for Port1 */
+#define UHCHR_PCPL	(1 << 7)	/* Power control polarity low */
+#define UHCHR_PSPL	(1 << 6)	/* Power sense polarity low */
+#define UHCHR_SSE	(1 << 5)	/* Sleep Standby Enable */
+#define UHCHR_UIT	(1 << 4)	/* USB Interrupt Test */
+#define UHCHR_SSDC	(1 << 3)	/* Simulation Scale Down Clock */
+#define UHCHR_CGR	(1 << 2)	/* Clock Generation Reset */
+#define UHCHR_FHR	(1 << 1)	/* Force Host Controller Reset */
+#define UHCHR_FSBIR	(1 << 0)	/* Force System Bus Iface Reset */
+
+#define UHCHIE          (0x0068) /* UHC Interrupt Enable Register*/
+#define UHCHIE_UPS3IE	(1 << 14)	/* Power Sense Port3 IntEn */
+#define UHCHIE_UPRIE	(1 << 13)	/* Port Resume IntEn */
+#define UHCHIE_UPS2IE	(1 << 12)	/* Power Sense Port2 IntEn */
+#define UHCHIE_UPS1IE	(1 << 11)	/* Power Sense Port1 IntEn */
+#define UHCHIE_TAIE	(1 << 10)	/* HCI Interface Transfer Abort
+					   Interrupt Enable*/
+#define UHCHIE_HBAIE	(1 << 8)	/* HCI Buffer Active IntEn */
+#define UHCHIE_RWIE	(1 << 7)	/* Remote Wake-up IntEn */
+
+#define UHCHIT          (0x006C) /* UHC Interrupt Test register */
 
 #define PXA_UHC_MAX_PORTNUM    3
 
-#define UHCRHPS(x)              __REG2( 0x4C000050, (x)<<2 )
+struct pxa27x_ohci {
+	/* must be 1st member here for hcd_to_ohci() to work */
+	struct ohci_hcd ohci;
+
+	struct device	*dev;
+	struct clk	*clk;
+	void __iomem	*mmio_base;
+};
+
+#define to_pxa27x_ohci(hcd)	(struct pxa27x_ohci *)hcd_to_ohci(hcd)
 
 /*
   PMM_NPS_MODE -- PMM Non-power switching mode
@@ -42,30 +118,35 @@
   PMM_PERPORT_MODE -- PMM per port switching mode
       Ports are powered individually.
  */
-static int pxa27x_ohci_select_pmm( int mode )
+static int pxa27x_ohci_select_pmm(struct pxa27x_ohci *ohci, int mode)
 {
-	switch ( mode ) {
+	uint32_t uhcrhda = __raw_readl(ohci->mmio_base + UHCRHDA);
+	uint32_t uhcrhdb = __raw_readl(ohci->mmio_base + UHCRHDB);
+
+	switch (mode) {
 	case PMM_NPS_MODE:
-		UHCRHDA |= RH_A_NPS;
+		uhcrhda |= RH_A_NPS;
 		break;
 	case PMM_GLOBAL_MODE:
-		UHCRHDA &= ~(RH_A_NPS & RH_A_PSM);
+		uhcrhda &= ~(RH_A_NPS & RH_A_PSM);
 		break;
 	case PMM_PERPORT_MODE:
-		UHCRHDA &= ~(RH_A_NPS);
-		UHCRHDA |= RH_A_PSM;
+		uhcrhda &= ~(RH_A_NPS);
+		uhcrhda |= RH_A_PSM;
 
 		/* Set port power control mask bits, only 3 ports. */
-		UHCRHDB |= (0x7<<17);
+		uhcrhdb |= (0x7<<17);
 		break;
 	default:
 		printk( KERN_ERR
 			"Invalid mode %d, set to non-power switch mode.\n",
 			mode );
 
-		UHCRHDA |= RH_A_NPS;
+		uhcrhda |= RH_A_NPS;
 	}
 
+	__raw_writel(uhcrhda, ohci->mmio_base + UHCRHDA);
+	__raw_writel(uhcrhdb, ohci->mmio_base + UHCRHDB);
 	return 0;
 }
 
@@ -73,57 +154,110 @@
 
 /*-------------------------------------------------------------------------*/
 
-static int pxa27x_start_hc(struct device *dev)
+static inline void pxa27x_setup_hc(struct pxa27x_ohci *ohci,
+				   struct pxaohci_platform_data *inf)
+{
+	uint32_t uhchr = __raw_readl(ohci->mmio_base + UHCHR);
+	uint32_t uhcrhda = __raw_readl(ohci->mmio_base + UHCRHDA);
+
+	if (inf->flags & ENABLE_PORT1)
+		uhchr &= ~UHCHR_SSEP1;
+
+	if (inf->flags & ENABLE_PORT2)
+		uhchr &= ~UHCHR_SSEP2;
+
+	if (inf->flags & ENABLE_PORT3)
+		uhchr &= ~UHCHR_SSEP3;
+
+	if (inf->flags & POWER_CONTROL_LOW)
+		uhchr |= UHCHR_PCPL;
+
+	if (inf->flags & POWER_SENSE_LOW)
+		uhchr |= UHCHR_PSPL;
+
+	if (inf->flags & NO_OC_PROTECTION)
+		uhcrhda |= UHCRHDA_NOCP;
+
+	if (inf->flags & OC_MODE_PERPORT)
+		uhcrhda |= UHCRHDA_OCPM;
+
+	if (inf->power_on_delay) {
+		uhcrhda &= ~UHCRHDA_POTPGT(0xff);
+		uhcrhda |= UHCRHDA_POTPGT(inf->power_on_delay / 2);
+	}
+
+	__raw_writel(uhchr, ohci->mmio_base + UHCHR);
+	__raw_writel(uhcrhda, ohci->mmio_base + UHCRHDA);
+}
+
+static inline void pxa27x_reset_hc(struct pxa27x_ohci *ohci)
+{
+	uint32_t uhchr = __raw_readl(ohci->mmio_base + UHCHR);
+
+	__raw_writel(uhchr | UHCHR_FHR, ohci->mmio_base + UHCHR);
+	udelay(11);
+	__raw_writel(uhchr & ~UHCHR_FHR, ohci->mmio_base + UHCHR);
+}
+
+#ifdef CONFIG_CPU_PXA27x
+extern void pxa27x_clear_otgph(void);
+#else
+#define pxa27x_clear_otgph()	do {} while (0)
+#endif
+
+static int pxa27x_start_hc(struct pxa27x_ohci *ohci, struct device *dev)
 {
 	int retval = 0;
 	struct pxaohci_platform_data *inf;
+	uint32_t uhchr;
 
 	inf = dev->platform_data;
 
-	pxa_set_cken(CKEN_USBHOST, 1);
+	clk_enable(ohci->clk);
 
-	UHCHR |= UHCHR_FHR;
-	udelay(11);
-	UHCHR &= ~UHCHR_FHR;
+	pxa27x_reset_hc(ohci);
+
+	uhchr = __raw_readl(ohci->mmio_base + UHCHR) | UHCHR_FSBIR;
+	__raw_writel(uhchr, ohci->mmio_base + UHCHR);
 
-	UHCHR |= UHCHR_FSBIR;
-	while (UHCHR & UHCHR_FSBIR)
+	while (__raw_readl(ohci->mmio_base + UHCHR) & UHCHR_FSBIR)
 		cpu_relax();
 
+	pxa27x_setup_hc(ohci, inf);
+
 	if (inf->init)
 		retval = inf->init(dev);
 
 	if (retval < 0)
 		return retval;
 
-	UHCHR &= ~UHCHR_SSE;
-
-	UHCHIE = (UHCHIE_UPRIE | UHCHIE_RWIE);
+	uhchr = __raw_readl(ohci->mmio_base + UHCHR) & ~UHCHR_SSE;
+	__raw_writel(uhchr, ohci->mmio_base + UHCHR);
+	__raw_writel(UHCHIE_UPRIE | UHCHIE_RWIE, ohci->mmio_base + UHCHIE);
 
 	/* Clear any OTG Pin Hold */
-	if (PSSR & PSSR_OTGPH)
-		PSSR |= PSSR_OTGPH;
-
+	pxa27x_clear_otgph();
 	return 0;
 }
 
-static void pxa27x_stop_hc(struct device *dev)
+static void pxa27x_stop_hc(struct pxa27x_ohci *ohci, struct device *dev)
 {
 	struct pxaohci_platform_data *inf;
+	uint32_t uhccoms;
 
 	inf = dev->platform_data;
 
 	if (inf->exit)
 		inf->exit(dev);
 
-	UHCHR |= UHCHR_FHR;
-	udelay(11);
-	UHCHR &= ~UHCHR_FHR;
+	pxa27x_reset_hc(ohci);
 
-	UHCCOMS |= 1;
+	/* Host Controller Reset */
+	uhccoms = __raw_readl(ohci->mmio_base + UHCCOMS) | 0x01;
+	__raw_writel(uhccoms, ohci->mmio_base + UHCCOMS);
 	udelay(10);
 
-	pxa_set_cken(CKEN_USBHOST, 0);
+	clk_disable(ohci->clk);
 }
 
 
@@ -144,25 +278,41 @@
  */
 int usb_hcd_pxa27x_probe (const struct hc_driver *driver, struct platform_device *pdev)
 {
-	int retval;
+	int retval, irq;
 	struct usb_hcd *hcd;
 	struct pxaohci_platform_data *inf;
+	struct pxa27x_ohci *ohci;
+	struct resource *r;
+	struct clk *usb_clk;
 
 	inf = pdev->dev.platform_data;
 
 	if (!inf)
 		return -ENODEV;
 
-	if (pdev->resource[1].flags != IORESOURCE_IRQ) {
-		pr_debug ("resource[1] is not IORESOURCE_IRQ");
-		return -ENOMEM;
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		pr_err("no resource of IORESOURCE_IRQ");
+		return -ENXIO;
 	}
 
+	usb_clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(usb_clk))
+		return PTR_ERR(usb_clk);
+
 	hcd = usb_create_hcd (driver, &pdev->dev, "pxa27x");
 	if (!hcd)
 		return -ENOMEM;
-	hcd->rsrc_start = pdev->resource[0].start;
-	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		pr_err("no resource of IORESOURCE_MEM");
+		retval = -ENXIO;
+		goto err1;
+	}
+
+	hcd->rsrc_start = r->start;
+	hcd->rsrc_len = resource_size(r);
 
 	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
 		pr_debug("request_mem_region failed");
@@ -177,30 +327,37 @@
 		goto err2;
 	}
 
-	if ((retval = pxa27x_start_hc(&pdev->dev)) < 0) {
+	/* initialize "struct pxa27x_ohci" */
+	ohci = (struct pxa27x_ohci *)hcd_to_ohci(hcd);
+	ohci->dev = &pdev->dev;
+	ohci->clk = usb_clk;
+	ohci->mmio_base = (void __iomem *)hcd->regs;
+
+	if ((retval = pxa27x_start_hc(ohci, &pdev->dev)) < 0) {
 		pr_debug("pxa27x_start_hc failed");
 		goto err3;
 	}
 
 	/* Select Power Management Mode */
-	pxa27x_ohci_select_pmm(inf->port_mode);
+	pxa27x_ohci_select_pmm(ohci, inf->port_mode);
 
 	if (inf->power_budget)
 		hcd->power_budget = inf->power_budget;
 
 	ohci_hcd_init(hcd_to_ohci(hcd));
 
-	retval = usb_add_hcd(hcd, pdev->resource[1].start, IRQF_DISABLED);
+	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED);
 	if (retval == 0)
 		return retval;
 
-	pxa27x_stop_hc(&pdev->dev);
+	pxa27x_stop_hc(ohci, &pdev->dev);
  err3:
 	iounmap(hcd->regs);
  err2:
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
  err1:
 	usb_put_hcd(hcd);
+	clk_put(usb_clk);
 	return retval;
 }
 
@@ -220,11 +377,14 @@
  */
 void usb_hcd_pxa27x_remove (struct usb_hcd *hcd, struct platform_device *pdev)
 {
+	struct pxa27x_ohci *ohci = to_pxa27x_ohci(hcd);
+
 	usb_remove_hcd(hcd);
-	pxa27x_stop_hc(&pdev->dev);
+	pxa27x_stop_hc(ohci, &pdev->dev);
 	iounmap(hcd->regs);
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 	usb_put_hcd(hcd);
+	clk_put(ohci->clk);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -257,7 +417,7 @@
 static const struct hc_driver ohci_pxa27x_hc_driver = {
 	.description =		hcd_name,
 	.product_desc =		"PXA27x OHCI",
-	.hcd_priv_size =	sizeof(struct ohci_hcd),
+	.hcd_priv_size =	sizeof(struct pxa27x_ohci),
 
 	/*
 	 * generic hardware linkage
@@ -289,7 +449,6 @@
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef  CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
@@ -322,15 +481,14 @@
 static int ohci_hcd_pxa27x_drv_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	struct pxa27x_ohci *ohci = to_pxa27x_ohci(hcd);
 
-	if (time_before(jiffies, ohci->next_statechange))
+	if (time_before(jiffies, ohci->ohci.next_statechange))
 		msleep(5);
-	ohci->next_statechange = jiffies;
+	ohci->ohci.next_statechange = jiffies;
 
-	pxa27x_stop_hc(&pdev->dev);
+	pxa27x_stop_hc(ohci, &pdev->dev);
 	hcd->state = HC_STATE_SUSPENDED;
-	pdev->dev.power.power_state = PMSG_SUSPEND;
 
 	return 0;
 }
@@ -338,23 +496,23 @@
 static int ohci_hcd_pxa27x_drv_resume(struct platform_device *pdev)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	struct pxa27x_ohci *ohci = to_pxa27x_ohci(hcd);
 	int status;
 
-	if (time_before(jiffies, ohci->next_statechange))
+	if (time_before(jiffies, ohci->ohci.next_statechange))
 		msleep(5);
-	ohci->next_statechange = jiffies;
+	ohci->ohci.next_statechange = jiffies;
 
-	if ((status = pxa27x_start_hc(&pdev->dev)) < 0)
+	if ((status = pxa27x_start_hc(ohci, &pdev->dev)) < 0)
 		return status;
 
-	pdev->dev.power.power_state = PMSG_ON;
-	usb_hcd_resume_root_hub(hcd);
-
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 #endif
 
+/* work with hotplug and coldplug */
+MODULE_ALIAS("platform:pxa27x-ohci");
 
 static struct platform_driver ohci_hcd_pxa27x_driver = {
 	.probe		= ohci_hcd_pxa27x_drv_probe,
@@ -366,6 +524,7 @@
 #endif
 	.driver		= {
 		.name	= "pxa27x-ohci",
+		.owner	= THIS_MODULE,
 	},
 };
 
diff -urN host/ohci-q.c host.new/ohci-q.c
--- host/ohci-q.c	2009-02-24 19:00:15.503965165 +0100
+++ host.new/ohci-q.c	2009-03-28 17:46:02.000000000 +0100
@@ -36,33 +36,22 @@
  * PRECONDITION:  ohci lock held, irqs blocked.
  */
 static void
-finish_urb (struct ohci_hcd *ohci, struct urb *urb)
+finish_urb(struct ohci_hcd *ohci, struct urb *urb, int status)
 __releases(ohci->lock)
 __acquires(ohci->lock)
 {
 	// ASSERT (urb->hcpriv != 0);
 
 	urb_free_priv (ohci, urb->hcpriv);
-	urb->hcpriv = NULL;
-
-	spin_lock (&urb->lock);
-	if (likely (urb->status == -EINPROGRESS))
-		urb->status = 0;
-	/* report short control reads right even though the data TD always
-	 * has TD_R set.  (much simpler, but creates the 1-td limit.)
-	 */
-	if (unlikely (urb->transfer_flags & URB_SHORT_NOT_OK)
-			&& unlikely (usb_pipecontrol (urb->pipe))
-			&& urb->actual_length < urb->transfer_buffer_length
-			&& usb_pipein (urb->pipe)
-			&& urb->status == 0) {
-		urb->status = -EREMOTEIO;
-	}
-	spin_unlock (&urb->lock);
+	if (likely(status == -EINPROGRESS))
+		status = 0;
 
 	switch (usb_pipetype (urb->pipe)) {
 	case PIPE_ISOCHRONOUS:
 		ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs--;
+		if (ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs == 0
+				&& quirk_amdiso(ohci))
+			quirk_amd_pll(1);
 		break;
 	case PIPE_INTERRUPT:
 		ohci_to_hcd(ohci)->self.bandwidth_int_reqs--;
@@ -70,12 +59,13 @@
 	}
 
 #ifdef OHCI_VERBOSE_DEBUG
-	urb_print (urb, "RET", usb_pipeout (urb->pipe));
+	urb_print(urb, "RET", usb_pipeout (urb->pipe), status);
 #endif
 
 	/* urb->complete() can reenter this HCD */
+	usb_hcd_unlink_urb_from_ep(ohci_to_hcd(ohci), urb);
 	spin_unlock (&ohci->lock);
-	usb_hcd_giveback_urb (ohci_to_hcd(ohci), urb);
+	usb_hcd_giveback_urb(ohci_to_hcd(ohci), urb, status);
 	spin_lock (&ohci->lock);
 
 	/* stop periodic dma if it's not needed */
@@ -172,13 +162,14 @@
 {
 	int	branch;
 
-	if (ohci_to_hcd(ohci)->state == HC_STATE_QUIESCING)
-		return -EAGAIN;
-
 	ed->state = ED_OPER;
 	ed->ed_prev = NULL;
 	ed->ed_next = NULL;
 	ed->hwNextED = 0;
+	if (quirk_zfmicro(ohci)
+			&& (ed->type == PIPE_INTERRUPT)
+			&& !(ohci->eds_scheduled++))
+		mod_timer(&ohci->unlink_watchdog, round_jiffies(jiffies + HZ));
 	wmb ();
 
 	/* we care about rm_list when setting CLE/BLE in case the HC was at
@@ -689,6 +680,9 @@
 				data + urb->iso_frame_desc [cnt].offset,
 				urb->iso_frame_desc [cnt].length, urb, cnt);
 		}
+		if (ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs == 0
+				&& quirk_amdiso(ohci))
+			quirk_amd_pll(0);
 		periodic = ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs++ == 0
 			&& ohci_to_hcd(ohci)->self.bandwidth_int_reqs == 0;
 		break;
@@ -708,19 +702,18 @@
  * Done List handling functions
  *-------------------------------------------------------------------------*/
 
-/* calculate transfer length/status and update the urb
- * PRECONDITION:  irqsafe (only for urb->status locking)
- */
-static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
+/* calculate transfer length/status and update the urb */
+static int td_done(struct ohci_hcd *ohci, struct urb *urb, struct td *td)
 {
 	u32	tdINFO = hc32_to_cpup (ohci, &td->hwINFO);
 	int	cc = 0;
+	int	status = -EINPROGRESS;
 
 	list_del (&td->td_list);
 
 	/* ISO ... drivers see per-TD length/status */
 	if (tdINFO & TD_ISO) {
-		u16	tdPSW = ohci_hwPSW (ohci, td, 0);
+		u16	tdPSW = ohci_hwPSW(ohci, td, 0);
 		int	dlen = 0;
 
 		/* NOTE:  assumes FC in tdINFO == 0, and that
@@ -729,7 +722,7 @@
 
 		cc = (tdPSW >> 12) & 0xF;
 		if (tdINFO & TD_CC)	/* hc didn't touch? */
-			return;
+			return status;
 
 		if (usb_pipeout (urb->pipe))
 			dlen = urb->iso_frame_desc [td->index].length;
@@ -762,12 +755,8 @@
 		if (cc == TD_DATAUNDERRUN
 				&& !(urb->transfer_flags & URB_SHORT_NOT_OK))
 			cc = TD_CC_NOERROR;
-		if (cc != TD_CC_NOERROR && cc < 0x0E) {
-			spin_lock (&urb->lock);
-			if (urb->status == -EINPROGRESS)
-				urb->status = cc_to_error [cc];
-			spin_unlock (&urb->lock);
-		}
+		if (cc != TD_CC_NOERROR && cc < 0x0E)
+			status = cc_to_error[cc];
 
 		/* count all non-empty packets except control SETUP packet */
 		if ((type != PIPE_CONTROL || td->index != 0) && tdBE != 0) {
@@ -786,14 +775,15 @@
 				urb->actual_length,
 				urb->transfer_buffer_length);
 	}
+	return status;
 }
 
 /*-------------------------------------------------------------------------*/
 
-static inline struct td *
-ed_halted (struct ohci_hcd *ohci, struct td *td, int cc, struct td *rev)
+static void ed_halted(struct ohci_hcd *ohci, struct td *td, int cc)
 {
 	struct urb		*urb = td->urb;
+	urb_priv_t		*urb_priv = urb->hcpriv;
 	struct ed		*ed = td->ed;
 	struct list_head	*tmp = td->td_list.next;
 	__hc32			toggle = ed->hwHeadP & cpu_to_hc32 (ohci, ED_C);
@@ -805,13 +795,12 @@
 	wmb ();
 	ed->hwHeadP &= ~cpu_to_hc32 (ohci, ED_H);
 
-	/* put any later tds from this urb onto the donelist, after 'td',
-	 * order won't matter here: no errors, and nothing was transferred.
-	 * also patch the ed so it looks as if those tds completed normally.
+	/* Get rid of all later tds from this urb.  We don't have
+	 * to be careful: no errors and nothing was transferred.
+	 * Also patch the ed so it looks as if those tds completed normally.
 	 */
 	while (tmp != &ed->td_list) {
 		struct td	*next;
-		__hc32		info;
 
 		next = list_entry (tmp, struct td, td_list);
 		tmp = next->td_list.next;
@@ -826,14 +815,9 @@
 		 * then we need to leave the control STATUS packet queued
 		 * and clear ED_SKIP.
 		 */
-		info = next->hwINFO;
-		info |= cpu_to_hc32 (ohci, TD_DONE);
-		info &= ~cpu_to_hc32 (ohci, TD_CC);
-		next->hwINFO = info;
-
-		next->next_dl_td = rev;
-		rev = next;
 
+		list_del(&next->td_list);
+		urb_priv->td_cnt++;
 		ed->hwHeadP = next->hwNextTD | toggle;
 	}
 
@@ -859,8 +843,6 @@
 			hc32_to_cpu (ohci, td->hwINFO),
 			cc, cc_to_error [cc]);
 	}
-
-	return rev;
 }
 
 /* replies to the request have to be on a FIFO basis so
@@ -897,7 +879,7 @@
 		 */
 		if (cc != TD_CC_NOERROR
 				&& (td->ed->hwHeadP & cpu_to_hc32 (ohci, ED_H)))
-			td_rev = ed_halted (ohci, td, cc, td_rev);
+			ed_halted(ohci, td, cc);
 
 		td->next_dl_td = td_rev;
 		td_rev = td;
@@ -940,8 +922,12 @@
 								TD_MASK;
 
 				/* INTR_WDH may need to clean up first */
-				if (td->td_dma != head)
-					goto skip_ed;
+				if (td->td_dma != head) {
+					if (ed == ohci->ed_to_check)
+						ohci->ed_to_check = NULL;
+					else
+						goto skip_ed;
+				}
 			}
 		}
 
@@ -969,12 +955,13 @@
 			struct urb	*urb;
 			urb_priv_t	*urb_priv;
 			__hc32		savebits;
+			u32		tdINFO;
 
 			td = list_entry (entry, struct td, td_list);
 			urb = td->urb;
 			urb_priv = td->urb->hcpriv;
 
-			if (urb->status == -EINPROGRESS) {
+			if (!urb->unlinked) {
 				prev = &td->hwNextTD;
 				continue;
 			}
@@ -983,6 +970,17 @@
 			savebits = *prev & ~cpu_to_hc32 (ohci, TD_MASK);
 			*prev = td->hwNextTD | savebits;
 
+			/* If this was unlinked, the TD may not have been
+			 * retired ... so manually save the data toggle.
+			 * The controller ignores the value we save for
+			 * control and ISO endpoints.
+			 */
+			tdINFO = hc32_to_cpup(ohci, &td->hwINFO);
+			if ((tdINFO & TD_T) == TD_T_DATA0)
+				ed->hwHeadP &= ~cpu_to_hc32(ohci, ED_C);
+			else if ((tdINFO & TD_T) == TD_T_DATA1)
+				ed->hwHeadP |= cpu_to_hc32(ohci, ED_C);
+
 			/* HC may have partly processed this TD */
 			td_done (ohci, urb, td);
 			urb_priv->td_cnt++;
@@ -990,7 +988,7 @@
 			/* if URB is done, clean up */
 			if (urb_priv->td_cnt == urb_priv->length) {
 				modified = completed = 1;
-				finish_urb (ohci, urb);
+				finish_urb(ohci, urb, 0);
 			}
 		}
 		if (completed && !list_empty (&ed->td_list))
@@ -998,6 +996,8 @@
 
 		/* ED's now officially unlinked, hc doesn't see */
 		ed->state = ED_IDLE;
+		if (quirk_zfmicro(ohci) && ed->type == PIPE_INTERRUPT)
+			ohci->eds_scheduled--;
 		ed->hwHeadP &= ~cpu_to_hc32(ohci, ED_H);
 		ed->hwNextED = 0;
 		wmb ();
@@ -1021,7 +1021,7 @@
 
 		if (ohci->ed_controltail) {
 			command |= OHCI_CLF;
-			if (ohci->flags & OHCI_QUIRK_ZFMICRO)
+			if (quirk_zfmicro(ohci))
 				mdelay(1);
 			if (!(ohci->hc_control & OHCI_CTRL_CLE)) {
 				control |= OHCI_CTRL_CLE;
@@ -1031,7 +1031,7 @@
 		}
 		if (ohci->ed_bulktail) {
 			command |= OHCI_BLF;
-			if (ohci->flags & OHCI_QUIRK_ZFMICRO)
+			if (quirk_zfmicro(ohci))
 				mdelay(1);
 			if (!(ohci->hc_control & OHCI_CTRL_BLE)) {
 				control |= OHCI_CTRL_BLE;
@@ -1043,13 +1043,13 @@
 		/* CLE/BLE to enable, CLF/BLF to (maybe) kickstart */
 		if (control) {
 			ohci->hc_control |= control;
-			if (ohci->flags & OHCI_QUIRK_ZFMICRO)
+			if (quirk_zfmicro(ohci))
 				mdelay(1);
 			ohci_writel (ohci, ohci->hc_control,
 					&ohci->regs->control);
 		}
 		if (command) {
-			if (ohci->flags & OHCI_QUIRK_ZFMICRO)
+			if (quirk_zfmicro(ohci))
 				mdelay(1);
 			ohci_writel (ohci, command, &ohci->regs->cmdstatus);
 		}
@@ -1061,11 +1061,60 @@
 /*-------------------------------------------------------------------------*/
 
 /*
+ * Used to take back a TD from the host controller. This would normally be
+ * called from within dl_done_list, however it may be called directly if the
+ * HC no longer sees the TD and it has not appeared on the donelist (after
+ * two frames).  This bug has been observed on ZF Micro systems.
+ */
+static void takeback_td(struct ohci_hcd *ohci, struct td *td)
+{
+	struct urb	*urb = td->urb;
+	urb_priv_t	*urb_priv = urb->hcpriv;
+	struct ed	*ed = td->ed;
+	int		status;
+
+	/* update URB's length and status from TD */
+	status = td_done(ohci, urb, td);
+	urb_priv->td_cnt++;
+
+	/* If all this urb's TDs are done, call complete() */
+	if (urb_priv->td_cnt == urb_priv->length)
+		finish_urb(ohci, urb, status);
+
+	/* clean schedule:  unlink EDs that are no longer busy */
+	if (list_empty(&ed->td_list)) {
+		if (ed->state == ED_OPER)
+			start_ed_unlink(ohci, ed);
+
+	/* ... reenabling halted EDs only after fault cleanup */
+	} else if ((ed->hwINFO & cpu_to_hc32(ohci, ED_SKIP | ED_DEQUEUE))
+			== cpu_to_hc32(ohci, ED_SKIP)) {
+		td = list_entry(ed->td_list.next, struct td, td_list);
+		if (!(td->hwINFO & cpu_to_hc32(ohci, TD_DONE))) {
+			ed->hwINFO &= ~cpu_to_hc32(ohci, ED_SKIP);
+			/* ... hc may need waking-up */
+			switch (ed->type) {
+			case PIPE_CONTROL:
+				ohci_writel(ohci, OHCI_CLF,
+						&ohci->regs->cmdstatus);
+				break;
+			case PIPE_BULK:
+				ohci_writel(ohci, OHCI_BLF,
+						&ohci->regs->cmdstatus);
+				break;
+			}
+		}
+	}
+}
+
+/*
  * Process normal completions (error or success) and clean the schedules.
  *
  * This is the main path for handing urbs back to drivers.  The only other
- * path is finish_unlinks(), which unlinks URBs using ed_rm_list, instead of
- * scanning the (re-reversed) donelist as this does.
+ * normal path is finish_unlinks(), which unlinks URBs using ed_rm_list,
+ * instead of scanning the (re-reversed) donelist as this does.  There's
+ * an abnormal path too, handling a quirk in some Compaq silicon:  URBs
+ * with TDs that appear to be orphaned are directly reclaimed.
  */
 static void
 dl_done_list (struct ohci_hcd *ohci)
@@ -1074,44 +1123,7 @@
 
 	while (td) {
 		struct td	*td_next = td->next_dl_td;
-		struct urb	*urb = td->urb;
-		urb_priv_t	*urb_priv = urb->hcpriv;
-		struct ed	*ed = td->ed;
-
-		/* update URB's length and status from TD */
-		td_done (ohci, urb, td);
-		urb_priv->td_cnt++;
-
-		/* If all this urb's TDs are done, call complete() */
-		if (urb_priv->td_cnt == urb_priv->length)
-			finish_urb (ohci, urb);
-
-		/* clean schedule:  unlink EDs that are no longer busy */
-		if (list_empty (&ed->td_list)) {
-			if (ed->state == ED_OPER)
-				start_ed_unlink (ohci, ed);
-
-		/* ... reenabling halted EDs only after fault cleanup */
-		} else if ((ed->hwINFO & cpu_to_hc32 (ohci,
-						ED_SKIP | ED_DEQUEUE))
-					== cpu_to_hc32 (ohci, ED_SKIP)) {
-			td = list_entry (ed->td_list.next, struct td, td_list);
-			if (!(td->hwINFO & cpu_to_hc32 (ohci, TD_DONE))) {
-				ed->hwINFO &= ~cpu_to_hc32 (ohci, ED_SKIP);
-				/* ... hc may need waking-up */
-				switch (ed->type) {
-				case PIPE_CONTROL:
-					ohci_writel (ohci, OHCI_CLF,
-						&ohci->regs->cmdstatus);
-					break;
-				case PIPE_BULK:
-					ohci_writel (ohci, OHCI_BLF,
-						&ohci->regs->cmdstatus);
-					break;
-				}
-			}
-		}
-
+		takeback_td(ohci, td);
 		td = td_next;
 	}
 }
diff -urN host/ohci-s3c2410.c host.new/ohci-s3c2410.c
--- host/ohci-s3c2410.c	2009-02-24 19:00:15.523964149 +0100
+++ host.new/ohci-s3c2410.c	2009-03-28 17:46:02.000000000 +0100
@@ -8,7 +8,7 @@
  * USB Bus Glue for Samsung S3C2410
  *
  * Written by Christopher Hoover <ch@hpl.hp.com>
- * Based on fragments of previous driver by Rusell King et al.
+ * Based on fragments of previous driver by Russell King et al.
  *
  * Modified for S3C2410 from ohci-sa1111.c, ohci-omap.c and ohci-lh7a40.c
  *	by Ben Dooks, <ben@simtec.co.uk>
@@ -21,9 +21,7 @@
 
 #include <linux/platform_device.h>
 #include <linux/clk.h>
-
-#include <asm/hardware.h>
-#include <asm/arch/usb-control.h>
+#include <plat/usb-control.h>
 
 #define valid_port(idx) ((idx) == 1 || (idx) == 2)
 
@@ -358,7 +356,7 @@
 	hcd->rsrc_len   = dev->resource[0].end - dev->resource[0].start + 1;
 
 	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
-		dev_err(&dev->dev, "request_mem_region failed");
+		dev_err(&dev->dev, "request_mem_region failed\n");
 		retval = -EBUSY;
 		goto err_put;
 	}
@@ -372,7 +370,7 @@
 
 	usb_clk = clk_get(&dev->dev, "usb-bus-host");
 	if (IS_ERR(usb_clk)) {
-		dev_err(&dev->dev, "cannot get usb-host clock\n");
+		dev_err(&dev->dev, "cannot get usb-bus-host clock\n");
 		retval = -ENOENT;
 		goto err_clk;
 	}
@@ -466,7 +464,6 @@
 	 */
 	.hub_status_data =	ohci_s3c2410_hub_status_data,
 	.hub_control =		ohci_s3c2410_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
@@ -501,3 +498,4 @@
 	},
 };
 
+MODULE_ALIAS("platform:s3c2410-ohci");
diff -urN host/ohci-sa1111.c host.new/ohci-sa1111.c
--- host/ohci-sa1111.c	2009-02-24 19:00:15.523964149 +0100
+++ host.new/ohci-sa1111.c	2009-03-28 17:46:02.000000000 +0100
@@ -8,15 +8,15 @@
  * SA1111 Bus Glue
  *
  * Written by Christopher Hoover <ch@hpl.hp.com>
- * Based on fragments of previous driver by Rusell King et al.
+ * Based on fragments of previous driver by Russell King et al.
  *
  * This file is licenced under the GPL.
  */
 
-#include <asm/hardware.h>
+#include <mach/hardware.h>
 #include <asm/mach-types.h>
-#include <asm/arch/assabet.h>
-#include <asm/arch/badge4.h>
+#include <mach/assabet.h>
+#include <mach/badge4.h>
 #include <asm/hardware/sa1111.h>
 
 #ifndef CONFIG_SA1111
@@ -231,7 +231,6 @@
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff -urN host/ohci-sh.c host.new/ohci-sh.c
--- host/ohci-sh.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/ohci-sh.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,143 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ *
+ * Author : Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <linux/platform_device.h>
+
+static int ohci_sh_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+
+	ohci_hcd_init(ohci);
+	ohci_init(ohci);
+	ohci_run(ohci);
+	hcd->state = HC_STATE_RUNNING;
+	return 0;
+}
+
+static const struct hc_driver ohci_sh_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"SuperH OHCI",
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start =		ohci_sh_start,
+	.stop =			ohci_stop,
+	.shutdown =		ohci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
+#endif
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+/*-------------------------------------------------------------------------*/
+
+#define resource_len(r) (((r)->end - (r)->start) + 1)
+static int ohci_hcd_sh_probe(struct platform_device *pdev)
+{
+	struct resource *res = NULL;
+	struct usb_hcd *hcd = NULL;
+	int irq = -1;
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		err("platform_get_resource error.");
+		return -ENODEV;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		err("platform_get_irq error.");
+		return -ENODEV;
+	}
+
+	/* initialize hcd */
+	hcd = usb_create_hcd(&ohci_sh_hc_driver, &pdev->dev, (char *)hcd_name);
+	if (!hcd) {
+		err("Failed to create hcd");
+		return -ENOMEM;
+	}
+
+	hcd->regs = (void __iomem *)res->start;
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = resource_len(res);
+	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED);
+	if (ret != 0) {
+		err("Failed to add hcd");
+		usb_put_hcd(hcd);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int ohci_hcd_sh_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_remove_hcd(hcd);
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+static struct platform_driver ohci_hcd_sh_driver = {
+	.probe		= ohci_hcd_sh_probe,
+	.remove		= ohci_hcd_sh_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.driver		= {
+		.name	= "sh_ohci",
+		.owner	= THIS_MODULE,
+	},
+};
+
+MODULE_ALIAS("platform:sh_ohci");
diff -urN host/ohci-sm501.c host.new/ohci-sm501.c
--- host/ohci-sm501.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/ohci-sm501.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,265 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2005 David Brownell
+ * (C) Copyright 2002 Hewlett-Packard Company
+ * (C) Copyright 2008 Magnus Damm
+ *
+ * SM501 Bus Glue - based on ohci-omap.c
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/sm501.h>
+#include <linux/sm501-regs.h>
+
+static int ohci_sm501_init(struct usb_hcd *hcd)
+{
+	return ohci_init(hcd_to_ohci(hcd));
+}
+
+static int ohci_sm501_start(struct usb_hcd *hcd)
+{
+	struct device *dev = hcd->self.controller;
+	int ret;
+
+	ret = ohci_run(hcd_to_ohci(hcd));
+	if (ret < 0) {
+		dev_err(dev, "can't start %s", hcd->self.bus_name);
+		ohci_stop(hcd);
+	}
+
+	return ret;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ohci_sm501_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"SM501 OHCI",
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY | HCD_LOCAL_MEM,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset =		ohci_sm501_init,
+	.start =		ohci_sm501_start,
+	.stop =			ohci_stop,
+	.shutdown =		ohci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
+#endif
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int ohci_hcd_sm501_drv_probe(struct platform_device *pdev)
+{
+	const struct hc_driver *driver = &ohci_sm501_hc_driver;
+	struct device *dev = &pdev->dev;
+	struct resource	*res, *mem;
+	int retval, irq;
+	struct usb_hcd *hcd = NULL;
+
+	irq = retval = platform_get_irq(pdev, 0);
+	if (retval < 0)
+		goto err0;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (mem == NULL) {
+		dev_err(dev, "no resource definition for memory\n");
+		retval = -ENOENT;
+		goto err0;
+	}
+
+	if (!request_mem_region(mem->start, mem->end - mem->start + 1,
+				pdev->name)) {
+		dev_err(dev, "request_mem_region failed\n");
+		retval = -EBUSY;
+		goto err0;
+	}
+
+	/* The sm501 chip is equipped with local memory that may be used
+	 * by on-chip devices such as the video controller and the usb host.
+	 * This driver uses dma_declare_coherent_memory() to make sure
+	 * usb allocations with dma_alloc_coherent() allocate from
+	 * this local memory. The dma_handle returned by dma_alloc_coherent()
+	 * will be an offset starting from 0 for the first local memory byte.
+	 *
+	 * So as long as data is allocated using dma_alloc_coherent() all is
+	 * fine. This is however not always the case - buffers may be allocated
+	 * using kmalloc() - so the usb core needs to be told that it must copy
+	 * data into our local memory if the buffers happen to be placed in
+	 * regular memory. The HCD_LOCAL_MEM flag does just that.
+	 */
+
+	if (!dma_declare_coherent_memory(dev, mem->start,
+					 mem->start - mem->parent->start,
+					 (mem->end - mem->start) + 1,
+					 DMA_MEMORY_MAP |
+					 DMA_MEMORY_EXCLUSIVE)) {
+		dev_err(dev, "cannot declare coherent memory\n");
+		retval = -ENXIO;
+		goto err1;
+	}
+
+	/* allocate, reserve and remap resources for registers */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(dev, "no resource definition for registers\n");
+		retval = -ENOENT;
+		goto err2;
+	}
+
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = res->end - res->start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,	pdev->name)) {
+		dev_err(dev, "request_mem_region failed\n");
+		retval = -EBUSY;
+		goto err3;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (hcd->regs == NULL) {
+		dev_err(dev, "cannot remap registers\n");
+		retval = -ENXIO;
+		goto err4;
+	}
+
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
+	if (retval)
+		goto err4;
+
+	/* enable power and unmask interrupts */
+
+	sm501_unit_power(dev->parent, SM501_GATE_USB_HOST, 1);
+	sm501_modify_reg(dev->parent, SM501_IRQ_MASK, 1 << 6, 0);
+
+	return 0;
+err4:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err3:
+	usb_put_hcd(hcd);
+err2:
+	dma_release_declared_memory(dev);
+err1:
+	release_mem_region(mem->start, mem->end - mem->start + 1);
+err0:
+	return retval;
+}
+
+static int ohci_hcd_sm501_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct resource	*mem;
+
+	usb_remove_hcd(hcd);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+	dma_release_declared_memory(&pdev->dev);
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (mem)
+		release_mem_region(mem->start, mem->end - mem->start + 1);
+
+	/* mask interrupts and disable power */
+
+	sm501_modify_reg(pdev->dev.parent, SM501_IRQ_MASK, 0, 1 << 6);
+	sm501_unit_power(pdev->dev.parent, SM501_GATE_USB_HOST, 0);
+
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef CONFIG_PM
+static int ohci_sm501_suspend(struct platform_device *pdev, pm_message_t msg)
+{
+	struct device *dev = &pdev->dev;
+	struct ohci_hcd	*ohci = hcd_to_ohci(platform_get_drvdata(pdev));
+
+	if (time_before(jiffies, ohci->next_statechange))
+		msleep(5);
+	ohci->next_statechange = jiffies;
+
+	sm501_unit_power(dev->parent, SM501_GATE_USB_HOST, 0);
+	ohci_to_hcd(ohci)->state = HC_STATE_SUSPENDED;
+	return 0;
+}
+
+static int ohci_sm501_resume(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct usb_hcd	*hcd = platform_get_drvdata(pdev);
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+
+	if (time_before(jiffies, ohci->next_statechange))
+		msleep(5);
+	ohci->next_statechange = jiffies;
+
+	sm501_unit_power(dev->parent, SM501_GATE_USB_HOST, 1);
+	ohci_finish_controller_resume(hcd);
+	return 0;
+}
+#else
+#define ohci_sm501_suspend NULL
+#define ohci_sm501_resume NULL
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Driver definition to register with the SM501 bus
+ */
+static struct platform_driver ohci_hcd_sm501_driver = {
+	.probe		= ohci_hcd_sm501_drv_probe,
+	.remove		= ohci_hcd_sm501_drv_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.suspend	= ohci_sm501_suspend,
+	.resume		= ohci_sm501_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "sm501-usb",
+	},
+};
+MODULE_ALIAS("platform:sm501-usb");
diff -urN host/ohci-ssb.c host.new/ohci-ssb.c
--- host/ohci-ssb.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/ohci-ssb.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,214 @@
+/*
+ * Sonics Silicon Backplane
+ * Broadcom USB-core OHCI driver
+ *
+ * Copyright 2007 Michael Buesch <mb@bu3sch.de>
+ *
+ * Derived from the OHCI-PCI driver
+ * Copyright 1999 Roman Weissgaerber
+ * Copyright 2000-2002 David Brownell
+ * Copyright 1999 Linus Torvalds
+ * Copyright 1999 Gregory P. Smith
+ *
+ * Derived from the USBcore related parts of Broadcom-SB
+ * Copyright 2005 Broadcom Corporation
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+#include <linux/ssb/ssb.h>
+
+
+#define SSB_OHCI_TMSLOW_HOSTMODE	(1 << 29)
+
+struct ssb_ohci_device {
+	struct ohci_hcd ohci; /* _must_ be at the beginning. */
+
+	u32 enable_flags;
+};
+
+static inline
+struct ssb_ohci_device *hcd_to_ssb_ohci(struct usb_hcd *hcd)
+{
+	return (struct ssb_ohci_device *)(hcd->hcd_priv);
+}
+
+
+static int ssb_ohci_reset(struct usb_hcd *hcd)
+{
+	struct ssb_ohci_device *ohcidev = hcd_to_ssb_ohci(hcd);
+	struct ohci_hcd *ohci = &ohcidev->ohci;
+	int err;
+
+	ohci_hcd_init(ohci);
+	err = ohci_init(ohci);
+
+	return err;
+}
+
+static int ssb_ohci_start(struct usb_hcd *hcd)
+{
+	struct ssb_ohci_device *ohcidev = hcd_to_ssb_ohci(hcd);
+	struct ohci_hcd *ohci = &ohcidev->ohci;
+	int err;
+
+	err = ohci_run(ohci);
+	if (err < 0) {
+		ohci_err(ohci, "can't start\n");
+		ohci_stop(hcd);
+	}
+
+	return err;
+}
+
+static const struct hc_driver ssb_ohci_hc_driver = {
+	.description		= "ssb-usb-ohci",
+	.product_desc		= "SSB OHCI Controller",
+	.hcd_priv_size		= sizeof(struct ssb_ohci_device),
+
+	.irq			= ohci_irq,
+	.flags			= HCD_MEMORY | HCD_USB11,
+
+	.reset			= ssb_ohci_reset,
+	.start			= ssb_ohci_start,
+	.stop			= ohci_stop,
+	.shutdown		= ohci_shutdown,
+
+	.urb_enqueue		= ohci_urb_enqueue,
+	.urb_dequeue		= ohci_urb_dequeue,
+	.endpoint_disable	= ohci_endpoint_disable,
+
+	.get_frame_number	= ohci_get_frame,
+
+	.hub_status_data	= ohci_hub_status_data,
+	.hub_control		= ohci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend		= ohci_bus_suspend,
+	.bus_resume		= ohci_bus_resume,
+#endif
+
+	.start_port_reset	= ohci_start_port_reset,
+};
+
+static void ssb_ohci_detach(struct ssb_device *dev)
+{
+	struct usb_hcd *hcd = ssb_get_drvdata(dev);
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	usb_put_hcd(hcd);
+	ssb_device_disable(dev, 0);
+}
+
+static int ssb_ohci_attach(struct ssb_device *dev)
+{
+	struct ssb_ohci_device *ohcidev;
+	struct usb_hcd *hcd;
+	int err = -ENOMEM;
+	u32 tmp, flags = 0;
+
+	if (dev->id.coreid == SSB_DEV_USB11_HOSTDEV)
+		flags |= SSB_OHCI_TMSLOW_HOSTMODE;
+
+	ssb_device_enable(dev, flags);
+
+	hcd = usb_create_hcd(&ssb_ohci_hc_driver, dev->dev,
+			dev_name(dev->dev));
+	if (!hcd)
+		goto err_dev_disable;
+	ohcidev = hcd_to_ssb_ohci(hcd);
+	ohcidev->enable_flags = flags;
+
+	tmp = ssb_read32(dev, SSB_ADMATCH0);
+	hcd->rsrc_start = ssb_admatch_base(tmp);
+	hcd->rsrc_len = ssb_admatch_size(tmp);
+	hcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs)
+		goto err_put_hcd;
+	err = usb_add_hcd(hcd, dev->irq, IRQF_DISABLED | IRQF_SHARED);
+	if (err)
+		goto err_iounmap;
+
+	ssb_set_drvdata(dev, hcd);
+
+	return err;
+
+err_iounmap:
+	iounmap(hcd->regs);
+err_put_hcd:
+	usb_put_hcd(hcd);
+err_dev_disable:
+	ssb_device_disable(dev, flags);
+	return err;
+}
+
+static int ssb_ohci_probe(struct ssb_device *dev,
+		const struct ssb_device_id *id)
+{
+	int err;
+	u16 chipid_top;
+
+	/* USBcores are only connected on embedded devices. */
+	chipid_top = (dev->bus->chip_id & 0xFF00);
+	if (chipid_top != 0x4700 && chipid_top != 0x5300)
+		return -ENODEV;
+
+	/* TODO: Probably need checks here; is the core connected? */
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	/* We currently always attach SSB_DEV_USB11_HOSTDEV
+	 * as HOST OHCI. If we want to attach it as Client device,
+	 * we must branch here and call into the (yet to
+	 * be written) Client mode driver. Same for remove(). */
+
+	err = ssb_ohci_attach(dev);
+
+	return err;
+}
+
+static void ssb_ohci_remove(struct ssb_device *dev)
+{
+	ssb_ohci_detach(dev);
+}
+
+#ifdef CONFIG_PM
+
+static int ssb_ohci_suspend(struct ssb_device *dev, pm_message_t state)
+{
+	ssb_device_disable(dev, 0);
+
+	return 0;
+}
+
+static int ssb_ohci_resume(struct ssb_device *dev)
+{
+	struct usb_hcd *hcd = ssb_get_drvdata(dev);
+	struct ssb_ohci_device *ohcidev = hcd_to_ssb_ohci(hcd);
+
+	ssb_device_enable(dev, ohcidev->enable_flags);
+
+	ohci_finish_controller_resume(hcd);
+	return 0;
+}
+
+#else /* !CONFIG_PM */
+#define ssb_ohci_suspend	NULL
+#define ssb_ohci_resume	NULL
+#endif /* CONFIG_PM */
+
+static const struct ssb_device_id ssb_ohci_table[] = {
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB11_HOSTDEV, SSB_ANY_REV),
+	SSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB11_HOST, SSB_ANY_REV),
+	SSB_DEVTABLE_END
+};
+MODULE_DEVICE_TABLE(ssb, ssb_ohci_table);
+
+static struct ssb_driver ssb_ohci_driver = {
+	.name		= KBUILD_MODNAME,
+	.id_table	= ssb_ohci_table,
+	.probe		= ssb_ohci_probe,
+	.remove		= ssb_ohci_remove,
+	.suspend	= ssb_ohci_suspend,
+	.resume		= ssb_ohci_resume,
+};
diff -urN host/ohci-tmio.c host.new/ohci-tmio.c
--- host/ohci-tmio.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/ohci-tmio.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,376 @@
+/*
+ * OHCI HCD(Host Controller Driver) for USB.
+ *
+ *(C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ *(C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
+ *(C) Copyright 2002 Hewlett-Packard Company
+ *
+ * Bus glue for Toshiba Mobile IO(TMIO) Controller's OHCI core
+ * (C) Copyright 2005 Chris Humbert <mahadri-usb@drigon.com>
+ * (C) Copyright 2007, 2008 Dmitry Baryshkov <dbaryshkov@gmail.com>
+ *
+ * This is known to work with the following variants:
+ *	TC6393XB revision 3	(32kB SRAM)
+ *
+ * The TMIO's OHCI core DMAs through a small internal buffer that
+ * is directly addressable by the CPU.
+ *
+ * Written from sparse documentation from Toshiba and Sharp's driver
+ * for the 2.4 kernel,
+ *	usb-ohci-tc6393.c(C) Copyright 2004 Lineo Solutions, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*#include <linux/fs.h>
+#include <linux/mount.h>
+#include <linux/pagemap.h>
+#include <linux/init.h>
+#include <linux/namei.h>
+#include <linux/sched.h>*/
+#include <linux/platform_device.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/tmio.h>
+#include <linux/dma-mapping.h>
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * USB Host Controller Configuration Register
+ */
+#define CCR_REVID	0x08	/* b Revision ID				*/
+#define CCR_BASE	0x10	/* l USB Control Register Base Address Low	*/
+#define CCR_ILME	0x40	/* b Internal Local Memory Enable		*/
+#define CCR_PM		0x4c	/* w Power Management			*/
+#define CCR_INTC	0x50	/* b INT Control				*/
+#define CCR_LMW1L	0x54	/* w Local Memory Window 1 LMADRS Low	*/
+#define CCR_LMW1H	0x56	/* w Local Memory Window 1 LMADRS High	*/
+#define CCR_LMW1BL	0x58	/* w Local Memory Window 1 Base Address Low	*/
+#define CCR_LMW1BH	0x5A	/* w Local Memory Window 1 Base Address High	*/
+#define CCR_LMW2L	0x5C	/* w Local Memory Window 2 LMADRS Low	*/
+#define CCR_LMW2H	0x5E	/* w Local Memory Window 2 LMADRS High	*/
+#define CCR_LMW2BL	0x60	/* w Local Memory Window 2 Base Address Low	*/
+#define CCR_LMW2BH	0x62	/* w Local Memory Window 2 Base Address High	*/
+#define CCR_MISC	0xFC	/* b MISC					*/
+
+#define CCR_PM_GKEN      0x0001
+#define CCR_PM_CKRNEN    0x0002
+#define CCR_PM_USBPW1    0x0004
+#define CCR_PM_USBPW2    0x0008
+#define CCR_PM_USBPW3    0x0008
+#define CCR_PM_PMEE      0x0100
+#define CCR_PM_PMES      0x8000
+
+/*-------------------------------------------------------------------------*/
+
+struct tmio_hcd {
+	void __iomem		*ccr;
+	spinlock_t		lock; /* protects RMW cycles */
+};
+
+#define hcd_to_tmio(hcd)	((struct tmio_hcd *)(hcd_to_ohci(hcd) + 1))
+
+/*-------------------------------------------------------------------------*/
+
+static void tmio_write_pm(struct platform_device *dev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(dev);
+	struct tmio_hcd *tmio = hcd_to_tmio(hcd);
+	u16 pm;
+	unsigned long flags;
+
+	spin_lock_irqsave(&tmio->lock, flags);
+
+	pm = CCR_PM_GKEN | CCR_PM_CKRNEN |
+	     CCR_PM_PMEE | CCR_PM_PMES;
+
+	tmio_iowrite16(pm, tmio->ccr + CCR_PM);
+	spin_unlock_irqrestore(&tmio->lock, flags);
+}
+
+static void tmio_stop_hc(struct platform_device *dev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(dev);
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	struct tmio_hcd *tmio = hcd_to_tmio(hcd);
+	u16 pm;
+
+	pm = CCR_PM_GKEN | CCR_PM_CKRNEN;
+	switch (ohci->num_ports) {
+		default:
+			dev_err(&dev->dev, "Unsupported amount of ports: %d\n", ohci->num_ports);
+		case 3:
+			pm |= CCR_PM_USBPW3;
+		case 2:
+			pm |= CCR_PM_USBPW2;
+		case 1:
+			pm |= CCR_PM_USBPW1;
+	}
+	tmio_iowrite8(0, tmio->ccr + CCR_INTC);
+	tmio_iowrite8(0, tmio->ccr + CCR_ILME);
+	tmio_iowrite16(0, tmio->ccr + CCR_BASE);
+	tmio_iowrite16(0, tmio->ccr + CCR_BASE + 2);
+	tmio_iowrite16(pm, tmio->ccr + CCR_PM);
+}
+
+static void tmio_start_hc(struct platform_device *dev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(dev);
+	struct tmio_hcd *tmio = hcd_to_tmio(hcd);
+	unsigned long base = hcd->rsrc_start;
+
+	tmio_write_pm(dev);
+	tmio_iowrite16(base, tmio->ccr + CCR_BASE);
+	tmio_iowrite16(base >> 16, tmio->ccr + CCR_BASE + 2);
+	tmio_iowrite8(1, tmio->ccr + CCR_ILME);
+	tmio_iowrite8(2, tmio->ccr + CCR_INTC);
+
+	dev_info(&dev->dev, "revision %d @ 0x%08llx, irq %d\n",
+			tmio_ioread8(tmio->ccr + CCR_REVID), hcd->rsrc_start, hcd->irq);
+}
+
+static int ohci_tmio_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	int ret;
+
+	if ((ret = ohci_init(ohci)) < 0)
+		return ret;
+
+	if ((ret = ohci_run(ohci)) < 0) {
+		err("can't start %s", hcd->self.bus_name);
+		ohci_stop(hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct hc_driver ohci_tmio_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"TMIO OHCI USB Host Controller",
+	.hcd_priv_size =	sizeof(struct ohci_hcd) + sizeof (struct tmio_hcd),
+
+	/* generic hardware linkage */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY | HCD_LOCAL_MEM,
+
+	/* basic lifecycle operations */
+	.start =		ohci_tmio_start,
+	.stop =			ohci_stop,
+	.shutdown =		ohci_shutdown,
+
+	/* managing i/o requests and associated device resources */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/* scheduling support */
+	.get_frame_number =	ohci_get_frame,
+
+	/* root hub support */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
+#endif
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+/*-------------------------------------------------------------------------*/
+static struct platform_driver ohci_hcd_tmio_driver;
+
+static int __devinit ohci_hcd_tmio_drv_probe(struct platform_device *dev)
+{
+	struct mfd_cell *cell = dev->dev.platform_data;
+	struct resource *regs = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	struct resource *config = platform_get_resource(dev, IORESOURCE_MEM, 1);
+	struct resource *sram = platform_get_resource(dev, IORESOURCE_MEM, 2);
+	int irq = platform_get_irq(dev, 0);
+	struct tmio_hcd *tmio;
+	struct ohci_hcd *ohci;
+	struct usb_hcd *hcd;
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	if (!cell)
+		return -EINVAL;
+
+	hcd = usb_create_hcd(&ohci_tmio_hc_driver, &dev->dev, dev_name(&dev->dev));
+	if (!hcd) {
+		ret = -ENOMEM;
+		goto err_usb_create_hcd;
+	}
+
+	hcd->rsrc_start = regs->start;
+	hcd->rsrc_len = regs->end - regs->start + 1;
+
+	tmio = hcd_to_tmio(hcd);
+
+	spin_lock_init(&tmio->lock);
+
+	tmio->ccr = ioremap(config->start, config->end - config->start + 1);
+	if (!tmio->ccr) {
+		ret = -ENOMEM;
+		goto err_ioremap_ccr;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		ret = -ENOMEM;
+		goto err_ioremap_regs;
+	}
+
+	if (!dma_declare_coherent_memory(&dev->dev, sram->start,
+				sram->start,
+				sram->end - sram->start + 1,
+				DMA_MEMORY_MAP | DMA_MEMORY_EXCLUSIVE)) {
+		ret = -EBUSY;
+		goto err_dma_declare;
+	}
+
+	if (cell->enable) {
+		ret = cell->enable(dev);
+		if (ret)
+			goto err_enable;
+	}
+
+	tmio_start_hc(dev);
+	ohci = hcd_to_ohci(hcd);
+	ohci_hcd_init(ohci);
+
+	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED);
+	if (ret)
+		goto err_add_hcd;
+
+	if (ret == 0)
+		return ret;
+
+	usb_remove_hcd(hcd);
+
+err_add_hcd:
+	tmio_stop_hc(dev);
+	if (cell->disable)
+		cell->disable(dev);
+err_enable:
+	dma_release_declared_memory(&dev->dev);
+err_dma_declare:
+	iounmap(hcd->regs);
+err_ioremap_regs:
+	iounmap(tmio->ccr);
+err_ioremap_ccr:
+	usb_put_hcd(hcd);
+err_usb_create_hcd:
+
+	return ret;
+}
+
+static int __devexit ohci_hcd_tmio_drv_remove(struct platform_device *dev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(dev);
+	struct tmio_hcd *tmio = hcd_to_tmio(hcd);
+	struct mfd_cell *cell = dev->dev.platform_data;
+
+	usb_remove_hcd(hcd);
+	tmio_stop_hc(dev);
+	if (cell->disable)
+		cell->disable(dev);
+	dma_release_declared_memory(&dev->dev);
+	iounmap(hcd->regs);
+	iounmap(tmio->ccr);
+	usb_put_hcd(hcd);
+
+	platform_set_drvdata(dev, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ohci_hcd_tmio_drv_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct mfd_cell *cell = dev->dev.platform_data;
+	struct usb_hcd *hcd = platform_get_drvdata(dev);
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	struct tmio_hcd *tmio = hcd_to_tmio(hcd);
+	unsigned long flags;
+	u8 misc;
+	int ret;
+
+	if (time_before(jiffies, ohci->next_statechange))
+		msleep(5);
+	ohci->next_statechange = jiffies;
+
+	spin_lock_irqsave(&tmio->lock, flags);
+
+	misc = tmio_ioread8(tmio->ccr + CCR_MISC);
+	misc |= 1 << 3; /* USSUSP */
+	tmio_iowrite8(misc, tmio->ccr + CCR_MISC);
+
+	spin_unlock_irqrestore(&tmio->lock, flags);
+
+	if (cell->suspend) {
+		ret = cell->suspend(dev);
+		if (ret)
+			return ret;
+	}
+
+	hcd->state = HC_STATE_SUSPENDED;
+
+	return 0;
+}
+
+static int ohci_hcd_tmio_drv_resume(struct platform_device *dev)
+{
+	struct mfd_cell *cell = dev->dev.platform_data;
+	struct usb_hcd *hcd = platform_get_drvdata(dev);
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	struct tmio_hcd *tmio = hcd_to_tmio(hcd);
+	unsigned long flags;
+	u8 misc;
+	int ret;
+
+	if (time_before(jiffies, ohci->next_statechange))
+		msleep(5);
+	ohci->next_statechange = jiffies;
+
+	if (cell->resume) {
+		ret = cell->resume(dev);
+		if (ret)
+			return ret;
+	}
+
+	tmio_start_hc(dev);
+
+	spin_lock_irqsave(&tmio->lock, flags);
+
+	misc = tmio_ioread8(tmio->ccr + CCR_MISC);
+	misc &= ~(1 << 3); /* USSUSP */
+	tmio_iowrite8(misc, tmio->ccr + CCR_MISC);
+
+	spin_unlock_irqrestore(&tmio->lock, flags);
+
+	ohci_finish_controller_resume(hcd);
+
+	return 0;
+}
+#else
+#define ohci_hcd_tmio_drv_suspend NULL
+#define ohci_hcd_tmio_drv_resume NULL
+#endif
+
+static struct platform_driver ohci_hcd_tmio_driver = {
+	.probe		= ohci_hcd_tmio_drv_probe,
+	.remove		= __devexit_p(ohci_hcd_tmio_drv_remove),
+	.shutdown	= usb_hcd_platform_shutdown,
+	.suspend	= ohci_hcd_tmio_drv_suspend,
+	.resume		= ohci_hcd_tmio_drv_resume,
+	.driver		= {
+		.name	= "tmio-ohci",
+		.owner	= THIS_MODULE,
+	},
+};
diff -urN host/ohci.h host.new/ohci.h
--- host/ohci.h	2009-02-24 19:00:15.539963336 +0100
+++ host.new/ohci.h	2009-03-28 17:46:02.000000000 +0100
@@ -371,6 +371,7 @@
 	 * other external transceivers should be software-transparent
 	 */
 	struct otg_transceiver	*transceiver;
+	void (*start_hnp)(struct ohci_hcd *ohci);
 
 	/*
 	 * memory management for queue data structures
@@ -398,11 +399,55 @@
 #define	OHCI_QUIRK_BE_MMIO	0x10			/* BE registers */
 #define	OHCI_QUIRK_ZFMICRO	0x20			/* Compaq ZFMicro chipset*/
 #define	OHCI_QUIRK_NEC		0x40			/* lost interrupts */
+#define	OHCI_QUIRK_FRAME_NO	0x80			/* no big endian frame_no shift */
+#define	OHCI_QUIRK_HUB_POWER	0x100			/* distrust firmware power/oc setup */
+#define	OHCI_QUIRK_AMD_ISO	0x200			/* ISO transfers*/
 	// there are also chip quirks/bugs in init logic
 
 	struct work_struct	nec_work;	/* Worker for NEC quirk */
+
+	/* Needed for ZF Micro quirk */
+	struct timer_list	unlink_watchdog;
+	unsigned		eds_scheduled;
+	struct ed		*ed_to_check;
+	unsigned		zf_delay;
+
+#ifdef DEBUG
+	struct dentry		*debug_dir;
+	struct dentry		*debug_async;
+	struct dentry		*debug_periodic;
+	struct dentry		*debug_registers;
+#endif
 };
 
+#ifdef CONFIG_PCI
+static inline int quirk_nec(struct ohci_hcd *ohci)
+{
+	return ohci->flags & OHCI_QUIRK_NEC;
+}
+static inline int quirk_zfmicro(struct ohci_hcd *ohci)
+{
+	return ohci->flags & OHCI_QUIRK_ZFMICRO;
+}
+static inline int quirk_amdiso(struct ohci_hcd *ohci)
+{
+	return ohci->flags & OHCI_QUIRK_AMD_ISO;
+}
+#else
+static inline int quirk_nec(struct ohci_hcd *ohci)
+{
+	return 0;
+}
+static inline int quirk_zfmicro(struct ohci_hcd *ohci)
+{
+	return 0;
+}
+static inline int quirk_amdiso(struct ohci_hcd *ohci)
+{
+	return 0;
+}
+#endif
+
 /* convert between an hcd pointer and the corresponding ohci_hcd */
 static inline struct ohci_hcd *hcd_to_ohci (struct usb_hcd *hcd)
 {
@@ -495,15 +540,7 @@
  * Big-endian read/write functions are arch-specific.
  * Other arches can be added if/when they're needed.
  *
- * REVISIT: arch/powerpc now has readl/writel_be, so the
- * definition below can die once the STB04xxx support is
- * finally ported over.
  */
-#if defined(CONFIG_PPC) && !defined(CONFIG_PPC_MERGE)
-#define readl_be(addr)		in_be32((__force unsigned *)addr)
-#define writel_be(val, addr)	out_be32((__force unsigned *)addr, val)
-#endif
-
 static inline unsigned int _ohci_readl (const struct ohci_hcd *ohci,
 					__hc32 __iomem * regs)
 {
@@ -607,15 +644,12 @@
 /* HCCA frame number is 16 bits, but is accessed as 32 bits since not all
  * hardware handles 16 bit reads.  That creates a different confusion on
  * some big-endian SOC implementations.  Same thing happens with PSW access.
- *
- * FIXME: Deal with that as a runtime quirk when STB03xxx is ported over
- * to arch/powerpc
  */
 
-#ifdef CONFIG_STB03xxx
-#define OHCI_BE_FRAME_NO_SHIFT	16
+#ifdef CONFIG_PPC_MPC52xx
+#define big_endian_frame_no_quirk(ohci)	(ohci->flags & OHCI_QUIRK_FRAME_NO)
 #else
-#define OHCI_BE_FRAME_NO_SHIFT	0
+#define big_endian_frame_no_quirk(ohci)	0
 #endif
 
 static inline u16 ohci_frame_no(const struct ohci_hcd *ohci)
@@ -623,7 +657,8 @@
 	u32 tmp;
 	if (big_endian_desc(ohci)) {
 		tmp = be32_to_cpup((__force __be32 *)&ohci->hcca->frame_no);
-		tmp >>= OHCI_BE_FRAME_NO_SHIFT;
+		if (!big_endian_frame_no_quirk(ohci))
+			tmp >>= 16;
 	} else
 		tmp = le32_to_cpup((__force __le32 *)&ohci->hcca->frame_no);
 
diff -urN host/oxu210hp-hcd.c host.new/oxu210hp-hcd.c
--- host/oxu210hp-hcd.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/oxu210hp-hcd.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,3985 @@
+/*
+ * Copyright (c) 2008 Rodolfo Giometti <giometti@linux.it>
+ * Copyright (c) 2008 Eurotech S.p.A. <info@eurtech.it>
+ *
+ * This code is *strongly* based on EHCI-HCD code by David Brownell since
+ * the chip is a quasi-EHCI compatible.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/dmapool.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/reboot.h>
+#include <linux/usb.h>
+#include <linux/moduleparam.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+
+#include "../core/hcd.h"
+
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+
+#include "oxu210hp.h"
+
+#define DRIVER_VERSION "0.0.50"
+
+/*
+ * Main defines
+ */
+
+#define oxu_dbg(oxu, fmt, args...) \
+		dev_dbg(oxu_to_hcd(oxu)->self.controller , fmt , ## args)
+#define oxu_err(oxu, fmt, args...) \
+		dev_err(oxu_to_hcd(oxu)->self.controller , fmt , ## args)
+#define oxu_info(oxu, fmt, args...) \
+		dev_info(oxu_to_hcd(oxu)->self.controller , fmt , ## args)
+
+static inline struct usb_hcd *oxu_to_hcd(struct oxu_hcd *oxu)
+{
+	return container_of((void *) oxu, struct usb_hcd, hcd_priv);
+}
+
+static inline struct oxu_hcd *hcd_to_oxu(struct usb_hcd *hcd)
+{
+	return (struct oxu_hcd *) (hcd->hcd_priv);
+}
+
+/*
+ * Debug stuff
+ */
+
+#undef OXU_URB_TRACE
+#undef OXU_VERBOSE_DEBUG
+
+#ifdef OXU_VERBOSE_DEBUG
+#define oxu_vdbg			oxu_dbg
+#else
+#define oxu_vdbg(oxu, fmt, args...)	/* Nop */
+#endif
+
+#ifdef DEBUG
+
+static int __attribute__((__unused__))
+dbg_status_buf(char *buf, unsigned len, const char *label, u32 status)
+{
+	return scnprintf(buf, len, "%s%sstatus %04x%s%s%s%s%s%s%s%s%s%s",
+		label, label[0] ? " " : "", status,
+		(status & STS_ASS) ? " Async" : "",
+		(status & STS_PSS) ? " Periodic" : "",
+		(status & STS_RECL) ? " Recl" : "",
+		(status & STS_HALT) ? " Halt" : "",
+		(status & STS_IAA) ? " IAA" : "",
+		(status & STS_FATAL) ? " FATAL" : "",
+		(status & STS_FLR) ? " FLR" : "",
+		(status & STS_PCD) ? " PCD" : "",
+		(status & STS_ERR) ? " ERR" : "",
+		(status & STS_INT) ? " INT" : ""
+		);
+}
+
+static int __attribute__((__unused__))
+dbg_intr_buf(char *buf, unsigned len, const char *label, u32 enable)
+{
+	return scnprintf(buf, len, "%s%sintrenable %02x%s%s%s%s%s%s",
+		label, label[0] ? " " : "", enable,
+		(enable & STS_IAA) ? " IAA" : "",
+		(enable & STS_FATAL) ? " FATAL" : "",
+		(enable & STS_FLR) ? " FLR" : "",
+		(enable & STS_PCD) ? " PCD" : "",
+		(enable & STS_ERR) ? " ERR" : "",
+		(enable & STS_INT) ? " INT" : ""
+		);
+}
+
+static const char *const fls_strings[] =
+    { "1024", "512", "256", "??" };
+
+static int dbg_command_buf(char *buf, unsigned len,
+				const char *label, u32 command)
+{
+	return scnprintf(buf, len,
+		"%s%scommand %06x %s=%d ithresh=%d%s%s%s%s period=%s%s %s",
+		label, label[0] ? " " : "", command,
+		(command & CMD_PARK) ? "park" : "(park)",
+		CMD_PARK_CNT(command),
+		(command >> 16) & 0x3f,
+		(command & CMD_LRESET) ? " LReset" : "",
+		(command & CMD_IAAD) ? " IAAD" : "",
+		(command & CMD_ASE) ? " Async" : "",
+		(command & CMD_PSE) ? " Periodic" : "",
+		fls_strings[(command >> 2) & 0x3],
+		(command & CMD_RESET) ? " Reset" : "",
+		(command & CMD_RUN) ? "RUN" : "HALT"
+		);
+}
+
+static int dbg_port_buf(char *buf, unsigned len, const char *label,
+				int port, u32 status)
+{
+	char	*sig;
+
+	/* signaling state */
+	switch (status & (3 << 10)) {
+	case 0 << 10:
+		sig = "se0";
+		break;
+	case 1 << 10:
+		sig = "k";	/* low speed */
+		break;
+	case 2 << 10:
+		sig = "j";
+		break;
+	default:
+		sig = "?";
+		break;
+	}
+
+	return scnprintf(buf, len,
+		"%s%sport %d status %06x%s%s sig=%s%s%s%s%s%s%s%s%s%s",
+		label, label[0] ? " " : "", port, status,
+		(status & PORT_POWER) ? " POWER" : "",
+		(status & PORT_OWNER) ? " OWNER" : "",
+		sig,
+		(status & PORT_RESET) ? " RESET" : "",
+		(status & PORT_SUSPEND) ? " SUSPEND" : "",
+		(status & PORT_RESUME) ? " RESUME" : "",
+		(status & PORT_OCC) ? " OCC" : "",
+		(status & PORT_OC) ? " OC" : "",
+		(status & PORT_PEC) ? " PEC" : "",
+		(status & PORT_PE) ? " PE" : "",
+		(status & PORT_CSC) ? " CSC" : "",
+		(status & PORT_CONNECT) ? " CONNECT" : ""
+	    );
+}
+
+#else
+
+static inline int __attribute__((__unused__))
+dbg_status_buf(char *buf, unsigned len, const char *label, u32 status)
+{ return 0; }
+
+static inline int __attribute__((__unused__))
+dbg_command_buf(char *buf, unsigned len, const char *label, u32 command)
+{ return 0; }
+
+static inline int __attribute__((__unused__))
+dbg_intr_buf(char *buf, unsigned len, const char *label, u32 enable)
+{ return 0; }
+
+static inline int __attribute__((__unused__))
+dbg_port_buf(char *buf, unsigned len, const char *label, int port, u32 status)
+{ return 0; }
+
+#endif /* DEBUG */
+
+/* functions have the "wrong" filename when they're output... */
+#define dbg_status(oxu, label, status) { \
+	char _buf[80]; \
+	dbg_status_buf(_buf, sizeof _buf, label, status); \
+	oxu_dbg(oxu, "%s\n", _buf); \
+}
+
+#define dbg_cmd(oxu, label, command) { \
+	char _buf[80]; \
+	dbg_command_buf(_buf, sizeof _buf, label, command); \
+	oxu_dbg(oxu, "%s\n", _buf); \
+}
+
+#define dbg_port(oxu, label, port, status) { \
+	char _buf[80]; \
+	dbg_port_buf(_buf, sizeof _buf, label, port, status); \
+	oxu_dbg(oxu, "%s\n", _buf); \
+}
+
+/*
+ * Module parameters
+ */
+
+/* Initial IRQ latency: faster than hw default */
+static int log2_irq_thresh;			/* 0 to 6 */
+module_param(log2_irq_thresh, int, S_IRUGO);
+MODULE_PARM_DESC(log2_irq_thresh, "log2 IRQ latency, 1-64 microframes");
+
+/* Initial park setting: slower than hw default */
+static unsigned park;
+module_param(park, uint, S_IRUGO);
+MODULE_PARM_DESC(park, "park setting; 1-3 back-to-back async packets");
+
+/* For flakey hardware, ignore overcurrent indicators */
+static int ignore_oc;
+module_param(ignore_oc, bool, S_IRUGO);
+MODULE_PARM_DESC(ignore_oc, "ignore bogus hardware overcurrent indications");
+
+
+static void ehci_work(struct oxu_hcd *oxu);
+static int oxu_hub_control(struct usb_hcd *hcd,
+				u16 typeReq, u16 wValue, u16 wIndex,
+				char *buf, u16 wLength);
+
+/*
+ * Local functions
+ */
+
+/* Low level read/write registers functions */
+static inline u32 oxu_readl(void *base, u32 reg)
+{
+	return readl(base + reg);
+}
+
+static inline void oxu_writel(void *base, u32 reg, u32 val)
+{
+	writel(val, base + reg);
+}
+
+static inline void timer_action_done(struct oxu_hcd *oxu,
+					enum ehci_timer_action action)
+{
+	clear_bit(action, &oxu->actions);
+}
+
+static inline void timer_action(struct oxu_hcd *oxu,
+					enum ehci_timer_action action)
+{
+	if (!test_and_set_bit(action, &oxu->actions)) {
+		unsigned long t;
+
+		switch (action) {
+		case TIMER_IAA_WATCHDOG:
+			t = EHCI_IAA_JIFFIES;
+			break;
+		case TIMER_IO_WATCHDOG:
+			t = EHCI_IO_JIFFIES;
+			break;
+		case TIMER_ASYNC_OFF:
+			t = EHCI_ASYNC_JIFFIES;
+			break;
+		case TIMER_ASYNC_SHRINK:
+		default:
+			t = EHCI_SHRINK_JIFFIES;
+			break;
+		}
+		t += jiffies;
+		/* all timings except IAA watchdog can be overridden.
+		 * async queue SHRINK often precedes IAA.  while it's ready
+		 * to go OFF neither can matter, and afterwards the IO
+		 * watchdog stops unless there's still periodic traffic.
+		 */
+		if (action != TIMER_IAA_WATCHDOG
+				&& t > oxu->watchdog.expires
+				&& timer_pending(&oxu->watchdog))
+			return;
+		mod_timer(&oxu->watchdog, t);
+	}
+}
+
+/*
+ * handshake - spin reading hc until handshake completes or fails
+ * @ptr: address of hc register to be read
+ * @mask: bits to look at in result of read
+ * @done: value of those bits when handshake succeeds
+ * @usec: timeout in microseconds
+ *
+ * Returns negative errno, or zero on success
+ *
+ * Success happens when the "mask" bits have the specified value (hardware
+ * handshake done).  There are two failure modes:  "usec" have passed (major
+ * hardware flakeout), or the register reads as all-ones (hardware removed).
+ *
+ * That last failure should_only happen in cases like physical cardbus eject
+ * before driver shutdown. But it also seems to be caused by bugs in cardbus
+ * bridge shutdown:  shutting down the bridge before the devices using it.
+ */
+static int handshake(struct oxu_hcd *oxu, void __iomem *ptr,
+					u32 mask, u32 done, int usec)
+{
+	u32 result;
+
+	do {
+		result = readl(ptr);
+		if (result == ~(u32)0)		/* card removed */
+			return -ENODEV;
+		result &= mask;
+		if (result == done)
+			return 0;
+		udelay(1);
+		usec--;
+	} while (usec > 0);
+	return -ETIMEDOUT;
+}
+
+/* Force HC to halt state from unknown (EHCI spec section 2.3) */
+static int ehci_halt(struct oxu_hcd *oxu)
+{
+	u32	temp = readl(&oxu->regs->status);
+
+	/* disable any irqs left enabled by previous code */
+	writel(0, &oxu->regs->intr_enable);
+
+	if ((temp & STS_HALT) != 0)
+		return 0;
+
+	temp = readl(&oxu->regs->command);
+	temp &= ~CMD_RUN;
+	writel(temp, &oxu->regs->command);
+	return handshake(oxu, &oxu->regs->status,
+			  STS_HALT, STS_HALT, 16 * 125);
+}
+
+/* Put TDI/ARC silicon into EHCI mode */
+static void tdi_reset(struct oxu_hcd *oxu)
+{
+	u32 __iomem *reg_ptr;
+	u32 tmp;
+
+	reg_ptr = (u32 __iomem *)(((u8 __iomem *)oxu->regs) + 0x68);
+	tmp = readl(reg_ptr);
+	tmp |= 0x3;
+	writel(tmp, reg_ptr);
+}
+
+/* Reset a non-running (STS_HALT == 1) controller */
+static int ehci_reset(struct oxu_hcd *oxu)
+{
+	int	retval;
+	u32	command = readl(&oxu->regs->command);
+
+	command |= CMD_RESET;
+	dbg_cmd(oxu, "reset", command);
+	writel(command, &oxu->regs->command);
+	oxu_to_hcd(oxu)->state = HC_STATE_HALT;
+	oxu->next_statechange = jiffies;
+	retval = handshake(oxu, &oxu->regs->command,
+			    CMD_RESET, 0, 250 * 1000);
+
+	if (retval)
+		return retval;
+
+	tdi_reset(oxu);
+
+	return retval;
+}
+
+/* Idle the controller (from running) */
+static void ehci_quiesce(struct oxu_hcd *oxu)
+{
+	u32	temp;
+
+#ifdef DEBUG
+	if (!HC_IS_RUNNING(oxu_to_hcd(oxu)->state))
+		BUG();
+#endif
+
+	/* wait for any schedule enables/disables to take effect */
+	temp = readl(&oxu->regs->command) << 10;
+	temp &= STS_ASS | STS_PSS;
+	if (handshake(oxu, &oxu->regs->status, STS_ASS | STS_PSS,
+				temp, 16 * 125) != 0) {
+		oxu_to_hcd(oxu)->state = HC_STATE_HALT;
+		return;
+	}
+
+	/* then disable anything that's still active */
+	temp = readl(&oxu->regs->command);
+	temp &= ~(CMD_ASE | CMD_IAAD | CMD_PSE);
+	writel(temp, &oxu->regs->command);
+
+	/* hardware can take 16 microframes to turn off ... */
+	if (handshake(oxu, &oxu->regs->status, STS_ASS | STS_PSS,
+				0, 16 * 125) != 0) {
+		oxu_to_hcd(oxu)->state = HC_STATE_HALT;
+		return;
+	}
+}
+
+static int check_reset_complete(struct oxu_hcd *oxu, int index,
+				u32 __iomem *status_reg, int port_status)
+{
+	if (!(port_status & PORT_CONNECT)) {
+		oxu->reset_done[index] = 0;
+		return port_status;
+	}
+
+	/* if reset finished and it's still not enabled -- handoff */
+	if (!(port_status & PORT_PE)) {
+		oxu_dbg(oxu, "Failed to enable port %d on root hub TT\n",
+				index+1);
+		return port_status;
+	} else
+		oxu_dbg(oxu, "port %d high speed\n", index + 1);
+
+	return port_status;
+}
+
+static void ehci_hub_descriptor(struct oxu_hcd *oxu,
+				struct usb_hub_descriptor *desc)
+{
+	int ports = HCS_N_PORTS(oxu->hcs_params);
+	u16 temp;
+
+	desc->bDescriptorType = 0x29;
+	desc->bPwrOn2PwrGood = 10;	/* oxu 1.0, 2.3.9 says 20ms max */
+	desc->bHubContrCurrent = 0;
+
+	desc->bNbrPorts = ports;
+	temp = 1 + (ports / 8);
+	desc->bDescLength = 7 + 2 * temp;
+
+	/* two bitmaps:  ports removable, and usb 1.0 legacy PortPwrCtrlMask */
+	memset(&desc->bitmap[0], 0, temp);
+	memset(&desc->bitmap[temp], 0xff, temp);
+
+	temp = 0x0008;			/* per-port overcurrent reporting */
+	if (HCS_PPC(oxu->hcs_params))
+		temp |= 0x0001;		/* per-port power control */
+	else
+		temp |= 0x0002;		/* no power switching */
+	desc->wHubCharacteristics = (__force __u16)cpu_to_le16(temp);
+}
+
+
+/* Allocate an OXU210HP on-chip memory data buffer
+ *
+ * An on-chip memory data buffer is required for each OXU210HP USB transfer.
+ * Each transfer descriptor has one or more on-chip memory data buffers.
+ *
+ * Data buffers are allocated from a fix sized pool of data blocks.
+ * To minimise fragmentation and give reasonable memory utlisation,
+ * data buffers are allocated with sizes the power of 2 multiples of
+ * the block size, starting on an address a multiple of the allocated size.
+ *
+ * FIXME: callers of this function require a buffer to be allocated for
+ * len=0. This is a waste of on-chip memory and should be fix. Then this
+ * function should be changed to not allocate a buffer for len=0.
+ */
+static int oxu_buf_alloc(struct oxu_hcd *oxu, struct ehci_qtd *qtd, int len)
+{
+	int n_blocks;	/* minium blocks needed to hold len */
+	int a_blocks;	/* blocks allocated */
+	int i, j;
+
+	/* Don't allocte bigger than supported */
+	if (len > BUFFER_SIZE * BUFFER_NUM) {
+		oxu_err(oxu, "buffer too big (%d)\n", len);
+		return -ENOMEM;
+	}
+
+	spin_lock(&oxu->mem_lock);
+
+	/* Number of blocks needed to hold len */
+	n_blocks = (len + BUFFER_SIZE - 1) / BUFFER_SIZE;
+
+	/* Round the number of blocks up to the power of 2 */
+	for (a_blocks = 1; a_blocks < n_blocks; a_blocks <<= 1)
+		;
+
+	/* Find a suitable available data buffer */
+	for (i = 0; i < BUFFER_NUM;
+			i += max(a_blocks, (int)oxu->db_used[i])) {
+
+		/* Check all the required blocks are available */
+		for (j = 0; j < a_blocks; j++)
+			if (oxu->db_used[i + j])
+				break;
+
+		if (j != a_blocks)
+			continue;
+
+		/* Allocate blocks found! */
+		qtd->buffer = (void *) &oxu->mem->db_pool[i];
+		qtd->buffer_dma = virt_to_phys(qtd->buffer);
+
+		qtd->qtd_buffer_len = BUFFER_SIZE * a_blocks;
+		oxu->db_used[i] = a_blocks;
+
+		spin_unlock(&oxu->mem_lock);
+
+		return 0;
+	}
+
+	/* Failed */
+
+	spin_unlock(&oxu->mem_lock);
+
+	return -ENOMEM;
+}
+
+static void oxu_buf_free(struct oxu_hcd *oxu, struct ehci_qtd *qtd)
+{
+	int index;
+
+	spin_lock(&oxu->mem_lock);
+
+	index = (qtd->buffer - (void *) &oxu->mem->db_pool[0])
+							 / BUFFER_SIZE;
+	oxu->db_used[index] = 0;
+	qtd->qtd_buffer_len = 0;
+	qtd->buffer_dma = 0;
+	qtd->buffer = NULL;
+
+	spin_unlock(&oxu->mem_lock);
+
+	return;
+}
+
+static inline void ehci_qtd_init(struct ehci_qtd *qtd, dma_addr_t dma)
+{
+	memset(qtd, 0, sizeof *qtd);
+	qtd->qtd_dma = dma;
+	qtd->hw_token = cpu_to_le32(QTD_STS_HALT);
+	qtd->hw_next = EHCI_LIST_END;
+	qtd->hw_alt_next = EHCI_LIST_END;
+	INIT_LIST_HEAD(&qtd->qtd_list);
+}
+
+static inline void oxu_qtd_free(struct oxu_hcd *oxu, struct ehci_qtd *qtd)
+{
+	int index;
+
+	if (qtd->buffer)
+		oxu_buf_free(oxu, qtd);
+
+	spin_lock(&oxu->mem_lock);
+
+	index = qtd - &oxu->mem->qtd_pool[0];
+	oxu->qtd_used[index] = 0;
+
+	spin_unlock(&oxu->mem_lock);
+
+	return;
+}
+
+static struct ehci_qtd *ehci_qtd_alloc(struct oxu_hcd *oxu)
+{
+	int i;
+	struct ehci_qtd *qtd = NULL;
+
+	spin_lock(&oxu->mem_lock);
+
+	for (i = 0; i < QTD_NUM; i++)
+		if (!oxu->qtd_used[i])
+			break;
+
+	if (i < QTD_NUM) {
+		qtd = (struct ehci_qtd *) &oxu->mem->qtd_pool[i];
+		memset(qtd, 0, sizeof *qtd);
+
+		qtd->hw_token = cpu_to_le32(QTD_STS_HALT);
+		qtd->hw_next = EHCI_LIST_END;
+		qtd->hw_alt_next = EHCI_LIST_END;
+		INIT_LIST_HEAD(&qtd->qtd_list);
+
+		qtd->qtd_dma = virt_to_phys(qtd);
+
+		oxu->qtd_used[i] = 1;
+	}
+
+	spin_unlock(&oxu->mem_lock);
+
+	return qtd;
+}
+
+static void oxu_qh_free(struct oxu_hcd *oxu, struct ehci_qh *qh)
+{
+	int index;
+
+	spin_lock(&oxu->mem_lock);
+
+	index = qh - &oxu->mem->qh_pool[0];
+	oxu->qh_used[index] = 0;
+
+	spin_unlock(&oxu->mem_lock);
+
+	return;
+}
+
+static void qh_destroy(struct kref *kref)
+{
+	struct ehci_qh *qh = container_of(kref, struct ehci_qh, kref);
+	struct oxu_hcd *oxu = qh->oxu;
+
+	/* clean qtds first, and know this is not linked */
+	if (!list_empty(&qh->qtd_list) || qh->qh_next.ptr) {
+		oxu_dbg(oxu, "unused qh not empty!\n");
+		BUG();
+	}
+	if (qh->dummy)
+		oxu_qtd_free(oxu, qh->dummy);
+	oxu_qh_free(oxu, qh);
+}
+
+static struct ehci_qh *oxu_qh_alloc(struct oxu_hcd *oxu)
+{
+	int i;
+	struct ehci_qh *qh = NULL;
+
+	spin_lock(&oxu->mem_lock);
+
+	for (i = 0; i < QHEAD_NUM; i++)
+		if (!oxu->qh_used[i])
+			break;
+
+	if (i < QHEAD_NUM) {
+		qh = (struct ehci_qh *) &oxu->mem->qh_pool[i];
+		memset(qh, 0, sizeof *qh);
+
+		kref_init(&qh->kref);
+		qh->oxu = oxu;
+		qh->qh_dma = virt_to_phys(qh);
+		INIT_LIST_HEAD(&qh->qtd_list);
+
+		/* dummy td enables safe urb queuing */
+		qh->dummy = ehci_qtd_alloc(oxu);
+		if (qh->dummy == NULL) {
+			oxu_dbg(oxu, "no dummy td\n");
+			oxu->qh_used[i] = 0;
+
+			return NULL;
+		}
+
+		oxu->qh_used[i] = 1;
+	}
+
+	spin_unlock(&oxu->mem_lock);
+
+	return qh;
+}
+
+/* to share a qh (cpu threads, or hc) */
+static inline struct ehci_qh *qh_get(struct ehci_qh *qh)
+{
+	kref_get(&qh->kref);
+	return qh;
+}
+
+static inline void qh_put(struct ehci_qh *qh)
+{
+	kref_put(&qh->kref, qh_destroy);
+}
+
+static void oxu_murb_free(struct oxu_hcd *oxu, struct oxu_murb *murb)
+{
+	int index;
+
+	spin_lock(&oxu->mem_lock);
+
+	index = murb - &oxu->murb_pool[0];
+	oxu->murb_used[index] = 0;
+
+	spin_unlock(&oxu->mem_lock);
+
+	return;
+}
+
+static struct oxu_murb *oxu_murb_alloc(struct oxu_hcd *oxu)
+
+{
+	int i;
+	struct oxu_murb *murb = NULL;
+
+	spin_lock(&oxu->mem_lock);
+
+	for (i = 0; i < MURB_NUM; i++)
+		if (!oxu->murb_used[i])
+			break;
+
+	if (i < MURB_NUM) {
+		murb = &(oxu->murb_pool)[i];
+
+		oxu->murb_used[i] = 1;
+	}
+
+	spin_unlock(&oxu->mem_lock);
+
+	return murb;
+}
+
+/* The queue heads and transfer descriptors are managed from pools tied
+ * to each of the "per device" structures.
+ * This is the initialisation and cleanup code.
+ */
+static void ehci_mem_cleanup(struct oxu_hcd *oxu)
+{
+	kfree(oxu->murb_pool);
+	oxu->murb_pool = NULL;
+
+	if (oxu->async)
+		qh_put(oxu->async);
+	oxu->async = NULL;
+
+	del_timer(&oxu->urb_timer);
+
+	oxu->periodic = NULL;
+
+	/* shadow periodic table */
+	kfree(oxu->pshadow);
+	oxu->pshadow = NULL;
+}
+
+/* Remember to add cleanup code (above) if you add anything here.
+ */
+static int ehci_mem_init(struct oxu_hcd *oxu, gfp_t flags)
+{
+	int i;
+
+	for (i = 0; i < oxu->periodic_size; i++)
+		oxu->mem->frame_list[i] = EHCI_LIST_END;
+	for (i = 0; i < QHEAD_NUM; i++)
+		oxu->qh_used[i] = 0;
+	for (i = 0; i < QTD_NUM; i++)
+		oxu->qtd_used[i] = 0;
+
+	oxu->murb_pool = kcalloc(MURB_NUM, sizeof(struct oxu_murb), flags);
+	if (!oxu->murb_pool)
+		goto fail;
+
+	for (i = 0; i < MURB_NUM; i++)
+		oxu->murb_used[i] = 0;
+
+	oxu->async = oxu_qh_alloc(oxu);
+	if (!oxu->async)
+		goto fail;
+
+	oxu->periodic = (__le32 *) &oxu->mem->frame_list;
+	oxu->periodic_dma = virt_to_phys(oxu->periodic);
+
+	for (i = 0; i < oxu->periodic_size; i++)
+		oxu->periodic[i] = EHCI_LIST_END;
+
+	/* software shadow of hardware table */
+	oxu->pshadow = kcalloc(oxu->periodic_size, sizeof(void *), flags);
+	if (oxu->pshadow != NULL)
+		return 0;
+
+fail:
+	oxu_dbg(oxu, "couldn't init memory\n");
+	ehci_mem_cleanup(oxu);
+	return -ENOMEM;
+}
+
+/* Fill a qtd, returning how much of the buffer we were able to queue up.
+ */
+static int qtd_fill(struct ehci_qtd *qtd, dma_addr_t buf, size_t len,
+				int token, int maxpacket)
+{
+	int i, count;
+	u64 addr = buf;
+
+	/* one buffer entry per 4K ... first might be short or unaligned */
+	qtd->hw_buf[0] = cpu_to_le32((u32)addr);
+	qtd->hw_buf_hi[0] = cpu_to_le32((u32)(addr >> 32));
+	count = 0x1000 - (buf & 0x0fff);	/* rest of that page */
+	if (likely(len < count))		/* ... iff needed */
+		count = len;
+	else {
+		buf +=  0x1000;
+		buf &= ~0x0fff;
+
+		/* per-qtd limit: from 16K to 20K (best alignment) */
+		for (i = 1; count < len && i < 5; i++) {
+			addr = buf;
+			qtd->hw_buf[i] = cpu_to_le32((u32)addr);
+			qtd->hw_buf_hi[i] = cpu_to_le32((u32)(addr >> 32));
+			buf += 0x1000;
+			if ((count + 0x1000) < len)
+				count += 0x1000;
+			else
+				count = len;
+		}
+
+		/* short packets may only terminate transfers */
+		if (count != len)
+			count -= (count % maxpacket);
+	}
+	qtd->hw_token = cpu_to_le32((count << 16) | token);
+	qtd->length = count;
+
+	return count;
+}
+
+static inline void qh_update(struct oxu_hcd *oxu,
+				struct ehci_qh *qh, struct ehci_qtd *qtd)
+{
+	/* writes to an active overlay are unsafe */
+	BUG_ON(qh->qh_state != QH_STATE_IDLE);
+
+	qh->hw_qtd_next = QTD_NEXT(qtd->qtd_dma);
+	qh->hw_alt_next = EHCI_LIST_END;
+
+	/* Except for control endpoints, we make hardware maintain data
+	 * toggle (like OHCI) ... here (re)initialize the toggle in the QH,
+	 * and set the pseudo-toggle in udev. Only usb_clear_halt() will
+	 * ever clear it.
+	 */
+	if (!(qh->hw_info1 & cpu_to_le32(1 << 14))) {
+		unsigned	is_out, epnum;
+
+		is_out = !(qtd->hw_token & cpu_to_le32(1 << 8));
+		epnum = (le32_to_cpup(&qh->hw_info1) >> 8) & 0x0f;
+		if (unlikely(!usb_gettoggle(qh->dev, epnum, is_out))) {
+			qh->hw_token &= ~cpu_to_le32(QTD_TOGGLE);
+			usb_settoggle(qh->dev, epnum, is_out, 1);
+		}
+	}
+
+	/* HC must see latest qtd and qh data before we clear ACTIVE+HALT */
+	wmb();
+	qh->hw_token &= cpu_to_le32(QTD_TOGGLE | QTD_STS_PING);
+}
+
+/* If it weren't for a common silicon quirk (writing the dummy into the qh
+ * overlay, so qh->hw_token wrongly becomes inactive/halted), only fault
+ * recovery (including urb dequeue) would need software changes to a QH...
+ */
+static void qh_refresh(struct oxu_hcd *oxu, struct ehci_qh *qh)
+{
+	struct ehci_qtd *qtd;
+
+	if (list_empty(&qh->qtd_list))
+		qtd = qh->dummy;
+	else {
+		qtd = list_entry(qh->qtd_list.next,
+				struct ehci_qtd, qtd_list);
+		/* first qtd may already be partially processed */
+		if (cpu_to_le32(qtd->qtd_dma) == qh->hw_current)
+			qtd = NULL;
+	}
+
+	if (qtd)
+		qh_update(oxu, qh, qtd);
+}
+
+static void qtd_copy_status(struct oxu_hcd *oxu, struct urb *urb,
+				size_t length, u32 token)
+{
+	/* count IN/OUT bytes, not SETUP (even short packets) */
+	if (likely(QTD_PID(token) != 2))
+		urb->actual_length += length - QTD_LENGTH(token);
+
+	/* don't modify error codes */
+	if (unlikely(urb->status != -EINPROGRESS))
+		return;
+
+	/* force cleanup after short read; not always an error */
+	if (unlikely(IS_SHORT_READ(token)))
+		urb->status = -EREMOTEIO;
+
+	/* serious "can't proceed" faults reported by the hardware */
+	if (token & QTD_STS_HALT) {
+		if (token & QTD_STS_BABBLE) {
+			/* FIXME "must" disable babbling device's port too */
+			urb->status = -EOVERFLOW;
+		} else if (token & QTD_STS_MMF) {
+			/* fs/ls interrupt xfer missed the complete-split */
+			urb->status = -EPROTO;
+		} else if (token & QTD_STS_DBE) {
+			urb->status = (QTD_PID(token) == 1) /* IN ? */
+				? -ENOSR  /* hc couldn't read data */
+				: -ECOMM; /* hc couldn't write data */
+		} else if (token & QTD_STS_XACT) {
+			/* timeout, bad crc, wrong PID, etc; retried */
+			if (QTD_CERR(token))
+				urb->status = -EPIPE;
+			else {
+				oxu_dbg(oxu, "devpath %s ep%d%s 3strikes\n",
+					urb->dev->devpath,
+					usb_pipeendpoint(urb->pipe),
+					usb_pipein(urb->pipe) ? "in" : "out");
+				urb->status = -EPROTO;
+			}
+		/* CERR nonzero + no errors + halt --> stall */
+		} else if (QTD_CERR(token))
+			urb->status = -EPIPE;
+		else	/* unknown */
+			urb->status = -EPROTO;
+
+		oxu_vdbg(oxu, "dev%d ep%d%s qtd token %08x --> status %d\n",
+			usb_pipedevice(urb->pipe),
+			usb_pipeendpoint(urb->pipe),
+			usb_pipein(urb->pipe) ? "in" : "out",
+			token, urb->status);
+	}
+}
+
+static void ehci_urb_done(struct oxu_hcd *oxu, struct urb *urb)
+__releases(oxu->lock)
+__acquires(oxu->lock)
+{
+	if (likely(urb->hcpriv != NULL)) {
+		struct ehci_qh	*qh = (struct ehci_qh *) urb->hcpriv;
+
+		/* S-mask in a QH means it's an interrupt urb */
+		if ((qh->hw_info2 & cpu_to_le32(QH_SMASK)) != 0) {
+
+			/* ... update hc-wide periodic stats (for usbfs) */
+			oxu_to_hcd(oxu)->self.bandwidth_int_reqs--;
+		}
+		qh_put(qh);
+	}
+
+	urb->hcpriv = NULL;
+	switch (urb->status) {
+	case -EINPROGRESS:		/* success */
+		urb->status = 0;
+	default:			/* fault */
+		break;
+	case -EREMOTEIO:		/* fault or normal */
+		if (!(urb->transfer_flags & URB_SHORT_NOT_OK))
+			urb->status = 0;
+		break;
+	case -ECONNRESET:		/* canceled */
+	case -ENOENT:
+		break;
+	}
+
+#ifdef OXU_URB_TRACE
+	oxu_dbg(oxu, "%s %s urb %p ep%d%s status %d len %d/%d\n",
+		__func__, urb->dev->devpath, urb,
+		usb_pipeendpoint(urb->pipe),
+		usb_pipein(urb->pipe) ? "in" : "out",
+		urb->status,
+		urb->actual_length, urb->transfer_buffer_length);
+#endif
+
+	/* complete() can reenter this HCD */
+	spin_unlock(&oxu->lock);
+	usb_hcd_giveback_urb(oxu_to_hcd(oxu), urb, urb->status);
+	spin_lock(&oxu->lock);
+}
+
+static void start_unlink_async(struct oxu_hcd *oxu, struct ehci_qh *qh);
+static void unlink_async(struct oxu_hcd *oxu, struct ehci_qh *qh);
+
+static void intr_deschedule(struct oxu_hcd *oxu, struct ehci_qh *qh);
+static int qh_schedule(struct oxu_hcd *oxu, struct ehci_qh *qh);
+
+#define HALT_BIT cpu_to_le32(QTD_STS_HALT)
+
+/* Process and free completed qtds for a qh, returning URBs to drivers.
+ * Chases up to qh->hw_current.  Returns number of completions called,
+ * indicating how much "real" work we did.
+ */
+static unsigned qh_completions(struct oxu_hcd *oxu, struct ehci_qh *qh)
+{
+	struct ehci_qtd *last = NULL, *end = qh->dummy;
+	struct list_head *entry, *tmp;
+	int stopped;
+	unsigned count = 0;
+	int do_status = 0;
+	u8 state;
+	struct oxu_murb *murb = NULL;
+
+	if (unlikely(list_empty(&qh->qtd_list)))
+		return count;
+
+	/* completions (or tasks on other cpus) must never clobber HALT
+	 * till we've gone through and cleaned everything up, even when
+	 * they add urbs to this qh's queue or mark them for unlinking.
+	 *
+	 * NOTE:  unlinking expects to be done in queue order.
+	 */
+	state = qh->qh_state;
+	qh->qh_state = QH_STATE_COMPLETING;
+	stopped = (state == QH_STATE_IDLE);
+
+	/* remove de-activated QTDs from front of queue.
+	 * after faults (including short reads), cleanup this urb
+	 * then let the queue advance.
+	 * if queue is stopped, handles unlinks.
+	 */
+	list_for_each_safe(entry, tmp, &qh->qtd_list) {
+		struct ehci_qtd	*qtd;
+		struct urb *urb;
+		u32 token = 0;
+
+		qtd = list_entry(entry, struct ehci_qtd, qtd_list);
+		urb = qtd->urb;
+
+		/* Clean up any state from previous QTD ...*/
+		if (last) {
+			if (likely(last->urb != urb)) {
+				if (last->urb->complete == NULL) {
+					murb = (struct oxu_murb *) last->urb;
+					last->urb = murb->main;
+					if (murb->last) {
+						ehci_urb_done(oxu, last->urb);
+						count++;
+					}
+					oxu_murb_free(oxu, murb);
+				} else {
+					ehci_urb_done(oxu, last->urb);
+					count++;
+				}
+			}
+			oxu_qtd_free(oxu, last);
+			last = NULL;
+		}
+
+		/* ignore urbs submitted during completions we reported */
+		if (qtd == end)
+			break;
+
+		/* hardware copies qtd out of qh overlay */
+		rmb();
+		token = le32_to_cpu(qtd->hw_token);
+
+		/* always clean up qtds the hc de-activated */
+		if ((token & QTD_STS_ACTIVE) == 0) {
+
+			if ((token & QTD_STS_HALT) != 0) {
+				stopped = 1;
+
+			/* magic dummy for some short reads; qh won't advance.
+			 * that silicon quirk can kick in with this dummy too.
+			 */
+			} else if (IS_SHORT_READ(token) &&
+					!(qtd->hw_alt_next & EHCI_LIST_END)) {
+				stopped = 1;
+				goto halt;
+			}
+
+		/* stop scanning when we reach qtds the hc is using */
+		} else if (likely(!stopped &&
+				HC_IS_RUNNING(oxu_to_hcd(oxu)->state))) {
+			break;
+
+		} else {
+			stopped = 1;
+
+			if (unlikely(!HC_IS_RUNNING(oxu_to_hcd(oxu)->state)))
+				urb->status = -ESHUTDOWN;
+
+			/* ignore active urbs unless some previous qtd
+			 * for the urb faulted (including short read) or
+			 * its urb was canceled.  we may patch qh or qtds.
+			 */
+			if (likely(urb->status == -EINPROGRESS))
+				continue;
+
+			/* issue status after short control reads */
+			if (unlikely(do_status != 0)
+					&& QTD_PID(token) == 0 /* OUT */) {
+				do_status = 0;
+				continue;
+			}
+
+			/* token in overlay may be most current */
+			if (state == QH_STATE_IDLE
+					&& cpu_to_le32(qtd->qtd_dma)
+						== qh->hw_current)
+				token = le32_to_cpu(qh->hw_token);
+
+			/* force halt for unlinked or blocked qh, so we'll
+			 * patch the qh later and so that completions can't
+			 * activate it while we "know" it's stopped.
+			 */
+			if ((HALT_BIT & qh->hw_token) == 0) {
+halt:
+				qh->hw_token |= HALT_BIT;
+				wmb();
+			}
+		}
+
+		/* Remove it from the queue */
+		qtd_copy_status(oxu, urb->complete ?
+					urb : ((struct oxu_murb *) urb)->main,
+				qtd->length, token);
+		if ((usb_pipein(qtd->urb->pipe)) &&
+				(NULL != qtd->transfer_buffer))
+			memcpy(qtd->transfer_buffer, qtd->buffer, qtd->length);
+		do_status = (urb->status == -EREMOTEIO)
+				&& usb_pipecontrol(urb->pipe);
+
+		if (stopped && qtd->qtd_list.prev != &qh->qtd_list) {
+			last = list_entry(qtd->qtd_list.prev,
+					struct ehci_qtd, qtd_list);
+			last->hw_next = qtd->hw_next;
+		}
+		list_del(&qtd->qtd_list);
+		last = qtd;
+	}
+
+	/* last urb's completion might still need calling */
+	if (likely(last != NULL)) {
+		if (last->urb->complete == NULL) {
+			murb = (struct oxu_murb *) last->urb;
+			last->urb = murb->main;
+			if (murb->last) {
+				ehci_urb_done(oxu, last->urb);
+				count++;
+			}
+			oxu_murb_free(oxu, murb);
+		} else {
+			ehci_urb_done(oxu, last->urb);
+			count++;
+		}
+		oxu_qtd_free(oxu, last);
+	}
+
+	/* restore original state; caller must unlink or relink */
+	qh->qh_state = state;
+
+	/* be sure the hardware's done with the qh before refreshing
+	 * it after fault cleanup, or recovering from silicon wrongly
+	 * overlaying the dummy qtd (which reduces DMA chatter).
+	 */
+	if (stopped != 0 || qh->hw_qtd_next == EHCI_LIST_END) {
+		switch (state) {
+		case QH_STATE_IDLE:
+			qh_refresh(oxu, qh);
+			break;
+		case QH_STATE_LINKED:
+			/* should be rare for periodic transfers,
+			 * except maybe high bandwidth ...
+			 */
+			if ((cpu_to_le32(QH_SMASK)
+					& qh->hw_info2) != 0) {
+				intr_deschedule(oxu, qh);
+				(void) qh_schedule(oxu, qh);
+			} else
+				unlink_async(oxu, qh);
+			break;
+		/* otherwise, unlink already started */
+		}
+	}
+
+	return count;
+}
+
+/* High bandwidth multiplier, as encoded in highspeed endpoint descriptors */
+#define hb_mult(wMaxPacketSize)		(1 + (((wMaxPacketSize) >> 11) & 0x03))
+/* ... and packet size, for any kind of endpoint descriptor */
+#define max_packet(wMaxPacketSize)	((wMaxPacketSize) & 0x07ff)
+
+/* Reverse of qh_urb_transaction: free a list of TDs.
+ * used for cleanup after errors, before HC sees an URB's TDs.
+ */
+static void qtd_list_free(struct oxu_hcd *oxu,
+				struct urb *urb, struct list_head *qtd_list)
+{
+	struct list_head *entry, *temp;
+
+	list_for_each_safe(entry, temp, qtd_list) {
+		struct ehci_qtd	*qtd;
+
+		qtd = list_entry(entry, struct ehci_qtd, qtd_list);
+		list_del(&qtd->qtd_list);
+		oxu_qtd_free(oxu, qtd);
+	}
+}
+
+/* Create a list of filled qtds for this URB; won't link into qh.
+ */
+static struct list_head *qh_urb_transaction(struct oxu_hcd *oxu,
+						struct urb *urb,
+						struct list_head *head,
+						gfp_t flags)
+{
+	struct ehci_qtd	*qtd, *qtd_prev;
+	dma_addr_t buf;
+	int len, maxpacket;
+	int is_input;
+	u32 token;
+	void *transfer_buf = NULL;
+	int ret;
+
+	/*
+	 * URBs map to sequences of QTDs: one logical transaction
+	 */
+	qtd = ehci_qtd_alloc(oxu);
+	if (unlikely(!qtd))
+		return NULL;
+	list_add_tail(&qtd->qtd_list, head);
+	qtd->urb = urb;
+
+	token = QTD_STS_ACTIVE;
+	token |= (EHCI_TUNE_CERR << 10);
+	/* for split transactions, SplitXState initialized to zero */
+
+	len = urb->transfer_buffer_length;
+	is_input = usb_pipein(urb->pipe);
+	if (!urb->transfer_buffer && urb->transfer_buffer_length && is_input)
+		urb->transfer_buffer = phys_to_virt(urb->transfer_dma);
+
+	if (usb_pipecontrol(urb->pipe)) {
+		/* SETUP pid */
+		ret = oxu_buf_alloc(oxu, qtd, sizeof(struct usb_ctrlrequest));
+		if (ret)
+			goto cleanup;
+
+		qtd_fill(qtd, qtd->buffer_dma, sizeof(struct usb_ctrlrequest),
+				token | (2 /* "setup" */ << 8), 8);
+		memcpy(qtd->buffer, qtd->urb->setup_packet,
+				sizeof(struct usb_ctrlrequest));
+
+		/* ... and always at least one more pid */
+		token ^= QTD_TOGGLE;
+		qtd_prev = qtd;
+		qtd = ehci_qtd_alloc(oxu);
+		if (unlikely(!qtd))
+			goto cleanup;
+		qtd->urb = urb;
+		qtd_prev->hw_next = QTD_NEXT(qtd->qtd_dma);
+		list_add_tail(&qtd->qtd_list, head);
+
+		/* for zero length DATA stages, STATUS is always IN */
+		if (len == 0)
+			token |= (1 /* "in" */ << 8);
+	}
+
+	/*
+	 * Data transfer stage: buffer setup
+	 */
+
+	ret = oxu_buf_alloc(oxu, qtd, len);
+	if (ret)
+		goto cleanup;
+
+	buf = qtd->buffer_dma;
+	transfer_buf = urb->transfer_buffer;
+
+	if (!is_input)
+		memcpy(qtd->buffer, qtd->urb->transfer_buffer, len);
+
+	if (is_input)
+		token |= (1 /* "in" */ << 8);
+	/* else it's already initted to "out" pid (0 << 8) */
+
+	maxpacket = max_packet(usb_maxpacket(urb->dev, urb->pipe, !is_input));
+
+	/*
+	 * buffer gets wrapped in one or more qtds;
+	 * last one may be "short" (including zero len)
+	 * and may serve as a control status ack
+	 */
+	for (;;) {
+		int this_qtd_len;
+
+		this_qtd_len = qtd_fill(qtd, buf, len, token, maxpacket);
+		qtd->transfer_buffer = transfer_buf;
+		len -= this_qtd_len;
+		buf += this_qtd_len;
+		transfer_buf += this_qtd_len;
+		if (is_input)
+			qtd->hw_alt_next = oxu->async->hw_alt_next;
+
+		/* qh makes control packets use qtd toggle; maybe switch it */
+		if ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)
+			token ^= QTD_TOGGLE;
+
+		if (likely(len <= 0))
+			break;
+
+		qtd_prev = qtd;
+		qtd = ehci_qtd_alloc(oxu);
+		if (unlikely(!qtd))
+			goto cleanup;
+		if (likely(len > 0)) {
+			ret = oxu_buf_alloc(oxu, qtd, len);
+			if (ret)
+				goto cleanup;
+		}
+		qtd->urb = urb;
+		qtd_prev->hw_next = QTD_NEXT(qtd->qtd_dma);
+		list_add_tail(&qtd->qtd_list, head);
+	}
+
+	/* unless the bulk/interrupt caller wants a chance to clean
+	 * up after short reads, hc should advance qh past this urb
+	 */
+	if (likely((urb->transfer_flags & URB_SHORT_NOT_OK) == 0
+				|| usb_pipecontrol(urb->pipe)))
+		qtd->hw_alt_next = EHCI_LIST_END;
+
+	/*
+	 * control requests may need a terminating data "status" ack;
+	 * bulk ones may need a terminating short packet (zero length).
+	 */
+	if (likely(urb->transfer_buffer_length != 0)) {
+		int	one_more = 0;
+
+		if (usb_pipecontrol(urb->pipe)) {
+			one_more = 1;
+			token ^= 0x0100;	/* "in" <--> "out"  */
+			token |= QTD_TOGGLE;	/* force DATA1 */
+		} else if (usb_pipebulk(urb->pipe)
+				&& (urb->transfer_flags & URB_ZERO_PACKET)
+				&& !(urb->transfer_buffer_length % maxpacket)) {
+			one_more = 1;
+		}
+		if (one_more) {
+			qtd_prev = qtd;
+			qtd = ehci_qtd_alloc(oxu);
+			if (unlikely(!qtd))
+				goto cleanup;
+			qtd->urb = urb;
+			qtd_prev->hw_next = QTD_NEXT(qtd->qtd_dma);
+			list_add_tail(&qtd->qtd_list, head);
+
+			/* never any data in such packets */
+			qtd_fill(qtd, 0, 0, token, 0);
+		}
+	}
+
+	/* by default, enable interrupt on urb completion */
+		qtd->hw_token |= cpu_to_le32(QTD_IOC);
+	return head;
+
+cleanup:
+	qtd_list_free(oxu, urb, head);
+	return NULL;
+}
+
+/* Each QH holds a qtd list; a QH is used for everything except iso.
+ *
+ * For interrupt urbs, the scheduler must set the microframe scheduling
+ * mask(s) each time the QH gets scheduled.  For highspeed, that's
+ * just one microframe in the s-mask.  For split interrupt transactions
+ * there are additional complications: c-mask, maybe FSTNs.
+ */
+static struct ehci_qh *qh_make(struct oxu_hcd *oxu,
+				struct urb *urb, gfp_t flags)
+{
+	struct ehci_qh *qh = oxu_qh_alloc(oxu);
+	u32 info1 = 0, info2 = 0;
+	int is_input, type;
+	int maxp = 0;
+
+	if (!qh)
+		return qh;
+
+	/*
+	 * init endpoint/device data for this QH
+	 */
+	info1 |= usb_pipeendpoint(urb->pipe) << 8;
+	info1 |= usb_pipedevice(urb->pipe) << 0;
+
+	is_input = usb_pipein(urb->pipe);
+	type = usb_pipetype(urb->pipe);
+	maxp = usb_maxpacket(urb->dev, urb->pipe, !is_input);
+
+	/* Compute interrupt scheduling parameters just once, and save.
+	 * - allowing for high bandwidth, how many nsec/uframe are used?
+	 * - split transactions need a second CSPLIT uframe; same question
+	 * - splits also need a schedule gap (for full/low speed I/O)
+	 * - qh has a polling interval
+	 *
+	 * For control/bulk requests, the HC or TT handles these.
+	 */
+	if (type == PIPE_INTERRUPT) {
+		qh->usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,
+								is_input, 0,
+				hb_mult(maxp) * max_packet(maxp)));
+		qh->start = NO_FRAME;
+
+		if (urb->dev->speed == USB_SPEED_HIGH) {
+			qh->c_usecs = 0;
+			qh->gap_uf = 0;
+
+			qh->period = urb->interval >> 3;
+			if (qh->period == 0 && urb->interval != 1) {
+				/* NOTE interval 2 or 4 uframes could work.
+				 * But interval 1 scheduling is simpler, and
+				 * includes high bandwidth.
+				 */
+				dbg("intr period %d uframes, NYET!",
+						urb->interval);
+				goto done;
+			}
+		} else {
+			struct usb_tt	*tt = urb->dev->tt;
+			int		think_time;
+
+			/* gap is f(FS/LS transfer times) */
+			qh->gap_uf = 1 + usb_calc_bus_time(urb->dev->speed,
+					is_input, 0, maxp) / (125 * 1000);
+
+			/* FIXME this just approximates SPLIT/CSPLIT times */
+			if (is_input) {		/* SPLIT, gap, CSPLIT+DATA */
+				qh->c_usecs = qh->usecs + HS_USECS(0);
+				qh->usecs = HS_USECS(1);
+			} else {		/* SPLIT+DATA, gap, CSPLIT */
+				qh->usecs += HS_USECS(1);
+				qh->c_usecs = HS_USECS(0);
+			}
+
+			think_time = tt ? tt->think_time : 0;
+			qh->tt_usecs = NS_TO_US(think_time +
+					usb_calc_bus_time(urb->dev->speed,
+					is_input, 0, max_packet(maxp)));
+			qh->period = urb->interval;
+		}
+	}
+
+	/* support for tt scheduling, and access to toggles */
+	qh->dev = urb->dev;
+
+	/* using TT? */
+	switch (urb->dev->speed) {
+	case USB_SPEED_LOW:
+		info1 |= (1 << 12);	/* EPS "low" */
+		/* FALL THROUGH */
+
+	case USB_SPEED_FULL:
+		/* EPS 0 means "full" */
+		if (type != PIPE_INTERRUPT)
+			info1 |= (EHCI_TUNE_RL_TT << 28);
+		if (type == PIPE_CONTROL) {
+			info1 |= (1 << 27);	/* for TT */
+			info1 |= 1 << 14;	/* toggle from qtd */
+		}
+		info1 |= maxp << 16;
+
+		info2 |= (EHCI_TUNE_MULT_TT << 30);
+		info2 |= urb->dev->ttport << 23;
+
+		/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets c-mask } */
+
+		break;
+
+	case USB_SPEED_HIGH:		/* no TT involved */
+		info1 |= (2 << 12);	/* EPS "high" */
+		if (type == PIPE_CONTROL) {
+			info1 |= (EHCI_TUNE_RL_HS << 28);
+			info1 |= 64 << 16;	/* usb2 fixed maxpacket */
+			info1 |= 1 << 14;	/* toggle from qtd */
+			info2 |= (EHCI_TUNE_MULT_HS << 30);
+		} else if (type == PIPE_BULK) {
+			info1 |= (EHCI_TUNE_RL_HS << 28);
+			info1 |= 512 << 16;	/* usb2 fixed maxpacket */
+			info2 |= (EHCI_TUNE_MULT_HS << 30);
+		} else {		/* PIPE_INTERRUPT */
+			info1 |= max_packet(maxp) << 16;
+			info2 |= hb_mult(maxp) << 30;
+		}
+		break;
+	default:
+		dbg("bogus dev %p speed %d", urb->dev, urb->dev->speed);
+done:
+		qh_put(qh);
+		return NULL;
+	}
+
+	/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets s-mask } */
+
+	/* init as live, toggle clear, advance to dummy */
+	qh->qh_state = QH_STATE_IDLE;
+	qh->hw_info1 = cpu_to_le32(info1);
+	qh->hw_info2 = cpu_to_le32(info2);
+	usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe), !is_input, 1);
+	qh_refresh(oxu, qh);
+	return qh;
+}
+
+/* Move qh (and its qtds) onto async queue; maybe enable queue.
+ */
+static void qh_link_async(struct oxu_hcd *oxu, struct ehci_qh *qh)
+{
+	__le32 dma = QH_NEXT(qh->qh_dma);
+	struct ehci_qh *head;
+
+	/* (re)start the async schedule? */
+	head = oxu->async;
+	timer_action_done(oxu, TIMER_ASYNC_OFF);
+	if (!head->qh_next.qh) {
+		u32	cmd = readl(&oxu->regs->command);
+
+		if (!(cmd & CMD_ASE)) {
+			/* in case a clear of CMD_ASE didn't take yet */
+			(void)handshake(oxu, &oxu->regs->status,
+					STS_ASS, 0, 150);
+			cmd |= CMD_ASE | CMD_RUN;
+			writel(cmd, &oxu->regs->command);
+			oxu_to_hcd(oxu)->state = HC_STATE_RUNNING;
+			/* posted write need not be known to HC yet ... */
+		}
+	}
+
+	/* clear halt and/or toggle; and maybe recover from silicon quirk */
+	if (qh->qh_state == QH_STATE_IDLE)
+		qh_refresh(oxu, qh);
+
+	/* splice right after start */
+	qh->qh_next = head->qh_next;
+	qh->hw_next = head->hw_next;
+	wmb();
+
+	head->qh_next.qh = qh;
+	head->hw_next = dma;
+
+	qh->qh_state = QH_STATE_LINKED;
+	/* qtd completions reported later by interrupt */
+}
+
+#define	QH_ADDR_MASK	cpu_to_le32(0x7f)
+
+/*
+ * For control/bulk/interrupt, return QH with these TDs appended.
+ * Allocates and initializes the QH if necessary.
+ * Returns null if it can't allocate a QH it needs to.
+ * If the QH has TDs (urbs) already, that's great.
+ */
+static struct ehci_qh *qh_append_tds(struct oxu_hcd *oxu,
+				struct urb *urb, struct list_head *qtd_list,
+				int epnum, void	**ptr)
+{
+	struct ehci_qh *qh = NULL;
+
+	qh = (struct ehci_qh *) *ptr;
+	if (unlikely(qh == NULL)) {
+		/* can't sleep here, we have oxu->lock... */
+		qh = qh_make(oxu, urb, GFP_ATOMIC);
+		*ptr = qh;
+	}
+	if (likely(qh != NULL)) {
+		struct ehci_qtd	*qtd;
+
+		if (unlikely(list_empty(qtd_list)))
+			qtd = NULL;
+		else
+			qtd = list_entry(qtd_list->next, struct ehci_qtd,
+					qtd_list);
+
+		/* control qh may need patching ... */
+		if (unlikely(epnum == 0)) {
+
+			/* usb_reset_device() briefly reverts to address 0 */
+			if (usb_pipedevice(urb->pipe) == 0)
+				qh->hw_info1 &= ~QH_ADDR_MASK;
+		}
+
+		/* just one way to queue requests: swap with the dummy qtd.
+		 * only hc or qh_refresh() ever modify the overlay.
+		 */
+		if (likely(qtd != NULL)) {
+			struct ehci_qtd	*dummy;
+			dma_addr_t dma;
+			__le32 token;
+
+			/* to avoid racing the HC, use the dummy td instead of
+			 * the first td of our list (becomes new dummy).  both
+			 * tds stay deactivated until we're done, when the
+			 * HC is allowed to fetch the old dummy (4.10.2).
+			 */
+			token = qtd->hw_token;
+			qtd->hw_token = HALT_BIT;
+			wmb();
+			dummy = qh->dummy;
+
+			dma = dummy->qtd_dma;
+			*dummy = *qtd;
+			dummy->qtd_dma = dma;
+
+			list_del(&qtd->qtd_list);
+			list_add(&dummy->qtd_list, qtd_list);
+			list_splice(qtd_list, qh->qtd_list.prev);
+
+			ehci_qtd_init(qtd, qtd->qtd_dma);
+			qh->dummy = qtd;
+
+			/* hc must see the new dummy at list end */
+			dma = qtd->qtd_dma;
+			qtd = list_entry(qh->qtd_list.prev,
+					struct ehci_qtd, qtd_list);
+			qtd->hw_next = QTD_NEXT(dma);
+
+			/* let the hc process these next qtds */
+			dummy->hw_token = (token & ~(0x80));
+			wmb();
+			dummy->hw_token = token;
+
+			urb->hcpriv = qh_get(qh);
+		}
+	}
+	return qh;
+}
+
+static int submit_async(struct oxu_hcd	*oxu, struct urb *urb,
+			struct list_head *qtd_list, gfp_t mem_flags)
+{
+	struct ehci_qtd	*qtd;
+	int epnum;
+	unsigned long flags;
+	struct ehci_qh *qh = NULL;
+	int rc = 0;
+
+	qtd = list_entry(qtd_list->next, struct ehci_qtd, qtd_list);
+	epnum = urb->ep->desc.bEndpointAddress;
+
+#ifdef OXU_URB_TRACE
+	oxu_dbg(oxu, "%s %s urb %p ep%d%s len %d, qtd %p [qh %p]\n",
+		__func__, urb->dev->devpath, urb,
+		epnum & 0x0f, (epnum & USB_DIR_IN) ? "in" : "out",
+		urb->transfer_buffer_length,
+		qtd, urb->ep->hcpriv);
+#endif
+
+	spin_lock_irqsave(&oxu->lock, flags);
+	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
+			       &oxu_to_hcd(oxu)->flags))) {
+		rc = -ESHUTDOWN;
+		goto done;
+	}
+
+	qh = qh_append_tds(oxu, urb, qtd_list, epnum, &urb->ep->hcpriv);
+	if (unlikely(qh == NULL)) {
+		rc = -ENOMEM;
+		goto done;
+	}
+
+	/* Control/bulk operations through TTs don't need scheduling,
+	 * the HC and TT handle it when the TT has a buffer ready.
+	 */
+	if (likely(qh->qh_state == QH_STATE_IDLE))
+		qh_link_async(oxu, qh_get(qh));
+done:
+	spin_unlock_irqrestore(&oxu->lock, flags);
+	if (unlikely(qh == NULL))
+		qtd_list_free(oxu, urb, qtd_list);
+	return rc;
+}
+
+/* The async qh for the qtds being reclaimed are now unlinked from the HC */
+
+static void end_unlink_async(struct oxu_hcd *oxu)
+{
+	struct ehci_qh *qh = oxu->reclaim;
+	struct ehci_qh *next;
+
+	timer_action_done(oxu, TIMER_IAA_WATCHDOG);
+
+	qh->qh_state = QH_STATE_IDLE;
+	qh->qh_next.qh = NULL;
+	qh_put(qh);			/* refcount from reclaim */
+
+	/* other unlink(s) may be pending (in QH_STATE_UNLINK_WAIT) */
+	next = qh->reclaim;
+	oxu->reclaim = next;
+	oxu->reclaim_ready = 0;
+	qh->reclaim = NULL;
+
+	qh_completions(oxu, qh);
+
+	if (!list_empty(&qh->qtd_list)
+			&& HC_IS_RUNNING(oxu_to_hcd(oxu)->state))
+		qh_link_async(oxu, qh);
+	else {
+		qh_put(qh);		/* refcount from async list */
+
+		/* it's not free to turn the async schedule on/off; leave it
+		 * active but idle for a while once it empties.
+		 */
+		if (HC_IS_RUNNING(oxu_to_hcd(oxu)->state)
+				&& oxu->async->qh_next.qh == NULL)
+			timer_action(oxu, TIMER_ASYNC_OFF);
+	}
+
+	if (next) {
+		oxu->reclaim = NULL;
+		start_unlink_async(oxu, next);
+	}
+}
+
+/* makes sure the async qh will become idle */
+/* caller must own oxu->lock */
+
+static void start_unlink_async(struct oxu_hcd *oxu, struct ehci_qh *qh)
+{
+	int cmd = readl(&oxu->regs->command);
+	struct ehci_qh *prev;
+
+#ifdef DEBUG
+	assert_spin_locked(&oxu->lock);
+	if (oxu->reclaim || (qh->qh_state != QH_STATE_LINKED
+				&& qh->qh_state != QH_STATE_UNLINK_WAIT))
+		BUG();
+#endif
+
+	/* stop async schedule right now? */
+	if (unlikely(qh == oxu->async)) {
+		/* can't get here without STS_ASS set */
+		if (oxu_to_hcd(oxu)->state != HC_STATE_HALT
+				&& !oxu->reclaim) {
+			/* ... and CMD_IAAD clear */
+			writel(cmd & ~CMD_ASE, &oxu->regs->command);
+			wmb();
+			/* handshake later, if we need to */
+			timer_action_done(oxu, TIMER_ASYNC_OFF);
+		}
+		return;
+	}
+
+	qh->qh_state = QH_STATE_UNLINK;
+	oxu->reclaim = qh = qh_get(qh);
+
+	prev = oxu->async;
+	while (prev->qh_next.qh != qh)
+		prev = prev->qh_next.qh;
+
+	prev->hw_next = qh->hw_next;
+	prev->qh_next = qh->qh_next;
+	wmb();
+
+	if (unlikely(oxu_to_hcd(oxu)->state == HC_STATE_HALT)) {
+		/* if (unlikely(qh->reclaim != 0))
+		 *	this will recurse, probably not much
+		 */
+		end_unlink_async(oxu);
+		return;
+	}
+
+	oxu->reclaim_ready = 0;
+	cmd |= CMD_IAAD;
+	writel(cmd, &oxu->regs->command);
+	(void) readl(&oxu->regs->command);
+	timer_action(oxu, TIMER_IAA_WATCHDOG);
+}
+
+static void scan_async(struct oxu_hcd *oxu)
+{
+	struct ehci_qh *qh;
+	enum ehci_timer_action action = TIMER_IO_WATCHDOG;
+
+	if (!++(oxu->stamp))
+		oxu->stamp++;
+	timer_action_done(oxu, TIMER_ASYNC_SHRINK);
+rescan:
+	qh = oxu->async->qh_next.qh;
+	if (likely(qh != NULL)) {
+		do {
+			/* clean any finished work for this qh */
+			if (!list_empty(&qh->qtd_list)
+					&& qh->stamp != oxu->stamp) {
+				int temp;
+
+				/* unlinks could happen here; completion
+				 * reporting drops the lock.  rescan using
+				 * the latest schedule, but don't rescan
+				 * qhs we already finished (no looping).
+				 */
+				qh = qh_get(qh);
+				qh->stamp = oxu->stamp;
+				temp = qh_completions(oxu, qh);
+				qh_put(qh);
+				if (temp != 0)
+					goto rescan;
+			}
+
+			/* unlink idle entries, reducing HC PCI usage as well
+			 * as HCD schedule-scanning costs.  delay for any qh
+			 * we just scanned, there's a not-unusual case that it
+			 * doesn't stay idle for long.
+			 * (plus, avoids some kind of re-activation race.)
+			 */
+			if (list_empty(&qh->qtd_list)) {
+				if (qh->stamp == oxu->stamp)
+					action = TIMER_ASYNC_SHRINK;
+				else if (!oxu->reclaim
+					    && qh->qh_state == QH_STATE_LINKED)
+					start_unlink_async(oxu, qh);
+			}
+
+			qh = qh->qh_next.qh;
+		} while (qh);
+	}
+	if (action == TIMER_ASYNC_SHRINK)
+		timer_action(oxu, TIMER_ASYNC_SHRINK);
+}
+
+/*
+ * periodic_next_shadow - return "next" pointer on shadow list
+ * @periodic: host pointer to qh/itd/sitd
+ * @tag: hardware tag for type of this record
+ */
+static union ehci_shadow *periodic_next_shadow(union ehci_shadow *periodic,
+						__le32 tag)
+{
+	switch (tag) {
+	default:
+	case Q_TYPE_QH:
+		return &periodic->qh->qh_next;
+	}
+}
+
+/* caller must hold oxu->lock */
+static void periodic_unlink(struct oxu_hcd *oxu, unsigned frame, void *ptr)
+{
+	union ehci_shadow *prev_p = &oxu->pshadow[frame];
+	__le32 *hw_p = &oxu->periodic[frame];
+	union ehci_shadow here = *prev_p;
+
+	/* find predecessor of "ptr"; hw and shadow lists are in sync */
+	while (here.ptr && here.ptr != ptr) {
+		prev_p = periodic_next_shadow(prev_p, Q_NEXT_TYPE(*hw_p));
+		hw_p = here.hw_next;
+		here = *prev_p;
+	}
+	/* an interrupt entry (at list end) could have been shared */
+	if (!here.ptr)
+		return;
+
+	/* update shadow and hardware lists ... the old "next" pointers
+	 * from ptr may still be in use, the caller updates them.
+	 */
+	*prev_p = *periodic_next_shadow(&here, Q_NEXT_TYPE(*hw_p));
+	*hw_p = *here.hw_next;
+}
+
+/* how many of the uframe's 125 usecs are allocated? */
+static unsigned short periodic_usecs(struct oxu_hcd *oxu,
+					unsigned frame, unsigned uframe)
+{
+	__le32 *hw_p = &oxu->periodic[frame];
+	union ehci_shadow *q = &oxu->pshadow[frame];
+	unsigned usecs = 0;
+
+	while (q->ptr) {
+		switch (Q_NEXT_TYPE(*hw_p)) {
+		case Q_TYPE_QH:
+		default:
+			/* is it in the S-mask? */
+			if (q->qh->hw_info2 & cpu_to_le32(1 << uframe))
+				usecs += q->qh->usecs;
+			/* ... or C-mask? */
+			if (q->qh->hw_info2 & cpu_to_le32(1 << (8 + uframe)))
+				usecs += q->qh->c_usecs;
+			hw_p = &q->qh->hw_next;
+			q = &q->qh->qh_next;
+			break;
+		}
+	}
+#ifdef DEBUG
+	if (usecs > 100)
+		oxu_err(oxu, "uframe %d sched overrun: %d usecs\n",
+						frame * 8 + uframe, usecs);
+#endif
+	return usecs;
+}
+
+static int enable_periodic(struct oxu_hcd *oxu)
+{
+	u32 cmd;
+	int status;
+
+	/* did clearing PSE did take effect yet?
+	 * takes effect only at frame boundaries...
+	 */
+	status = handshake(oxu, &oxu->regs->status, STS_PSS, 0, 9 * 125);
+	if (status != 0) {
+		oxu_to_hcd(oxu)->state = HC_STATE_HALT;
+		return status;
+	}
+
+	cmd = readl(&oxu->regs->command) | CMD_PSE;
+	writel(cmd, &oxu->regs->command);
+	/* posted write ... PSS happens later */
+	oxu_to_hcd(oxu)->state = HC_STATE_RUNNING;
+
+	/* make sure ehci_work scans these */
+	oxu->next_uframe = readl(&oxu->regs->frame_index)
+		% (oxu->periodic_size << 3);
+	return 0;
+}
+
+static int disable_periodic(struct oxu_hcd *oxu)
+{
+	u32 cmd;
+	int status;
+
+	/* did setting PSE not take effect yet?
+	 * takes effect only at frame boundaries...
+	 */
+	status = handshake(oxu, &oxu->regs->status, STS_PSS, STS_PSS, 9 * 125);
+	if (status != 0) {
+		oxu_to_hcd(oxu)->state = HC_STATE_HALT;
+		return status;
+	}
+
+	cmd = readl(&oxu->regs->command) & ~CMD_PSE;
+	writel(cmd, &oxu->regs->command);
+	/* posted write ... */
+
+	oxu->next_uframe = -1;
+	return 0;
+}
+
+/* periodic schedule slots have iso tds (normal or split) first, then a
+ * sparse tree for active interrupt transfers.
+ *
+ * this just links in a qh; caller guarantees uframe masks are set right.
+ * no FSTN support (yet; oxu 0.96+)
+ */
+static int qh_link_periodic(struct oxu_hcd *oxu, struct ehci_qh *qh)
+{
+	unsigned i;
+	unsigned period = qh->period;
+
+	dev_dbg(&qh->dev->dev,
+		"link qh%d-%04x/%p start %d [%d/%d us]\n",
+		period, le32_to_cpup(&qh->hw_info2) & (QH_CMASK | QH_SMASK),
+		qh, qh->start, qh->usecs, qh->c_usecs);
+
+	/* high bandwidth, or otherwise every microframe */
+	if (period == 0)
+		period = 1;
+
+	for (i = qh->start; i < oxu->periodic_size; i += period) {
+		union ehci_shadow	*prev = &oxu->pshadow[i];
+		__le32			*hw_p = &oxu->periodic[i];
+		union ehci_shadow	here = *prev;
+		__le32			type = 0;
+
+		/* skip the iso nodes at list head */
+		while (here.ptr) {
+			type = Q_NEXT_TYPE(*hw_p);
+			if (type == Q_TYPE_QH)
+				break;
+			prev = periodic_next_shadow(prev, type);
+			hw_p = &here.qh->hw_next;
+			here = *prev;
+		}
+
+		/* sorting each branch by period (slow-->fast)
+		 * enables sharing interior tree nodes
+		 */
+		while (here.ptr && qh != here.qh) {
+			if (qh->period > here.qh->period)
+				break;
+			prev = &here.qh->qh_next;
+			hw_p = &here.qh->hw_next;
+			here = *prev;
+		}
+		/* link in this qh, unless some earlier pass did that */
+		if (qh != here.qh) {
+			qh->qh_next = here;
+			if (here.qh)
+				qh->hw_next = *hw_p;
+			wmb();
+			prev->qh = qh;
+			*hw_p = QH_NEXT(qh->qh_dma);
+		}
+	}
+	qh->qh_state = QH_STATE_LINKED;
+	qh_get(qh);
+
+	/* update per-qh bandwidth for usbfs */
+	oxu_to_hcd(oxu)->self.bandwidth_allocated += qh->period
+		? ((qh->usecs + qh->c_usecs) / qh->period)
+		: (qh->usecs * 8);
+
+	/* maybe enable periodic schedule processing */
+	if (!oxu->periodic_sched++)
+		return enable_periodic(oxu);
+
+	return 0;
+}
+
+static void qh_unlink_periodic(struct oxu_hcd *oxu, struct ehci_qh *qh)
+{
+	unsigned i;
+	unsigned period;
+
+	/* FIXME:
+	 *   IF this isn't high speed
+	 *   and this qh is active in the current uframe
+	 *   (and overlay token SplitXstate is false?)
+	 * THEN
+	 *   qh->hw_info1 |= cpu_to_le32(1 << 7 "ignore");
+	 */
+
+	/* high bandwidth, or otherwise part of every microframe */
+	period = qh->period;
+	if (period == 0)
+		period = 1;
+
+	for (i = qh->start; i < oxu->periodic_size; i += period)
+		periodic_unlink(oxu, i, qh);
+
+	/* update per-qh bandwidth for usbfs */
+	oxu_to_hcd(oxu)->self.bandwidth_allocated -= qh->period
+		? ((qh->usecs + qh->c_usecs) / qh->period)
+		: (qh->usecs * 8);
+
+	dev_dbg(&qh->dev->dev,
+		"unlink qh%d-%04x/%p start %d [%d/%d us]\n",
+		qh->period,
+		le32_to_cpup(&qh->hw_info2) & (QH_CMASK | QH_SMASK),
+		qh, qh->start, qh->usecs, qh->c_usecs);
+
+	/* qh->qh_next still "live" to HC */
+	qh->qh_state = QH_STATE_UNLINK;
+	qh->qh_next.ptr = NULL;
+	qh_put(qh);
+
+	/* maybe turn off periodic schedule */
+	oxu->periodic_sched--;
+	if (!oxu->periodic_sched)
+		(void) disable_periodic(oxu);
+}
+
+static void intr_deschedule(struct oxu_hcd *oxu, struct ehci_qh *qh)
+{
+	unsigned wait;
+
+	qh_unlink_periodic(oxu, qh);
+
+	/* simple/paranoid:  always delay, expecting the HC needs to read
+	 * qh->hw_next or finish a writeback after SPLIT/CSPLIT ... and
+	 * expect khubd to clean up after any CSPLITs we won't issue.
+	 * active high speed queues may need bigger delays...
+	 */
+	if (list_empty(&qh->qtd_list)
+		|| (cpu_to_le32(QH_CMASK) & qh->hw_info2) != 0)
+		wait = 2;
+	else
+		wait = 55;	/* worst case: 3 * 1024 */
+
+	udelay(wait);
+	qh->qh_state = QH_STATE_IDLE;
+	qh->hw_next = EHCI_LIST_END;
+	wmb();
+}
+
+static int check_period(struct oxu_hcd *oxu,
+			unsigned frame, unsigned uframe,
+			unsigned period, unsigned usecs)
+{
+	int claimed;
+
+	/* complete split running into next frame?
+	 * given FSTN support, we could sometimes check...
+	 */
+	if (uframe >= 8)
+		return 0;
+
+	/*
+	 * 80% periodic == 100 usec/uframe available
+	 * convert "usecs we need" to "max already claimed"
+	 */
+	usecs = 100 - usecs;
+
+	/* we "know" 2 and 4 uframe intervals were rejected; so
+	 * for period 0, check _every_ microframe in the schedule.
+	 */
+	if (unlikely(period == 0)) {
+		do {
+			for (uframe = 0; uframe < 7; uframe++) {
+				claimed = periodic_usecs(oxu, frame, uframe);
+				if (claimed > usecs)
+					return 0;
+			}
+		} while ((frame += 1) < oxu->periodic_size);
+
+	/* just check the specified uframe, at that period */
+	} else {
+		do {
+			claimed = periodic_usecs(oxu, frame, uframe);
+			if (claimed > usecs)
+				return 0;
+		} while ((frame += period) < oxu->periodic_size);
+	}
+
+	return 1;
+}
+
+static int check_intr_schedule(struct oxu_hcd	*oxu,
+				unsigned frame, unsigned uframe,
+				const struct ehci_qh *qh, __le32 *c_maskp)
+{
+	int retval = -ENOSPC;
+
+	if (qh->c_usecs && uframe >= 6)		/* FSTN territory? */
+		goto done;
+
+	if (!check_period(oxu, frame, uframe, qh->period, qh->usecs))
+		goto done;
+	if (!qh->c_usecs) {
+		retval = 0;
+		*c_maskp = 0;
+		goto done;
+	}
+
+done:
+	return retval;
+}
+
+/* "first fit" scheduling policy used the first time through,
+ * or when the previous schedule slot can't be re-used.
+ */
+static int qh_schedule(struct oxu_hcd *oxu, struct ehci_qh *qh)
+{
+	int		status;
+	unsigned	uframe;
+	__le32		c_mask;
+	unsigned	frame;		/* 0..(qh->period - 1), or NO_FRAME */
+
+	qh_refresh(oxu, qh);
+	qh->hw_next = EHCI_LIST_END;
+	frame = qh->start;
+
+	/* reuse the previous schedule slots, if we can */
+	if (frame < qh->period) {
+		uframe = ffs(le32_to_cpup(&qh->hw_info2) & QH_SMASK);
+		status = check_intr_schedule(oxu, frame, --uframe,
+				qh, &c_mask);
+	} else {
+		uframe = 0;
+		c_mask = 0;
+		status = -ENOSPC;
+	}
+
+	/* else scan the schedule to find a group of slots such that all
+	 * uframes have enough periodic bandwidth available.
+	 */
+	if (status) {
+		/* "normal" case, uframing flexible except with splits */
+		if (qh->period) {
+			frame = qh->period - 1;
+			do {
+				for (uframe = 0; uframe < 8; uframe++) {
+					status = check_intr_schedule(oxu,
+							frame, uframe, qh,
+							&c_mask);
+					if (status == 0)
+						break;
+				}
+			} while (status && frame--);
+
+		/* qh->period == 0 means every uframe */
+		} else {
+			frame = 0;
+			status = check_intr_schedule(oxu, 0, 0, qh, &c_mask);
+		}
+		if (status)
+			goto done;
+		qh->start = frame;
+
+		/* reset S-frame and (maybe) C-frame masks */
+		qh->hw_info2 &= cpu_to_le32(~(QH_CMASK | QH_SMASK));
+		qh->hw_info2 |= qh->period
+			? cpu_to_le32(1 << uframe)
+			: cpu_to_le32(QH_SMASK);
+		qh->hw_info2 |= c_mask;
+	} else
+		oxu_dbg(oxu, "reused qh %p schedule\n", qh);
+
+	/* stuff into the periodic schedule */
+	status = qh_link_periodic(oxu, qh);
+done:
+	return status;
+}
+
+static int intr_submit(struct oxu_hcd *oxu, struct urb *urb,
+			struct list_head *qtd_list, gfp_t mem_flags)
+{
+	unsigned epnum;
+	unsigned long flags;
+	struct ehci_qh *qh;
+	int status = 0;
+	struct list_head	empty;
+
+	/* get endpoint and transfer/schedule data */
+	epnum = urb->ep->desc.bEndpointAddress;
+
+	spin_lock_irqsave(&oxu->lock, flags);
+
+	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
+			       &oxu_to_hcd(oxu)->flags))) {
+		status = -ESHUTDOWN;
+		goto done;
+	}
+
+	/* get qh and force any scheduling errors */
+	INIT_LIST_HEAD(&empty);
+	qh = qh_append_tds(oxu, urb, &empty, epnum, &urb->ep->hcpriv);
+	if (qh == NULL) {
+		status = -ENOMEM;
+		goto done;
+	}
+	if (qh->qh_state == QH_STATE_IDLE) {
+		status = qh_schedule(oxu, qh);
+		if (status != 0)
+			goto done;
+	}
+
+	/* then queue the urb's tds to the qh */
+	qh = qh_append_tds(oxu, urb, qtd_list, epnum, &urb->ep->hcpriv);
+	BUG_ON(qh == NULL);
+
+	/* ... update usbfs periodic stats */
+	oxu_to_hcd(oxu)->self.bandwidth_int_reqs++;
+
+done:
+	spin_unlock_irqrestore(&oxu->lock, flags);
+	if (status)
+		qtd_list_free(oxu, urb, qtd_list);
+
+	return status;
+}
+
+static inline int itd_submit(struct oxu_hcd *oxu, struct urb *urb,
+						gfp_t mem_flags)
+{
+	oxu_dbg(oxu, "iso support is missing!\n");
+	return -ENOSYS;
+}
+
+static inline int sitd_submit(struct oxu_hcd *oxu, struct urb *urb,
+						gfp_t mem_flags)
+{
+	oxu_dbg(oxu, "split iso support is missing!\n");
+	return -ENOSYS;
+}
+
+static void scan_periodic(struct oxu_hcd *oxu)
+{
+	unsigned frame, clock, now_uframe, mod;
+	unsigned modified;
+
+	mod = oxu->periodic_size << 3;
+
+	/*
+	 * When running, scan from last scan point up to "now"
+	 * else clean up by scanning everything that's left.
+	 * Touches as few pages as possible:  cache-friendly.
+	 */
+	now_uframe = oxu->next_uframe;
+	if (HC_IS_RUNNING(oxu_to_hcd(oxu)->state))
+		clock = readl(&oxu->regs->frame_index);
+	else
+		clock = now_uframe + mod - 1;
+	clock %= mod;
+
+	for (;;) {
+		union ehci_shadow	q, *q_p;
+		__le32			type, *hw_p;
+		unsigned		uframes;
+
+		/* don't scan past the live uframe */
+		frame = now_uframe >> 3;
+		if (frame == (clock >> 3))
+			uframes = now_uframe & 0x07;
+		else {
+			/* safe to scan the whole frame at once */
+			now_uframe |= 0x07;
+			uframes = 8;
+		}
+
+restart:
+		/* scan each element in frame's queue for completions */
+		q_p = &oxu->pshadow[frame];
+		hw_p = &oxu->periodic[frame];
+		q.ptr = q_p->ptr;
+		type = Q_NEXT_TYPE(*hw_p);
+		modified = 0;
+
+		while (q.ptr != NULL) {
+			union ehci_shadow temp;
+			int live;
+
+			live = HC_IS_RUNNING(oxu_to_hcd(oxu)->state);
+			switch (type) {
+			case Q_TYPE_QH:
+				/* handle any completions */
+				temp.qh = qh_get(q.qh);
+				type = Q_NEXT_TYPE(q.qh->hw_next);
+				q = q.qh->qh_next;
+				modified = qh_completions(oxu, temp.qh);
+				if (unlikely(list_empty(&temp.qh->qtd_list)))
+					intr_deschedule(oxu, temp.qh);
+				qh_put(temp.qh);
+				break;
+			default:
+				dbg("corrupt type %d frame %d shadow %p",
+					type, frame, q.ptr);
+				q.ptr = NULL;
+			}
+
+			/* assume completion callbacks modify the queue */
+			if (unlikely(modified))
+				goto restart;
+		}
+
+		/* Stop when we catch up to the HC */
+
+		/* FIXME:  this assumes we won't get lapped when
+		 * latencies climb; that should be rare, but...
+		 * detect it, and just go all the way around.
+		 * FLR might help detect this case, so long as latencies
+		 * don't exceed periodic_size msec (default 1.024 sec).
+		 */
+
+		/* FIXME: likewise assumes HC doesn't halt mid-scan */
+
+		if (now_uframe == clock) {
+			unsigned	now;
+
+			if (!HC_IS_RUNNING(oxu_to_hcd(oxu)->state))
+				break;
+			oxu->next_uframe = now_uframe;
+			now = readl(&oxu->regs->frame_index) % mod;
+			if (now_uframe == now)
+				break;
+
+			/* rescan the rest of this frame, then ... */
+			clock = now;
+		} else {
+			now_uframe++;
+			now_uframe %= mod;
+		}
+	}
+}
+
+/* On some systems, leaving remote wakeup enabled prevents system shutdown.
+ * The firmware seems to think that powering off is a wakeup event!
+ * This routine turns off remote wakeup and everything else, on all ports.
+ */
+static void ehci_turn_off_all_ports(struct oxu_hcd *oxu)
+{
+	int port = HCS_N_PORTS(oxu->hcs_params);
+
+	while (port--)
+		writel(PORT_RWC_BITS, &oxu->regs->port_status[port]);
+}
+
+static void ehci_port_power(struct oxu_hcd *oxu, int is_on)
+{
+	unsigned port;
+
+	if (!HCS_PPC(oxu->hcs_params))
+		return;
+
+	oxu_dbg(oxu, "...power%s ports...\n", is_on ? "up" : "down");
+	for (port = HCS_N_PORTS(oxu->hcs_params); port > 0; )
+		(void) oxu_hub_control(oxu_to_hcd(oxu),
+				is_on ? SetPortFeature : ClearPortFeature,
+				USB_PORT_FEAT_POWER,
+				port--, NULL, 0);
+	msleep(20);
+}
+
+/* Called from some interrupts, timers, and so on.
+ * It calls driver completion functions, after dropping oxu->lock.
+ */
+static void ehci_work(struct oxu_hcd *oxu)
+{
+	timer_action_done(oxu, TIMER_IO_WATCHDOG);
+	if (oxu->reclaim_ready)
+		end_unlink_async(oxu);
+
+	/* another CPU may drop oxu->lock during a schedule scan while
+	 * it reports urb completions.  this flag guards against bogus
+	 * attempts at re-entrant schedule scanning.
+	 */
+	if (oxu->scanning)
+		return;
+	oxu->scanning = 1;
+	scan_async(oxu);
+	if (oxu->next_uframe != -1)
+		scan_periodic(oxu);
+	oxu->scanning = 0;
+
+	/* the IO watchdog guards against hardware or driver bugs that
+	 * misplace IRQs, and should let us run completely without IRQs.
+	 * such lossage has been observed on both VT6202 and VT8235.
+	 */
+	if (HC_IS_RUNNING(oxu_to_hcd(oxu)->state) &&
+			(oxu->async->qh_next.ptr != NULL ||
+			 oxu->periodic_sched != 0))
+		timer_action(oxu, TIMER_IO_WATCHDOG);
+}
+
+static void unlink_async(struct oxu_hcd *oxu, struct ehci_qh *qh)
+{
+	/* if we need to use IAA and it's busy, defer */
+	if (qh->qh_state == QH_STATE_LINKED
+			&& oxu->reclaim
+			&& HC_IS_RUNNING(oxu_to_hcd(oxu)->state)) {
+		struct ehci_qh		*last;
+
+		for (last = oxu->reclaim;
+				last->reclaim;
+				last = last->reclaim)
+			continue;
+		qh->qh_state = QH_STATE_UNLINK_WAIT;
+		last->reclaim = qh;
+
+	/* bypass IAA if the hc can't care */
+	} else if (!HC_IS_RUNNING(oxu_to_hcd(oxu)->state) && oxu->reclaim)
+		end_unlink_async(oxu);
+
+	/* something else might have unlinked the qh by now */
+	if (qh->qh_state == QH_STATE_LINKED)
+		start_unlink_async(oxu, qh);
+}
+
+/*
+ * USB host controller methods
+ */
+
+static irqreturn_t oxu210_hcd_irq(struct usb_hcd *hcd)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+	u32 status, pcd_status = 0;
+	int bh;
+
+	spin_lock(&oxu->lock);
+
+	status = readl(&oxu->regs->status);
+
+	/* e.g. cardbus physical eject */
+	if (status == ~(u32) 0) {
+		oxu_dbg(oxu, "device removed\n");
+		goto dead;
+	}
+
+	status &= INTR_MASK;
+	if (!status) {			/* irq sharing? */
+		spin_unlock(&oxu->lock);
+		return IRQ_NONE;
+	}
+
+	/* clear (just) interrupts */
+	writel(status, &oxu->regs->status);
+	readl(&oxu->regs->command);	/* unblock posted write */
+	bh = 0;
+
+#ifdef OXU_VERBOSE_DEBUG
+	/* unrequested/ignored: Frame List Rollover */
+	dbg_status(oxu, "irq", status);
+#endif
+
+	/* INT, ERR, and IAA interrupt rates can be throttled */
+
+	/* normal [4.15.1.2] or error [4.15.1.1] completion */
+	if (likely((status & (STS_INT|STS_ERR)) != 0))
+		bh = 1;
+
+	/* complete the unlinking of some qh [4.15.2.3] */
+	if (status & STS_IAA) {
+		oxu->reclaim_ready = 1;
+		bh = 1;
+	}
+
+	/* remote wakeup [4.3.1] */
+	if (status & STS_PCD) {
+		unsigned i = HCS_N_PORTS(oxu->hcs_params);
+		pcd_status = status;
+
+		/* resume root hub? */
+		if (!(readl(&oxu->regs->command) & CMD_RUN))
+			usb_hcd_resume_root_hub(hcd);
+
+		while (i--) {
+			int pstatus = readl(&oxu->regs->port_status[i]);
+
+			if (pstatus & PORT_OWNER)
+				continue;
+			if (!(pstatus & PORT_RESUME)
+					|| oxu->reset_done[i] != 0)
+				continue;
+
+			/* start 20 msec resume signaling from this port,
+			 * and make khubd collect PORT_STAT_C_SUSPEND to
+			 * stop that signaling.
+			 */
+			oxu->reset_done[i] = jiffies + msecs_to_jiffies(20);
+			oxu_dbg(oxu, "port %d remote wakeup\n", i + 1);
+			mod_timer(&hcd->rh_timer, oxu->reset_done[i]);
+		}
+	}
+
+	/* PCI errors [4.15.2.4] */
+	if (unlikely((status & STS_FATAL) != 0)) {
+		/* bogus "fatal" IRQs appear on some chips... why?  */
+		status = readl(&oxu->regs->status);
+		dbg_cmd(oxu, "fatal", readl(&oxu->regs->command));
+		dbg_status(oxu, "fatal", status);
+		if (status & STS_HALT) {
+			oxu_err(oxu, "fatal error\n");
+dead:
+			ehci_reset(oxu);
+			writel(0, &oxu->regs->configured_flag);
+			/* generic layer kills/unlinks all urbs, then
+			 * uses oxu_stop to clean up the rest
+			 */
+			bh = 1;
+		}
+	}
+
+	if (bh)
+		ehci_work(oxu);
+	spin_unlock(&oxu->lock);
+	if (pcd_status & STS_PCD)
+		usb_hcd_poll_rh_status(hcd);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t oxu_irq(struct usb_hcd *hcd)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+	int ret = IRQ_HANDLED;
+
+	u32 status = oxu_readl(hcd->regs, OXU_CHIPIRQSTATUS);
+	u32 enable = oxu_readl(hcd->regs, OXU_CHIPIRQEN_SET);
+
+	/* Disable all interrupt */
+	oxu_writel(hcd->regs, OXU_CHIPIRQEN_CLR, enable);
+
+	if ((oxu->is_otg && (status & OXU_USBOTGI)) ||
+		(!oxu->is_otg && (status & OXU_USBSPHI)))
+		oxu210_hcd_irq(hcd);
+	else
+		ret = IRQ_NONE;
+
+	/* Enable all interrupt back */
+	oxu_writel(hcd->regs, OXU_CHIPIRQEN_SET, enable);
+
+	return ret;
+}
+
+static void oxu_watchdog(unsigned long param)
+{
+	struct oxu_hcd	*oxu = (struct oxu_hcd *) param;
+	unsigned long flags;
+
+	spin_lock_irqsave(&oxu->lock, flags);
+
+	/* lost IAA irqs wedge things badly; seen with a vt8235 */
+	if (oxu->reclaim) {
+		u32 status = readl(&oxu->regs->status);
+		if (status & STS_IAA) {
+			oxu_vdbg(oxu, "lost IAA\n");
+			writel(STS_IAA, &oxu->regs->status);
+			oxu->reclaim_ready = 1;
+		}
+	}
+
+	/* stop async processing after it's idled a bit */
+	if (test_bit(TIMER_ASYNC_OFF, &oxu->actions))
+		start_unlink_async(oxu, oxu->async);
+
+	/* oxu could run by timer, without IRQs ... */
+	ehci_work(oxu);
+
+	spin_unlock_irqrestore(&oxu->lock, flags);
+}
+
+/* One-time init, only for memory state.
+ */
+static int oxu_hcd_init(struct usb_hcd *hcd)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+	u32 temp;
+	int retval;
+	u32 hcc_params;
+
+	spin_lock_init(&oxu->lock);
+
+	init_timer(&oxu->watchdog);
+	oxu->watchdog.function = oxu_watchdog;
+	oxu->watchdog.data = (unsigned long) oxu;
+
+	/*
+	 * hw default: 1K periodic list heads, one per frame.
+	 * periodic_size can shrink by USBCMD update if hcc_params allows.
+	 */
+	oxu->periodic_size = DEFAULT_I_TDPS;
+	retval = ehci_mem_init(oxu, GFP_KERNEL);
+	if (retval < 0)
+		return retval;
+
+	/* controllers may cache some of the periodic schedule ... */
+	hcc_params = readl(&oxu->caps->hcc_params);
+	if (HCC_ISOC_CACHE(hcc_params))		/* full frame cache */
+		oxu->i_thresh = 8;
+	else					/* N microframes cached */
+		oxu->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
+
+	oxu->reclaim = NULL;
+	oxu->reclaim_ready = 0;
+	oxu->next_uframe = -1;
+
+	/*
+	 * dedicate a qh for the async ring head, since we couldn't unlink
+	 * a 'real' qh without stopping the async schedule [4.8].  use it
+	 * as the 'reclamation list head' too.
+	 * its dummy is used in hw_alt_next of many tds, to prevent the qh
+	 * from automatically advancing to the next td after short reads.
+	 */
+	oxu->async->qh_next.qh = NULL;
+	oxu->async->hw_next = QH_NEXT(oxu->async->qh_dma);
+	oxu->async->hw_info1 = cpu_to_le32(QH_HEAD);
+	oxu->async->hw_token = cpu_to_le32(QTD_STS_HALT);
+	oxu->async->hw_qtd_next = EHCI_LIST_END;
+	oxu->async->qh_state = QH_STATE_LINKED;
+	oxu->async->hw_alt_next = QTD_NEXT(oxu->async->dummy->qtd_dma);
+
+	/* clear interrupt enables, set irq latency */
+	if (log2_irq_thresh < 0 || log2_irq_thresh > 6)
+		log2_irq_thresh = 0;
+	temp = 1 << (16 + log2_irq_thresh);
+	if (HCC_CANPARK(hcc_params)) {
+		/* HW default park == 3, on hardware that supports it (like
+		 * NVidia and ALI silicon), maximizes throughput on the async
+		 * schedule by avoiding QH fetches between transfers.
+		 *
+		 * With fast usb storage devices and NForce2, "park" seems to
+		 * make problems:  throughput reduction (!), data errors...
+		 */
+		if (park) {
+			park = min(park, (unsigned) 3);
+			temp |= CMD_PARK;
+			temp |= park << 8;
+		}
+		oxu_dbg(oxu, "park %d\n", park);
+	}
+	if (HCC_PGM_FRAMELISTLEN(hcc_params)) {
+		/* periodic schedule size can be smaller than default */
+		temp &= ~(3 << 2);
+		temp |= (EHCI_TUNE_FLS << 2);
+	}
+	oxu->command = temp;
+
+	return 0;
+}
+
+/* Called during probe() after chip reset completes.
+ */
+static int oxu_reset(struct usb_hcd *hcd)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+	int ret;
+
+	spin_lock_init(&oxu->mem_lock);
+	INIT_LIST_HEAD(&oxu->urb_list);
+	oxu->urb_len = 0;
+
+	/* FIMXE */
+	hcd->self.controller->dma_mask = NULL;
+
+	if (oxu->is_otg) {
+		oxu->caps = hcd->regs + OXU_OTG_CAP_OFFSET;
+		oxu->regs = hcd->regs + OXU_OTG_CAP_OFFSET + \
+			HC_LENGTH(readl(&oxu->caps->hc_capbase));
+
+		oxu->mem = hcd->regs + OXU_SPH_MEM;
+	} else {
+		oxu->caps = hcd->regs + OXU_SPH_CAP_OFFSET;
+		oxu->regs = hcd->regs + OXU_SPH_CAP_OFFSET + \
+			HC_LENGTH(readl(&oxu->caps->hc_capbase));
+
+		oxu->mem = hcd->regs + OXU_OTG_MEM;
+	}
+
+	oxu->hcs_params = readl(&oxu->caps->hcs_params);
+	oxu->sbrn = 0x20;
+
+	ret = oxu_hcd_init(hcd);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int oxu_run(struct usb_hcd *hcd)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+	int retval;
+	u32 temp, hcc_params;
+
+	hcd->uses_new_polling = 1;
+	hcd->poll_rh = 0;
+
+	/* EHCI spec section 4.1 */
+	retval = ehci_reset(oxu);
+	if (retval != 0) {
+		ehci_mem_cleanup(oxu);
+		return retval;
+	}
+	writel(oxu->periodic_dma, &oxu->regs->frame_list);
+	writel((u32) oxu->async->qh_dma, &oxu->regs->async_next);
+
+	/* hcc_params controls whether oxu->regs->segment must (!!!)
+	 * be used; it constrains QH/ITD/SITD and QTD locations.
+	 * pci_pool consistent memory always uses segment zero.
+	 * streaming mappings for I/O buffers, like pci_map_single(),
+	 * can return segments above 4GB, if the device allows.
+	 *
+	 * NOTE:  the dma mask is visible through dma_supported(), so
+	 * drivers can pass this info along ... like NETIF_F_HIGHDMA,
+	 * Scsi_Host.highmem_io, and so forth.  It's readonly to all
+	 * host side drivers though.
+	 */
+	hcc_params = readl(&oxu->caps->hcc_params);
+	if (HCC_64BIT_ADDR(hcc_params))
+		writel(0, &oxu->regs->segment);
+
+	oxu->command &= ~(CMD_LRESET | CMD_IAAD | CMD_PSE |
+				CMD_ASE | CMD_RESET);
+	oxu->command |= CMD_RUN;
+	writel(oxu->command, &oxu->regs->command);
+	dbg_cmd(oxu, "init", oxu->command);
+
+	/*
+	 * Start, enabling full USB 2.0 functionality ... usb 1.1 devices
+	 * are explicitly handed to companion controller(s), so no TT is
+	 * involved with the root hub.  (Except where one is integrated,
+	 * and there's no companion controller unless maybe for USB OTG.)
+	 */
+	hcd->state = HC_STATE_RUNNING;
+	writel(FLAG_CF, &oxu->regs->configured_flag);
+	readl(&oxu->regs->command);	/* unblock posted writes */
+
+	temp = HC_VERSION(readl(&oxu->caps->hc_capbase));
+	oxu_info(oxu, "USB %x.%x started, quasi-EHCI %x.%02x, driver %s%s\n",
+		((oxu->sbrn & 0xf0)>>4), (oxu->sbrn & 0x0f),
+		temp >> 8, temp & 0xff, DRIVER_VERSION,
+		ignore_oc ? ", overcurrent ignored" : "");
+
+	writel(INTR_MASK, &oxu->regs->intr_enable); /* Turn On Interrupts */
+
+	return 0;
+}
+
+static void oxu_stop(struct usb_hcd *hcd)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+
+	/* Turn off port power on all root hub ports. */
+	ehci_port_power(oxu, 0);
+
+	/* no more interrupts ... */
+	del_timer_sync(&oxu->watchdog);
+
+	spin_lock_irq(&oxu->lock);
+	if (HC_IS_RUNNING(hcd->state))
+		ehci_quiesce(oxu);
+
+	ehci_reset(oxu);
+	writel(0, &oxu->regs->intr_enable);
+	spin_unlock_irq(&oxu->lock);
+
+	/* let companion controllers work when we aren't */
+	writel(0, &oxu->regs->configured_flag);
+
+	/* root hub is shut down separately (first, when possible) */
+	spin_lock_irq(&oxu->lock);
+	if (oxu->async)
+		ehci_work(oxu);
+	spin_unlock_irq(&oxu->lock);
+	ehci_mem_cleanup(oxu);
+
+	dbg_status(oxu, "oxu_stop completed", readl(&oxu->regs->status));
+}
+
+/* Kick in for silicon on any bus (not just pci, etc).
+ * This forcibly disables dma and IRQs, helping kexec and other cases
+ * where the next system software may expect clean state.
+ */
+static void oxu_shutdown(struct usb_hcd *hcd)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+
+	(void) ehci_halt(oxu);
+	ehci_turn_off_all_ports(oxu);
+
+	/* make BIOS/etc use companion controller during reboot */
+	writel(0, &oxu->regs->configured_flag);
+
+	/* unblock posted writes */
+	readl(&oxu->regs->configured_flag);
+}
+
+/* Non-error returns are a promise to giveback() the urb later
+ * we drop ownership so next owner (or urb unlink) can get it
+ *
+ * urb + dev is in hcd.self.controller.urb_list
+ * we're queueing TDs onto software and hardware lists
+ *
+ * hcd-specific init for hcpriv hasn't been done yet
+ *
+ * NOTE:  control, bulk, and interrupt share the same code to append TDs
+ * to a (possibly active) QH, and the same QH scanning code.
+ */
+static int __oxu_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
+				gfp_t mem_flags)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+	struct list_head qtd_list;
+
+	INIT_LIST_HEAD(&qtd_list);
+
+	switch (usb_pipetype(urb->pipe)) {
+	case PIPE_CONTROL:
+	case PIPE_BULK:
+	default:
+		if (!qh_urb_transaction(oxu, urb, &qtd_list, mem_flags))
+			return -ENOMEM;
+		return submit_async(oxu, urb, &qtd_list, mem_flags);
+
+	case PIPE_INTERRUPT:
+		if (!qh_urb_transaction(oxu, urb, &qtd_list, mem_flags))
+			return -ENOMEM;
+		return intr_submit(oxu, urb, &qtd_list, mem_flags);
+
+	case PIPE_ISOCHRONOUS:
+		if (urb->dev->speed == USB_SPEED_HIGH)
+			return itd_submit(oxu, urb, mem_flags);
+		else
+			return sitd_submit(oxu, urb, mem_flags);
+	}
+}
+
+/* This function is responsible for breaking URBs with big data size
+ * into smaller size and processing small urbs in sequence.
+ */
+static int oxu_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
+				gfp_t mem_flags)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+	int num, rem;
+	int transfer_buffer_length;
+	void *transfer_buffer;
+	struct urb *murb;
+	int i, ret;
+
+	/* If not bulk pipe just enqueue the URB */
+	if (!usb_pipebulk(urb->pipe))
+		return __oxu_urb_enqueue(hcd, urb, mem_flags);
+
+	/* Otherwise we should verify the USB transfer buffer size! */
+	transfer_buffer = urb->transfer_buffer;
+	transfer_buffer_length = urb->transfer_buffer_length;
+
+	num = urb->transfer_buffer_length / 4096;
+	rem = urb->transfer_buffer_length % 4096;
+	if (rem != 0)
+		num++;
+
+	/* If URB is smaller than 4096 bytes just enqueue it! */
+	if (num == 1)
+		return __oxu_urb_enqueue(hcd, urb, mem_flags);
+
+	/* Ok, we have more job to do! :) */
+
+	for (i = 0; i < num - 1; i++) {
+		/* Get free micro URB poll till a free urb is recieved */
+
+		do {
+			murb = (struct urb *) oxu_murb_alloc(oxu);
+			if (!murb)
+				schedule();
+		} while (!murb);
+
+		/* Coping the urb */
+		memcpy(murb, urb, sizeof(struct urb));
+
+		murb->transfer_buffer_length = 4096;
+		murb->transfer_buffer = transfer_buffer + i * 4096;
+
+		/* Null pointer for the encodes that this is a micro urb */
+		murb->complete = NULL;
+
+		((struct oxu_murb *) murb)->main = urb;
+		((struct oxu_murb *) murb)->last = 0;
+
+		/* This loop is to guarantee urb to be processed when there's
+		 * not enough resources at a particular time by retrying.
+		 */
+		do {
+			ret  = __oxu_urb_enqueue(hcd, murb, mem_flags);
+			if (ret)
+				schedule();
+		} while (ret);
+	}
+
+	/* Last urb requires special handling  */
+
+	/* Get free micro URB poll till a free urb is recieved */
+	do {
+		murb = (struct urb *) oxu_murb_alloc(oxu);
+		if (!murb)
+			schedule();
+	} while (!murb);
+
+	/* Coping the urb */
+	memcpy(murb, urb, sizeof(struct urb));
+
+	murb->transfer_buffer_length = rem > 0 ? rem : 4096;
+	murb->transfer_buffer = transfer_buffer + (num - 1) * 4096;
+
+	/* Null pointer for the encodes that this is a micro urb */
+	murb->complete = NULL;
+
+	((struct oxu_murb *) murb)->main = urb;
+	((struct oxu_murb *) murb)->last = 1;
+
+	do {
+		ret = __oxu_urb_enqueue(hcd, murb, mem_flags);
+		if (ret)
+			schedule();
+	} while (ret);
+
+	return ret;
+}
+
+/* Remove from hardware lists.
+ * Completions normally happen asynchronously
+ */
+static int oxu_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+	struct ehci_qh *qh;
+	unsigned long flags;
+
+	spin_lock_irqsave(&oxu->lock, flags);
+	switch (usb_pipetype(urb->pipe)) {
+	case PIPE_CONTROL:
+	case PIPE_BULK:
+	default:
+		qh = (struct ehci_qh *) urb->hcpriv;
+		if (!qh)
+			break;
+		unlink_async(oxu, qh);
+		break;
+
+	case PIPE_INTERRUPT:
+		qh = (struct ehci_qh *) urb->hcpriv;
+		if (!qh)
+			break;
+		switch (qh->qh_state) {
+		case QH_STATE_LINKED:
+			intr_deschedule(oxu, qh);
+			/* FALL THROUGH */
+		case QH_STATE_IDLE:
+			qh_completions(oxu, qh);
+			break;
+		default:
+			oxu_dbg(oxu, "bogus qh %p state %d\n",
+					qh, qh->qh_state);
+			goto done;
+		}
+
+		/* reschedule QH iff another request is queued */
+		if (!list_empty(&qh->qtd_list)
+				&& HC_IS_RUNNING(hcd->state)) {
+			int status;
+
+			status = qh_schedule(oxu, qh);
+			spin_unlock_irqrestore(&oxu->lock, flags);
+
+			if (status != 0) {
+				/* shouldn't happen often, but ...
+				 * FIXME kill those tds' urbs
+				 */
+				err("can't reschedule qh %p, err %d",
+					qh, status);
+			}
+			return status;
+		}
+		break;
+	}
+done:
+	spin_unlock_irqrestore(&oxu->lock, flags);
+	return 0;
+}
+
+/* Bulk qh holds the data toggle */
+static void oxu_endpoint_disable(struct usb_hcd *hcd,
+					struct usb_host_endpoint *ep)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+	unsigned long		flags;
+	struct ehci_qh		*qh, *tmp;
+
+	/* ASSERT:  any requests/urbs are being unlinked */
+	/* ASSERT:  nobody can be submitting urbs for this any more */
+
+rescan:
+	spin_lock_irqsave(&oxu->lock, flags);
+	qh = ep->hcpriv;
+	if (!qh)
+		goto done;
+
+	/* endpoints can be iso streams.  for now, we don't
+	 * accelerate iso completions ... so spin a while.
+	 */
+	if (qh->hw_info1 == 0) {
+		oxu_vdbg(oxu, "iso delay\n");
+		goto idle_timeout;
+	}
+
+	if (!HC_IS_RUNNING(hcd->state))
+		qh->qh_state = QH_STATE_IDLE;
+	switch (qh->qh_state) {
+	case QH_STATE_LINKED:
+		for (tmp = oxu->async->qh_next.qh;
+				tmp && tmp != qh;
+				tmp = tmp->qh_next.qh)
+			continue;
+		/* periodic qh self-unlinks on empty */
+		if (!tmp)
+			goto nogood;
+		unlink_async(oxu, qh);
+		/* FALL THROUGH */
+	case QH_STATE_UNLINK:		/* wait for hw to finish? */
+idle_timeout:
+		spin_unlock_irqrestore(&oxu->lock, flags);
+		schedule_timeout_uninterruptible(1);
+		goto rescan;
+	case QH_STATE_IDLE:		/* fully unlinked */
+		if (list_empty(&qh->qtd_list)) {
+			qh_put(qh);
+			break;
+		}
+		/* else FALL THROUGH */
+	default:
+nogood:
+		/* caller was supposed to have unlinked any requests;
+		 * that's not our job.  just leak this memory.
+		 */
+		oxu_err(oxu, "qh %p (#%02x) state %d%s\n",
+			qh, ep->desc.bEndpointAddress, qh->qh_state,
+			list_empty(&qh->qtd_list) ? "" : "(has tds)");
+		break;
+	}
+	ep->hcpriv = NULL;
+done:
+	spin_unlock_irqrestore(&oxu->lock, flags);
+	return;
+}
+
+static int oxu_get_frame(struct usb_hcd *hcd)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+
+	return (readl(&oxu->regs->frame_index) >> 3) %
+		oxu->periodic_size;
+}
+
+/* Build "status change" packet (one or two bytes) from HC registers */
+static int oxu_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+	u32 temp, mask, status = 0;
+	int ports, i, retval = 1;
+	unsigned long flags;
+
+	/* if !USB_SUSPEND, root hub timers won't get shut down ... */
+	if (!HC_IS_RUNNING(hcd->state))
+		return 0;
+
+	/* init status to no-changes */
+	buf[0] = 0;
+	ports = HCS_N_PORTS(oxu->hcs_params);
+	if (ports > 7) {
+		buf[1] = 0;
+		retval++;
+	}
+
+	/* Some boards (mostly VIA?) report bogus overcurrent indications,
+	 * causing massive log spam unless we completely ignore them.  It
+	 * may be relevant that VIA VT8235 controlers, where PORT_POWER is
+	 * always set, seem to clear PORT_OCC and PORT_CSC when writing to
+	 * PORT_POWER; that's surprising, but maybe within-spec.
+	 */
+	if (!ignore_oc)
+		mask = PORT_CSC | PORT_PEC | PORT_OCC;
+	else
+		mask = PORT_CSC | PORT_PEC;
+
+	/* no hub change reports (bit 0) for now (power, ...) */
+
+	/* port N changes (bit N)? */
+	spin_lock_irqsave(&oxu->lock, flags);
+	for (i = 0; i < ports; i++) {
+		temp = readl(&oxu->regs->port_status[i]);
+
+		/*
+		 * Return status information even for ports with OWNER set.
+		 * Otherwise khubd wouldn't see the disconnect event when a
+		 * high-speed device is switched over to the companion
+		 * controller by the user.
+		 */
+
+		if (!(temp & PORT_CONNECT))
+			oxu->reset_done[i] = 0;
+		if ((temp & mask) != 0 || ((temp & PORT_RESUME) != 0 &&
+				time_after_eq(jiffies, oxu->reset_done[i]))) {
+			if (i < 7)
+				buf[0] |= 1 << (i + 1);
+			else
+				buf[1] |= 1 << (i - 7);
+			status = STS_PCD;
+		}
+	}
+	/* FIXME autosuspend idle root hubs */
+	spin_unlock_irqrestore(&oxu->lock, flags);
+	return status ? retval : 0;
+}
+
+/* Returns the speed of a device attached to a port on the root hub. */
+static inline unsigned int oxu_port_speed(struct oxu_hcd *oxu,
+						unsigned int portsc)
+{
+	switch ((portsc >> 26) & 3) {
+	case 0:
+		return 0;
+	case 1:
+		return 1 << USB_PORT_FEAT_LOWSPEED;
+	case 2:
+	default:
+		return 1 << USB_PORT_FEAT_HIGHSPEED;
+	}
+}
+
+#define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
+static int oxu_hub_control(struct usb_hcd *hcd, u16 typeReq,
+				u16 wValue, u16 wIndex, char *buf, u16 wLength)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+	int ports = HCS_N_PORTS(oxu->hcs_params);
+	u32 __iomem *status_reg = &oxu->regs->port_status[wIndex - 1];
+	u32 temp, status;
+	unsigned long	flags;
+	int retval = 0;
+	unsigned selector;
+
+	/*
+	 * FIXME:  support SetPortFeatures USB_PORT_FEAT_INDICATOR.
+	 * HCS_INDICATOR may say we can change LEDs to off/amber/green.
+	 * (track current state ourselves) ... blink for diagnostics,
+	 * power, "this is the one", etc.  EHCI spec supports this.
+	 */
+
+	spin_lock_irqsave(&oxu->lock, flags);
+	switch (typeReq) {
+	case ClearHubFeature:
+		switch (wValue) {
+		case C_HUB_LOCAL_POWER:
+		case C_HUB_OVER_CURRENT:
+			/* no hub-wide feature/status flags */
+			break;
+		default:
+			goto error;
+		}
+		break;
+	case ClearPortFeature:
+		if (!wIndex || wIndex > ports)
+			goto error;
+		wIndex--;
+		temp = readl(status_reg);
+
+		/*
+		 * Even if OWNER is set, so the port is owned by the
+		 * companion controller, khubd needs to be able to clear
+		 * the port-change status bits (especially
+		 * USB_PORT_FEAT_C_CONNECTION).
+		 */
+
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			writel(temp & ~PORT_PE, status_reg);
+			break;
+		case USB_PORT_FEAT_C_ENABLE:
+			writel((temp & ~PORT_RWC_BITS) | PORT_PEC, status_reg);
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			if (temp & PORT_RESET)
+				goto error;
+			if (temp & PORT_SUSPEND) {
+				if ((temp & PORT_PE) == 0)
+					goto error;
+				/* resume signaling for 20 msec */
+				temp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
+				writel(temp | PORT_RESUME, status_reg);
+				oxu->reset_done[wIndex] = jiffies
+						+ msecs_to_jiffies(20);
+			}
+			break;
+		case USB_PORT_FEAT_C_SUSPEND:
+			/* we auto-clear this feature */
+			break;
+		case USB_PORT_FEAT_POWER:
+			if (HCS_PPC(oxu->hcs_params))
+				writel(temp & ~(PORT_RWC_BITS | PORT_POWER),
+					  status_reg);
+			break;
+		case USB_PORT_FEAT_C_CONNECTION:
+			writel((temp & ~PORT_RWC_BITS) | PORT_CSC, status_reg);
+			break;
+		case USB_PORT_FEAT_C_OVER_CURRENT:
+			writel((temp & ~PORT_RWC_BITS) | PORT_OCC, status_reg);
+			break;
+		case USB_PORT_FEAT_C_RESET:
+			/* GetPortStatus clears reset */
+			break;
+		default:
+			goto error;
+		}
+		readl(&oxu->regs->command);	/* unblock posted write */
+		break;
+	case GetHubDescriptor:
+		ehci_hub_descriptor(oxu, (struct usb_hub_descriptor *)
+			buf);
+		break;
+	case GetHubStatus:
+		/* no hub-wide feature/status flags */
+		memset(buf, 0, 4);
+		break;
+	case GetPortStatus:
+		if (!wIndex || wIndex > ports)
+			goto error;
+		wIndex--;
+		status = 0;
+		temp = readl(status_reg);
+
+		/* wPortChange bits */
+		if (temp & PORT_CSC)
+			status |= 1 << USB_PORT_FEAT_C_CONNECTION;
+		if (temp & PORT_PEC)
+			status |= 1 << USB_PORT_FEAT_C_ENABLE;
+		if ((temp & PORT_OCC) && !ignore_oc)
+			status |= 1 << USB_PORT_FEAT_C_OVER_CURRENT;
+
+		/* whoever resumes must GetPortStatus to complete it!! */
+		if (temp & PORT_RESUME) {
+
+			/* Remote Wakeup received? */
+			if (!oxu->reset_done[wIndex]) {
+				/* resume signaling for 20 msec */
+				oxu->reset_done[wIndex] = jiffies
+						+ msecs_to_jiffies(20);
+				/* check the port again */
+				mod_timer(&oxu_to_hcd(oxu)->rh_timer,
+						oxu->reset_done[wIndex]);
+			}
+
+			/* resume completed? */
+			else if (time_after_eq(jiffies,
+					oxu->reset_done[wIndex])) {
+				status |= 1 << USB_PORT_FEAT_C_SUSPEND;
+				oxu->reset_done[wIndex] = 0;
+
+				/* stop resume signaling */
+				temp = readl(status_reg);
+				writel(temp & ~(PORT_RWC_BITS | PORT_RESUME),
+					status_reg);
+				retval = handshake(oxu, status_reg,
+					   PORT_RESUME, 0, 2000 /* 2msec */);
+				if (retval != 0) {
+					oxu_err(oxu,
+						"port %d resume error %d\n",
+						wIndex + 1, retval);
+					goto error;
+				}
+				temp &= ~(PORT_SUSPEND|PORT_RESUME|(3<<10));
+			}
+		}
+
+		/* whoever resets must GetPortStatus to complete it!! */
+		if ((temp & PORT_RESET)
+				&& time_after_eq(jiffies,
+					oxu->reset_done[wIndex])) {
+			status |= 1 << USB_PORT_FEAT_C_RESET;
+			oxu->reset_done[wIndex] = 0;
+
+			/* force reset to complete */
+			writel(temp & ~(PORT_RWC_BITS | PORT_RESET),
+					status_reg);
+			/* REVISIT:  some hardware needs 550+ usec to clear
+			 * this bit; seems too long to spin routinely...
+			 */
+			retval = handshake(oxu, status_reg,
+					PORT_RESET, 0, 750);
+			if (retval != 0) {
+				oxu_err(oxu, "port %d reset error %d\n",
+					wIndex + 1, retval);
+				goto error;
+			}
+
+			/* see what we found out */
+			temp = check_reset_complete(oxu, wIndex, status_reg,
+					readl(status_reg));
+		}
+
+		/* transfer dedicated ports to the companion hc */
+		if ((temp & PORT_CONNECT) &&
+				test_bit(wIndex, &oxu->companion_ports)) {
+			temp &= ~PORT_RWC_BITS;
+			temp |= PORT_OWNER;
+			writel(temp, status_reg);
+			oxu_dbg(oxu, "port %d --> companion\n", wIndex + 1);
+			temp = readl(status_reg);
+		}
+
+		/*
+		 * Even if OWNER is set, there's no harm letting khubd
+		 * see the wPortStatus values (they should all be 0 except
+		 * for PORT_POWER anyway).
+		 */
+
+		if (temp & PORT_CONNECT) {
+			status |= 1 << USB_PORT_FEAT_CONNECTION;
+			/* status may be from integrated TT */
+			status |= oxu_port_speed(oxu, temp);
+		}
+		if (temp & PORT_PE)
+			status |= 1 << USB_PORT_FEAT_ENABLE;
+		if (temp & (PORT_SUSPEND|PORT_RESUME))
+			status |= 1 << USB_PORT_FEAT_SUSPEND;
+		if (temp & PORT_OC)
+			status |= 1 << USB_PORT_FEAT_OVER_CURRENT;
+		if (temp & PORT_RESET)
+			status |= 1 << USB_PORT_FEAT_RESET;
+		if (temp & PORT_POWER)
+			status |= 1 << USB_PORT_FEAT_POWER;
+
+#ifndef	OXU_VERBOSE_DEBUG
+	if (status & ~0xffff)	/* only if wPortChange is interesting */
+#endif
+		dbg_port(oxu, "GetStatus", wIndex + 1, temp);
+		put_unaligned(cpu_to_le32(status), (__le32 *) buf);
+		break;
+	case SetHubFeature:
+		switch (wValue) {
+		case C_HUB_LOCAL_POWER:
+		case C_HUB_OVER_CURRENT:
+			/* no hub-wide feature/status flags */
+			break;
+		default:
+			goto error;
+		}
+		break;
+	case SetPortFeature:
+		selector = wIndex >> 8;
+		wIndex &= 0xff;
+		if (!wIndex || wIndex > ports)
+			goto error;
+		wIndex--;
+		temp = readl(status_reg);
+		if (temp & PORT_OWNER)
+			break;
+
+		temp &= ~PORT_RWC_BITS;
+		switch (wValue) {
+		case USB_PORT_FEAT_SUSPEND:
+			if ((temp & PORT_PE) == 0
+					|| (temp & PORT_RESET) != 0)
+				goto error;
+			if (device_may_wakeup(&hcd->self.root_hub->dev))
+				temp |= PORT_WAKE_BITS;
+			writel(temp | PORT_SUSPEND, status_reg);
+			break;
+		case USB_PORT_FEAT_POWER:
+			if (HCS_PPC(oxu->hcs_params))
+				writel(temp | PORT_POWER, status_reg);
+			break;
+		case USB_PORT_FEAT_RESET:
+			if (temp & PORT_RESUME)
+				goto error;
+			/* line status bits may report this as low speed,
+			 * which can be fine if this root hub has a
+			 * transaction translator built in.
+			 */
+			oxu_vdbg(oxu, "port %d reset\n", wIndex + 1);
+			temp |= PORT_RESET;
+			temp &= ~PORT_PE;
+
+			/*
+			 * caller must wait, then call GetPortStatus
+			 * usb 2.0 spec says 50 ms resets on root
+			 */
+			oxu->reset_done[wIndex] = jiffies
+					+ msecs_to_jiffies(50);
+			writel(temp, status_reg);
+			break;
+
+		/* For downstream facing ports (these):  one hub port is put
+		 * into test mode according to USB2 11.24.2.13, then the hub
+		 * must be reset (which for root hub now means rmmod+modprobe,
+		 * or else system reboot).  See EHCI 2.3.9 and 4.14 for info
+		 * about the EHCI-specific stuff.
+		 */
+		case USB_PORT_FEAT_TEST:
+			if (!selector || selector > 5)
+				goto error;
+			ehci_quiesce(oxu);
+			ehci_halt(oxu);
+			temp |= selector << 16;
+			writel(temp, status_reg);
+			break;
+
+		default:
+			goto error;
+		}
+		readl(&oxu->regs->command);	/* unblock posted writes */
+		break;
+
+	default:
+error:
+		/* "stall" on error */
+		retval = -EPIPE;
+	}
+	spin_unlock_irqrestore(&oxu->lock, flags);
+	return retval;
+}
+
+#ifdef CONFIG_PM
+
+static int oxu_bus_suspend(struct usb_hcd *hcd)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+	int port;
+	int mask;
+
+	oxu_dbg(oxu, "suspend root hub\n");
+
+	if (time_before(jiffies, oxu->next_statechange))
+		msleep(5);
+
+	port = HCS_N_PORTS(oxu->hcs_params);
+	spin_lock_irq(&oxu->lock);
+
+	/* stop schedules, clean any completed work */
+	if (HC_IS_RUNNING(hcd->state)) {
+		ehci_quiesce(oxu);
+		hcd->state = HC_STATE_QUIESCING;
+	}
+	oxu->command = readl(&oxu->regs->command);
+	if (oxu->reclaim)
+		oxu->reclaim_ready = 1;
+	ehci_work(oxu);
+
+	/* Unlike other USB host controller types, EHCI doesn't have
+	 * any notion of "global" or bus-wide suspend.  The driver has
+	 * to manually suspend all the active unsuspended ports, and
+	 * then manually resume them in the bus_resume() routine.
+	 */
+	oxu->bus_suspended = 0;
+	while (port--) {
+		u32 __iomem *reg = &oxu->regs->port_status[port];
+		u32 t1 = readl(reg) & ~PORT_RWC_BITS;
+		u32 t2 = t1;
+
+		/* keep track of which ports we suspend */
+		if ((t1 & PORT_PE) && !(t1 & PORT_OWNER) &&
+				!(t1 & PORT_SUSPEND)) {
+			t2 |= PORT_SUSPEND;
+			set_bit(port, &oxu->bus_suspended);
+		}
+
+		/* enable remote wakeup on all ports */
+		if (device_may_wakeup(&hcd->self.root_hub->dev))
+			t2 |= PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E;
+		else
+			t2 &= ~(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E);
+
+		if (t1 != t2) {
+			oxu_vdbg(oxu, "port %d, %08x -> %08x\n",
+				port + 1, t1, t2);
+			writel(t2, reg);
+		}
+	}
+
+	/* turn off now-idle HC */
+	del_timer_sync(&oxu->watchdog);
+	ehci_halt(oxu);
+	hcd->state = HC_STATE_SUSPENDED;
+
+	/* allow remote wakeup */
+	mask = INTR_MASK;
+	if (!device_may_wakeup(&hcd->self.root_hub->dev))
+		mask &= ~STS_PCD;
+	writel(mask, &oxu->regs->intr_enable);
+	readl(&oxu->regs->intr_enable);
+
+	oxu->next_statechange = jiffies + msecs_to_jiffies(10);
+	spin_unlock_irq(&oxu->lock);
+	return 0;
+}
+
+/* Caller has locked the root hub, and should reset/reinit on error */
+static int oxu_bus_resume(struct usb_hcd *hcd)
+{
+	struct oxu_hcd *oxu = hcd_to_oxu(hcd);
+	u32 temp;
+	int i;
+
+	if (time_before(jiffies, oxu->next_statechange))
+		msleep(5);
+	spin_lock_irq(&oxu->lock);
+
+	/* Ideally and we've got a real resume here, and no port's power
+	 * was lost.  (For PCI, that means Vaux was maintained.)  But we
+	 * could instead be restoring a swsusp snapshot -- so that BIOS was
+	 * the last user of the controller, not reset/pm hardware keeping
+	 * state we gave to it.
+	 */
+	temp = readl(&oxu->regs->intr_enable);
+	oxu_dbg(oxu, "resume root hub%s\n", temp ? "" : " after power loss");
+
+	/* at least some APM implementations will try to deliver
+	 * IRQs right away, so delay them until we're ready.
+	 */
+	writel(0, &oxu->regs->intr_enable);
+
+	/* re-init operational registers */
+	writel(0, &oxu->regs->segment);
+	writel(oxu->periodic_dma, &oxu->regs->frame_list);
+	writel((u32) oxu->async->qh_dma, &oxu->regs->async_next);
+
+	/* restore CMD_RUN, framelist size, and irq threshold */
+	writel(oxu->command, &oxu->regs->command);
+
+	/* Some controller/firmware combinations need a delay during which
+	 * they set up the port statuses.  See Bugzilla #8190. */
+	mdelay(8);
+
+	/* manually resume the ports we suspended during bus_suspend() */
+	i = HCS_N_PORTS(oxu->hcs_params);
+	while (i--) {
+		temp = readl(&oxu->regs->port_status[i]);
+		temp &= ~(PORT_RWC_BITS
+			| PORT_WKOC_E | PORT_WKDISC_E | PORT_WKCONN_E);
+		if (test_bit(i, &oxu->bus_suspended) && (temp & PORT_SUSPEND)) {
+			oxu->reset_done[i] = jiffies + msecs_to_jiffies(20);
+			temp |= PORT_RESUME;
+		}
+		writel(temp, &oxu->regs->port_status[i]);
+	}
+	i = HCS_N_PORTS(oxu->hcs_params);
+	mdelay(20);
+	while (i--) {
+		temp = readl(&oxu->regs->port_status[i]);
+		if (test_bit(i, &oxu->bus_suspended) && (temp & PORT_SUSPEND)) {
+			temp &= ~(PORT_RWC_BITS | PORT_RESUME);
+			writel(temp, &oxu->regs->port_status[i]);
+			oxu_vdbg(oxu, "resumed port %d\n", i + 1);
+		}
+	}
+	(void) readl(&oxu->regs->command);
+
+	/* maybe re-activate the schedule(s) */
+	temp = 0;
+	if (oxu->async->qh_next.qh)
+		temp |= CMD_ASE;
+	if (oxu->periodic_sched)
+		temp |= CMD_PSE;
+	if (temp) {
+		oxu->command |= temp;
+		writel(oxu->command, &oxu->regs->command);
+	}
+
+	oxu->next_statechange = jiffies + msecs_to_jiffies(5);
+	hcd->state = HC_STATE_RUNNING;
+
+	/* Now we can safely re-enable irqs */
+	writel(INTR_MASK, &oxu->regs->intr_enable);
+
+	spin_unlock_irq(&oxu->lock);
+	return 0;
+}
+
+#else
+
+static int oxu_bus_suspend(struct usb_hcd *hcd)
+{
+	return 0;
+}
+
+static int oxu_bus_resume(struct usb_hcd *hcd)
+{
+	return 0;
+}
+
+#endif	/* CONFIG_PM */
+
+static const struct hc_driver oxu_hc_driver = {
+	.description =		"oxu210hp_hcd",
+	.product_desc =		"oxu210hp HCD",
+	.hcd_priv_size =	sizeof(struct oxu_hcd),
+
+	/*
+	 * Generic hardware linkage
+	 */
+	.irq =			oxu_irq,
+	.flags =		HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * Basic lifecycle operations
+	 */
+	.reset =		oxu_reset,
+	.start =		oxu_run,
+	.stop =			oxu_stop,
+	.shutdown =		oxu_shutdown,
+
+	/*
+	 * Managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		oxu_urb_enqueue,
+	.urb_dequeue =		oxu_urb_dequeue,
+	.endpoint_disable =	oxu_endpoint_disable,
+
+	/*
+	 * Scheduling support
+	 */
+	.get_frame_number =	oxu_get_frame,
+
+	/*
+	 * Root hub support
+	 */
+	.hub_status_data =	oxu_hub_status_data,
+	.hub_control =		oxu_hub_control,
+	.bus_suspend =		oxu_bus_suspend,
+	.bus_resume =		oxu_bus_resume,
+};
+
+/*
+ * Module stuff
+ */
+
+static void oxu_configuration(struct platform_device *pdev, void *base)
+{
+	u32 tmp;
+
+	/* Initialize top level registers.
+	 * First write ever
+	 */
+	oxu_writel(base, OXU_HOSTIFCONFIG, 0x0000037D);
+	oxu_writel(base, OXU_SOFTRESET, OXU_SRESET);
+	oxu_writel(base, OXU_HOSTIFCONFIG, 0x0000037D);
+
+	tmp = oxu_readl(base, OXU_PIOBURSTREADCTRL);
+	oxu_writel(base, OXU_PIOBURSTREADCTRL, tmp | 0x0040);
+
+	oxu_writel(base, OXU_ASO, OXU_SPHPOEN | OXU_OVRCCURPUPDEN |
+					OXU_COMPARATOR | OXU_ASO_OP);
+
+	tmp = oxu_readl(base, OXU_CLKCTRL_SET);
+	oxu_writel(base, OXU_CLKCTRL_SET, tmp | OXU_SYSCLKEN | OXU_USBOTGCLKEN);
+
+	/* Clear all top interrupt enable */
+	oxu_writel(base, OXU_CHIPIRQEN_CLR, 0xff);
+
+	/* Clear all top interrupt status */
+	oxu_writel(base, OXU_CHIPIRQSTATUS, 0xff);
+
+	/* Enable all needed top interrupt except OTG SPH core */
+	oxu_writel(base, OXU_CHIPIRQEN_SET, OXU_USBSPHLPWUI | OXU_USBOTGLPWUI);
+}
+
+static int oxu_verify_id(struct platform_device *pdev, void *base)
+{
+	u32 id;
+	char *bo[] = {
+		"reserved",
+		"128-pin LQFP",
+		"84-pin TFBGA",
+		"reserved",
+	};
+
+	/* Read controller signature register to find a match */
+	id = oxu_readl(base, OXU_DEVICEID);
+	dev_info(&pdev->dev, "device ID %x\n", id);
+	if ((id & OXU_REV_MASK) != (OXU_REV_2100 << OXU_REV_SHIFT))
+		return -1;
+
+	dev_info(&pdev->dev, "found device %x %s (%04x:%04x)\n",
+		id >> OXU_REV_SHIFT,
+		bo[(id & OXU_BO_MASK) >> OXU_BO_SHIFT],
+		(id & OXU_MAJ_REV_MASK) >> OXU_MAJ_REV_SHIFT,
+		(id & OXU_MIN_REV_MASK) >> OXU_MIN_REV_SHIFT);
+
+	return 0;
+}
+
+static const struct hc_driver oxu_hc_driver;
+static struct usb_hcd *oxu_create(struct platform_device *pdev,
+				unsigned long memstart, unsigned long memlen,
+				void *base, int irq, int otg)
+{
+	struct device *dev = &pdev->dev;
+
+	struct usb_hcd *hcd;
+	struct oxu_hcd *oxu;
+	int ret;
+
+	/* Set endian mode and host mode */
+	oxu_writel(base + (otg ? OXU_OTG_CORE_OFFSET : OXU_SPH_CORE_OFFSET),
+				OXU_USBMODE,
+				OXU_CM_HOST_ONLY | OXU_ES_LITTLE | OXU_VBPS);
+
+	hcd = usb_create_hcd(&oxu_hc_driver, dev,
+				otg ? "oxu210hp_otg" : "oxu210hp_sph");
+	if (!hcd)
+		return ERR_PTR(-ENOMEM);
+
+	hcd->rsrc_start = memstart;
+	hcd->rsrc_len = memlen;
+	hcd->regs = base;
+	hcd->irq = irq;
+	hcd->state = HC_STATE_HALT;
+
+	oxu = hcd_to_oxu(hcd);
+	oxu->is_otg = otg;
+
+	ret = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
+	return hcd;
+}
+
+static int oxu_init(struct platform_device *pdev,
+				unsigned long memstart, unsigned long memlen,
+				void *base, int irq)
+{
+	struct oxu_info *info = platform_get_drvdata(pdev);
+	struct usb_hcd *hcd;
+	int ret;
+
+	/* First time configuration at start up */
+	oxu_configuration(pdev, base);
+
+	ret = oxu_verify_id(pdev, base);
+	if (ret) {
+		dev_err(&pdev->dev, "no devices found!\n");
+		return -ENODEV;
+	}
+
+	/* Create the OTG controller */
+	hcd = oxu_create(pdev, memstart, memlen, base, irq, 1);
+	if (IS_ERR(hcd)) {
+		dev_err(&pdev->dev, "cannot create OTG controller!\n");
+		ret = PTR_ERR(hcd);
+		goto error_create_otg;
+	}
+	info->hcd[0] = hcd;
+
+	/* Create the SPH host controller */
+	hcd = oxu_create(pdev, memstart, memlen, base, irq, 0);
+	if (IS_ERR(hcd)) {
+		dev_err(&pdev->dev, "cannot create SPH controller!\n");
+		ret = PTR_ERR(hcd);
+		goto error_create_sph;
+	}
+	info->hcd[1] = hcd;
+
+	oxu_writel(base, OXU_CHIPIRQEN_SET,
+		oxu_readl(base, OXU_CHIPIRQEN_SET) | 3);
+
+	return 0;
+
+error_create_sph:
+	usb_remove_hcd(info->hcd[0]);
+	usb_put_hcd(info->hcd[0]);
+
+error_create_otg:
+	return ret;
+}
+
+static int oxu_drv_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	void *base;
+	unsigned long memstart, memlen;
+	int irq, ret;
+	struct oxu_info *info;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	/*
+	 * Get the platform resources
+	 */
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"no IRQ! Check %s setup!\n", dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	irq = res->start;
+	dev_dbg(&pdev->dev, "IRQ resource %d\n", irq);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no registers address! Check %s setup!\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	memstart = res->start;
+	memlen = res->end - res->start + 1;
+	dev_dbg(&pdev->dev, "MEM resource %lx-%lx\n", memstart, memlen);
+	if (!request_mem_region(memstart, memlen,
+				oxu_hc_driver.description)) {
+		dev_dbg(&pdev->dev, "memory area already in use\n");
+		return -EBUSY;
+	}
+
+	ret = set_irq_type(irq, IRQF_TRIGGER_FALLING);
+	if (ret) {
+		dev_err(&pdev->dev, "error setting irq type\n");
+		ret = -EFAULT;
+		goto error_set_irq_type;
+	}
+
+	base = ioremap(memstart, memlen);
+	if (!base) {
+		dev_dbg(&pdev->dev, "error mapping memory\n");
+		ret = -EFAULT;
+		goto error_ioremap;
+	}
+
+	/* Allocate a driver data struct to hold useful info for both
+	 * SPH & OTG devices
+	 */
+	info = kzalloc(sizeof(struct oxu_info), GFP_KERNEL);
+	if (!info) {
+		dev_dbg(&pdev->dev, "error allocating memory\n");
+		ret = -EFAULT;
+		goto error_alloc;
+	}
+	platform_set_drvdata(pdev, info);
+
+	ret = oxu_init(pdev, memstart, memlen, base, irq);
+	if (ret < 0) {
+		dev_dbg(&pdev->dev, "cannot init USB devices\n");
+		goto error_init;
+	}
+
+	dev_info(&pdev->dev, "devices enabled and running\n");
+	platform_set_drvdata(pdev, info);
+
+	return 0;
+
+error_init:
+	kfree(info);
+	platform_set_drvdata(pdev, NULL);
+
+error_alloc:
+	iounmap(base);
+
+error_set_irq_type:
+error_ioremap:
+	release_mem_region(memstart, memlen);
+
+	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), ret);
+	return ret;
+}
+
+static void oxu_remove(struct platform_device *pdev, struct usb_hcd *hcd)
+{
+	usb_remove_hcd(hcd);
+	usb_put_hcd(hcd);
+}
+
+static int oxu_drv_remove(struct platform_device *pdev)
+{
+	struct oxu_info *info = platform_get_drvdata(pdev);
+	unsigned long memstart = info->hcd[0]->rsrc_start,
+			memlen = info->hcd[0]->rsrc_len;
+	void *base = info->hcd[0]->regs;
+
+	oxu_remove(pdev, info->hcd[0]);
+	oxu_remove(pdev, info->hcd[1]);
+
+	iounmap(base);
+	release_mem_region(memstart, memlen);
+
+	kfree(info);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static void oxu_drv_shutdown(struct platform_device *pdev)
+{
+	oxu_drv_remove(pdev);
+}
+
+#if 0
+/* FIXME: TODO */
+static int oxu_drv_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+
+	return 0;
+}
+
+static int oxu_drv_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+
+	return 0;
+}
+#else
+#define oxu_drv_suspend	NULL
+#define oxu_drv_resume	NULL
+#endif
+
+static struct platform_driver oxu_driver = {
+	.probe		= oxu_drv_probe,
+	.remove		= oxu_drv_remove,
+	.shutdown	= oxu_drv_shutdown,
+	.suspend	= oxu_drv_suspend,
+	.resume		= oxu_drv_resume,
+	.driver = {
+		.name = "oxu210hp-hcd",
+		.bus = &platform_bus_type
+	}
+};
+
+static int __init oxu_module_init(void)
+{
+	int retval = 0;
+
+	retval = platform_driver_register(&oxu_driver);
+	if (retval < 0)
+		return retval;
+
+	return retval;
+}
+
+static void __exit oxu_module_cleanup(void)
+{
+	platform_driver_unregister(&oxu_driver);
+}
+
+module_init(oxu_module_init);
+module_exit(oxu_module_cleanup);
+
+MODULE_DESCRIPTION("Oxford OXU210HP HCD driver - ver. " DRIVER_VERSION);
+MODULE_AUTHOR("Rodolfo Giometti <giometti@linux.it>");
+MODULE_LICENSE("GPL");
diff -urN host/oxu210hp.h host.new/oxu210hp.h
--- host/oxu210hp.h	1970-01-01 01:00:00.000000000 +0100
+++ host.new/oxu210hp.h	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,447 @@
+/*
+ * Host interface registers
+ */
+
+#define OXU_DEVICEID			0x00
+	#define OXU_REV_MASK		0xffff0000
+	#define OXU_REV_SHIFT		16
+	#define OXU_REV_2100		0x2100
+	#define OXU_BO_SHIFT		8
+	#define OXU_BO_MASK		(0x3 << OXU_BO_SHIFT)
+	#define OXU_MAJ_REV_SHIFT	4
+	#define OXU_MAJ_REV_MASK	(0xf << OXU_MAJ_REV_SHIFT)
+	#define OXU_MIN_REV_SHIFT	0
+	#define OXU_MIN_REV_MASK	(0xf << OXU_MIN_REV_SHIFT)
+#define OXU_HOSTIFCONFIG		0x04
+#define OXU_SOFTRESET			0x08
+	#define OXU_SRESET		(1 << 0)
+
+#define OXU_PIOBURSTREADCTRL		0x0C
+
+#define OXU_CHIPIRQSTATUS		0x10
+#define OXU_CHIPIRQEN_SET		0x14
+#define OXU_CHIPIRQEN_CLR		0x18
+	#define OXU_USBSPHLPWUI		0x00000080
+	#define OXU_USBOTGLPWUI		0x00000040
+	#define OXU_USBSPHI		0x00000002
+	#define OXU_USBOTGI		0x00000001
+
+#define OXU_CLKCTRL_SET			0x1C
+	#define OXU_SYSCLKEN		0x00000008
+	#define OXU_USBSPHCLKEN		0x00000002
+	#define OXU_USBOTGCLKEN		0x00000001
+
+#define OXU_ASO				0x68
+	#define OXU_SPHPOEN		0x00000100
+	#define OXU_OVRCCURPUPDEN	0x00000800
+	#define OXU_ASO_OP		(1 << 10)
+	#define OXU_COMPARATOR		0x000004000
+
+#define OXU_USBMODE			0x1A8
+	#define OXU_VBPS		0x00000020
+	#define OXU_ES_LITTLE		0x00000000
+	#define OXU_CM_HOST_ONLY	0x00000003
+
+/*
+ * Proper EHCI structs & defines
+ */
+
+/* Magic numbers that can affect system performance */
+#define EHCI_TUNE_CERR		3	/* 0-3 qtd retries; 0 == don't stop */
+#define EHCI_TUNE_RL_HS		4	/* nak throttle; see 4.9 */
+#define EHCI_TUNE_RL_TT		0
+#define EHCI_TUNE_MULT_HS	1	/* 1-3 transactions/uframe; 4.10.3 */
+#define EHCI_TUNE_MULT_TT	1
+#define EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
+
+struct oxu_hcd;
+
+/* EHCI register interface, corresponds to EHCI Revision 0.95 specification */
+
+/* Section 2.2 Host Controller Capability Registers */
+struct ehci_caps {
+	/* these fields are specified as 8 and 16 bit registers,
+	 * but some hosts can't perform 8 or 16 bit PCI accesses.
+	 */
+	u32		hc_capbase;
+#define HC_LENGTH(p)		(((p)>>00)&0x00ff)	/* bits 7:0 */
+#define HC_VERSION(p)		(((p)>>16)&0xffff)	/* bits 31:16 */
+	u32		hcs_params;     /* HCSPARAMS - offset 0x4 */
+#define HCS_DEBUG_PORT(p)	(((p)>>20)&0xf)	/* bits 23:20, debug port? */
+#define HCS_INDICATOR(p)	((p)&(1 << 16))	/* true: has port indicators */
+#define HCS_N_CC(p)		(((p)>>12)&0xf)	/* bits 15:12, #companion HCs */
+#define HCS_N_PCC(p)		(((p)>>8)&0xf)	/* bits 11:8, ports per CC */
+#define HCS_PORTROUTED(p)	((p)&(1 << 7))	/* true: port routing */
+#define HCS_PPC(p)		((p)&(1 << 4))	/* true: port power control */
+#define HCS_N_PORTS(p)		(((p)>>0)&0xf)	/* bits 3:0, ports on HC */
+
+	u32		hcc_params;      /* HCCPARAMS - offset 0x8 */
+#define HCC_EXT_CAPS(p)		(((p)>>8)&0xff)	/* for pci extended caps */
+#define HCC_ISOC_CACHE(p)       ((p)&(1 << 7))  /* true: can cache isoc frame */
+#define HCC_ISOC_THRES(p)       (((p)>>4)&0x7)  /* bits 6:4, uframes cached */
+#define HCC_CANPARK(p)		((p)&(1 << 2))  /* true: can park on async qh */
+#define HCC_PGM_FRAMELISTLEN(p) ((p)&(1 << 1))  /* true: periodic_size changes*/
+#define HCC_64BIT_ADDR(p)       ((p)&(1))       /* true: can use 64-bit addr */
+	u8		portroute[8];	 /* nibbles for routing - offset 0xC */
+} __attribute__ ((packed));
+
+
+/* Section 2.3 Host Controller Operational Registers */
+struct ehci_regs {
+	/* USBCMD: offset 0x00 */
+	u32		command;
+/* 23:16 is r/w intr rate, in microframes; default "8" == 1/msec */
+#define CMD_PARK	(1<<11)		/* enable "park" on async qh */
+#define CMD_PARK_CNT(c)	(((c)>>8)&3)	/* how many transfers to park for */
+#define CMD_LRESET	(1<<7)		/* partial reset (no ports, etc) */
+#define CMD_IAAD	(1<<6)		/* "doorbell" interrupt async advance */
+#define CMD_ASE		(1<<5)		/* async schedule enable */
+#define CMD_PSE		(1<<4)		/* periodic schedule enable */
+/* 3:2 is periodic frame list size */
+#define CMD_RESET	(1<<1)		/* reset HC not bus */
+#define CMD_RUN		(1<<0)		/* start/stop HC */
+
+	/* USBSTS: offset 0x04 */
+	u32		status;
+#define STS_ASS		(1<<15)		/* Async Schedule Status */
+#define STS_PSS		(1<<14)		/* Periodic Schedule Status */
+#define STS_RECL	(1<<13)		/* Reclamation */
+#define STS_HALT	(1<<12)		/* Not running (any reason) */
+/* some bits reserved */
+	/* these STS_* flags are also intr_enable bits (USBINTR) */
+#define STS_IAA		(1<<5)		/* Interrupted on async advance */
+#define STS_FATAL	(1<<4)		/* such as some PCI access errors */
+#define STS_FLR		(1<<3)		/* frame list rolled over */
+#define STS_PCD		(1<<2)		/* port change detect */
+#define STS_ERR		(1<<1)		/* "error" completion (overflow, ...) */
+#define STS_INT		(1<<0)		/* "normal" completion (short, ...) */
+
+#define INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
+
+	/* USBINTR: offset 0x08 */
+	u32		intr_enable;
+
+	/* FRINDEX: offset 0x0C */
+	u32		frame_index;	/* current microframe number */
+	/* CTRLDSSEGMENT: offset 0x10 */
+	u32		segment;	/* address bits 63:32 if needed */
+	/* PERIODICLISTBASE: offset 0x14 */
+	u32		frame_list;	/* points to periodic list */
+	/* ASYNCLISTADDR: offset 0x18 */
+	u32		async_next;	/* address of next async queue head */
+
+	u32		reserved[9];
+
+	/* CONFIGFLAG: offset 0x40 */
+	u32		configured_flag;
+#define FLAG_CF		(1<<0)		/* true: we'll support "high speed" */
+
+	/* PORTSC: offset 0x44 */
+	u32		port_status[0];	/* up to N_PORTS */
+/* 31:23 reserved */
+#define PORT_WKOC_E	(1<<22)		/* wake on overcurrent (enable) */
+#define PORT_WKDISC_E	(1<<21)		/* wake on disconnect (enable) */
+#define PORT_WKCONN_E	(1<<20)		/* wake on connect (enable) */
+/* 19:16 for port testing */
+#define PORT_LED_OFF	(0<<14)
+#define PORT_LED_AMBER	(1<<14)
+#define PORT_LED_GREEN	(2<<14)
+#define PORT_LED_MASK	(3<<14)
+#define PORT_OWNER	(1<<13)		/* true: companion hc owns this port */
+#define PORT_POWER	(1<<12)		/* true: has power (see PPC) */
+#define PORT_USB11(x) (((x)&(3<<10)) == (1<<10))	/* USB 1.1 device */
+/* 11:10 for detecting lowspeed devices (reset vs release ownership) */
+/* 9 reserved */
+#define PORT_RESET	(1<<8)		/* reset port */
+#define PORT_SUSPEND	(1<<7)		/* suspend port */
+#define PORT_RESUME	(1<<6)		/* resume it */
+#define PORT_OCC	(1<<5)		/* over current change */
+#define PORT_OC		(1<<4)		/* over current active */
+#define PORT_PEC	(1<<3)		/* port enable change */
+#define PORT_PE		(1<<2)		/* port enable */
+#define PORT_CSC	(1<<1)		/* connect status change */
+#define PORT_CONNECT	(1<<0)		/* device connected */
+#define PORT_RWC_BITS   (PORT_CSC | PORT_PEC | PORT_OCC)
+} __attribute__ ((packed));
+
+/* Appendix C, Debug port ... intended for use with special "debug devices"
+ * that can help if there's no serial console.  (nonstandard enumeration.)
+ */
+struct ehci_dbg_port {
+	u32	control;
+#define DBGP_OWNER	(1<<30)
+#define DBGP_ENABLED	(1<<28)
+#define DBGP_DONE	(1<<16)
+#define DBGP_INUSE	(1<<10)
+#define DBGP_ERRCODE(x)	(((x)>>7)&0x07)
+#	define DBGP_ERR_BAD	1
+#	define DBGP_ERR_SIGNAL	2
+#define DBGP_ERROR	(1<<6)
+#define DBGP_GO		(1<<5)
+#define DBGP_OUT	(1<<4)
+#define DBGP_LEN(x)	(((x)>>0)&0x0f)
+	u32	pids;
+#define DBGP_PID_GET(x)		(((x)>>16)&0xff)
+#define DBGP_PID_SET(data, tok)	(((data)<<8)|(tok))
+	u32	data03;
+	u32	data47;
+	u32	address;
+#define DBGP_EPADDR(dev, ep)	(((dev)<<8)|(ep))
+} __attribute__ ((packed));
+
+
+#define	QTD_NEXT(dma)	cpu_to_le32((u32)dma)
+
+/*
+ * EHCI Specification 0.95 Section 3.5
+ * QTD: describe data transfer components (buffer, direction, ...)
+ * See Fig 3-6 "Queue Element Transfer Descriptor Block Diagram".
+ *
+ * These are associated only with "QH" (Queue Head) structures,
+ * used with control, bulk, and interrupt transfers.
+ */
+struct ehci_qtd {
+	/* first part defined by EHCI spec */
+	__le32			hw_next;		/* see EHCI 3.5.1 */
+	__le32			hw_alt_next;		/* see EHCI 3.5.2 */
+	__le32			hw_token;		/* see EHCI 3.5.3 */
+#define	QTD_TOGGLE	(1 << 31)	/* data toggle */
+#define	QTD_LENGTH(tok)	(((tok)>>16) & 0x7fff)
+#define	QTD_IOC		(1 << 15)	/* interrupt on complete */
+#define	QTD_CERR(tok)	(((tok)>>10) & 0x3)
+#define	QTD_PID(tok)	(((tok)>>8) & 0x3)
+#define	QTD_STS_ACTIVE	(1 << 7)	/* HC may execute this */
+#define	QTD_STS_HALT	(1 << 6)	/* halted on error */
+#define	QTD_STS_DBE	(1 << 5)	/* data buffer error (in HC) */
+#define	QTD_STS_BABBLE	(1 << 4)	/* device was babbling (qtd halted) */
+#define	QTD_STS_XACT	(1 << 3)	/* device gave illegal response */
+#define	QTD_STS_MMF	(1 << 2)	/* incomplete split transaction */
+#define	QTD_STS_STS	(1 << 1)	/* split transaction state */
+#define	QTD_STS_PING	(1 << 0)	/* issue PING? */
+	__le32			hw_buf[5];		/* see EHCI 3.5.4 */
+	__le32			hw_buf_hi[5];		/* Appendix B */
+
+	/* the rest is HCD-private */
+	dma_addr_t		qtd_dma;		/* qtd address */
+	struct list_head	qtd_list;		/* sw qtd list */
+	struct urb		*urb;			/* qtd's urb */
+	size_t			length;			/* length of buffer */
+
+	u32			qtd_buffer_len;
+	void			*buffer;
+	dma_addr_t		buffer_dma;
+	void			*transfer_buffer;
+	void			*transfer_dma;
+} __attribute__ ((aligned(32)));
+
+/* mask NakCnt+T in qh->hw_alt_next */
+#define QTD_MASK cpu_to_le32 (~0x1f)
+
+#define IS_SHORT_READ(token) (QTD_LENGTH(token) != 0 && QTD_PID(token) == 1)
+
+/* Type tag from {qh, itd, sitd, fstn}->hw_next */
+#define Q_NEXT_TYPE(dma) ((dma) & cpu_to_le32 (3 << 1))
+
+/* values for that type tag */
+#define Q_TYPE_QH	cpu_to_le32 (1 << 1)
+
+/* next async queue entry, or pointer to interrupt/periodic QH */
+#define	QH_NEXT(dma)	(cpu_to_le32(((u32)dma)&~0x01f)|Q_TYPE_QH)
+
+/* for periodic/async schedules and qtd lists, mark end of list */
+#define	EHCI_LIST_END	cpu_to_le32(1) /* "null pointer" to hw */
+
+/*
+ * Entries in periodic shadow table are pointers to one of four kinds
+ * of data structure.  That's dictated by the hardware; a type tag is
+ * encoded in the low bits of the hardware's periodic schedule.  Use
+ * Q_NEXT_TYPE to get the tag.
+ *
+ * For entries in the async schedule, the type tag always says "qh".
+ */
+union ehci_shadow {
+	struct ehci_qh		*qh;		/* Q_TYPE_QH */
+	__le32			*hw_next;	/* (all types) */
+	void			*ptr;
+};
+
+/*
+ * EHCI Specification 0.95 Section 3.6
+ * QH: describes control/bulk/interrupt endpoints
+ * See Fig 3-7 "Queue Head Structure Layout".
+ *
+ * These appear in both the async and (for interrupt) periodic schedules.
+ */
+
+struct ehci_qh {
+	/* first part defined by EHCI spec */
+	__le32			hw_next;	 /* see EHCI 3.6.1 */
+	__le32			hw_info1;	/* see EHCI 3.6.2 */
+#define	QH_HEAD		0x00008000
+	__le32			hw_info2;	/* see EHCI 3.6.2 */
+#define	QH_SMASK	0x000000ff
+#define	QH_CMASK	0x0000ff00
+#define	QH_HUBADDR	0x007f0000
+#define	QH_HUBPORT	0x3f800000
+#define	QH_MULT		0xc0000000
+	__le32			hw_current;	 /* qtd list - see EHCI 3.6.4 */
+
+	/* qtd overlay (hardware parts of a struct ehci_qtd) */
+	__le32			hw_qtd_next;
+	__le32			hw_alt_next;
+	__le32			hw_token;
+	__le32			hw_buf[5];
+	__le32			hw_buf_hi[5];
+
+	/* the rest is HCD-private */
+	dma_addr_t		qh_dma;		/* address of qh */
+	union ehci_shadow	qh_next;	/* ptr to qh; or periodic */
+	struct list_head	qtd_list;	/* sw qtd list */
+	struct ehci_qtd		*dummy;
+	struct ehci_qh		*reclaim;	/* next to reclaim */
+
+	struct oxu_hcd		*oxu;
+	struct kref		kref;
+	unsigned		stamp;
+
+	u8			qh_state;
+#define	QH_STATE_LINKED		1		/* HC sees this */
+#define	QH_STATE_UNLINK		2		/* HC may still see this */
+#define	QH_STATE_IDLE		3		/* HC doesn't see this */
+#define	QH_STATE_UNLINK_WAIT	4		/* LINKED and on reclaim q */
+#define	QH_STATE_COMPLETING	5		/* don't touch token.HALT */
+
+	/* periodic schedule info */
+	u8			usecs;		/* intr bandwidth */
+	u8			gap_uf;		/* uframes split/csplit gap */
+	u8			c_usecs;	/* ... split completion bw */
+	u16			tt_usecs;	/* tt downstream bandwidth */
+	unsigned short		period;		/* polling interval */
+	unsigned short		start;		/* where polling starts */
+#define NO_FRAME ((unsigned short)~0)			/* pick new start */
+	struct usb_device	*dev;		/* access to TT */
+} __attribute__ ((aligned(32)));
+
+/*
+ * Proper OXU210HP structs
+ */
+
+#define OXU_OTG_CORE_OFFSET	0x00400
+#define OXU_OTG_CAP_OFFSET	(OXU_OTG_CORE_OFFSET + 0x100)
+#define OXU_SPH_CORE_OFFSET	0x00800
+#define OXU_SPH_CAP_OFFSET	(OXU_SPH_CORE_OFFSET + 0x100)
+
+#define OXU_OTG_MEM		0xE000
+#define OXU_SPH_MEM		0x16000
+
+/* Only how many elements & element structure are specifies here. */
+/* 2 host controllers are enabled - total size <= 28 kbytes */
+#define	DEFAULT_I_TDPS		1024
+#define QHEAD_NUM		16
+#define QTD_NUM			32
+#define SITD_NUM		8
+#define MURB_NUM		8
+
+#define BUFFER_NUM		8
+#define BUFFER_SIZE		512
+
+struct oxu_info {
+	struct usb_hcd *hcd[2];
+};
+
+struct oxu_buf {
+	u8			buffer[BUFFER_SIZE];
+} __attribute__ ((aligned(BUFFER_SIZE)));
+
+struct oxu_onchip_mem {
+	struct oxu_buf		db_pool[BUFFER_NUM];
+
+	u32			frame_list[DEFAULT_I_TDPS];
+	struct ehci_qh		qh_pool[QHEAD_NUM];
+	struct ehci_qtd		qtd_pool[QTD_NUM];
+} __attribute__ ((aligned(4 << 10)));
+
+#define	EHCI_MAX_ROOT_PORTS	15		/* see HCS_N_PORTS */
+
+struct oxu_murb {
+	struct urb		urb;
+	struct urb		*main;
+	u8			last;
+};
+
+struct oxu_hcd {				/* one per controller */
+	unsigned int		is_otg:1;
+
+	u8			qh_used[QHEAD_NUM];
+	u8			qtd_used[QTD_NUM];
+	u8			db_used[BUFFER_NUM];
+	u8			murb_used[MURB_NUM];
+
+	struct oxu_onchip_mem	__iomem *mem;
+	spinlock_t		mem_lock;
+
+	struct timer_list	urb_timer;
+
+	struct ehci_caps __iomem *caps;
+	struct ehci_regs __iomem *regs;
+
+	__u32			hcs_params;	/* cached register copy */
+	spinlock_t		lock;
+
+	/* async schedule support */
+	struct ehci_qh		*async;
+	struct ehci_qh		*reclaim;
+	unsigned		reclaim_ready:1;
+	unsigned		scanning:1;
+
+	/* periodic schedule support */
+	unsigned		periodic_size;
+	__le32			*periodic;	/* hw periodic table */
+	dma_addr_t		periodic_dma;
+	unsigned		i_thresh;	/* uframes HC might cache */
+
+	union ehci_shadow	*pshadow;	/* mirror hw periodic table */
+	int			next_uframe;	/* scan periodic, start here */
+	unsigned		periodic_sched;	/* periodic activity count */
+
+	/* per root hub port */
+	unsigned long		reset_done[EHCI_MAX_ROOT_PORTS];
+	/* bit vectors (one bit per port) */
+	unsigned long		bus_suspended;	/* which ports were
+						 * already suspended at the
+						 * start of a bus suspend
+						 */
+	unsigned long		companion_ports;/* which ports are dedicated
+						 * to the companion controller
+						 */
+
+	struct timer_list	watchdog;
+	unsigned long		actions;
+	unsigned		stamp;
+	unsigned long		next_statechange;
+	u32			command;
+
+	/* SILICON QUIRKS */
+	struct list_head	urb_list;	/* this is the head to urb
+						 * queue that didn't get enough
+						 * resources
+						 */
+	struct oxu_murb		*murb_pool;	/* murb per split big urb */
+	unsigned urb_len;
+
+	u8			sbrn;		/* packed release number */
+};
+
+#define EHCI_IAA_JIFFIES	(HZ/100)	/* arbitrary; ~10 msec */
+#define EHCI_IO_JIFFIES	 	(HZ/10)		/* io watchdog > irq_thresh */
+#define EHCI_ASYNC_JIFFIES      (HZ/20)		/* async idle timeout */
+#define EHCI_SHRINK_JIFFIES     (HZ/200)	/* async qh unlink delay */
+
+enum ehci_timer_action {
+	TIMER_IO_WATCHDOG,
+	TIMER_IAA_WATCHDOG,
+	TIMER_ASYNC_SHRINK,
+	TIMER_ASYNC_OFF,
+};
+
+#include <linux/oxu210hp.h>
diff -urN host/pci-quirks.c host.new/pci-quirks.c
--- host/pci-quirks.c	2009-02-24 19:00:15.543963133 +0100
+++ host.new/pci-quirks.c	2009-03-28 17:46:02.000000000 +0100
@@ -106,7 +106,7 @@
 	pci_read_config_word(pdev, UHCI_USBLEGSUP, &legsup);
 	if (legsup & ~(UHCI_USBLEGSUP_RO | UHCI_USBLEGSUP_RWC)) {
 		dev_dbg(&pdev->dev, "%s: legsup = 0x%04x\n",
-				__FUNCTION__, legsup);
+				__func__, legsup);
 		goto reset_needed;
 	}
 
@@ -114,14 +114,14 @@
 	if ((cmd & UHCI_USBCMD_RUN) || !(cmd & UHCI_USBCMD_CONFIGURE) ||
 			!(cmd & UHCI_USBCMD_EGSM)) {
 		dev_dbg(&pdev->dev, "%s: cmd = 0x%04x\n",
-				__FUNCTION__, cmd);
+				__func__, cmd);
 		goto reset_needed;
 	}
 
 	intr = inw(base + UHCI_USBINTR);
 	if (intr & (~UHCI_USBINTR_RESUME)) {
 		dev_dbg(&pdev->dev, "%s: intr = 0x%04x\n",
-				__FUNCTION__, intr);
+				__func__, intr);
 		goto reset_needed;
 	}
 	return 0;
@@ -172,9 +172,9 @@
 	if (!mmio_resource_enabled(pdev, 0))
 		return;
 
-	base = ioremap_nocache(pci_resource_start(pdev, 0),
-				     pci_resource_len(pdev, 0));
-	if (base == NULL) return;
+	base = pci_ioremap_bar(pdev, 0);
+	if (base == NULL)
+		return;
 
 /* On PA-RISC, PDC can leave IR set incorrectly; ignore it there. */
 #ifndef __hppa__
@@ -190,9 +190,8 @@
 			msleep(10);
 		}
 		if (wait_time <= 0)
-			printk(KERN_WARNING "%s %s: BIOS handoff "
-					"failed (BIOS bug ?) %08x\n",
-					pdev->dev.bus_id, "OHCI",
+			dev_warn(&pdev->dev, "OHCI: BIOS handoff failed"
+					" (BIOS bug?) %08x\n",
 					readl(base + OHCI_CONTROL));
 
 		/* reset controller, preserving RWC */
@@ -222,9 +221,9 @@
 	if (!mmio_resource_enabled(pdev, 0))
 		return;
 
-	base = ioremap_nocache(pci_resource_start(pdev, 0),
-				pci_resource_len(pdev, 0));
-	if (base == NULL) return;
+	base = pci_ioremap_bar(pdev, 0);
+	if (base == NULL)
+		return;
 
 	cap_length = readb(base);
 	op_reg_base = base + cap_length;
@@ -235,7 +234,7 @@
 	 */
 	hcc_params = readl(base + EHCI_HCC_PARAMS);
 	offset = (hcc_params >> 8) & 0xff;
-	while (offset && count--) {
+	while (offset && --count) {
 		u32		cap;
 		int		msec;
 
@@ -243,8 +242,7 @@
 		switch (cap & 0xff) {
 		case 1:			/* BIOS/SMM/... handoff support */
 			if ((cap & EHCI_USBLEGSUP_BIOS)) {
-				pr_debug("%s %s: BIOS handoff\n",
-						pdev->dev.bus_id, "EHCI");
+				dev_dbg(&pdev->dev, "EHCI: BIOS handoff\n");
 
 #if 0
 /* aleksey_gorelov@phoenix.com reports that some systems need SMI forced on,
@@ -273,7 +271,7 @@
 			/* if boot firmware now owns EHCI, spin till
 			 * it hands it over.
 			 */
-			msec = 5000;
+			msec = 1000;
 			while ((cap & EHCI_USBLEGSUP_BIOS) && (msec > 0)) {
 				tried_handoff = 1;
 				msleep(10);
@@ -285,9 +283,8 @@
 				/* well, possibly buggy BIOS... try to shut
 				 * it down, and hope nothing goes too wrong
 				 */
-				printk(KERN_WARNING "%s %s: BIOS handoff "
-						"failed (BIOS bug ?) %08x\n",
-					pdev->dev.bus_id, "EHCI", cap);
+				dev_warn(&pdev->dev, "EHCI: BIOS handoff failed"
+						" (BIOS bug?) %08x\n", cap);
 				pci_write_config_byte(pdev, offset + 2, 0);
 			}
 
@@ -306,17 +303,14 @@
 			cap = 0;
 			/* FALLTHROUGH */
 		default:
-			printk(KERN_WARNING "%s %s: unrecognized "
-					"capability %02x\n",
-					pdev->dev.bus_id, "EHCI",
-					cap & 0xff);
+			dev_warn(&pdev->dev, "EHCI: unrecognized capability "
+					"%02x\n", cap & 0xff);
 			break;
 		}
 		offset = (cap >> 8) & 0xff;
 	}
 	if (!count)
-		printk(KERN_DEBUG "%s %s: capability loop?\n",
-				pdev->dev.bus_id, "EHCI");
+		dev_printk(KERN_DEBUG, &pdev->dev, "EHCI: capability loop?\n");
 
 	/*
 	 * halt EHCI & disable its interrupts in any case
Files host/pci-quirks.o and host.new/pci-quirks.o differ
diff -urN host/r8a66597-hcd.c host.new/r8a66597-hcd.c
--- host/r8a66597-hcd.c	2009-02-24 19:00:15.551962726 +0100
+++ host.new/r8a66597-hcd.c	2009-03-28 17:46:02.000000000 +0100
@@ -44,16 +44,19 @@
 MODULE_DESCRIPTION("R8A66597 USB Host Controller Driver");
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Yoshihiro Shimoda");
+MODULE_ALIAS("platform:r8a66597_hcd");
 
-#define DRIVER_VERSION	"29 May 2007"
+#define DRIVER_VERSION	"10 Apr 2008"
 
 static const char hcd_name[] = "r8a66597_hcd";
 
 /* module parameters */
+#if !defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
 static unsigned short clock = XTAL12;
 module_param(clock, ushort, 0644);
 MODULE_PARM_DESC(clock, "input clock: 48MHz=32768, 24MHz=16384, 12MHz=0 "
 		"(default=0)");
+#endif
 
 static unsigned short vif = LDRV;
 module_param(vif, ushort, 0644);
@@ -63,7 +66,7 @@
 module_param(endian, ushort, 0644);
 MODULE_PARM_DESC(endian, "data endian: big=256, little=0 (default=0)");
 
-static unsigned short irq_sense = INTL;
+static unsigned short irq_sense = 0xff;
 module_param(irq_sense, ushort, 0644);
 MODULE_PARM_DESC(irq_sense, "IRQ sense: low level=32, falling edge=0 "
 		"(default=32)");
@@ -105,16 +108,30 @@
 	r8a66597_write(r8a66597, val, devadd_reg);
 }
 
-static int enable_controller(struct r8a66597 *r8a66597)
+static int r8a66597_clock_enable(struct r8a66597 *r8a66597)
 {
 	u16 tmp;
 	int i = 0;
 
+#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
+#if defined(CONFIG_HAVE_CLK)
+	clk_enable(r8a66597->clk);
+#endif
+	do {
+		r8a66597_write(r8a66597, SCKE, SYSCFG0);
+		tmp = r8a66597_read(r8a66597, SYSCFG0);
+		if (i++ > 1000) {
+			printk(KERN_ERR "r8a66597: register access fail.\n");
+			return -ENXIO;
+		}
+	} while ((tmp & SCKE) != SCKE);
+	r8a66597_write(r8a66597, 0x04, 0x02);
+#else
 	do {
 		r8a66597_write(r8a66597, USBE, SYSCFG0);
 		tmp = r8a66597_read(r8a66597, SYSCFG0);
 		if (i++ > 1000) {
-			err("register access fail.");
+			printk(KERN_ERR "r8a66597: register access fail.\n");
 			return -ENXIO;
 		}
 	} while ((tmp & USBE) != USBE);
@@ -127,17 +144,71 @@
 		msleep(1);
 		tmp = r8a66597_read(r8a66597, SYSCFG0);
 		if (i++ > 500) {
-			err("register access fail.");
+			printk(KERN_ERR "r8a66597: register access fail.\n");
 			return -ENXIO;
 		}
 	} while ((tmp & SCKE) != SCKE);
+#endif	/* #if defined(CONFIG_SUPERH_ON_CHIP_R8A66597) */
+
+	return 0;
+}
+
+static void r8a66597_clock_disable(struct r8a66597 *r8a66597)
+{
+	r8a66597_bclr(r8a66597, SCKE, SYSCFG0);
+	udelay(1);
+#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
+#if defined(CONFIG_HAVE_CLK)
+	clk_disable(r8a66597->clk);
+#endif
+#else
+	r8a66597_bclr(r8a66597, PLLC, SYSCFG0);
+	r8a66597_bclr(r8a66597, XCKE, SYSCFG0);
+	r8a66597_bclr(r8a66597, USBE, SYSCFG0);
+#endif
+}
+
+static void r8a66597_enable_port(struct r8a66597 *r8a66597, int port)
+{
+	u16 val;
+
+	val = port ? DRPD : DCFM | DRPD;
+	r8a66597_bset(r8a66597, val, get_syscfg_reg(port));
+	r8a66597_bset(r8a66597, HSE, get_syscfg_reg(port));
+
+	r8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR, get_dmacfg_reg(port));
+	r8a66597_bclr(r8a66597, DTCHE, get_intenb_reg(port));
+	r8a66597_bset(r8a66597, ATTCHE, get_intenb_reg(port));
+}
+
+static void r8a66597_disable_port(struct r8a66597 *r8a66597, int port)
+{
+	u16 val, tmp;
 
-	r8a66597_bset(r8a66597, DCFM | DRPD, SYSCFG0);
-	r8a66597_bset(r8a66597, DRPD, SYSCFG1);
+	r8a66597_write(r8a66597, 0, get_intenb_reg(port));
+	r8a66597_write(r8a66597, 0, get_intsts_reg(port));
+
+	r8a66597_port_power(r8a66597, port, 0);
+
+	do {
+		tmp = r8a66597_read(r8a66597, SOFCFG) & EDGESTS;
+		udelay(640);
+	} while (tmp == EDGESTS);
+
+	val = port ? DRPD : DCFM | DRPD;
+	r8a66597_bclr(r8a66597, val, get_syscfg_reg(port));
+	r8a66597_bclr(r8a66597, HSE, get_syscfg_reg(port));
+}
+
+static int enable_controller(struct r8a66597 *r8a66597)
+{
+	int ret, port;
+
+	ret = r8a66597_clock_enable(r8a66597);
+	if (ret < 0)
+		return ret;
 
 	r8a66597_bset(r8a66597, vif & LDRV, PINCFG);
-	r8a66597_bset(r8a66597, HSE, SYSCFG0);
-	r8a66597_bset(r8a66597, HSE, SYSCFG1);
 	r8a66597_bset(r8a66597, USBE, SYSCFG0);
 
 	r8a66597_bset(r8a66597, BEMPE | NRDYE | BRDYE, INTENB0);
@@ -145,53 +216,30 @@
 	r8a66597_bset(r8a66597, BRDY0, BRDYENB);
 	r8a66597_bset(r8a66597, BEMP0, BEMPENB);
 
-	r8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR, DMA0CFG);
-	r8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR, DMA1CFG);
-
 	r8a66597_bset(r8a66597, endian & BIGEND, CFIFOSEL);
 	r8a66597_bset(r8a66597, endian & BIGEND, D0FIFOSEL);
 	r8a66597_bset(r8a66597, endian & BIGEND, D1FIFOSEL);
-
 	r8a66597_bset(r8a66597, TRNENSEL, SOFCFG);
 
 	r8a66597_bset(r8a66597, SIGNE | SACKE, INTENB1);
-	r8a66597_bclr(r8a66597, DTCHE, INTENB1);
-	r8a66597_bset(r8a66597, ATTCHE, INTENB1);
-	r8a66597_bclr(r8a66597, DTCHE, INTENB2);
-	r8a66597_bset(r8a66597, ATTCHE, INTENB2);
+
+	for (port = 0; port < R8A66597_MAX_ROOT_HUB; port++)
+		r8a66597_enable_port(r8a66597, port);
 
 	return 0;
 }
 
 static void disable_controller(struct r8a66597 *r8a66597)
 {
-	u16 tmp;
+	int port;
 
 	r8a66597_write(r8a66597, 0, INTENB0);
-	r8a66597_write(r8a66597, 0, INTENB1);
-	r8a66597_write(r8a66597, 0, INTENB2);
 	r8a66597_write(r8a66597, 0, INTSTS0);
-	r8a66597_write(r8a66597, 0, INTSTS1);
-	r8a66597_write(r8a66597, 0, INTSTS2);
-
-	r8a66597_port_power(r8a66597, 0, 0);
-	r8a66597_port_power(r8a66597, 1, 0);
-
-	do {
-		tmp = r8a66597_read(r8a66597, SOFCFG) & EDGESTS;
-		udelay(640);
-	} while (tmp == EDGESTS);
 
-	r8a66597_bclr(r8a66597, DCFM | DRPD, SYSCFG0);
-	r8a66597_bclr(r8a66597, DRPD, SYSCFG1);
-	r8a66597_bclr(r8a66597, HSE, SYSCFG0);
-	r8a66597_bclr(r8a66597, HSE, SYSCFG1);
+	for (port = 0; port < R8A66597_MAX_ROOT_HUB; port++)
+		r8a66597_disable_port(r8a66597, port);
 
-	r8a66597_bclr(r8a66597, SCKE, SYSCFG0);
-	udelay(1);
-	r8a66597_bclr(r8a66597, PLLC, SYSCFG0);
-	r8a66597_bclr(r8a66597, XCKE, SYSCFG0);
-	r8a66597_bclr(r8a66597, USBE, SYSCFG0);
+	r8a66597_clock_disable(r8a66597);
 }
 
 static int get_parent_r8a66597_address(struct r8a66597 *r8a66597,
@@ -224,7 +272,7 @@
 	if (root_port) {
 		*root_port = (devpath[0] & 0x0F) - 1;
 		if (*root_port >= R8A66597_MAX_ROOT_HUB)
-			err("illegal root port number");
+			printk(KERN_ERR "r8a66597: Illegal root port number.\n");
 	}
 	if (hub_port)
 		*hub_port = devpath[2] & 0x0F;
@@ -245,7 +293,7 @@
 		usbspd = HSMODE;
 		break;
 	default:
-		err("unknown speed");
+		printk(KERN_ERR "r8a66597: unknown speed\n");
 		break;
 	}
 
@@ -271,9 +319,9 @@
 static void set_pipe_reg_addr(struct r8a66597_pipe *pipe, u8 dma_ch)
 {
 	u16 pipenum = pipe->info.pipenum;
-	unsigned long fifoaddr[] = {D0FIFO, D1FIFO, CFIFO};
-	unsigned long fifosel[] = {D0FIFOSEL, D1FIFOSEL, CFIFOSEL};
-	unsigned long fifoctr[] = {D0FIFOCTR, D1FIFOCTR, CFIFOCTR};
+	const unsigned long fifoaddr[] = {D0FIFO, D1FIFO, CFIFO};
+	const unsigned long fifosel[] = {D0FIFOSEL, D1FIFOSEL, CFIFOSEL};
+	const unsigned long fifoctr[] = {D0FIFOCTR, D1FIFOCTR, CFIFOCTR};
 
 	if (dma_ch > R8A66597_PIPE_NO_DMA)	/* dma fifo not use? */
 		dma_ch = R8A66597_PIPE_NO_DMA;
@@ -344,7 +392,7 @@
 	struct r8a66597_device *dev;
 
 	if (is_hub_limit(urb->dev->devpath)) {
-		err("Externel hub limit reached.");
+		dev_err(&urb->dev->dev, "External hub limit reached.\n");
 		return 0;
 	}
 
@@ -365,8 +413,9 @@
 		return addr;
 	}
 
-	err("cannot communicate with a USB device more than 10.(%x)",
-	    r8a66597->address_map);
+	dev_err(&urb->dev->dev,
+		"cannot communicate with a USB device more than 10.(%x)\n",
+		r8a66597->address_map);
 
 	return 0;
 }
@@ -406,7 +455,8 @@
 	do {
 		tmp = r8a66597_read(r8a66597, reg);
 		if (i++ > 1000000) {
-			err("register%lx, loop %x is timeout", reg, loop);
+			printk(KERN_ERR "r8a66597: register%lx, loop %x "
+			       "is timeout\n", reg, loop);
 			break;
 		}
 		ndelay(1);
@@ -576,13 +626,9 @@
 		       PIPEBUF);
 	r8a66597_write(r8a66597, make_devsel(info->address) | info->maxpacket,
 		       PIPEMAXP);
-	if (info->interval)
-		info->interval--;
 	r8a66597_write(r8a66597, info->interval, PIPEPERI);
 }
 
-
-
 /* this function must be called with interrupt disabled */
 static void pipe_setting(struct r8a66597 *r8a66597, struct r8a66597_td *td)
 {
@@ -614,9 +660,9 @@
 	u16 array[R8A66597_MAX_NUM_PIPE], i = 0, min;
 
 	memset(array, 0, sizeof(array));
-	switch (ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
+	switch (usb_endpoint_type(ep)) {
 	case USB_ENDPOINT_XFER_BULK:
-		if (ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+		if (usb_endpoint_dir_in(ep))
 			array[i++] = 4;
 		else {
 			array[i++] = 3;
@@ -624,7 +670,7 @@
 		}
 		break;
 	case USB_ENDPOINT_XFER_INT:
-		if (ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) {
+		if (usb_endpoint_dir_in(ep)) {
 			array[i++] = 6;
 			array[i++] = 7;
 			array[i++] = 8;
@@ -632,13 +678,13 @@
 			array[i++] = 9;
 		break;
 	case USB_ENDPOINT_XFER_ISOC:
-		if (ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+		if (usb_endpoint_dir_in(ep))
 			array[i++] = 2;
 		else
 			array[i++] = 1;
 		break;
 	default:
-		err("Illegal type");
+		printk(KERN_ERR "r8a66597: Illegal type\n");
 		return 0;
 	}
 
@@ -668,7 +714,7 @@
 		r8a66597_type = R8A66597_ISO;
 		break;
 	default:
-		err("Illegal type");
+		printk(KERN_ERR "r8a66597: Illegal type\n");
 		r8a66597_type = 0x0000;
 		break;
 	}
@@ -687,7 +733,7 @@
 	else if (check_interrupt(pipenum))
 		bufnum = 4 + (pipenum - 6);
 	else
-		err("Illegal pipenum (%d)", pipenum);
+		printk(KERN_ERR "r8a66597: Illegal pipenum (%d)\n", pipenum);
 
 	return bufnum;
 }
@@ -703,7 +749,7 @@
 	else if (check_interrupt(pipenum))
 		buf_bsize = 0;
 	else
-		err("Illegal pipenum (%d)", pipenum);
+		printk(KERN_ERR "r8a66597: Illegal pipenum (%d)\n", pipenum);
 
 	return buf_bsize;
 }
@@ -714,6 +760,7 @@
 				     struct r8a66597_pipe *pipe,
 				     struct urb *urb)
 {
+#if !defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
 	int i;
 	struct r8a66597_pipe_info *info = &pipe->info;
 
@@ -722,10 +769,12 @@
 			if ((r8a66597->dma_map & (1 << i)) != 0)
 				continue;
 
-			info("address %d, EndpointAddress 0x%02x use DMA FIFO",
-			     usb_pipedevice(urb->pipe),
-			     info->dir_in ? USB_ENDPOINT_DIR_MASK + info->epnum
-					    : info->epnum);
+			dev_info(&dev->udev->dev,
+				 "address %d, EndpointAddress 0x%02x use "
+				 "DMA FIFO\n", usb_pipedevice(urb->pipe),
+				 info->dir_in ?
+				 	USB_ENDPOINT_DIR_MASK + info->epnum
+					: info->epnum);
 
 			r8a66597->dma_map |= 1 << i;
 			dev->dma_map |= 1 << i;
@@ -741,6 +790,7 @@
 			break;
 		}
 	}
+#endif	/* #if defined(CONFIG_SUPERH_ON_CHIP_R8A66597) */
 }
 
 /* this function must be called with interrupt disabled */
@@ -782,10 +832,12 @@
 		kfree(td);
 
 		if (urb) {
-			urb->status = -ENODEV;
-			urb->hcpriv = NULL;
+			usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597),
+					urb);
+
 			spin_unlock(&r8a66597->lock);
-			usb_hcd_giveback_urb(r8a66597_to_hcd(r8a66597), urb);
+			usb_hcd_giveback_urb(r8a66597_to_hcd(r8a66597), urb,
+					-ENODEV);
 			spin_lock(&r8a66597->lock);
 		}
 		break;
@@ -822,6 +874,51 @@
 	dev->dma_map = 0;
 }
 
+static u16 get_interval(struct urb *urb, __u8 interval)
+{
+	u16 time = 1;
+	int i;
+
+	if (urb->dev->speed == USB_SPEED_HIGH) {
+		if (interval > IITV)
+			time = IITV;
+		else
+			time = interval ? interval - 1 : 0;
+	} else {
+		if (interval > 128) {
+			time = IITV;
+		} else {
+			/* calculate the nearest value for PIPEPERI */
+			for (i = 0; i < 7; i++) {
+				if ((1 << i) < interval &&
+				    (1 << (i + 1) > interval))
+					time = 1 << i;
+			}
+		}
+	}
+
+	return time;
+}
+
+static unsigned long get_timer_interval(struct urb *urb, __u8 interval)
+{
+	__u8 i;
+	unsigned long time = 1;
+
+	if (usb_pipeisoc(urb->pipe))
+		return 0;
+
+	if (get_r8a66597_usb_speed(urb->dev->speed) == HSMODE) {
+		for (i = 0; i < (interval - 1); i++)
+			time *= 2;
+		time = time * 125 / 1000;	/* uSOF -> msec */
+	} else {
+		time = interval;
+	}
+
+	return time;
+}
+
 /* this function must be called with interrupt disabled */
 static void init_pipe_info(struct r8a66597 *r8a66597, struct urb *urb,
 			   struct usb_host_endpoint *hep,
@@ -831,14 +928,19 @@
 
 	info.pipenum = get_empty_pipenum(r8a66597, ep);
 	info.address = get_urb_to_r8a66597_addr(r8a66597, urb);
-	info.epnum = ep->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
-	info.maxpacket = ep->wMaxPacketSize;
-	info.type = get_r8a66597_type(ep->bmAttributes
-				      & USB_ENDPOINT_XFERTYPE_MASK);
+	info.epnum = usb_endpoint_num(ep);
+	info.maxpacket = le16_to_cpu(ep->wMaxPacketSize);
+	info.type = get_r8a66597_type(usb_endpoint_type(ep));
 	info.bufnum = get_bufnum(info.pipenum);
 	info.buf_bsize = get_buf_bsize(info.pipenum);
-	info.interval = ep->bInterval;
-	if (ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+	if (info.type == R8A66597_BULK) {
+		info.interval = 0;
+		info.timer_interval = 0;
+	} else {
+		info.interval = get_interval(urb, ep->bInterval);
+		info.timer_interval = get_timer_interval(urb, ep->bInterval);
+	}
+	if (usb_endpoint_dir_in(ep))
 		info.dir_in = 1;
 	else
 		info.dir_in = 0;
@@ -872,13 +974,48 @@
 	disable_irq_nrdy(r8a66597, pipenum);
 }
 
+static void r8a66597_root_hub_start_polling(struct r8a66597 *r8a66597)
+{
+	mod_timer(&r8a66597->rh_timer,
+			jiffies + msecs_to_jiffies(R8A66597_RH_POLL_TIME));
+}
+
+static void start_root_hub_sampling(struct r8a66597 *r8a66597, int port,
+					int connect)
+{
+	struct r8a66597_root_hub *rh = &r8a66597->root_hub[port];
+
+	rh->old_syssts = r8a66597_read(r8a66597, get_syssts_reg(port)) & LNST;
+	rh->scount = R8A66597_MAX_SAMPLING;
+	if (connect)
+		rh->port |= 1 << USB_PORT_FEAT_CONNECTION;
+	else
+		rh->port &= ~(1 << USB_PORT_FEAT_CONNECTION);
+	rh->port |= 1 << USB_PORT_FEAT_C_CONNECTION;
+
+	r8a66597_root_hub_start_polling(r8a66597);
+}
+
 /* this function must be called with interrupt disabled */
-static void r8a66597_usb_preconnect(struct r8a66597 *r8a66597, int port)
+static void r8a66597_check_syssts(struct r8a66597 *r8a66597, int port,
+					u16 syssts)
 {
-	r8a66597->root_hub[port].port |= (1 << USB_PORT_FEAT_CONNECTION)
-					 | (1 << USB_PORT_FEAT_C_CONNECTION);
+	if (syssts == SE0) {
+		r8a66597_write(r8a66597, ~ATTCH, get_intsts_reg(port));
+		r8a66597_bset(r8a66597, ATTCHE, get_intenb_reg(port));
+		return;
+	}
+
+	if (syssts == FS_JSTS)
+		r8a66597_bset(r8a66597, HSE, get_syscfg_reg(port));
+	else if (syssts == LS_JSTS)
+		r8a66597_bclr(r8a66597, HSE, get_syscfg_reg(port));
+
 	r8a66597_write(r8a66597, ~DTCH, get_intsts_reg(port));
 	r8a66597_bset(r8a66597, DTCHE, get_intenb_reg(port));
+
+	if (r8a66597->bus_suspended)
+		usb_hcd_resume_root_hub(r8a66597_to_hcd(r8a66597));
 }
 
 /* this function must be called with interrupt disabled */
@@ -901,13 +1038,10 @@
 {
 	struct r8a66597_device *dev = r8a66597->root_hub[port].dev;
 
-	r8a66597->root_hub[port].port &= ~(1 << USB_PORT_FEAT_CONNECTION);
-	r8a66597->root_hub[port].port |= (1 << USB_PORT_FEAT_C_CONNECTION);
-
 	disable_r8a66597_pipe_all(r8a66597, dev);
 	free_usb_address(r8a66597, dev);
 
-	r8a66597_bset(r8a66597, ATTCHE, get_intenb_reg(port));
+	start_root_hub_sampling(r8a66597, port, 0);
 }
 
 /* this function must be called with interrupt disabled */
@@ -915,7 +1049,7 @@
 				 struct r8a66597_td *td)
 {
 	int i;
-	u16 *p = (u16 *)td->urb->setup_packet;
+	__le16 *p = (__le16 *)td->urb->setup_packet;
 	unsigned long setup_addr = USBREQ;
 
 	r8a66597_write(r8a66597, make_devsel(td->address) | td->maxpacket,
@@ -923,7 +1057,7 @@
 	r8a66597_write(r8a66597, ~(SIGN | SACK), INTSTS1);
 
 	for (i = 0; i < 4; i++) {
-		r8a66597_write(r8a66597, p[i], setup_addr);
+		r8a66597_write(r8a66597, le16_to_cpu(p[i]), setup_addr);
 		setup_addr += 2;
 	}
 	r8a66597_write(r8a66597, SUREQ, DCPCTR);
@@ -957,9 +1091,9 @@
 				r8a66597_write(r8a66597, TRCLR,
 						td->pipe->pipetre);
 				r8a66597_write(r8a66597,
-						(urb->transfer_buffer_length
-						+ td->maxpacket - 1)
-						/ td->maxpacket,
+						DIV_ROUND_UP
+						  (urb->transfer_buffer_length,
+						   td->maxpacket),
 						td->pipe->pipetrn);
 				r8a66597_bset(r8a66597, TRENB,
 						td->pipe->pipetre);
@@ -1018,8 +1152,7 @@
 		r8a66597_mdfy(r8a66597, ISEL, ISEL | CURPIPE, CFIFOSEL);
 		r8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, 0);
 		r8a66597_write(r8a66597, ~BEMP0, BEMPSTS);
-		r8a66597_write(r8a66597, BCLR, CFIFOCTR);
-		r8a66597_write(r8a66597, BVAL, CFIFOCTR);
+		r8a66597_write(r8a66597, BCLR | BVAL, CFIFOCTR);
 		enable_irq_empty(r8a66597, 0);
 	} else {
 		r8a66597_bclr(r8a66597, R8A66597_DIR, DCPCFG);
@@ -1032,6 +1165,15 @@
 	pipe_start(r8a66597, td->pipe);
 }
 
+static int is_set_address(unsigned char *setup_packet)
+{
+	if (((setup_packet[0] & USB_TYPE_MASK) == USB_TYPE_STANDARD) &&
+			setup_packet[1] == USB_REQ_SET_ADDRESS)
+		return 1;
+	else
+		return 0;
+}
+
 /* this function must be called with interrupt disabled */
 static int start_transfer(struct r8a66597 *r8a66597, struct r8a66597_td *td)
 {
@@ -1039,7 +1181,7 @@
 
 	switch (td->type) {
 	case USB_PID_SETUP:
-		if (td->urb->setup_packet[1] == USB_REQ_SET_ADDRESS) {
+		if (is_set_address(td->urb->setup_packet)) {
 			td->set_address = 1;
 			td->urb->setup_packet[2] = alloc_usb_address(r8a66597,
 								     td->urb);
@@ -1058,7 +1200,7 @@
 		prepare_status_packet(r8a66597, td);
 		break;
 	default:
-		err("invalid type.");
+		printk(KERN_ERR "r8a66597: invalid type.\n");
 		break;
 	}
 
@@ -1106,8 +1248,9 @@
 }
 
 /* this function must be called with interrupt disabled */
-static void done(struct r8a66597 *r8a66597, struct r8a66597_td *td,
-		 u16 pipenum, struct urb *urb)
+static void finish_request(struct r8a66597 *r8a66597, struct r8a66597_td *td,
+		u16 pipenum, struct urb *urb, int status)
+__releases(r8a66597->lock) __acquires(r8a66597->lock)
 {
 	int restart = 0;
 	struct usb_hcd *hcd = r8a66597_to_hcd(r8a66597);
@@ -1115,7 +1258,7 @@
 	r8a66597->timeout_map &= ~(1 << pipenum);
 
 	if (likely(td)) {
-		if (td->set_address && urb->status != 0)
+		if (td->set_address && (status != 0 || urb->unlinked))
 			r8a66597->address_map &= ~(1 << urb->setup_packet[2]);
 
 		pipe_toggle_save(r8a66597, td->pipe, urb);
@@ -1130,9 +1273,9 @@
 		if (usb_pipeisoc(urb->pipe))
 			urb->start_frame = r8a66597_get_frame(hcd);
 
-		urb->hcpriv = NULL;
+		usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597), urb);
 		spin_unlock(&r8a66597->lock);
-		usb_hcd_giveback_urb(hcd, urb);
+		usb_hcd_giveback_urb(hcd, urb, status);
 		spin_lock(&r8a66597->lock);
 	}
 
@@ -1146,14 +1289,6 @@
 	}
 }
 
-/* this function must be called with interrupt disabled */
-static void finish_request(struct r8a66597 *r8a66597, struct r8a66597_td *td,
-			   u16 pipenum, struct urb *urb)
-__releases(r8a66597->lock) __acquires(r8a66597->lock)
-{
-	done(r8a66597, td, pipenum, urb);
-}
-
 static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 {
 	u16 tmp;
@@ -1162,6 +1297,7 @@
 	struct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);
 	struct urb *urb;
 	int finish = 0;
+	int status = 0;
 
 	if (unlikely(!td))
 		return;
@@ -1170,17 +1306,15 @@
 	fifo_change_from_pipe(r8a66597, td->pipe);
 	tmp = r8a66597_read(r8a66597, td->pipe->fifoctr);
 	if (unlikely((tmp & FRDY) == 0)) {
-		urb->status = -EPIPE;
 		pipe_stop(r8a66597, td->pipe);
 		pipe_irq_disable(r8a66597, pipenum);
-		err("in fifo not ready (%d)", pipenum);
-		finish_request(r8a66597, td, pipenum, td->urb);
+		printk(KERN_ERR "r8a66597: in fifo not ready (%d)\n", pipenum);
+		finish_request(r8a66597, td, pipenum, td->urb, -EPIPE);
 		return;
 	}
 
 	/* prepare parameters */
 	rcv_len = tmp & DTLN;
-	bufsize = td->maxpacket;
 	if (usb_pipeisoc(urb->pipe)) {
 		buf = (u16 *)(urb->transfer_buffer +
 				urb->iso_frame_desc[td->iso_cnt].offset);
@@ -1189,29 +1323,31 @@
 		buf = (void *)urb->transfer_buffer + urb->actual_length;
 		urb_len = urb->transfer_buffer_length - urb->actual_length;
 	}
-	if (rcv_len < bufsize)
-		size = min(rcv_len, urb_len);
-	else
-		size = min(bufsize, urb_len);
+	bufsize = min(urb_len, (int) td->maxpacket);
+	if (rcv_len <= bufsize) {
+		size = rcv_len;
+	} else {
+		size = bufsize;
+		status = -EOVERFLOW;
+		finish = 1;
+	}
 
 	/* update parameters */
 	urb->actual_length += size;
 	if (rcv_len == 0)
 		td->zero_packet = 1;
-	if ((size % td->maxpacket) > 0) {
+	if (rcv_len < bufsize) {
 		td->short_packet = 1;
-		if (urb->transfer_buffer_length != urb->actual_length &&
-		    urb->transfer_flags & URB_SHORT_NOT_OK)
-			td->urb->status = -EREMOTEIO;
 	}
 	if (usb_pipeisoc(urb->pipe)) {
 		urb->iso_frame_desc[td->iso_cnt].actual_length = size;
-		urb->iso_frame_desc[td->iso_cnt].status = 0;
+		urb->iso_frame_desc[td->iso_cnt].status = status;
 		td->iso_cnt++;
+		finish = 0;
 	}
 
 	/* check transfer finish */
-	if (check_transfer_finish(td, urb)) {
+	if (finish || check_transfer_finish(td, urb)) {
 		pipe_stop(r8a66597, td->pipe);
 		pipe_irq_disable(r8a66597, pipenum);
 		finish = 1;
@@ -1226,11 +1362,8 @@
 					   buf, size);
 	}
 
-	if (finish && pipenum != 0) {
-		if (td->urb->status == -EINPROGRESS)
-			td->urb->status = 0;
-		finish_request(r8a66597, td, pipenum, urb);
-	}
+	if (finish && pipenum != 0)
+		finish_request(r8a66597, td, pipenum, urb, status);
 }
 
 static void packet_write(struct r8a66597 *r8a66597, u16 pipenum)
@@ -1248,11 +1381,10 @@
 	fifo_change_from_pipe(r8a66597, td->pipe);
 	tmp = r8a66597_read(r8a66597, td->pipe->fifoctr);
 	if (unlikely((tmp & FRDY) == 0)) {
-		urb->status = -EPIPE;
 		pipe_stop(r8a66597, td->pipe);
 		pipe_irq_disable(r8a66597, pipenum);
-		err("out write fifo not ready. (%d)", pipenum);
-		finish_request(r8a66597, td, pipenum, td->urb);
+		printk(KERN_ERR "r8a66597: out fifo not ready (%d)\n", pipenum);
+		finish_request(r8a66597, td, pipenum, urb, -EPIPE);
 		return;
 	}
 
@@ -1265,7 +1397,7 @@
 			   (int)urb->iso_frame_desc[td->iso_cnt].length);
 	} else {
 		buf = (u16 *)(urb->transfer_buffer + urb->actual_length);
-		size = min((int)bufsize,
+		size = min_t(u32, bufsize,
 			   urb->transfer_buffer_length - urb->actual_length);
 	}
 
@@ -1297,7 +1429,7 @@
 }
 
 
-static void check_next_phase(struct r8a66597 *r8a66597)
+static void check_next_phase(struct r8a66597 *r8a66597, int status)
 {
 	struct r8a66597_td *td = r8a66597_get_td(r8a66597, 0);
 	struct urb *urb;
@@ -1310,49 +1442,41 @@
 	switch (td->type) {
 	case USB_PID_IN:
 	case USB_PID_OUT:
-		if (urb->status != -EINPROGRESS) {
-			finish = 1;
-			break;
-		}
 		if (check_transfer_finish(td, urb))
 			td->type = USB_PID_ACK;
 		break;
 	case USB_PID_SETUP:
-		if (urb->status != -EINPROGRESS)
-			finish = 1;
-		else if (urb->transfer_buffer_length == urb->actual_length) {
+		if (urb->transfer_buffer_length == urb->actual_length)
 			td->type = USB_PID_ACK;
-			urb->status = 0;
-		} else if (usb_pipeout(urb->pipe))
+		else if (usb_pipeout(urb->pipe))
 			td->type = USB_PID_OUT;
 		else
 			td->type = USB_PID_IN;
 		break;
 	case USB_PID_ACK:
 		finish = 1;
-		if (urb->status == -EINPROGRESS)
-			urb->status = 0;
 		break;
 	}
 
-	if (finish)
-		finish_request(r8a66597, td, 0, urb);
+	if (finish || status != 0 || urb->unlinked)
+		finish_request(r8a66597, td, 0, urb, status);
 	else
 		start_transfer(r8a66597, td);
 }
 
-static void set_urb_error(struct r8a66597 *r8a66597, u16 pipenum)
+static int get_urb_error(struct r8a66597 *r8a66597, u16 pipenum)
 {
 	struct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);
 
-	if (td && td->urb) {
+	if (td) {
 		u16 pid = r8a66597_read(r8a66597, td->pipe->pipectr) & PID;
 
 		if (pid == PID_NAK)
-			td->urb->status = -ECONNRESET;
+			return -ECONNRESET;
 		else
-			td->urb->status = -EPIPE;
+			return -EPIPE;
 	}
+	return 0;
 }
 
 static void irq_pipe_ready(struct r8a66597 *r8a66597)
@@ -1371,7 +1495,7 @@
 			packet_read(r8a66597, 0);
 		else
 			pipe_irq_disable(r8a66597, 0);
-		check_next_phase(r8a66597);
+		check_next_phase(r8a66597, 0);
 	}
 
 	for (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {
@@ -1405,7 +1529,7 @@
 		td = r8a66597_get_td(r8a66597, 0);
 		if (td && td->type != USB_PID_OUT)
 			disable_irq_empty(r8a66597, 0);
-		check_next_phase(r8a66597);
+		check_next_phase(r8a66597, 0);
 	}
 
 	for (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {
@@ -1420,9 +1544,8 @@
 			if ((tmp & INBUFM) == 0) {
 				disable_irq_empty(r8a66597, pipenum);
 				pipe_irq_disable(r8a66597, pipenum);
-				if (td->urb->status == -EINPROGRESS)
-					td->urb->status = 0;
-				finish_request(r8a66597, td, pipenum, td->urb);
+				finish_request(r8a66597, td, pipenum, td->urb,
+						0);
 			}
 		}
 	}
@@ -1433,15 +1556,16 @@
 	u16 check;
 	u16 pipenum;
 	u16 mask;
+	int status;
 
 	mask = r8a66597_read(r8a66597, NRDYSTS)
 	       & r8a66597_read(r8a66597, NRDYENB);
 	r8a66597_write(r8a66597, ~mask, NRDYSTS);
 	if (mask & NRDY0) {
 		cfifo_change(r8a66597, 0);
-		set_urb_error(r8a66597, 0);
+		status = get_urb_error(r8a66597, 0);
 		pipe_irq_disable(r8a66597, 0);
-		check_next_phase(r8a66597);
+		check_next_phase(r8a66597, status);
 	}
 
 	for (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {
@@ -1452,29 +1576,21 @@
 			if (unlikely(!td))
 				continue;
 
-			set_urb_error(r8a66597, pipenum);
+			status = get_urb_error(r8a66597, pipenum);
 			pipe_irq_disable(r8a66597, pipenum);
 			pipe_stop(r8a66597, td->pipe);
-			finish_request(r8a66597, td, pipenum, td->urb);
+			finish_request(r8a66597, td, pipenum, td->urb, status);
 		}
 	}
 }
 
-static void start_root_hub_sampling(struct r8a66597 *r8a66597, int port)
-{
-	struct r8a66597_root_hub *rh = &r8a66597->root_hub[port];
-
-	rh->old_syssts = r8a66597_read(r8a66597, get_syssts_reg(port)) & LNST;
-	rh->scount = R8A66597_MAX_SAMPLING;
-	mod_timer(&r8a66597->rh_timer, jiffies + msecs_to_jiffies(50));
-}
-
 static irqreturn_t r8a66597_irq(struct usb_hcd *hcd)
 {
 	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
 	u16 intsts0, intsts1, intsts2;
 	u16 intenb0, intenb1, intenb2;
 	u16 mask0, mask1, mask2;
+	int status;
 
 	spin_lock(&r8a66597->lock);
 
@@ -1494,13 +1610,18 @@
 			r8a66597_bclr(r8a66597, ATTCHE, INTENB2);
 
 			/* start usb bus sampling */
-			start_root_hub_sampling(r8a66597, 1);
+			start_root_hub_sampling(r8a66597, 1, 1);
 		}
 		if (mask2 & DTCH) {
 			r8a66597_write(r8a66597, ~DTCH, INTSTS2);
 			r8a66597_bclr(r8a66597, DTCHE, INTENB2);
 			r8a66597_usb_disconnect(r8a66597, 1);
 		}
+		if (mask2 & BCHG) {
+			r8a66597_write(r8a66597, ~BCHG, INTSTS2);
+			r8a66597_bclr(r8a66597, BCHGE, INTENB2);
+			usb_hcd_resume_root_hub(r8a66597_to_hcd(r8a66597));
+		}
 	}
 
 	if (mask1) {
@@ -1509,21 +1630,27 @@
 			r8a66597_bclr(r8a66597, ATTCHE, INTENB1);
 
 			/* start usb bus sampling */
-			start_root_hub_sampling(r8a66597, 0);
+			start_root_hub_sampling(r8a66597, 0, 1);
 		}
 		if (mask1 & DTCH) {
 			r8a66597_write(r8a66597, ~DTCH, INTSTS1);
 			r8a66597_bclr(r8a66597, DTCHE, INTENB1);
 			r8a66597_usb_disconnect(r8a66597, 0);
 		}
+		if (mask1 & BCHG) {
+			r8a66597_write(r8a66597, ~BCHG, INTSTS1);
+			r8a66597_bclr(r8a66597, BCHGE, INTENB1);
+			usb_hcd_resume_root_hub(r8a66597_to_hcd(r8a66597));
+		}
+
 		if (mask1 & SIGN) {
 			r8a66597_write(r8a66597, ~SIGN, INTSTS1);
-			set_urb_error(r8a66597, 0);
-			check_next_phase(r8a66597);
+			status = get_urb_error(r8a66597, 0);
+			check_next_phase(r8a66597, status);
 		}
 		if (mask1 & SACK) {
 			r8a66597_write(r8a66597, ~SACK, INTSTS1);
-			check_next_phase(r8a66597);
+			check_next_phase(r8a66597, 0);
 		}
 	}
 	if (mask0) {
@@ -1552,41 +1679,55 @@
 		if ((tmp & USBRST) == USBRST) {
 			r8a66597_mdfy(r8a66597, UACT, USBRST | UACT,
 				      dvstctr_reg);
-			mod_timer(&r8a66597->rh_timer,
-				  jiffies + msecs_to_jiffies(50));
+			r8a66597_root_hub_start_polling(r8a66597);
 		} else
 			r8a66597_usb_connect(r8a66597, port);
 	}
 
+	if (!(rh->port & (1 << USB_PORT_FEAT_CONNECTION))) {
+		r8a66597_write(r8a66597, ~ATTCH, get_intsts_reg(port));
+		r8a66597_bset(r8a66597, ATTCHE, get_intenb_reg(port));
+	}
+
 	if (rh->scount > 0) {
 		tmp = r8a66597_read(r8a66597, get_syssts_reg(port)) & LNST;
 		if (tmp == rh->old_syssts) {
 			rh->scount--;
-			if (rh->scount == 0) {
-				if (tmp == FS_JSTS) {
-					r8a66597_bset(r8a66597, HSE,
-						      get_syscfg_reg(port));
-					r8a66597_usb_preconnect(r8a66597, port);
-				} else if (tmp == LS_JSTS) {
-					r8a66597_bclr(r8a66597, HSE,
-						      get_syscfg_reg(port));
-					r8a66597_usb_preconnect(r8a66597, port);
-				} else if (tmp == SE0)
-					r8a66597_bset(r8a66597, ATTCHE,
-						      get_intenb_reg(port));
-			} else {
-				mod_timer(&r8a66597->rh_timer,
-					  jiffies + msecs_to_jiffies(50));
-			}
+			if (rh->scount == 0)
+				r8a66597_check_syssts(r8a66597, port, tmp);
+			else
+				r8a66597_root_hub_start_polling(r8a66597);
 		} else {
 			rh->scount = R8A66597_MAX_SAMPLING;
 			rh->old_syssts = tmp;
-			mod_timer(&r8a66597->rh_timer,
-				  jiffies + msecs_to_jiffies(50));
+			r8a66597_root_hub_start_polling(r8a66597);
 		}
 	}
 }
 
+static void r8a66597_interval_timer(unsigned long _r8a66597)
+{
+	struct r8a66597 *r8a66597 = (struct r8a66597 *)_r8a66597;
+	unsigned long flags;
+	u16 pipenum;
+	struct r8a66597_td *td;
+
+	spin_lock_irqsave(&r8a66597->lock, flags);
+
+	for (pipenum = 0; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {
+		if (!(r8a66597->interval_map & (1 << pipenum)))
+			continue;
+		if (timer_pending(&r8a66597->interval_timer[pipenum]))
+			continue;
+
+		td = r8a66597_get_td(r8a66597, pipenum);
+		if (td)
+			start_transfer(r8a66597, td);
+	}
+
+	spin_unlock_irqrestore(&r8a66597->lock, flags);
+}
+
 static void r8a66597_td_timer(unsigned long _r8a66597)
 {
 	struct r8a66597 *r8a66597 = (struct r8a66597 *)_r8a66597;
@@ -1642,11 +1783,12 @@
 {
 	struct r8a66597 *r8a66597 = (struct r8a66597 *)_r8a66597;
 	unsigned long flags;
+	int port;
 
 	spin_lock_irqsave(&r8a66597->lock, flags);
 
-	r8a66597_root_hub_control(r8a66597, 0);
-	r8a66597_root_hub_control(r8a66597, 1);
+	for (port = 0; port < R8A66597_MAX_ROOT_HUB; port++)
+		r8a66597_root_hub_control(r8a66597, port);
 
 	spin_unlock_irqrestore(&r8a66597->lock, flags);
 }
@@ -1722,21 +1864,25 @@
 }
 
 static int r8a66597_urb_enqueue(struct usb_hcd *hcd,
-				struct usb_host_endpoint *hep,
 				struct urb *urb,
 				gfp_t mem_flags)
 {
+	struct usb_host_endpoint *hep = urb->ep;
 	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
 	struct r8a66597_td *td = NULL;
-	int ret = 0, request = 0;
+	int ret, request = 0;
 	unsigned long flags;
 
 	spin_lock_irqsave(&r8a66597->lock, flags);
 	if (!get_urb_to_r8a66597_dev(r8a66597, urb)) {
 		ret = -ENODEV;
-		goto error;
+		goto error_not_linked;
 	}
 
+	ret = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (ret)
+		goto error_not_linked;
+
 	if (!hep->hcpriv) {
 		hep->hcpriv = kzalloc(sizeof(struct r8a66597_pipe),
 				GFP_ATOMIC);
@@ -1761,46 +1907,55 @@
 	if (list_empty(&r8a66597->pipe_queue[td->pipenum]))
 		request = 1;
 	list_add_tail(&td->queue, &r8a66597->pipe_queue[td->pipenum]);
-
-	spin_lock(&urb->lock);
-	if (urb->status != -EINPROGRESS) {
-		spin_unlock(&urb->lock);
-		ret = -EPIPE;
-		goto error;
-	}
 	urb->hcpriv = td;
-	spin_unlock(&urb->lock);
 
 	if (request) {
-		ret = start_transfer(r8a66597, td);
-		if (ret < 0) {
-			list_del(&td->queue);
-			kfree(td);
+		if (td->pipe->info.timer_interval) {
+			r8a66597->interval_map |= 1 << td->pipenum;
+			mod_timer(&r8a66597->interval_timer[td->pipenum],
+				  jiffies + msecs_to_jiffies(
+					td->pipe->info.timer_interval));
+		} else {
+			ret = start_transfer(r8a66597, td);
+			if (ret < 0) {
+				list_del(&td->queue);
+				kfree(td);
+			}
 		}
 	} else
 		set_td_timer(r8a66597, td);
 
 error:
+	if (ret)
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+error_not_linked:
 	spin_unlock_irqrestore(&r8a66597->lock, flags);
 	return ret;
 }
 
-static int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
+		int status)
 {
 	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
 	struct r8a66597_td *td;
 	unsigned long flags;
+	int rc;
 
 	spin_lock_irqsave(&r8a66597->lock, flags);
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto done;
+
 	if (urb->hcpriv) {
 		td = urb->hcpriv;
 		pipe_stop(r8a66597, td->pipe);
 		pipe_irq_disable(r8a66597, td->pipenum);
 		disable_irq_empty(r8a66597, td->pipenum);
-		done(r8a66597, td, td->pipenum, urb);
+		finish_request(r8a66597, td, td->pipenum, urb, status);
 	}
+ done:
 	spin_unlock_irqrestore(&r8a66597->lock, flags);
-	return 0;
+	return rc;
 }
 
 static void r8a66597_endpoint_disable(struct usb_hcd *hcd,
@@ -1830,7 +1985,7 @@
 	td = r8a66597_get_td(r8a66597, pipenum);
 	if (td)
 		urb = td->urb;
-	done(r8a66597, td, pipenum, urb);
+	finish_request(r8a66597, td, pipenum, urb, -ESHUTDOWN);
 	kfree(hep->hcpriv);
 	hep->hcpriv = NULL;
 	spin_unlock_irqrestore(&r8a66597->lock, flags);
@@ -1875,7 +2030,7 @@
 		return dev;
 	}
 
-	err("get_r8a66597_device fail.(%d)\n", addr);
+	printk(KERN_ERR "r8a66597: get_r8a66597_device fail.(%d)\n", addr);
 	return NULL;
 }
 
@@ -1999,7 +2154,7 @@
 
 		switch (wValue) {
 		case USB_PORT_FEAT_ENABLE:
-			rh->port &= (1 << USB_PORT_FEAT_POWER);
+			rh->port &= ~(1 << USB_PORT_FEAT_POWER);
 			break;
 		case USB_PORT_FEAT_SUSPEND:
 			break;
@@ -2027,7 +2182,7 @@
 	case GetPortStatus:
 		if (wIndex > R8A66597_MAX_ROOT_HUB)
 			goto error;
-		*(u32 *)buf = rh->port;
+		*(__le32 *)buf = cpu_to_le32(rh->port);
 		break;
 	case SetPortFeature:
 		if (wIndex > R8A66597_MAX_ROOT_HUB)
@@ -2071,6 +2226,68 @@
 	return ret;
 }
 
+#if defined(CONFIG_PM)
+static int r8a66597_bus_suspend(struct usb_hcd *hcd)
+{
+	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
+	int port;
+
+	dbg("%s", __func__);
+
+	for (port = 0; port < R8A66597_MAX_ROOT_HUB; port++) {
+		struct r8a66597_root_hub *rh = &r8a66597->root_hub[port];
+		unsigned long dvstctr_reg = get_dvstctr_reg(port);
+
+		if (!(rh->port & (1 << USB_PORT_FEAT_ENABLE)))
+			continue;
+
+		dbg("suspend port = %d", port);
+		r8a66597_bclr(r8a66597, UACT, dvstctr_reg);	/* suspend */
+		rh->port |= 1 << USB_PORT_FEAT_SUSPEND;
+
+		if (rh->dev->udev->do_remote_wakeup) {
+			msleep(3);	/* waiting last SOF */
+			r8a66597_bset(r8a66597, RWUPE, dvstctr_reg);
+			r8a66597_write(r8a66597, ~BCHG, get_intsts_reg(port));
+			r8a66597_bset(r8a66597, BCHGE, get_intenb_reg(port));
+		}
+	}
+
+	r8a66597->bus_suspended = 1;
+
+	return 0;
+}
+
+static int r8a66597_bus_resume(struct usb_hcd *hcd)
+{
+	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
+	int port;
+
+	dbg("%s", __func__);
+
+	for (port = 0; port < R8A66597_MAX_ROOT_HUB; port++) {
+		struct r8a66597_root_hub *rh = &r8a66597->root_hub[port];
+		unsigned long dvstctr_reg = get_dvstctr_reg(port);
+
+		if (!(rh->port & (1 << USB_PORT_FEAT_SUSPEND)))
+			continue;
+
+		dbg("resume port = %d", port);
+		rh->port &= ~(1 << USB_PORT_FEAT_SUSPEND);
+		rh->port |= 1 << USB_PORT_FEAT_C_SUSPEND;
+		r8a66597_mdfy(r8a66597, RESUME, RESUME | UACT, dvstctr_reg);
+		msleep(50);
+		r8a66597_mdfy(r8a66597, UACT, RESUME | UACT, dvstctr_reg);
+	}
+
+	return 0;
+
+}
+#else
+#define	r8a66597_bus_suspend	NULL
+#define	r8a66597_bus_resume	NULL
+#endif
+
 static struct hc_driver r8a66597_hc_driver = {
 	.description =		hcd_name,
 	.hcd_priv_size =	sizeof(struct r8a66597),
@@ -2101,18 +2318,39 @@
 	 */
 	.hub_status_data =	r8a66597_hub_status_data,
 	.hub_control =		r8a66597_hub_control,
+	.bus_suspend =		r8a66597_bus_suspend,
+	.bus_resume =		r8a66597_bus_resume,
 };
 
 #if defined(CONFIG_PM)
 static int r8a66597_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	pdev->dev.power.power_state = state;
+	struct r8a66597		*r8a66597 = dev_get_drvdata(&pdev->dev);
+	int port;
+
+	dbg("%s", __func__);
+
+	disable_controller(r8a66597);
+
+	for (port = 0; port < R8A66597_MAX_ROOT_HUB; port++) {
+		struct r8a66597_root_hub *rh = &r8a66597->root_hub[port];
+
+		rh->port = 0x00000000;
+	}
+
 	return 0;
 }
 
 static int r8a66597_resume(struct platform_device *pdev)
 {
-	pdev->dev.power.power_state = PMSG_ON;
+	struct r8a66597		*r8a66597 = dev_get_drvdata(&pdev->dev);
+	struct usb_hcd		*hcd = r8a66597_to_hcd(r8a66597);
+
+	dbg("%s", __func__);
+
+	enable_controller(r8a66597);
+	usb_root_hub_lost_power(hcd->self.root_hub);
+
 	return 0;
 }
 #else	/* if defined(CONFIG_PM) */
@@ -2126,48 +2364,57 @@
 	struct usb_hcd		*hcd = r8a66597_to_hcd(r8a66597);
 
 	del_timer_sync(&r8a66597->rh_timer);
-	iounmap((void *)r8a66597->reg);
 	usb_remove_hcd(hcd);
+	iounmap((void *)r8a66597->reg);
+#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597) && defined(CONFIG_HAVE_CLK)
+	clk_put(r8a66597->clk);
+#endif
 	usb_put_hcd(hcd);
 	return 0;
 }
 
-#define resource_len(r) (((r)->end - (r)->start) + 1)
 static int __init r8a66597_probe(struct platform_device *pdev)
 {
-	struct resource *res = NULL;
+#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597) && defined(CONFIG_HAVE_CLK)
+	char clk_name[8];
+#endif
+	struct resource *res = NULL, *ires;
 	int irq = -1;
 	void __iomem *reg = NULL;
 	struct usb_hcd *hcd = NULL;
 	struct r8a66597 *r8a66597;
 	int ret = 0;
 	int i;
+	unsigned long irq_trigger;
 
 	if (pdev->dev.dma_mask) {
 		ret = -EINVAL;
-		err("dma not support");
+		dev_err(&pdev->dev, "dma not supported\n");
 		goto clean_up;
 	}
 
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-					   (char *)hcd_name);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		ret = -ENODEV;
-		err("platform_get_resource_byname error.");
+		dev_err(&pdev->dev, "platform_get_resource error.\n");
 		goto clean_up;
 	}
 
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
+	ires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!ires) {
 		ret = -ENODEV;
-		err("platform_get_irq error.");
+		dev_err(&pdev->dev,
+			"platform_get_resource IORESOURCE_IRQ error.\n");
 		goto clean_up;
 	}
 
-	reg = ioremap(res->start, resource_len(res));
+	irq = ires->start;
+	irq_trigger = ires->flags & IRQF_TRIGGER_MASK;
+
+	reg = ioremap(res->start, resource_size(res));
 	if (reg == NULL) {
 		ret = -ENOMEM;
-		err("ioremap error.");
+		dev_err(&pdev->dev, "ioremap error.\n");
 		goto clean_up;
 	}
 
@@ -2175,13 +2422,23 @@
 	hcd = usb_create_hcd(&r8a66597_hc_driver, &pdev->dev, (char *)hcd_name);
 	if (!hcd) {
 		ret = -ENOMEM;
-		err("Failed to create hcd");
+		dev_err(&pdev->dev, "Failed to create hcd\n");
 		goto clean_up;
 	}
 	r8a66597 = hcd_to_r8a66597(hcd);
 	memset(r8a66597, 0, sizeof(struct r8a66597));
 	dev_set_drvdata(&pdev->dev, r8a66597);
 
+#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597) && defined(CONFIG_HAVE_CLK)
+	snprintf(clk_name, sizeof(clk_name), "usb%d", pdev->id);
+	r8a66597->clk = clk_get(&pdev->dev, clk_name);
+	if (IS_ERR(r8a66597->clk)) {
+		dev_err(&pdev->dev, "cannot get clock \"%s\"\n", clk_name);
+		ret = PTR_ERR(r8a66597->clk);
+		goto clean_up2;
+	}
+#endif
+
 	spin_lock_init(&r8a66597->lock);
 	init_timer(&r8a66597->rh_timer);
 	r8a66597->rh_timer.function = r8a66597_timer;
@@ -2193,18 +2450,52 @@
 		init_timer(&r8a66597->td_timer[i]);
 		r8a66597->td_timer[i].function = r8a66597_td_timer;
 		r8a66597->td_timer[i].data = (unsigned long)r8a66597;
+		setup_timer(&r8a66597->interval_timer[i],
+				r8a66597_interval_timer,
+				(unsigned long)r8a66597);
 	}
 	INIT_LIST_HEAD(&r8a66597->child_device);
 
 	hcd->rsrc_start = res->start;
-	ret = usb_add_hcd(hcd, irq, 0);
+
+	/* irq_sense setting on cmdline takes precedence over resource
+	 * settings, so the introduction of irqflags in IRQ resourse
+	 * won't disturb existing setups */
+	switch (irq_sense) {
+		case INTL:
+			irq_trigger = IRQF_TRIGGER_LOW;
+			break;
+		case 0:
+			irq_trigger = IRQF_TRIGGER_FALLING;
+			break;
+		case 0xff:
+			if (irq_trigger)
+				irq_sense = (irq_trigger & IRQF_TRIGGER_LOW) ?
+					    INTL : 0;
+			else {
+				irq_sense = INTL;
+				irq_trigger = IRQF_TRIGGER_LOW;
+			}
+			break;
+		default:
+			dev_err(&pdev->dev, "Unknown irq_sense value.\n");
+	}
+
+	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED | irq_trigger);
 	if (ret != 0) {
-		err("Failed to add hcd");
-		goto clean_up;
+		dev_err(&pdev->dev, "Failed to add hcd\n");
+		goto clean_up3;
 	}
 
 	return 0;
 
+clean_up3:
+#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597) && defined(CONFIG_HAVE_CLK)
+	clk_put(r8a66597->clk);
+clean_up2:
+#endif
+	usb_put_hcd(hcd);
+
 clean_up:
 	if (reg)
 		iounmap(reg);
@@ -2219,6 +2510,7 @@
 	.resume =	r8a66597_resume,
 	.driver		= {
 		.name = (char *) hcd_name,
+		.owner	= THIS_MODULE,
 	},
 };
 
@@ -2227,7 +2519,8 @@
 	if (usb_disabled())
 		return -ENODEV;
 
-	info("driver %s, %s", hcd_name, DRIVER_VERSION);
+	printk(KERN_INFO KBUILD_MODNAME ": driver %s, %s\n", hcd_name,
+	       DRIVER_VERSION);
 	return platform_driver_register(&r8a66597_driver);
 }
 module_init(r8a66597_init);
diff -urN host/r8a66597.h host.new/r8a66597.h
--- host/r8a66597.h	2009-02-24 19:00:15.559962319 +0100
+++ host.new/r8a66597.h	2009-03-28 17:46:02.000000000 +0100
@@ -26,6 +26,10 @@
 #ifndef __R8A66597_H__
 #define __R8A66597_H__
 
+#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597) && defined(CONFIG_HAVE_CLK)
+#include <linux/clk.h>
+#endif
+
 #define SYSCFG0		0x00
 #define SYSCFG1		0x02
 #define SYSSTS0		0x04
@@ -187,7 +191,11 @@
 #define	REW		0x4000	/* b14: Buffer rewind */
 #define	DCLRM		0x2000	/* b13: DMA buffer clear mode */
 #define	DREQE		0x1000	/* b12: DREQ output enable */
+#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
+#define	MBW		0x0800
+#else
 #define	MBW		0x0400	/* b10: Maximum bit width for FIFO access */
+#endif
 #define	  MBW_8		 0x0000	  /*  8bit */
 #define	  MBW_16	 0x0400	  /* 16bit */
 #define	BIGEND		0x0100	/* b8: Big endian mode */
@@ -395,8 +403,13 @@
 #define R8A66597_MAX_NUM_PIPE		10
 #define R8A66597_BUF_BSIZE		8
 #define R8A66597_MAX_DEVICE		10
+#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
+#define R8A66597_MAX_ROOT_HUB		1
+#else
 #define R8A66597_MAX_ROOT_HUB		2
-#define R8A66597_MAX_SAMPLING		10
+#endif
+#define R8A66597_MAX_SAMPLING		5
+#define R8A66597_RH_POLL_TIME		10
 #define R8A66597_MAX_DMA_CHANNEL	2
 #define R8A66597_PIPE_NO_DMA		R8A66597_MAX_DMA_CHANNEL
 #define check_bulk_or_isoc(pipenum)	((pipenum >= 1 && pipenum <= 5))
@@ -404,8 +417,9 @@
 #define make_devsel(addr)		(addr << 12)
 
 struct r8a66597_pipe_info {
+	unsigned long timer_interval;
 	u16 pipenum;
-	u16 address;	/* R8A66597 HCD usb addres */
+	u16 address;	/* R8A66597 HCD usb address */
 	u16 epnum;
 	u16 maxpacket;
 	u16 type;
@@ -471,21 +485,27 @@
 struct r8a66597 {
 	spinlock_t lock;
 	unsigned long reg;
-
+#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597) && defined(CONFIG_HAVE_CLK)
+	struct clk *clk;
+#endif
 	struct r8a66597_device		device0;
 	struct r8a66597_root_hub	root_hub[R8A66597_MAX_ROOT_HUB];
 	struct list_head		pipe_queue[R8A66597_MAX_NUM_PIPE];
 
 	struct timer_list rh_timer;
 	struct timer_list td_timer[R8A66597_MAX_NUM_PIPE];
+	struct timer_list interval_timer[R8A66597_MAX_NUM_PIPE];
 
 	unsigned short address_map;
 	unsigned short timeout_map;
+	unsigned short interval_map;
 	unsigned char pipe_cnt[R8A66597_MAX_NUM_PIPE];
 	unsigned char dma_map;
 
 	struct list_head child_device;
 	unsigned long child_connect_map[4];
+
+	unsigned bus_suspended:1;
 };
 
 static inline struct r8a66597 *hcd_to_r8a66597(struct usb_hcd *hcd)
@@ -526,8 +546,21 @@
 				      unsigned long offset, u16 *buf,
 				      int len)
 {
+#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
+	unsigned long fifoaddr = r8a66597->reg + offset;
+	unsigned long count;
+
+	count = len / 4;
+	insl(fifoaddr, buf, count);
+
+	if (len & 0x00000003) {
+		unsigned long tmp = inl(fifoaddr);
+		memcpy((unsigned char *)buf + count * 4, &tmp, len & 0x03);
+	}
+#else
 	len = (len + 1) / 2;
 	insw(r8a66597->reg + offset, buf, len);
+#endif
 }
 
 static inline void r8a66597_write(struct r8a66597 *r8a66597, u16 val,
@@ -541,6 +574,24 @@
 				       int len)
 {
 	unsigned long fifoaddr = r8a66597->reg + offset;
+#if defined(CONFIG_SUPERH_ON_CHIP_R8A66597)
+	unsigned long count;
+	unsigned char *pb;
+	int i;
+
+	count = len / 4;
+	outsl(fifoaddr, buf, count);
+
+	if (len & 0x00000003) {
+		pb = (unsigned char *)buf + count * 4;
+		for (i = 0; i < (len & 0x00000003); i++) {
+			if (r8a66597_read(r8a66597, CFIFOSEL) & BIGEND)
+				outb(pb[i], fifoaddr + i);
+			else
+				outb(pb[i], fifoaddr + 3 - i);
+		}
+	}
+#else
 	int odd = len & 0x0001;
 
 	len = len / 2;
@@ -549,6 +600,7 @@
 		buf = &buf[len];
 		outb((unsigned char)*buf, fifoaddr);
 	}
+#endif
 }
 
 static inline void r8a66597_mdfy(struct r8a66597 *r8a66597,
@@ -581,6 +633,11 @@
 	return port == 0 ? DVSTCTR0 : DVSTCTR1;
 }
 
+static inline unsigned long get_dmacfg_reg(int port)
+{
+	return port == 0 ? DMA0CFG : DMA1CFG;
+}
+
 static inline unsigned long get_intenb_reg(int port)
 {
 	return port == 0 ? INTENB1 : INTENB2;
diff -urN host/sl811-hcd.c host.new/sl811-hcd.c
--- host/sl811-hcd.c	2009-02-24 19:00:15.571961710 +0100
+++ host.new/sl811-hcd.c	2009-03-28 17:46:02.000000000 +0100
@@ -58,6 +58,7 @@
 
 MODULE_DESCRIPTION("SL811HS USB Host Controller Driver");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sl811-hcd");
 
 #define DRIVER_VERSION	"19 May 2005"
 
@@ -93,12 +94,10 @@
 
 		sl811->port1 = (1 << USB_PORT_FEAT_POWER);
 		sl811->irq_enable = SL11H_INTMASK_INSRMV;
-		hcd->self.controller->power.power_state = PMSG_ON;
 	} else {
 		sl811->port1 = 0;
 		sl811->irq_enable = 0;
 		hcd->state = HC_STATE_HALT;
-		hcd->self.controller->power.power_state = PMSG_SUSPEND;
 	}
 	sl811->ctrl1 = 0;
 	sl811_write(sl811, SL11H_IRQ_ENABLE, 0);
@@ -231,7 +230,7 @@
 	writeb(usb_pipedevice(urb->pipe), data_reg);
 
 	sl811_write(sl811, bank + SL11H_HOSTCTLREG, control);
-	ep->length = min((int)len,
+	ep->length = min_t(u32, len,
 			urb->transfer_buffer_length - urb->actual_length);
 	PACKET("IN%s/%d qh%p len%d\n", ep->nak_count ? "/retry" : "",
 			!!usb_gettoggle(urb->dev, ep->epnum, 0), ep, len);
@@ -256,7 +255,7 @@
 	buf = urb->transfer_buffer + urb->actual_length;
 	prefetch(buf);
 
-	len = min((int)ep->maxpacket,
+	len = min_t(u32, ep->maxpacket,
 			urb->transfer_buffer_length - urb->actual_length);
 
 	if (!(control & SL11H_HCTLMASK_ISOCH)
@@ -435,14 +434,9 @@
 	if (usb_pipecontrol(urb->pipe))
 		ep->nextpid = USB_PID_SETUP;
 
-	spin_lock(&urb->lock);
-	if (urb->status == -EINPROGRESS)
-		urb->status = status;
-	urb->hcpriv = NULL;
-	spin_unlock(&urb->lock);
-
+	usb_hcd_unlink_urb_from_ep(sl811_to_hcd(sl811), urb);
 	spin_unlock(&sl811->lock);
-	usb_hcd_giveback_urb(sl811_to_hcd(sl811), urb);
+	usb_hcd_giveback_urb(sl811_to_hcd(sl811), urb, status);
 	spin_lock(&sl811->lock);
 
 	/* leave active endpoints in the schedule */
@@ -538,35 +532,21 @@
 						bank + SL11H_XFERCNTREG);
 			if (len > ep->length) {
 				len = ep->length;
-				urb->status = -EOVERFLOW;
+				urbstat = -EOVERFLOW;
 			}
 			urb->actual_length += len;
 			sl811_read_buf(sl811, SL811HS_PACKET_BUF(bank == 0),
 					buf, len);
 			usb_dotoggle(udev, ep->epnum, 0);
-			if (urb->actual_length == urb->transfer_buffer_length)
-				urbstat = 0;
-			else if (len < ep->maxpacket) {
-				if (urb->transfer_flags & URB_SHORT_NOT_OK)
-					urbstat = -EREMOTEIO;
+			if (urbstat == -EINPROGRESS &&
+					(len < ep->maxpacket ||
+						urb->actual_length ==
+						urb->transfer_buffer_length)) {
+				if (usb_pipecontrol(urb->pipe))
+					ep->nextpid = USB_PID_ACK;
 				else
 					urbstat = 0;
 			}
-			if (usb_pipecontrol(urb->pipe)
-					&& (urbstat == -EREMOTEIO
-						|| urbstat == 0)) {
-
-				/* NOTE if the status stage STALLs (why?),
-				 * this reports the wrong urb status.
-				 */
-				spin_lock(&urb->lock);
-				if (urb->status == -EINPROGRESS)
-					urb->status = urbstat;
-				spin_unlock(&urb->lock);
-
-				urb = NULL;
-				ep->nextpid = USB_PID_ACK;
-			}
 			break;
 		case USB_PID_SETUP:
 			// PACKET("...ACK/setup_%02x qh%p\n", bank, ep);
@@ -605,7 +585,7 @@
 				bank, status, ep, urbstat);
 	}
 
-	if (urb && (urbstat != -EINPROGRESS || urb->status != -EINPROGRESS))
+	if (urbstat != -EINPROGRESS || urb->unlinked)
 		finish_request(sl811, ep, urb, urbstat);
 }
 
@@ -807,7 +787,6 @@
 
 static int sl811h_urb_enqueue(
 	struct usb_hcd		*hcd,
-	struct usb_host_endpoint *hep,
 	struct urb		*urb,
 	gfp_t			mem_flags
 ) {
@@ -820,7 +799,8 @@
 	struct sl811h_ep	*ep = NULL;
 	unsigned long		flags;
 	int			i;
-	int			retval = 0;
+	int			retval;
+	struct usb_host_endpoint	*hep = urb->ep;
 
 #ifdef	DISABLE_ISO
 	if (type == PIPE_ISOCHRONOUS)
@@ -838,7 +818,12 @@
 			|| !HC_IS_RUNNING(hcd->state)) {
 		retval = -ENODEV;
 		kfree(ep);
-		goto fail;
+		goto fail_not_linked;
+	}
+	retval = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (retval) {
+		kfree(ep);
+		goto fail_not_linked;
 	}
 
 	if (hep->hcpriv) {
@@ -951,37 +936,31 @@
 		sofirq_on(sl811);
 	}
 
-	/* in case of unlink-during-submit */
-	spin_lock(&urb->lock);
-	if (urb->status != -EINPROGRESS) {
-		spin_unlock(&urb->lock);
-		finish_request(sl811, ep, urb, 0);
-		retval = 0;
-		goto fail;
-	}
 	urb->hcpriv = hep;
-	spin_unlock(&urb->lock);
-
 	start_transfer(sl811);
 	sl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);
 fail:
+	if (retval)
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+fail_not_linked:
 	spin_unlock_irqrestore(&sl811->lock, flags);
 	return retval;
 }
 
-static int sl811h_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int sl811h_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct sl811		*sl811 = hcd_to_sl811(hcd);
 	struct usb_host_endpoint *hep;
 	unsigned long		flags;
 	struct sl811h_ep	*ep;
-	int			retval = 0;
+	int			retval;
 
 	spin_lock_irqsave(&sl811->lock, flags);
-	hep = urb->hcpriv;
-	if (!hep)
+	retval = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (retval)
 		goto fail;
 
+	hep = urb->hcpriv;
 	ep = hep->hcpriv;
 	if (ep) {
 		/* finish right away if this urb can't be active ...
@@ -1029,8 +1008,8 @@
 			VDBG("dequeue, urb %p active %s; wait4irq\n", urb,
 				(sl811->active_a == ep) ? "A" : "B");
 	} else
-fail:
 		retval = -EINVAL;
+ fail:
 	spin_unlock_irqrestore(&sl811->lock, flags);
 	return retval;
 }
@@ -1047,7 +1026,7 @@
 	if (!list_empty(&hep->urb_list))
 		msleep(3);
 	if (!list_empty(&hep->urb_list))
-		WARN("ep %p not empty?\n", ep);
+		WARNING("ep %p not empty?\n", ep);
 
 	kfree(ep);
 	hep->hcpriv = NULL;
@@ -1121,7 +1100,7 @@
 	/* no overcurrent errors detection/handling */
 	temp |= 0x0010;
 
-	desc->wHubCharacteristics = (__force __u16)cpu_to_le16(temp);
+	desc->wHubCharacteristics = cpu_to_le16(temp);
 
 	/* two bitmaps:  ports removable, and legacy PortPwrCtrlMask */
 	desc->bitmap[0] = 0 << 1;
@@ -1356,7 +1335,7 @@
 sl811h_bus_suspend(struct usb_hcd *hcd)
 {
 	// SOFs off
-	DBG("%s\n", __FUNCTION__);
+	DBG("%s\n", __func__);
 	return 0;
 }
 
@@ -1364,7 +1343,7 @@
 sl811h_bus_resume(struct usb_hcd *hcd)
 {
 	// SOFs on
-	DBG("%s\n", __FUNCTION__);
+	DBG("%s\n", __func__);
 	return 0;
 }
 
@@ -1527,15 +1506,7 @@
 
 static void create_debug_file(struct sl811 *sl811)
 {
-	struct proc_dir_entry *pde;
-
-	pde = create_proc_entry(proc_filename, 0, NULL);
-	if (pde == NULL)
-		return;
-
-	pde->proc_fops = &proc_ops;
-	pde->data = sl811;
-	sl811->pde = pde;
+	sl811->pde = proc_create_data(proc_filename, 0, NULL, &proc_ops, sl811);
 }
 
 static void remove_debug_file(struct sl811 *sl811)
@@ -1576,7 +1547,7 @@
 		hcd->power_budget = sl811->board->power * 2;
 	}
 
-	/* enable power and interupts */
+	/* enable power and interrupts */
 	port_power(sl811, 1);
 
 	return 0;
@@ -1649,22 +1620,26 @@
 {
 	struct usb_hcd		*hcd;
 	struct sl811		*sl811;
-	struct resource		*addr, *data;
+	struct resource		*addr, *data, *ires;
 	int			irq;
 	void __iomem		*addr_reg;
 	void __iomem		*data_reg;
 	int			retval;
 	u8			tmp, ioaddr = 0;
+	unsigned long		irqflags;
 
 	/* basic sanity checks first.  board-specific init logic should
 	 * have initialized these three resources and probably board
 	 * specific platform_data.  we don't probe for IRQs, and do only
 	 * minimal sanity checking.
 	 */
-	irq = platform_get_irq(dev, 0);
-	if (dev->num_resources < 3 || irq < 0)
+	ires = platform_get_resource(dev, IORESOURCE_IRQ, 0);
+	if (dev->num_resources < 3 || !ires)
 		return -ENODEV;
 
+	irq = ires->start;
+	irqflags = ires->flags & IRQF_TRIGGER_MASK;
+
 	/* refuse to confuse usbcore */
 	if (dev->dev.dma_mask) {
 		DBG("no we won't dma\n");
@@ -1703,7 +1678,7 @@
 	}
 
 	/* allocate and initialize hcd */
-	hcd = usb_create_hcd(&sl811h_hc_driver, &dev->dev, dev->dev.bus_id);
+	hcd = usb_create_hcd(&sl811h_hc_driver, &dev->dev, dev_name(&dev->dev));
 	if (!hcd) {
 		retval = -ENOMEM;
 		goto err5;
@@ -1746,8 +1721,11 @@
 	 * triggers (e.g. most ARM CPUs).  Initial driver stress testing
 	 * was on a system with single edge triggering, so most sorts of
 	 * triggering arrangement should work.
+	 *
+	 * Use resource IRQ flags if set by platform device setup.
 	 */
-	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
+	irqflags |= IRQF_SHARED;
+	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | irqflags);
 	if (retval != 0)
 		goto err6;
 
@@ -1786,12 +1764,11 @@
 		retval = sl811h_bus_suspend(hcd);
 		break;
 	case PM_EVENT_SUSPEND:
+	case PM_EVENT_HIBERNATE:
 	case PM_EVENT_PRETHAW:		/* explicitly discard hw state */
 		port_power(sl811, 0);
 		break;
 	}
-	if (retval == 0)
-		dev->dev.power.power_state = state;
 	return retval;
 }
 
@@ -1804,15 +1781,13 @@
 	/* with no "check to see if VBUS is still powered" board hook,
 	 * let's assume it'd only be powered to enable remote wakeup.
 	 */
-	if (dev->dev.power.power_state.event == PM_EVENT_SUSPEND
-			|| !device_can_wakeup(&hcd->self.root_hub->dev)) {
+	if (!sl811->port1 || !device_can_wakeup(&hcd->self.root_hub->dev)) {
 		sl811->port1 = 0;
 		port_power(sl811, 1);
 		usb_root_hub_lost_power(hcd->self.root_hub);
 		return 0;
 	}
 
-	dev->dev.power.power_state = PMSG_ON;
 	return sl811h_bus_resume(hcd);
 }
 
diff -urN host/sl811.h host.new/sl811.h
--- host/sl811.h	2009-02-24 19:00:15.579961303 +0100
+++ host.new/sl811.h	2009-03-28 17:46:02.000000000 +0100
@@ -261,6 +261,6 @@
 #endif
 
 #define ERR(stuff...)		printk(KERN_ERR "sl811: " stuff)
-#define WARN(stuff...)		printk(KERN_WARNING "sl811: " stuff)
+#define WARNING(stuff...)	printk(KERN_WARNING "sl811: " stuff)
 #define INFO(stuff...)		printk(KERN_INFO "sl811: " stuff)
 
diff -urN host/sl811_cs.c host.new/sl811_cs.c
--- host/sl811_cs.c	2009-02-24 19:00:15.579961303 +0100
+++ host.new/sl811_cs.c	2009-03-28 17:46:02.000000000 +0100
@@ -112,7 +112,8 @@
 	.num_resources		= ARRAY_SIZE(resources),
 };
 
-static int sl811_hc_init(struct device *parent, ioaddr_t base_addr, int irq)
+static int sl811_hc_init(struct device *parent, resource_size_t base_addr,
+			 int irq)
 {
 	if (platform_dev.dev.parent)
 		return -EBUSY;
@@ -155,97 +156,72 @@
 	platform_device_unregister(&platform_dev);
 }
 
-static int sl811_cs_config(struct pcmcia_device *link)
+static int sl811_cs_config_check(struct pcmcia_device *p_dev,
+				 cistpl_cftable_entry_t *cfg,
+				 cistpl_cftable_entry_t *dflt,
+				 unsigned int vcc,
+				 void *priv_data)
 {
-	struct device		*parent = &handle_to_dev(link);
-	local_info_t		*dev = link->priv;
-	tuple_t			tuple;
-	cisparse_t		parse;
-	int			last_fn, last_ret;
-	u_char			buf[64];
-	config_info_t		conf;
-	cistpl_cftable_entry_t	dflt = { 0 };
+	if (cfg->index == 0)
+		return -ENODEV;
 
-	DBG(0, "sl811_cs_config(0x%p)\n", link);
-
-	/* Look up the current Vcc */
-	CS_CHECK(GetConfigurationInfo,
-			pcmcia_get_configuration_info(link, &conf));
-
-	tuple.Attributes = 0;
-	tuple.TupleData = buf;
-	tuple.TupleDataMax = sizeof(buf);
-	tuple.TupleOffset = 0;
-	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
-	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
-	while (1) {
-		cistpl_cftable_entry_t	*cfg = &(parse.cftable_entry);
-
-		if (pcmcia_get_tuple_data(link, &tuple) != 0
-				|| pcmcia_parse_tuple(link, &tuple, &parse)
-						!= 0)
-			goto next_entry;
-
-		if (cfg->flags & CISTPL_CFTABLE_DEFAULT) {
-			dflt = *cfg;
+	/* Use power settings for Vcc and Vpp if present */
+	/*  Note that the CIS values need to be rescaled */
+	if (cfg->vcc.present & (1<<CISTPL_POWER_VNOM)) {
+		if (cfg->vcc.param[CISTPL_POWER_VNOM]/10000 != vcc)
+			return -ENODEV;
+	} else if (dflt->vcc.present & (1<<CISTPL_POWER_VNOM)) {
+		if (dflt->vcc.param[CISTPL_POWER_VNOM]/10000 != vcc)
+			return -ENODEV;
 		}
 
-		if (cfg->index == 0)
-			goto next_entry;
+	if (cfg->vpp1.present & (1<<CISTPL_POWER_VNOM))
+		p_dev->conf.Vpp =
+			cfg->vpp1.param[CISTPL_POWER_VNOM]/10000;
+	else if (dflt->vpp1.present & (1<<CISTPL_POWER_VNOM))
+		p_dev->conf.Vpp =
+			dflt->vpp1.param[CISTPL_POWER_VNOM]/10000;
+
+	/* we need an interrupt */
+	if (cfg->irq.IRQInfo1 || dflt->irq.IRQInfo1)
+		p_dev->conf.Attributes |= CONF_ENABLE_IRQ;
+
+	/* IO window settings */
+	p_dev->io.NumPorts1 = p_dev->io.NumPorts2 = 0;
+	if ((cfg->io.nwin > 0) || (dflt->io.nwin > 0)) {
+		cistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt->io;
+
+		p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+		p_dev->io.IOAddrLines = io->flags & CISTPL_IO_LINES_MASK;
+		p_dev->io.BasePort1 = io->win[0].base;
+		p_dev->io.NumPorts1 = io->win[0].len;
 
-		link->conf.ConfigIndex = cfg->index;
+		return pcmcia_request_io(p_dev, &p_dev->io);
+	}
+	pcmcia_disable_device(p_dev);
+	return -ENODEV;
+}
 
-		/* Use power settings for Vcc and Vpp if present */
-		/*  Note that the CIS values need to be rescaled */
-		if (cfg->vcc.present & (1<<CISTPL_POWER_VNOM)) {
-			if (cfg->vcc.param[CISTPL_POWER_VNOM]/10000
-					!= conf.Vcc)
-				goto next_entry;
-		} else if (dflt.vcc.present & (1<<CISTPL_POWER_VNOM)) {
-			if (dflt.vcc.param[CISTPL_POWER_VNOM]/10000
-					!= conf.Vcc)
-				goto next_entry;
-		}
 
-		if (cfg->vpp1.present & (1<<CISTPL_POWER_VNOM))
-			link->conf.Vpp =
-				cfg->vpp1.param[CISTPL_POWER_VNOM]/10000;
-		else if (dflt.vpp1.present & (1<<CISTPL_POWER_VNOM))
-			link->conf.Vpp =
-				dflt.vpp1.param[CISTPL_POWER_VNOM]/10000;
-
-		/* we need an interrupt */
-		if (cfg->irq.IRQInfo1 || dflt.irq.IRQInfo1)
-			link->conf.Attributes |= CONF_ENABLE_IRQ;
-
-		/* IO window settings */
-		link->io.NumPorts1 = link->io.NumPorts2 = 0;
-		if ((cfg->io.nwin > 0) || (dflt.io.nwin > 0)) {
-			cistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt.io;
-
-			link->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
-			link->io.IOAddrLines = io->flags & CISTPL_IO_LINES_MASK;
-			link->io.BasePort1 = io->win[0].base;
-			link->io.NumPorts1 = io->win[0].len;
+static int sl811_cs_config(struct pcmcia_device *link)
+{
+	struct device		*parent = &handle_to_dev(link);
+	local_info_t		*dev = link->priv;
+	int			last_fn, last_ret;
 
-			if (pcmcia_request_io(link, &link->io) != 0)
-				goto next_entry;
-		}
-		break;
+	DBG(0, "sl811_cs_config(0x%p)\n", link);
 
-next_entry:
-		pcmcia_disable_device(link);
-		last_ret = pcmcia_get_next_tuple(link, &tuple);
-	}
+	if (pcmcia_loop_config(link, sl811_cs_config_check, NULL))
+		goto failed;
 
 	/* require an IRQ and two registers */
 	if (!link->io.NumPorts1 || link->io.NumPorts1 < 2)
-		goto cs_failed;
+		goto failed;
 	if (link->conf.Attributes & CONF_ENABLE_IRQ)
 		CS_CHECK(RequestIRQ,
 			pcmcia_request_irq(link, &link->irq));
 	else
-		goto cs_failed;
+		goto failed;
 
 	CS_CHECK(RequestConfiguration,
 		pcmcia_request_configuration(link, &link->conf));
@@ -266,8 +242,9 @@
 	if (sl811_hc_init(parent, link->io.BasePort1, link->irq.AssignedIRQ)
 			< 0) {
 cs_failed:
-		printk("sl811_cs_config failed\n");
 		cs_error(link, last_fn, last_ret);
+failed:
+		printk(KERN_WARNING "sl811_cs_config failed\n");
 		sl811_cs_release(link);
 		return  -ENODEV;
 	}
diff -urN host/u132-hcd.c host.new/u132-hcd.c
--- host/u132-hcd.c	2009-02-24 19:00:15.627958864 +0100
+++ host.new/u132-hcd.c	2009-03-28 17:46:02.000000000 +0100
@@ -51,7 +51,6 @@
 #include <linux/usb.h>
 #include <linux/workqueue.h>
 #include <linux/platform_device.h>
-#include <linux/pci_ids.h>
 #include <linux/mutex.h>
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -68,7 +67,7 @@
 #include "ohci.h"
 #define OHCI_CONTROL_INIT OHCI_CTRL_CBSR
 #define OHCI_INTR_INIT (OHCI_INTR_MIE | OHCI_INTR_UE | OHCI_INTR_RD | \
-        OHCI_INTR_WDH)
+	OHCI_INTR_WDH)
 MODULE_AUTHOR("Tony Olech - Elan Digital Systems Limited");
 MODULE_DESCRIPTION("U132 USB Host Controller Driver");
 MODULE_LICENSE("GPL");
@@ -78,15 +77,15 @@
 static int distrust_firmware = 1;
 module_param(distrust_firmware, bool, 0);
 MODULE_PARM_DESC(distrust_firmware, "true to distrust firmware power/overcurren"
-        "t setup");
+	"t setup");
 static DECLARE_WAIT_QUEUE_HEAD(u132_hcd_wait);
 /*
 * u132_module_lock exists to protect access to global variables
 *
 */
 static struct mutex u132_module_lock;
-static int u132_exiting = 0;
-static int u132_instances = 0;
+static int u132_exiting;
+static int u132_instances;
 static struct list_head u132_static_list;
 /*
 * end of the global variables protected by u132_module_lock
@@ -98,115 +97,115 @@
 #define MAX_U132_ENDPS 100
 #define MAX_U132_RINGS 4
 static const char *cc_to_text[16] = {
-        "No Error ",
-        "CRC Error ",
-        "Bit Stuff ",
-        "Data Togg ",
-        "Stall ",
-        "DevNotResp ",
-        "PIDCheck ",
-        "UnExpPID ",
-        "DataOver ",
-        "DataUnder ",
-        "(for hw) ",
-        "(for hw) ",
-        "BufferOver ",
-        "BuffUnder ",
-        "(for HCD) ",
-        "(for HCD) "
+	"No Error ",
+	"CRC Error ",
+	"Bit Stuff ",
+	"Data Togg ",
+	"Stall ",
+	"DevNotResp ",
+	"PIDCheck ",
+	"UnExpPID ",
+	"DataOver ",
+	"DataUnder ",
+	"(for hw) ",
+	"(for hw) ",
+	"BufferOver ",
+	"BuffUnder ",
+	"(for HCD) ",
+	"(for HCD) "
 };
 struct u132_port {
-        struct u132 *u132;
-        int reset;
-        int enable;
-        int power;
-        int Status;
+	struct u132 *u132;
+	int reset;
+	int enable;
+	int power;
+	int Status;
 };
 struct u132_addr {
-        u8 address;
+	u8 address;
 };
 struct u132_udev {
-        struct kref kref;
-        struct usb_device *usb_device;
-        u8 enumeration;
-        u8 udev_number;
-        u8 usb_addr;
-        u8 portnumber;
-        u8 endp_number_in[16];
-        u8 endp_number_out[16];
+	struct kref kref;
+	struct usb_device *usb_device;
+	u8 enumeration;
+	u8 udev_number;
+	u8 usb_addr;
+	u8 portnumber;
+	u8 endp_number_in[16];
+	u8 endp_number_out[16];
 };
 #define ENDP_QUEUE_SHIFT 3
 #define ENDP_QUEUE_SIZE (1<<ENDP_QUEUE_SHIFT)
 #define ENDP_QUEUE_MASK (ENDP_QUEUE_SIZE-1)
 struct u132_urbq {
-        struct list_head urb_more;
-        struct urb *urb;
+	struct list_head urb_more;
+	struct urb *urb;
 };
 struct u132_spin {
-        spinlock_t slock;
+	spinlock_t slock;
 };
 struct u132_endp {
-        struct kref kref;
-        u8 udev_number;
-        u8 endp_number;
-        u8 usb_addr;
-        u8 usb_endp;
-        struct u132 *u132;
-        struct list_head endp_ring;
-        struct u132_ring *ring;
-        unsigned toggle_bits:2;
-        unsigned active:1;
-        unsigned delayed:1;
-        unsigned input:1;
-        unsigned output:1;
-        unsigned pipetype:2;
-        unsigned dequeueing:1;
-        unsigned edset_flush:1;
-        unsigned spare_bits:14;
-        unsigned long jiffies;
-        struct usb_host_endpoint *hep;
-        struct u132_spin queue_lock;
-        u16 queue_size;
-        u16 queue_last;
-        u16 queue_next;
-        struct urb *urb_list[ENDP_QUEUE_SIZE];
-        struct list_head urb_more;
-        struct delayed_work scheduler;
+	struct kref kref;
+	u8 udev_number;
+	u8 endp_number;
+	u8 usb_addr;
+	u8 usb_endp;
+	struct u132 *u132;
+	struct list_head endp_ring;
+	struct u132_ring *ring;
+	unsigned toggle_bits:2;
+	unsigned active:1;
+	unsigned delayed:1;
+	unsigned input:1;
+	unsigned output:1;
+	unsigned pipetype:2;
+	unsigned dequeueing:1;
+	unsigned edset_flush:1;
+	unsigned spare_bits:14;
+	unsigned long jiffies;
+	struct usb_host_endpoint *hep;
+	struct u132_spin queue_lock;
+	u16 queue_size;
+	u16 queue_last;
+	u16 queue_next;
+	struct urb *urb_list[ENDP_QUEUE_SIZE];
+	struct list_head urb_more;
+	struct delayed_work scheduler;
 };
 struct u132_ring {
-        unsigned in_use:1;
-        unsigned length:7;
-        u8 number;
-        struct u132 *u132;
-        struct u132_endp *curr_endp;
-        struct delayed_work scheduler;
+	unsigned in_use:1;
+	unsigned length:7;
+	u8 number;
+	struct u132 *u132;
+	struct u132_endp *curr_endp;
+	struct delayed_work scheduler;
 };
 struct u132 {
-        struct kref kref;
-        struct list_head u132_list;
-        struct semaphore sw_lock;
-        struct semaphore scheduler_lock;
-        struct u132_platform_data *board;
-        struct platform_device *platform_dev;
-        struct u132_ring ring[MAX_U132_RINGS];
-        int sequence_num;
-        int going;
-        int power;
-        int reset;
-        int num_ports;
-        u32 hc_control;
-        u32 hc_fminterval;
-        u32 hc_roothub_status;
-        u32 hc_roothub_a;
-        u32 hc_roothub_portstatus[MAX_ROOT_PORTS];
-        int flags;
-        unsigned long next_statechange;
-        struct delayed_work monitor;
-        int num_endpoints;
-        struct u132_addr addr[MAX_U132_ADDRS];
-        struct u132_udev udev[MAX_U132_UDEVS];
-        struct u132_port port[MAX_U132_PORTS];
-        struct u132_endp *endp[MAX_U132_ENDPS];
+	struct kref kref;
+	struct list_head u132_list;
+	struct mutex sw_lock;
+	struct mutex scheduler_lock;
+	struct u132_platform_data *board;
+	struct platform_device *platform_dev;
+	struct u132_ring ring[MAX_U132_RINGS];
+	int sequence_num;
+	int going;
+	int power;
+	int reset;
+	int num_ports;
+	u32 hc_control;
+	u32 hc_fminterval;
+	u32 hc_roothub_status;
+	u32 hc_roothub_a;
+	u32 hc_roothub_portstatus[MAX_ROOT_PORTS];
+	int flags;
+	unsigned long next_statechange;
+	struct delayed_work monitor;
+	int num_endpoints;
+	struct u132_addr addr[MAX_U132_ADDRS];
+	struct u132_udev udev[MAX_U132_UDEVS];
+	struct u132_port port[MAX_U132_PORTS];
+	struct u132_endp *endp[MAX_U132_ENDPS];
 };
 
 /*
@@ -214,34 +213,34 @@
 * Does anyone have a better way?????
 */
 #define ftdi_read_pcimem(pdev, member, data) usb_ftdi_elan_read_pcimem(pdev, \
-        offsetof(struct ohci_regs, member), 0, data);
+	offsetof(struct ohci_regs, member), 0, data);
 #define ftdi_write_pcimem(pdev, member, data) usb_ftdi_elan_write_pcimem(pdev, \
-        offsetof(struct ohci_regs, member), 0, data);
+	offsetof(struct ohci_regs, member), 0, data);
 #define u132_read_pcimem(u132, member, data) \
-        usb_ftdi_elan_read_pcimem(u132->platform_dev, offsetof(struct \
-        ohci_regs, member), 0, data);
+	usb_ftdi_elan_read_pcimem(u132->platform_dev, offsetof(struct \
+	ohci_regs, member), 0, data);
 #define u132_write_pcimem(u132, member, data) \
-        usb_ftdi_elan_write_pcimem(u132->platform_dev, offsetof(struct \
-        ohci_regs, member), 0, data);
+	usb_ftdi_elan_write_pcimem(u132->platform_dev, offsetof(struct \
+	ohci_regs, member), 0, data);
 static inline struct u132 *udev_to_u132(struct u132_udev *udev)
 {
-        u8 udev_number = udev->udev_number;
-        return container_of(udev, struct u132, udev[udev_number]);
+	u8 udev_number = udev->udev_number;
+	return container_of(udev, struct u132, udev[udev_number]);
 }
 
 static inline struct u132 *hcd_to_u132(struct usb_hcd *hcd)
 {
-        return (struct u132 *)(hcd->hcd_priv);
+	return (struct u132 *)(hcd->hcd_priv);
 }
 
 static inline struct usb_hcd *u132_to_hcd(struct u132 *u132)
 {
-        return container_of((void *)u132, struct usb_hcd, hcd_priv);
+	return container_of((void *)u132, struct usb_hcd, hcd_priv);
 }
 
 static inline void u132_disable(struct u132 *u132)
 {
-        u132_to_hcd(u132)->state = HC_STATE_HALT;
+	u132_to_hcd(u132)->state = HC_STATE_HALT;
 }
 
 
@@ -251,147 +250,147 @@
 #include "../misc/usb_u132.h"
 static const char hcd_name[] = "u132_hcd";
 #define PORT_C_MASK ((USB_PORT_STAT_C_CONNECTION | USB_PORT_STAT_C_ENABLE | \
-        USB_PORT_STAT_C_SUSPEND | USB_PORT_STAT_C_OVERCURRENT | \
-        USB_PORT_STAT_C_RESET) << 16)
+	USB_PORT_STAT_C_SUSPEND | USB_PORT_STAT_C_OVERCURRENT | \
+	USB_PORT_STAT_C_RESET) << 16)
 static void u132_hcd_delete(struct kref *kref)
 {
-        struct u132 *u132 = kref_to_u132(kref);
-        struct platform_device *pdev = u132->platform_dev;
-        struct usb_hcd *hcd = u132_to_hcd(u132);
-        u132->going += 1;
-        mutex_lock(&u132_module_lock);
-        list_del_init(&u132->u132_list);
-        u132_instances -= 1;
-        mutex_unlock(&u132_module_lock);
-        dev_warn(&u132->platform_dev->dev, "FREEING the hcd=%p and thus the u13"
-                "2=%p going=%d pdev=%p\n", hcd, u132, u132->going, pdev);
-        usb_put_hcd(hcd);
+	struct u132 *u132 = kref_to_u132(kref);
+	struct platform_device *pdev = u132->platform_dev;
+	struct usb_hcd *hcd = u132_to_hcd(u132);
+	u132->going += 1;
+	mutex_lock(&u132_module_lock);
+	list_del_init(&u132->u132_list);
+	u132_instances -= 1;
+	mutex_unlock(&u132_module_lock);
+	dev_warn(&u132->platform_dev->dev, "FREEING the hcd=%p and thus the u13"
+		"2=%p going=%d pdev=%p\n", hcd, u132, u132->going, pdev);
+	usb_put_hcd(hcd);
 }
 
 static inline void u132_u132_put_kref(struct u132 *u132)
 {
-        kref_put(&u132->kref, u132_hcd_delete);
+	kref_put(&u132->kref, u132_hcd_delete);
 }
 
 static inline void u132_u132_init_kref(struct u132 *u132)
 {
-        kref_init(&u132->kref);
+	kref_init(&u132->kref);
 }
 
 static void u132_udev_delete(struct kref *kref)
 {
-        struct u132_udev *udev = kref_to_u132_udev(kref);
-        udev->udev_number = 0;
-        udev->usb_device = NULL;
-        udev->usb_addr = 0;
-        udev->enumeration = 0;
+	struct u132_udev *udev = kref_to_u132_udev(kref);
+	udev->udev_number = 0;
+	udev->usb_device = NULL;
+	udev->usb_addr = 0;
+	udev->enumeration = 0;
 }
 
 static inline void u132_udev_put_kref(struct u132 *u132, struct u132_udev *udev)
 {
-        kref_put(&udev->kref, u132_udev_delete);
+	kref_put(&udev->kref, u132_udev_delete);
 }
 
 static inline void u132_udev_get_kref(struct u132 *u132, struct u132_udev *udev)
 {
-        kref_get(&udev->kref);
+	kref_get(&udev->kref);
 }
 
 static inline void u132_udev_init_kref(struct u132 *u132,
-        struct u132_udev *udev)
+	struct u132_udev *udev)
 {
-        kref_init(&udev->kref);
+	kref_init(&udev->kref);
 }
 
 static inline void u132_ring_put_kref(struct u132 *u132, struct u132_ring *ring)
 {
-        kref_put(&u132->kref, u132_hcd_delete);
+	kref_put(&u132->kref, u132_hcd_delete);
 }
 
 static void u132_ring_requeue_work(struct u132 *u132, struct u132_ring *ring,
-        unsigned int delta)
+	unsigned int delta)
 {
-        if (delta > 0) {
-                if (queue_delayed_work(workqueue, &ring->scheduler, delta))
-                        return;
-        } else if (queue_delayed_work(workqueue, &ring->scheduler, 0))
-                return;
-        kref_put(&u132->kref, u132_hcd_delete);
-        return;
+	if (delta > 0) {
+		if (queue_delayed_work(workqueue, &ring->scheduler, delta))
+			return;
+	} else if (queue_delayed_work(workqueue, &ring->scheduler, 0))
+		return;
+	kref_put(&u132->kref, u132_hcd_delete);
+	return;
 }
 
 static void u132_ring_queue_work(struct u132 *u132, struct u132_ring *ring,
-        unsigned int delta)
+	unsigned int delta)
 {
-        kref_get(&u132->kref);
-        u132_ring_requeue_work(u132, ring, delta);
-        return;
+	kref_get(&u132->kref);
+	u132_ring_requeue_work(u132, ring, delta);
+	return;
 }
 
 static void u132_ring_cancel_work(struct u132 *u132, struct u132_ring *ring)
 {
-        if (cancel_delayed_work(&ring->scheduler)) {
-                kref_put(&u132->kref, u132_hcd_delete);
-        }
+	if (cancel_delayed_work(&ring->scheduler))
+		kref_put(&u132->kref, u132_hcd_delete);
 }
 
 static void u132_endp_delete(struct kref *kref)
 {
-        struct u132_endp *endp = kref_to_u132_endp(kref);
-        struct u132 *u132 = endp->u132;
-        u8 usb_addr = endp->usb_addr;
-        u8 usb_endp = endp->usb_endp;
-        u8 address = u132->addr[usb_addr].address;
-        struct u132_udev *udev = &u132->udev[address];
-        u8 endp_number = endp->endp_number;
-        struct usb_host_endpoint *hep = endp->hep;
-        struct u132_ring *ring = endp->ring;
-        struct list_head *head = &endp->endp_ring;
-        ring->length -= 1;
-        if (endp == ring->curr_endp) {
-                if (list_empty(head)) {
-                        ring->curr_endp = NULL;
-                        list_del(head);
-                } else {
-                        struct u132_endp *next_endp = list_entry(head->next,
-                                struct u132_endp, endp_ring);
-                        ring->curr_endp = next_endp;
-                        list_del(head);
-        }} else
-                list_del(head);
-        if (endp->input) {
-                udev->endp_number_in[usb_endp] = 0;
-                u132_udev_put_kref(u132, udev);
-        }
-        if (endp->output) {
-                udev->endp_number_out[usb_endp] = 0;
-                u132_udev_put_kref(u132, udev);
-        }
-        u132->endp[endp_number - 1] = NULL;
-        hep->hcpriv = NULL;
-        kfree(endp);
-        u132_u132_put_kref(u132);
+	struct u132_endp *endp = kref_to_u132_endp(kref);
+	struct u132 *u132 = endp->u132;
+	u8 usb_addr = endp->usb_addr;
+	u8 usb_endp = endp->usb_endp;
+	u8 address = u132->addr[usb_addr].address;
+	struct u132_udev *udev = &u132->udev[address];
+	u8 endp_number = endp->endp_number;
+	struct usb_host_endpoint *hep = endp->hep;
+	struct u132_ring *ring = endp->ring;
+	struct list_head *head = &endp->endp_ring;
+	ring->length -= 1;
+	if (endp == ring->curr_endp) {
+		if (list_empty(head)) {
+			ring->curr_endp = NULL;
+			list_del(head);
+		} else {
+			struct u132_endp *next_endp = list_entry(head->next,
+				struct u132_endp, endp_ring);
+			ring->curr_endp = next_endp;
+			list_del(head);
+		}
+	} else
+		list_del(head);
+	if (endp->input) {
+		udev->endp_number_in[usb_endp] = 0;
+		u132_udev_put_kref(u132, udev);
+	}
+	if (endp->output) {
+		udev->endp_number_out[usb_endp] = 0;
+		u132_udev_put_kref(u132, udev);
+	}
+	u132->endp[endp_number - 1] = NULL;
+	hep->hcpriv = NULL;
+	kfree(endp);
+	u132_u132_put_kref(u132);
 }
 
 static inline void u132_endp_put_kref(struct u132 *u132, struct u132_endp *endp)
 {
-        kref_put(&endp->kref, u132_endp_delete);
+	kref_put(&endp->kref, u132_endp_delete);
 }
 
 static inline void u132_endp_get_kref(struct u132 *u132, struct u132_endp *endp)
 {
-        kref_get(&endp->kref);
+	kref_get(&endp->kref);
 }
 
 static inline void u132_endp_init_kref(struct u132 *u132,
-        struct u132_endp *endp)
+	struct u132_endp *endp)
 {
-        kref_init(&endp->kref);
-        kref_get(&u132->kref);
+	kref_init(&endp->kref);
+	kref_get(&u132->kref);
 }
 
 static void u132_endp_queue_work(struct u132 *u132, struct u132_endp *endp,
-        unsigned int delta)
+	unsigned int delta)
 {
 	if (queue_delayed_work(workqueue, &endp->scheduler, delta))
 		kref_get(&endp->kref);
@@ -399,13 +398,13 @@
 
 static void u132_endp_cancel_work(struct u132 *u132, struct u132_endp *endp)
 {
-        if (cancel_delayed_work(&endp->scheduler))
-                kref_put(&endp->kref, u132_endp_delete);
+	if (cancel_delayed_work(&endp->scheduler))
+		kref_put(&endp->kref, u132_endp_delete);
 }
 
 static inline void u132_monitor_put_kref(struct u132 *u132)
 {
-        kref_put(&u132->kref, u132_hcd_delete);
+	kref_put(&u132->kref, u132_hcd_delete);
 }
 
 static void u132_monitor_queue_work(struct u132 *u132, unsigned int delta)
@@ -422,202 +421,201 @@
 
 static void u132_monitor_cancel_work(struct u132 *u132)
 {
-        if (cancel_delayed_work(&u132->monitor))
-                kref_put(&u132->kref, u132_hcd_delete);
+	if (cancel_delayed_work(&u132->monitor))
+		kref_put(&u132->kref, u132_hcd_delete);
 }
 
 static int read_roothub_info(struct u132 *u132)
 {
-        u32 revision;
-        int retval;
-        retval = u132_read_pcimem(u132, revision, &revision);
-        if (retval) {
-                dev_err(&u132->platform_dev->dev, "error %d accessing device co"
-                        "ntrol\n", retval);
-                return retval;
-        } else if ((revision & 0xFF) == 0x10) {
-        } else if ((revision & 0xFF) == 0x11) {
-        } else {
-                dev_err(&u132->platform_dev->dev, "device revision is not valid"
-                        " %08X\n", revision);
-                return -ENODEV;
-        }
-        retval = u132_read_pcimem(u132, control, &u132->hc_control);
-        if (retval) {
-                dev_err(&u132->platform_dev->dev, "error %d accessing device co"
-                        "ntrol\n", retval);
-                return retval;
-        }
-        retval = u132_read_pcimem(u132, roothub.status,
-                &u132->hc_roothub_status);
-        if (retval) {
-                dev_err(&u132->platform_dev->dev, "error %d accessing device re"
-                        "g roothub.status\n", retval);
-                return retval;
-        }
-        retval = u132_read_pcimem(u132, roothub.a, &u132->hc_roothub_a);
-        if (retval) {
-                dev_err(&u132->platform_dev->dev, "error %d accessing device re"
-                        "g roothub.a\n", retval);
-                return retval;
-        }
-        {
-                int I = u132->num_ports;
-                int i = 0;
-                while (I-- > 0) {
-                        retval = u132_read_pcimem(u132, roothub.portstatus[i],
-                                &u132->hc_roothub_portstatus[i]);
-                        if (retval) {
-                                dev_err(&u132->platform_dev->dev, "error %d acc"
-                                        "essing device roothub.portstatus[%d]\n"
-                                        , retval, i);
-                                return retval;
-                        } else
-                                i += 1;
-                }
-        }
-        return 0;
+	u32 revision;
+	int retval;
+	retval = u132_read_pcimem(u132, revision, &revision);
+	if (retval) {
+		dev_err(&u132->platform_dev->dev, "error %d accessing device co"
+			"ntrol\n", retval);
+		return retval;
+	} else if ((revision & 0xFF) == 0x10) {
+	} else if ((revision & 0xFF) == 0x11) {
+	} else {
+		dev_err(&u132->platform_dev->dev, "device revision is not valid"
+			" %08X\n", revision);
+		return -ENODEV;
+	}
+	retval = u132_read_pcimem(u132, control, &u132->hc_control);
+	if (retval) {
+		dev_err(&u132->platform_dev->dev, "error %d accessing device co"
+			"ntrol\n", retval);
+		return retval;
+	}
+	retval = u132_read_pcimem(u132, roothub.status,
+		&u132->hc_roothub_status);
+	if (retval) {
+		dev_err(&u132->platform_dev->dev, "error %d accessing device re"
+			"g roothub.status\n", retval);
+		return retval;
+	}
+	retval = u132_read_pcimem(u132, roothub.a, &u132->hc_roothub_a);
+	if (retval) {
+		dev_err(&u132->platform_dev->dev, "error %d accessing device re"
+			"g roothub.a\n", retval);
+		return retval;
+	}
+	{
+		int I = u132->num_ports;
+		int i = 0;
+		while (I-- > 0) {
+			retval = u132_read_pcimem(u132, roothub.portstatus[i],
+				&u132->hc_roothub_portstatus[i]);
+			if (retval) {
+				dev_err(&u132->platform_dev->dev, "error %d acc"
+					"essing device roothub.portstatus[%d]\n"
+					, retval, i);
+				return retval;
+			} else
+				i += 1;
+		}
+	}
+	return 0;
 }
 
 static void u132_hcd_monitor_work(struct work_struct *work)
 {
-        struct u132 *u132 = container_of(work, struct u132, monitor.work);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                u132_monitor_put_kref(u132);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                u132_monitor_put_kref(u132);
-                return;
-        } else {
-                int retval;
-                down(&u132->sw_lock);
-                retval = read_roothub_info(u132);
-                if (retval) {
-                        struct usb_hcd *hcd = u132_to_hcd(u132);
-                        u132_disable(u132);
-                        u132->going = 1;
-                        up(&u132->sw_lock);
-                        usb_hc_died(hcd);
-                        ftdi_elan_gone_away(u132->platform_dev);
-                        u132_monitor_put_kref(u132);
-                        return;
-                } else {
-                        u132_monitor_requeue_work(u132, 500);
-                        up(&u132->sw_lock);
-                        return;
-                }
-        }
+	struct u132 *u132 = container_of(work, struct u132, monitor.work);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		u132_monitor_put_kref(u132);
+		return;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed\n");
+		u132_monitor_put_kref(u132);
+		return;
+	} else {
+		int retval;
+		mutex_lock(&u132->sw_lock);
+		retval = read_roothub_info(u132);
+		if (retval) {
+			struct usb_hcd *hcd = u132_to_hcd(u132);
+			u132_disable(u132);
+			u132->going = 1;
+			mutex_unlock(&u132->sw_lock);
+			usb_hc_died(hcd);
+			ftdi_elan_gone_away(u132->platform_dev);
+			u132_monitor_put_kref(u132);
+			return;
+		} else {
+			u132_monitor_requeue_work(u132, 500);
+			mutex_unlock(&u132->sw_lock);
+			return;
+		}
+	}
 }
 
 static void u132_hcd_giveback_urb(struct u132 *u132, struct u132_endp *endp,
-        struct urb *urb, int status)
+	struct urb *urb, int status)
 {
-        struct u132_ring *ring;
-        unsigned long irqs;
-        struct usb_hcd *hcd = u132_to_hcd(u132);
-        urb->error_count = 0;
-        urb->status = status;
-        urb->hcpriv = NULL;
-        spin_lock_irqsave(&endp->queue_lock.slock, irqs);
-        endp->queue_next += 1;
-        if (ENDP_QUEUE_SIZE > --endp->queue_size) {
-                endp->active = 0;
-                spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-        } else {
-                struct list_head *next = endp->urb_more.next;
-                struct u132_urbq *urbq = list_entry(next, struct u132_urbq,
-                        urb_more);
-                list_del(next);
-                endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] =
-                        urbq->urb;
-                endp->active = 0;
-                spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                kfree(urbq);
-        } down(&u132->scheduler_lock);
-        ring = endp->ring;
-        ring->in_use = 0;
-        u132_ring_cancel_work(u132, ring);
-        u132_ring_queue_work(u132, ring, 0);
-        up(&u132->scheduler_lock);
-        u132_endp_put_kref(u132, endp);
-        usb_hcd_giveback_urb(hcd, urb);
-        return;
+	struct u132_ring *ring;
+	unsigned long irqs;
+	struct usb_hcd *hcd = u132_to_hcd(u132);
+	urb->error_count = 0;
+	spin_lock_irqsave(&endp->queue_lock.slock, irqs);
+	usb_hcd_unlink_urb_from_ep(hcd, urb);
+	endp->queue_next += 1;
+	if (ENDP_QUEUE_SIZE > --endp->queue_size) {
+		endp->active = 0;
+		spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+	} else {
+		struct list_head *next = endp->urb_more.next;
+		struct u132_urbq *urbq = list_entry(next, struct u132_urbq,
+			urb_more);
+		list_del(next);
+		endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] =
+			urbq->urb;
+		endp->active = 0;
+		spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+		kfree(urbq);
+	}
+	mutex_lock(&u132->scheduler_lock);
+	ring = endp->ring;
+	ring->in_use = 0;
+	u132_ring_cancel_work(u132, ring);
+	u132_ring_queue_work(u132, ring, 0);
+	mutex_unlock(&u132->scheduler_lock);
+	u132_endp_put_kref(u132, endp);
+	usb_hcd_giveback_urb(hcd, urb, status);
+	return;
 }
 
 static void u132_hcd_forget_urb(struct u132 *u132, struct u132_endp *endp,
-        struct urb *urb, int status)
+	struct urb *urb, int status)
 {
-        u132_endp_put_kref(u132, endp);
+	u132_endp_put_kref(u132, endp);
 }
 
 static void u132_hcd_abandon_urb(struct u132 *u132, struct u132_endp *endp,
-        struct urb *urb, int status)
+	struct urb *urb, int status)
 {
-        unsigned long irqs;
-        struct usb_hcd *hcd = u132_to_hcd(u132);
-        urb->error_count = 0;
-        urb->status = status;
-        urb->hcpriv = NULL;
-        spin_lock_irqsave(&endp->queue_lock.slock, irqs);
-        endp->queue_next += 1;
-        if (ENDP_QUEUE_SIZE > --endp->queue_size) {
-                endp->active = 0;
-                spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-        } else {
-                struct list_head *next = endp->urb_more.next;
-                struct u132_urbq *urbq = list_entry(next, struct u132_urbq,
-                        urb_more);
-                list_del(next);
-                endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] =
-                        urbq->urb;
-                endp->active = 0;
-                spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                kfree(urbq);
-        } usb_hcd_giveback_urb(hcd, urb);
-        return;
+	unsigned long irqs;
+	struct usb_hcd *hcd = u132_to_hcd(u132);
+	urb->error_count = 0;
+	spin_lock_irqsave(&endp->queue_lock.slock, irqs);
+	usb_hcd_unlink_urb_from_ep(hcd, urb);
+	endp->queue_next += 1;
+	if (ENDP_QUEUE_SIZE > --endp->queue_size) {
+		endp->active = 0;
+		spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+	} else {
+		struct list_head *next = endp->urb_more.next;
+		struct u132_urbq *urbq = list_entry(next, struct u132_urbq,
+			urb_more);
+		list_del(next);
+		endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] =
+			urbq->urb;
+		endp->active = 0;
+		spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+		kfree(urbq);
+	} usb_hcd_giveback_urb(hcd, urb, status);
+	return;
 }
 
 static inline int edset_input(struct u132 *u132, struct u132_ring *ring,
-        struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
-        void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
-        int toggle_bits, int error_count, int condition_code, int repeat_number,
-         int halted, int skipped, int actual, int non_null))
+	struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
+	void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
+	int toggle_bits, int error_count, int condition_code, int repeat_number,
+	 int halted, int skipped, int actual, int non_null))
 {
-        return usb_ftdi_elan_edset_input(u132->platform_dev, ring->number, endp,
-                 urb, address, endp->usb_endp, toggle_bits, callback);
+	return usb_ftdi_elan_edset_input(u132->platform_dev, ring->number, endp,
+		 urb, address, endp->usb_endp, toggle_bits, callback);
 }
 
 static inline int edset_setup(struct u132 *u132, struct u132_ring *ring,
-        struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
-        void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
-        int toggle_bits, int error_count, int condition_code, int repeat_number,
-         int halted, int skipped, int actual, int non_null))
+	struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
+	void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
+	int toggle_bits, int error_count, int condition_code, int repeat_number,
+	 int halted, int skipped, int actual, int non_null))
 {
-        return usb_ftdi_elan_edset_setup(u132->platform_dev, ring->number, endp,
-                 urb, address, endp->usb_endp, toggle_bits, callback);
+	return usb_ftdi_elan_edset_setup(u132->platform_dev, ring->number, endp,
+		 urb, address, endp->usb_endp, toggle_bits, callback);
 }
 
 static inline int edset_single(struct u132 *u132, struct u132_ring *ring,
-        struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
-        void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
-        int toggle_bits, int error_count, int condition_code, int repeat_number,
-         int halted, int skipped, int actual, int non_null))
+	struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
+	void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
+	int toggle_bits, int error_count, int condition_code, int repeat_number,
+	 int halted, int skipped, int actual, int non_null))
 {
-        return usb_ftdi_elan_edset_single(u132->platform_dev, ring->number,
-                endp, urb, address, endp->usb_endp, toggle_bits, callback);
+	return usb_ftdi_elan_edset_single(u132->platform_dev, ring->number,
+		endp, urb, address, endp->usb_endp, toggle_bits, callback);
 }
 
 static inline int edset_output(struct u132 *u132, struct u132_ring *ring,
-        struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
-        void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
-        int toggle_bits, int error_count, int condition_code, int repeat_number,
-         int halted, int skipped, int actual, int non_null))
+	struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
+	void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
+	int toggle_bits, int error_count, int condition_code, int repeat_number,
+	 int halted, int skipped, int actual, int non_null))
 {
-        return usb_ftdi_elan_edset_output(u132->platform_dev, ring->number,
-                endp, urb, address, endp->usb_endp, toggle_bits, callback);
+	return usb_ftdi_elan_edset_output(u132->platform_dev, ring->number,
+		endp, urb, address, endp->usb_endp, toggle_bits, callback);
 }
 
 
@@ -626,683 +624,678 @@
 *
 */
 static void u132_hcd_interrupt_recv(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
+	int len, int toggle_bits, int error_count, int condition_code,
+	int repeat_number, int halted, int skipped, int actual, int non_null)
 {
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        struct u132_udev *udev = &u132->udev[address];
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                struct u132_ring *ring = endp->ring;
-                u8 *u = urb->transfer_buffer + urb->actual_length;
-                u8 *b = buf;
-                int L = len;
-                while (L-- > 0) {
-                        *u++ = *b++;
-                }
-                urb->actual_length += len;
-                if ((condition_code == TD_CC_NOERROR) &&
-                        (urb->transfer_buffer_length > urb->actual_length)) {
-                        endp->toggle_bits = toggle_bits;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0,
-                                1 & toggle_bits);
-                        if (urb->actual_length > 0) {
-                                int retval;
-                                up(&u132->scheduler_lock);
-                                retval = edset_single(u132, ring, endp, urb,
-                                        address, endp->toggle_bits,
-                                        u132_hcd_interrupt_recv);
-                                if (retval == 0) {
-                                } else
-                                        u132_hcd_giveback_urb(u132, endp, urb,
-                                                retval);
-                        } else {
-                                ring->in_use = 0;
-                                endp->active = 0;
-                                endp->jiffies = jiffies +
-                                        msecs_to_jiffies(urb->interval);
-                                u132_ring_cancel_work(u132, ring);
-                                u132_ring_queue_work(u132, ring, 0);
-                                up(&u132->scheduler_lock);
-                                u132_endp_put_kref(u132, endp);
-                        }
-                        return;
-                } else if ((condition_code == TD_DATAUNDERRUN) &&
-                        ((urb->transfer_flags & URB_SHORT_NOT_OK) == 0)) {
-                        endp->toggle_bits = toggle_bits;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0,
-                                1 & toggle_bits);
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb, 0);
-                        return;
-                } else {
-                        if (condition_code == TD_CC_NOERROR) {
-                                endp->toggle_bits = toggle_bits;
-                                usb_settoggle(udev->usb_device, endp->usb_endp,
-                                        0, 1 & toggle_bits);
-                        } else if (condition_code == TD_CC_STALL) {
-                                endp->toggle_bits = 0x2;
-                                usb_settoggle(udev->usb_device, endp->usb_endp,
-                                        0, 0);
-                        } else {
-                                endp->toggle_bits = 0x2;
-                                usb_settoggle(udev->usb_device, endp->usb_endp,
-                                        0, 0);
-                                dev_err(&u132->platform_dev->dev, "urb=%p givin"
-                                        "g back INTERRUPT %s\n", urb,
-                                        cc_to_text[condition_code]);
-                        }
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb,
-                                cc_to_error[condition_code]);
-                        return;
-                }
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
+	struct u132_endp *endp = data;
+	struct u132 *u132 = endp->u132;
+	u8 address = u132->addr[endp->usb_addr].address;
+	struct u132_udev *udev = &u132->udev[address];
+	mutex_lock(&u132->scheduler_lock);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (endp->dequeueing) {
+		endp->dequeueing = 0;
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
+		return;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed "
+				"urb=%p\n", urb);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (!urb->unlinked) {
+		struct u132_ring *ring = endp->ring;
+		u8 *u = urb->transfer_buffer + urb->actual_length;
+		u8 *b = buf;
+		int L = len;
+
+		while (L-- > 0)
+			*u++ = *b++;
+
+		urb->actual_length += len;
+		if ((condition_code == TD_CC_NOERROR) &&
+			(urb->transfer_buffer_length > urb->actual_length)) {
+			endp->toggle_bits = toggle_bits;
+			usb_settoggle(udev->usb_device, endp->usb_endp, 0,
+				1 & toggle_bits);
+			if (urb->actual_length > 0) {
+				int retval;
+				mutex_unlock(&u132->scheduler_lock);
+				retval = edset_single(u132, ring, endp, urb,
+					address, endp->toggle_bits,
+					u132_hcd_interrupt_recv);
+				if (retval != 0)
+					u132_hcd_giveback_urb(u132, endp, urb,
+						retval);
+			} else {
+				ring->in_use = 0;
+				endp->active = 0;
+				endp->jiffies = jiffies +
+					msecs_to_jiffies(urb->interval);
+				u132_ring_cancel_work(u132, ring);
+				u132_ring_queue_work(u132, ring, 0);
+				mutex_unlock(&u132->scheduler_lock);
+				u132_endp_put_kref(u132, endp);
+			}
+			return;
+		} else if ((condition_code == TD_DATAUNDERRUN) &&
+			((urb->transfer_flags & URB_SHORT_NOT_OK) == 0)) {
+			endp->toggle_bits = toggle_bits;
+			usb_settoggle(udev->usb_device, endp->usb_endp, 0,
+				1 & toggle_bits);
+			mutex_unlock(&u132->scheduler_lock);
+			u132_hcd_giveback_urb(u132, endp, urb, 0);
+			return;
+		} else {
+			if (condition_code == TD_CC_NOERROR) {
+				endp->toggle_bits = toggle_bits;
+				usb_settoggle(udev->usb_device, endp->usb_endp,
+					0, 1 & toggle_bits);
+			} else if (condition_code == TD_CC_STALL) {
+				endp->toggle_bits = 0x2;
+				usb_settoggle(udev->usb_device, endp->usb_endp,
+					0, 0);
+			} else {
+				endp->toggle_bits = 0x2;
+				usb_settoggle(udev->usb_device, endp->usb_endp,
+					0, 0);
+				dev_err(&u132->platform_dev->dev, "urb=%p givin"
+					"g back INTERRUPT %s\n", urb,
+					cc_to_text[condition_code]);
+			}
+			mutex_unlock(&u132->scheduler_lock);
+			u132_hcd_giveback_urb(u132, endp, urb,
+				cc_to_error[condition_code]);
+			return;
+		}
+	} else {
+		dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb->unlinked);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	}
 }
 
 static void u132_hcd_bulk_output_sent(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
+	int len, int toggle_bits, int error_count, int condition_code,
+	int repeat_number, int halted, int skipped, int actual, int non_null)
 {
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                struct u132_ring *ring = endp->ring;
-                urb->actual_length += len;
-                endp->toggle_bits = toggle_bits;
-                if (urb->transfer_buffer_length > urb->actual_length) {
-                        int retval;
-                        up(&u132->scheduler_lock);
-                        retval = edset_output(u132, ring, endp, urb, address,
-                                endp->toggle_bits, u132_hcd_bulk_output_sent);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                } else {
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb, 0);
-                        return;
-                }
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
+	struct u132_endp *endp = data;
+	struct u132 *u132 = endp->u132;
+	u8 address = u132->addr[endp->usb_addr].address;
+	mutex_lock(&u132->scheduler_lock);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (endp->dequeueing) {
+		endp->dequeueing = 0;
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
+		return;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed "
+				"urb=%p\n", urb);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (!urb->unlinked) {
+		struct u132_ring *ring = endp->ring;
+		urb->actual_length += len;
+		endp->toggle_bits = toggle_bits;
+		if (urb->transfer_buffer_length > urb->actual_length) {
+			int retval;
+			mutex_unlock(&u132->scheduler_lock);
+			retval = edset_output(u132, ring, endp, urb, address,
+				endp->toggle_bits, u132_hcd_bulk_output_sent);
+			if (retval != 0)
+				u132_hcd_giveback_urb(u132, endp, urb, retval);
+			return;
+		} else {
+			mutex_unlock(&u132->scheduler_lock);
+			u132_hcd_giveback_urb(u132, endp, urb, 0);
+			return;
+		}
+	} else {
+		dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb->unlinked);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	}
 }
 
 static void u132_hcd_bulk_input_recv(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
+	int len, int toggle_bits, int error_count, int condition_code,
+	int repeat_number, int halted, int skipped, int actual, int non_null)
 {
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        struct u132_udev *udev = &u132->udev[address];
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                struct u132_ring *ring = endp->ring;
-                u8 *u = urb->transfer_buffer + urb->actual_length;
-                u8 *b = buf;
-                int L = len;
-                while (L-- > 0) {
-                        *u++ = *b++;
-                }
-                urb->actual_length += len;
-                if ((condition_code == TD_CC_NOERROR) &&
-                        (urb->transfer_buffer_length > urb->actual_length)) {
-                        int retval;
-                        endp->toggle_bits = toggle_bits;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0,
-                                1 & toggle_bits);
-                        up(&u132->scheduler_lock);
-                        retval = usb_ftdi_elan_edset_input(u132->platform_dev,
-                                ring->number, endp, urb, address,
-                                endp->usb_endp, endp->toggle_bits,
-                                u132_hcd_bulk_input_recv);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                } else if (condition_code == TD_CC_NOERROR) {
-                        endp->toggle_bits = toggle_bits;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0,
-                                1 & toggle_bits);
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb,
-                                cc_to_error[condition_code]);
-                        return;
-                } else if ((condition_code == TD_DATAUNDERRUN) &&
-                        ((urb->transfer_flags & URB_SHORT_NOT_OK) == 0)) {
-                        endp->toggle_bits = toggle_bits;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0,
-                                1 & toggle_bits);
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb, 0);
-                        return;
-                } else if (condition_code == TD_DATAUNDERRUN) {
-                        endp->toggle_bits = toggle_bits;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0,
-                                1 & toggle_bits);
-                        dev_warn(&u132->platform_dev->dev, "urb=%p(SHORT NOT OK"
-                                ") giving back BULK IN %s\n", urb,
-                                cc_to_text[condition_code]);
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb, 0);
-                        return;
-                } else if (condition_code == TD_CC_STALL) {
-                        endp->toggle_bits = 0x2;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0, 0);
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb,
-                                cc_to_error[condition_code]);
-                        return;
-                } else {
-                        endp->toggle_bits = 0x2;
-                        usb_settoggle(udev->usb_device, endp->usb_endp, 0, 0);
-                        dev_err(&u132->platform_dev->dev, "urb=%p giving back B"
-                                "ULK IN code=%d %s\n", urb, condition_code,
-                                cc_to_text[condition_code]);
-                        up(&u132->scheduler_lock);
-                        u132_hcd_giveback_urb(u132, endp, urb,
-                                cc_to_error[condition_code]);
-                        return;
-                }
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
+	struct u132_endp *endp = data;
+	struct u132 *u132 = endp->u132;
+	u8 address = u132->addr[endp->usb_addr].address;
+	struct u132_udev *udev = &u132->udev[address];
+	mutex_lock(&u132->scheduler_lock);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (endp->dequeueing) {
+		endp->dequeueing = 0;
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
+		return;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed "
+				"urb=%p\n", urb);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (!urb->unlinked) {
+		struct u132_ring *ring = endp->ring;
+		u8 *u = urb->transfer_buffer + urb->actual_length;
+		u8 *b = buf;
+		int L = len;
+
+		while (L-- > 0)
+			*u++ = *b++;
+
+		urb->actual_length += len;
+		if ((condition_code == TD_CC_NOERROR) &&
+			(urb->transfer_buffer_length > urb->actual_length)) {
+			int retval;
+			endp->toggle_bits = toggle_bits;
+			usb_settoggle(udev->usb_device, endp->usb_endp, 0,
+				1 & toggle_bits);
+			mutex_unlock(&u132->scheduler_lock);
+			retval = usb_ftdi_elan_edset_input(u132->platform_dev,
+				ring->number, endp, urb, address,
+				endp->usb_endp, endp->toggle_bits,
+				u132_hcd_bulk_input_recv);
+			if (retval != 0)
+				u132_hcd_giveback_urb(u132, endp, urb, retval);
+			return;
+		} else if (condition_code == TD_CC_NOERROR) {
+			endp->toggle_bits = toggle_bits;
+			usb_settoggle(udev->usb_device, endp->usb_endp, 0,
+				1 & toggle_bits);
+			mutex_unlock(&u132->scheduler_lock);
+			u132_hcd_giveback_urb(u132, endp, urb,
+				cc_to_error[condition_code]);
+			return;
+		} else if ((condition_code == TD_DATAUNDERRUN) &&
+			((urb->transfer_flags & URB_SHORT_NOT_OK) == 0)) {
+			endp->toggle_bits = toggle_bits;
+			usb_settoggle(udev->usb_device, endp->usb_endp, 0,
+				1 & toggle_bits);
+			mutex_unlock(&u132->scheduler_lock);
+			u132_hcd_giveback_urb(u132, endp, urb, 0);
+			return;
+		} else if (condition_code == TD_DATAUNDERRUN) {
+			endp->toggle_bits = toggle_bits;
+			usb_settoggle(udev->usb_device, endp->usb_endp, 0,
+				1 & toggle_bits);
+			dev_warn(&u132->platform_dev->dev, "urb=%p(SHORT NOT OK"
+				") giving back BULK IN %s\n", urb,
+				cc_to_text[condition_code]);
+			mutex_unlock(&u132->scheduler_lock);
+			u132_hcd_giveback_urb(u132, endp, urb, 0);
+			return;
+		} else if (condition_code == TD_CC_STALL) {
+			endp->toggle_bits = 0x2;
+			usb_settoggle(udev->usb_device, endp->usb_endp, 0, 0);
+			mutex_unlock(&u132->scheduler_lock);
+			u132_hcd_giveback_urb(u132, endp, urb,
+				cc_to_error[condition_code]);
+			return;
+		} else {
+			endp->toggle_bits = 0x2;
+			usb_settoggle(udev->usb_device, endp->usb_endp, 0, 0);
+			dev_err(&u132->platform_dev->dev, "urb=%p giving back B"
+				"ULK IN code=%d %s\n", urb, condition_code,
+				cc_to_text[condition_code]);
+			mutex_unlock(&u132->scheduler_lock);
+			u132_hcd_giveback_urb(u132, endp, urb,
+				cc_to_error[condition_code]);
+			return;
+		}
+	} else {
+		dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb->unlinked);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	}
 }
 
 static void u132_hcd_configure_empty_sent(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
+	int len, int toggle_bits, int error_count, int condition_code,
+	int repeat_number, int halted, int skipped, int actual, int non_null)
 {
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, 0);
-                return;
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
+	struct u132_endp *endp = data;
+	struct u132 *u132 = endp->u132;
+	mutex_lock(&u132->scheduler_lock);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (endp->dequeueing) {
+		endp->dequeueing = 0;
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
+		return;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed "
+				"urb=%p\n", urb);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (!urb->unlinked) {
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	} else {
+		dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb->unlinked);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	}
 }
 
 static void u132_hcd_configure_input_recv(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
+	int len, int toggle_bits, int error_count, int condition_code,
+	int repeat_number, int halted, int skipped, int actual, int non_null)
 {
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                struct u132_ring *ring = endp->ring;
-                u8 *u = urb->transfer_buffer;
-                u8 *b = buf;
-                int L = len;
-                while (L-- > 0) {
-                        *u++ = *b++;
-                }
-                urb->actual_length = len;
-                if ((condition_code == TD_CC_NOERROR) || ((condition_code ==
-                        TD_DATAUNDERRUN) && ((urb->transfer_flags &
-                        URB_SHORT_NOT_OK) == 0))) {
-                        int retval;
-                        up(&u132->scheduler_lock);
-                        retval = usb_ftdi_elan_edset_empty(u132->platform_dev,
-                                ring->number, endp, urb, address,
-                                endp->usb_endp, 0x3,
-                                u132_hcd_configure_empty_sent);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                } else if (condition_code == TD_CC_STALL) {
-                        up(&u132->scheduler_lock);
-                        dev_warn(&u132->platform_dev->dev, "giving back SETUP I"
-                                "NPUT STALL urb %p\n", urb);
-                        u132_hcd_giveback_urb(u132, endp, urb,
-                                cc_to_error[condition_code]);
-                        return;
-                } else {
-                        up(&u132->scheduler_lock);
-                        dev_err(&u132->platform_dev->dev, "giving back SETUP IN"
-                                "PUT %s urb %p\n", cc_to_text[condition_code],
-                                urb);
-                        u132_hcd_giveback_urb(u132, endp, urb,
-                                cc_to_error[condition_code]);
-                        return;
-                }
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
+	struct u132_endp *endp = data;
+	struct u132 *u132 = endp->u132;
+	u8 address = u132->addr[endp->usb_addr].address;
+	mutex_lock(&u132->scheduler_lock);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (endp->dequeueing) {
+		endp->dequeueing = 0;
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
+		return;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed "
+				"urb=%p\n", urb);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (!urb->unlinked) {
+		struct u132_ring *ring = endp->ring;
+		u8 *u = urb->transfer_buffer;
+		u8 *b = buf;
+		int L = len;
+
+		while (L-- > 0)
+			*u++ = *b++;
+
+		urb->actual_length = len;
+		if ((condition_code == TD_CC_NOERROR) || ((condition_code ==
+			TD_DATAUNDERRUN) && ((urb->transfer_flags &
+			URB_SHORT_NOT_OK) == 0))) {
+			int retval;
+			mutex_unlock(&u132->scheduler_lock);
+			retval = usb_ftdi_elan_edset_empty(u132->platform_dev,
+				ring->number, endp, urb, address,
+				endp->usb_endp, 0x3,
+				u132_hcd_configure_empty_sent);
+			if (retval != 0)
+				u132_hcd_giveback_urb(u132, endp, urb, retval);
+			return;
+		} else if (condition_code == TD_CC_STALL) {
+			mutex_unlock(&u132->scheduler_lock);
+			dev_warn(&u132->platform_dev->dev, "giving back SETUP I"
+				"NPUT STALL urb %p\n", urb);
+			u132_hcd_giveback_urb(u132, endp, urb,
+				cc_to_error[condition_code]);
+			return;
+		} else {
+			mutex_unlock(&u132->scheduler_lock);
+			dev_err(&u132->platform_dev->dev, "giving back SETUP IN"
+				"PUT %s urb %p\n", cc_to_text[condition_code],
+				urb);
+			u132_hcd_giveback_urb(u132, endp, urb,
+				cc_to_error[condition_code]);
+			return;
+		}
+	} else {
+		dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb->unlinked);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	}
 }
 
 static void u132_hcd_configure_empty_recv(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
+	int len, int toggle_bits, int error_count, int condition_code,
+	int repeat_number, int halted, int skipped, int actual, int non_null)
 {
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, 0);
-                return;
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
+	struct u132_endp *endp = data;
+	struct u132 *u132 = endp->u132;
+	mutex_lock(&u132->scheduler_lock);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (endp->dequeueing) {
+		endp->dequeueing = 0;
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
+		return;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed "
+				"urb=%p\n", urb);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (!urb->unlinked) {
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	} else {
+		dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb->unlinked);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	}
 }
 
 static void u132_hcd_configure_setup_sent(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
+	int len, int toggle_bits, int error_count, int condition_code,
+	int repeat_number, int halted, int skipped, int actual, int non_null)
 {
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                if (usb_pipein(urb->pipe)) {
-                        int retval;
-                        struct u132_ring *ring = endp->ring;
-                        up(&u132->scheduler_lock);
-                        retval = usb_ftdi_elan_edset_input(u132->platform_dev,
-                                ring->number, endp, urb, address,
-                                endp->usb_endp, 0,
-                                u132_hcd_configure_input_recv);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                } else {
-                        int retval;
-                        struct u132_ring *ring = endp->ring;
-                        up(&u132->scheduler_lock);
-                        retval = usb_ftdi_elan_edset_input(u132->platform_dev,
-                                ring->number, endp, urb, address,
-                                endp->usb_endp, 0,
-                                u132_hcd_configure_empty_recv);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                }
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
+	struct u132_endp *endp = data;
+	struct u132 *u132 = endp->u132;
+	u8 address = u132->addr[endp->usb_addr].address;
+	mutex_lock(&u132->scheduler_lock);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (endp->dequeueing) {
+		endp->dequeueing = 0;
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
+		return;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed "
+				"urb=%p\n", urb);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (!urb->unlinked) {
+		if (usb_pipein(urb->pipe)) {
+			int retval;
+			struct u132_ring *ring = endp->ring;
+			mutex_unlock(&u132->scheduler_lock);
+			retval = usb_ftdi_elan_edset_input(u132->platform_dev,
+				ring->number, endp, urb, address,
+				endp->usb_endp, 0,
+				u132_hcd_configure_input_recv);
+			if (retval != 0)
+				u132_hcd_giveback_urb(u132, endp, urb, retval);
+			return;
+		} else {
+			int retval;
+			struct u132_ring *ring = endp->ring;
+			mutex_unlock(&u132->scheduler_lock);
+			retval = usb_ftdi_elan_edset_input(u132->platform_dev,
+				ring->number, endp, urb, address,
+				endp->usb_endp, 0,
+				u132_hcd_configure_empty_recv);
+			if (retval != 0)
+				u132_hcd_giveback_urb(u132, endp, urb, retval);
+			return;
+		}
+	} else {
+		dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb->unlinked);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	}
 }
 
 static void u132_hcd_enumeration_empty_recv(void *data, struct urb *urb,
-        u8 *buf, int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
+	u8 *buf, int len, int toggle_bits, int error_count, int condition_code,
+	int repeat_number, int halted, int skipped, int actual, int non_null)
 {
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        struct u132_udev *udev = &u132->udev[address];
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                u132->addr[0].address = 0;
-                endp->usb_addr = udev->usb_addr;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, 0);
-                return;
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
+	struct u132_endp *endp = data;
+	struct u132 *u132 = endp->u132;
+	u8 address = u132->addr[endp->usb_addr].address;
+	struct u132_udev *udev = &u132->udev[address];
+	mutex_lock(&u132->scheduler_lock);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (endp->dequeueing) {
+		endp->dequeueing = 0;
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
+		return;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed "
+				"urb=%p\n", urb);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (!urb->unlinked) {
+		u132->addr[0].address = 0;
+		endp->usb_addr = udev->usb_addr;
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	} else {
+		dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb->unlinked);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	}
 }
 
 static void u132_hcd_enumeration_address_sent(void *data, struct urb *urb,
-        u8 *buf, int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
+	u8 *buf, int len, int toggle_bits, int error_count, int condition_code,
+	int repeat_number, int halted, int skipped, int actual, int non_null)
 {
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                int retval;
-                struct u132_ring *ring = endp->ring;
-                up(&u132->scheduler_lock);
-                retval = usb_ftdi_elan_edset_input(u132->platform_dev,
-                        ring->number, endp, urb, 0, endp->usb_endp, 0,
-                        u132_hcd_enumeration_empty_recv);
-                if (retval == 0) {
-                } else
-                        u132_hcd_giveback_urb(u132, endp, urb, retval);
-                return;
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
+	struct u132_endp *endp = data;
+	struct u132 *u132 = endp->u132;
+	mutex_lock(&u132->scheduler_lock);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (endp->dequeueing) {
+		endp->dequeueing = 0;
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
+		return;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed "
+				"urb=%p\n", urb);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (!urb->unlinked) {
+		int retval;
+		struct u132_ring *ring = endp->ring;
+		mutex_unlock(&u132->scheduler_lock);
+		retval = usb_ftdi_elan_edset_input(u132->platform_dev,
+			ring->number, endp, urb, 0, endp->usb_endp, 0,
+			u132_hcd_enumeration_empty_recv);
+		if (retval != 0)
+			u132_hcd_giveback_urb(u132, endp, urb, retval);
+		return;
+	} else {
+		dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb->unlinked);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	}
 }
 
 static void u132_hcd_initial_empty_sent(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
+	int len, int toggle_bits, int error_count, int condition_code,
+	int repeat_number, int halted, int skipped, int actual, int non_null)
 {
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, 0);
-                return;
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
+	struct u132_endp *endp = data;
+	struct u132 *u132 = endp->u132;
+	mutex_lock(&u132->scheduler_lock);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (endp->dequeueing) {
+		endp->dequeueing = 0;
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
+		return;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed "
+				"urb=%p\n", urb);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (!urb->unlinked) {
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	} else {
+		dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb->unlinked);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	}
 }
 
 static void u132_hcd_initial_input_recv(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
+	int len, int toggle_bits, int error_count, int condition_code,
+	int repeat_number, int halted, int skipped, int actual, int non_null)
 {
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                int retval;
-                struct u132_ring *ring = endp->ring;
-                u8 *u = urb->transfer_buffer;
-                u8 *b = buf;
-                int L = len;
-                while (L-- > 0) {
-                        *u++ = *b++;
-                }
-                urb->actual_length = len;
-                up(&u132->scheduler_lock);
-                retval = usb_ftdi_elan_edset_empty(u132->platform_dev,
-                        ring->number, endp, urb, address, endp->usb_endp, 0x3,
-                        u132_hcd_initial_empty_sent);
-                if (retval == 0) {
-                } else
-                        u132_hcd_giveback_urb(u132, endp, urb, retval);
-                return;
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
+	struct u132_endp *endp = data;
+	struct u132 *u132 = endp->u132;
+	u8 address = u132->addr[endp->usb_addr].address;
+	mutex_lock(&u132->scheduler_lock);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (endp->dequeueing) {
+		endp->dequeueing = 0;
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
+		return;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed "
+				"urb=%p\n", urb);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (!urb->unlinked) {
+		int retval;
+		struct u132_ring *ring = endp->ring;
+		u8 *u = urb->transfer_buffer;
+		u8 *b = buf;
+		int L = len;
+
+		while (L-- > 0)
+			*u++ = *b++;
+
+		urb->actual_length = len;
+		mutex_unlock(&u132->scheduler_lock);
+		retval = usb_ftdi_elan_edset_empty(u132->platform_dev,
+			ring->number, endp, urb, address, endp->usb_endp, 0x3,
+			u132_hcd_initial_empty_sent);
+		if (retval != 0)
+			u132_hcd_giveback_urb(u132, endp, urb, retval);
+		return;
+	} else {
+		dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb->unlinked);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	}
 }
 
 static void u132_hcd_initial_setup_sent(void *data, struct urb *urb, u8 *buf,
-        int len, int toggle_bits, int error_count, int condition_code,
-        int repeat_number, int halted, int skipped, int actual, int non_null)
+	int len, int toggle_bits, int error_count, int condition_code,
+	int repeat_number, int halted, int skipped, int actual, int non_null)
 {
-        struct u132_endp *endp = data;
-        struct u132 *u132 = endp->u132;
-        u8 address = u132->addr[endp->usb_addr].address;
-        down(&u132->scheduler_lock);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                up(&u132->scheduler_lock);
-                u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (endp->dequeueing) {
-                endp->dequeueing = 0;
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
-                return;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
-                return;
-        } else if (urb->status == -EINPROGRESS) {
-                int retval;
-                struct u132_ring *ring = endp->ring;
-                up(&u132->scheduler_lock);
-                retval = usb_ftdi_elan_edset_input(u132->platform_dev,
-                        ring->number, endp, urb, address, endp->usb_endp, 0,
-                        u132_hcd_initial_input_recv);
-                if (retval == 0) {
-                } else
-                        u132_hcd_giveback_urb(u132, endp, urb, retval);
-                return;
-        } else {
-                dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb->status);
-                up(&u132->scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb->status);
-                return;
-        }
+	struct u132_endp *endp = data;
+	struct u132 *u132 = endp->u132;
+	u8 address = u132->addr[endp->usb_addr].address;
+	mutex_lock(&u132->scheduler_lock);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_forget_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (endp->dequeueing) {
+		endp->dequeueing = 0;
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
+		return;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed "
+				"urb=%p\n", urb);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
+		return;
+	} else if (!urb->unlinked) {
+		int retval;
+		struct u132_ring *ring = endp->ring;
+		mutex_unlock(&u132->scheduler_lock);
+		retval = usb_ftdi_elan_edset_input(u132->platform_dev,
+			ring->number, endp, urb, address, endp->usb_endp, 0,
+			u132_hcd_initial_input_recv);
+		if (retval != 0)
+			u132_hcd_giveback_urb(u132, endp, urb, retval);
+		return;
+	} else {
+		dev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb->unlinked);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
+		return;
+	}
 }
 
 /*
@@ -1311,302 +1304,296 @@
 */
 static void u132_hcd_ring_work_scheduler(struct work_struct *work)
 {
-        struct u132_ring *ring =
+	struct u132_ring *ring =
 		container_of(work, struct u132_ring, scheduler.work);
-        struct u132 *u132 = ring->u132;
-        down(&u132->scheduler_lock);
-        if (ring->in_use) {
-                up(&u132->scheduler_lock);
-                u132_ring_put_kref(u132, ring);
-                return;
-        } else if (ring->curr_endp) {
-                struct u132_endp *last_endp = ring->curr_endp;
-                struct list_head *scan;
-                struct list_head *head = &last_endp->endp_ring;
-                unsigned long wakeup = 0;
-                list_for_each(scan, head) {
-                        struct u132_endp *endp = list_entry(scan,
-                                struct u132_endp, endp_ring);
-                        if (endp->queue_next == endp->queue_last) {
-                        } else if ((endp->delayed == 0)
-                                || time_after_eq(jiffies, endp->jiffies)) {
-                                ring->curr_endp = endp;
-                                u132_endp_cancel_work(u132, last_endp);
-                                u132_endp_queue_work(u132, last_endp, 0);
-                                up(&u132->scheduler_lock);
-                                u132_ring_put_kref(u132, ring);
-                                return;
-                        } else {
-                                unsigned long delta = endp->jiffies - jiffies;
-                                if (delta > wakeup)
-                                        wakeup = delta;
-                        }
-                }
-                if (last_endp->queue_next == last_endp->queue_last) {
-                } else if ((last_endp->delayed == 0) || time_after_eq(jiffies,
-                        last_endp->jiffies)) {
-                        u132_endp_cancel_work(u132, last_endp);
-                        u132_endp_queue_work(u132, last_endp, 0);
-                        up(&u132->scheduler_lock);
-                        u132_ring_put_kref(u132, ring);
-                        return;
-                } else {
-                        unsigned long delta = last_endp->jiffies - jiffies;
-                        if (delta > wakeup)
-                                wakeup = delta;
-                }
-                if (wakeup > 0) {
-                        u132_ring_requeue_work(u132, ring, wakeup);
-                        up(&u132->scheduler_lock);
-                        return;
-                } else {
-                        up(&u132->scheduler_lock);
-                        u132_ring_put_kref(u132, ring);
-                        return;
-                }
-        } else {
-                up(&u132->scheduler_lock);
-                u132_ring_put_kref(u132, ring);
-                return;
-        }
+	struct u132 *u132 = ring->u132;
+	mutex_lock(&u132->scheduler_lock);
+	if (ring->in_use) {
+		mutex_unlock(&u132->scheduler_lock);
+		u132_ring_put_kref(u132, ring);
+		return;
+	} else if (ring->curr_endp) {
+		struct u132_endp *last_endp = ring->curr_endp;
+		struct list_head *scan;
+		struct list_head *head = &last_endp->endp_ring;
+		unsigned long wakeup = 0;
+		list_for_each(scan, head) {
+			struct u132_endp *endp = list_entry(scan,
+				struct u132_endp, endp_ring);
+			if (endp->queue_next == endp->queue_last) {
+			} else if ((endp->delayed == 0)
+				|| time_after_eq(jiffies, endp->jiffies)) {
+				ring->curr_endp = endp;
+				u132_endp_cancel_work(u132, last_endp);
+				u132_endp_queue_work(u132, last_endp, 0);
+				mutex_unlock(&u132->scheduler_lock);
+				u132_ring_put_kref(u132, ring);
+				return;
+			} else {
+				unsigned long delta = endp->jiffies - jiffies;
+				if (delta > wakeup)
+					wakeup = delta;
+			}
+		}
+		if (last_endp->queue_next == last_endp->queue_last) {
+		} else if ((last_endp->delayed == 0) || time_after_eq(jiffies,
+			last_endp->jiffies)) {
+			u132_endp_cancel_work(u132, last_endp);
+			u132_endp_queue_work(u132, last_endp, 0);
+			mutex_unlock(&u132->scheduler_lock);
+			u132_ring_put_kref(u132, ring);
+			return;
+		} else {
+			unsigned long delta = last_endp->jiffies - jiffies;
+			if (delta > wakeup)
+				wakeup = delta;
+		}
+		if (wakeup > 0) {
+			u132_ring_requeue_work(u132, ring, wakeup);
+			mutex_unlock(&u132->scheduler_lock);
+			return;
+		} else {
+			mutex_unlock(&u132->scheduler_lock);
+			u132_ring_put_kref(u132, ring);
+			return;
+		}
+	} else {
+		mutex_unlock(&u132->scheduler_lock);
+		u132_ring_put_kref(u132, ring);
+		return;
+	}
 }
 
 static void u132_hcd_endp_work_scheduler(struct work_struct *work)
 {
-        struct u132_ring *ring;
-        struct u132_endp *endp =
+	struct u132_ring *ring;
+	struct u132_endp *endp =
 		container_of(work, struct u132_endp, scheduler.work);
-        struct u132 *u132 = endp->u132;
-        down(&u132->scheduler_lock);
-        ring = endp->ring;
-        if (endp->edset_flush) {
-                endp->edset_flush = 0;
-                if (endp->dequeueing)
-                        usb_ftdi_elan_edset_flush(u132->platform_dev,
-                                ring->number, endp);
-                up(&u132->scheduler_lock);
-                u132_endp_put_kref(u132, endp);
-                return;
-        } else if (endp->active) {
-                up(&u132->scheduler_lock);
-                u132_endp_put_kref(u132, endp);
-                return;
-        } else if (ring->in_use) {
-                up(&u132->scheduler_lock);
-                u132_endp_put_kref(u132, endp);
-                return;
-        } else if (endp->queue_next == endp->queue_last) {
-                up(&u132->scheduler_lock);
-                u132_endp_put_kref(u132, endp);
-                return;
-        } else if (endp->pipetype == PIPE_INTERRUPT) {
-                u8 address = u132->addr[endp->usb_addr].address;
-                if (ring->in_use) {
-                        up(&u132->scheduler_lock);
-                        u132_endp_put_kref(u132, endp);
-                        return;
-                } else {
-                        int retval;
-                        struct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &
-                                endp->queue_next];
-                        endp->active = 1;
-                        ring->curr_endp = endp;
-                        ring->in_use = 1;
-                        up(&u132->scheduler_lock);
-                        retval = edset_single(u132, ring, endp, urb, address,
-                                endp->toggle_bits, u132_hcd_interrupt_recv);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                }
-        } else if (endp->pipetype == PIPE_CONTROL) {
-                u8 address = u132->addr[endp->usb_addr].address;
-                if (ring->in_use) {
-                        up(&u132->scheduler_lock);
-                        u132_endp_put_kref(u132, endp);
-                        return;
-                } else if (address == 0) {
-                        int retval;
-                        struct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &
-                                endp->queue_next];
-                        endp->active = 1;
-                        ring->curr_endp = endp;
-                        ring->in_use = 1;
-                        up(&u132->scheduler_lock);
-                        retval = edset_setup(u132, ring, endp, urb, address,
-                                0x2, u132_hcd_initial_setup_sent);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                } else if (endp->usb_addr == 0) {
-                        int retval;
-                        struct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &
-                                endp->queue_next];
-                        endp->active = 1;
-                        ring->curr_endp = endp;
-                        ring->in_use = 1;
-                        up(&u132->scheduler_lock);
-                        retval = edset_setup(u132, ring, endp, urb, 0, 0x2,
-                                u132_hcd_enumeration_address_sent);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                } else {
-                        int retval;
-                        u8 address = u132->addr[endp->usb_addr].address;
-                        struct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &
-                                endp->queue_next];
-                        endp->active = 1;
-                        ring->curr_endp = endp;
-                        ring->in_use = 1;
-                        up(&u132->scheduler_lock);
-                        retval = edset_setup(u132, ring, endp, urb, address,
-                                0x2, u132_hcd_configure_setup_sent);
-                        if (retval == 0) {
-                        } else
-                                u132_hcd_giveback_urb(u132, endp, urb, retval);
-                        return;
-                }
-        } else {
-                if (endp->input) {
-                        u8 address = u132->addr[endp->usb_addr].address;
-                        if (ring->in_use) {
-                                up(&u132->scheduler_lock);
-                                u132_endp_put_kref(u132, endp);
-                                return;
-                        } else {
-                                int retval;
-                                struct urb *urb = endp->urb_list[
-                                        ENDP_QUEUE_MASK & endp->queue_next];
-                                endp->active = 1;
-                                ring->curr_endp = endp;
-                                ring->in_use = 1;
-                                up(&u132->scheduler_lock);
-                                retval = edset_input(u132, ring, endp, urb,
-                                        address, endp->toggle_bits,
-                                        u132_hcd_bulk_input_recv);
-                                if (retval == 0) {
-                                } else
-                                        u132_hcd_giveback_urb(u132, endp, urb,
-                                                retval);
-                                return;
-                        }
-                } else {        /* output pipe */
-                        u8 address = u132->addr[endp->usb_addr].address;
-                        if (ring->in_use) {
-                                up(&u132->scheduler_lock);
-                                u132_endp_put_kref(u132, endp);
-                                return;
-                        } else {
-                                int retval;
-                                struct urb *urb = endp->urb_list[
-                                        ENDP_QUEUE_MASK & endp->queue_next];
-                                endp->active = 1;
-                                ring->curr_endp = endp;
-                                ring->in_use = 1;
-                                up(&u132->scheduler_lock);
-                                retval = edset_output(u132, ring, endp, urb,
-                                        address, endp->toggle_bits,
-                                        u132_hcd_bulk_output_sent);
-                                if (retval == 0) {
-                                } else
-                                        u132_hcd_giveback_urb(u132, endp, urb,
-                                                retval);
-                                return;
-                        }
-                }
-        }
+	struct u132 *u132 = endp->u132;
+	mutex_lock(&u132->scheduler_lock);
+	ring = endp->ring;
+	if (endp->edset_flush) {
+		endp->edset_flush = 0;
+		if (endp->dequeueing)
+			usb_ftdi_elan_edset_flush(u132->platform_dev,
+				ring->number, endp);
+		mutex_unlock(&u132->scheduler_lock);
+		u132_endp_put_kref(u132, endp);
+		return;
+	} else if (endp->active) {
+		mutex_unlock(&u132->scheduler_lock);
+		u132_endp_put_kref(u132, endp);
+		return;
+	} else if (ring->in_use) {
+		mutex_unlock(&u132->scheduler_lock);
+		u132_endp_put_kref(u132, endp);
+		return;
+	} else if (endp->queue_next == endp->queue_last) {
+		mutex_unlock(&u132->scheduler_lock);
+		u132_endp_put_kref(u132, endp);
+		return;
+	} else if (endp->pipetype == PIPE_INTERRUPT) {
+		u8 address = u132->addr[endp->usb_addr].address;
+		if (ring->in_use) {
+			mutex_unlock(&u132->scheduler_lock);
+			u132_endp_put_kref(u132, endp);
+			return;
+		} else {
+			int retval;
+			struct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &
+				endp->queue_next];
+			endp->active = 1;
+			ring->curr_endp = endp;
+			ring->in_use = 1;
+			mutex_unlock(&u132->scheduler_lock);
+			retval = edset_single(u132, ring, endp, urb, address,
+				endp->toggle_bits, u132_hcd_interrupt_recv);
+			if (retval != 0)
+				u132_hcd_giveback_urb(u132, endp, urb, retval);
+			return;
+		}
+	} else if (endp->pipetype == PIPE_CONTROL) {
+		u8 address = u132->addr[endp->usb_addr].address;
+		if (ring->in_use) {
+			mutex_unlock(&u132->scheduler_lock);
+			u132_endp_put_kref(u132, endp);
+			return;
+		} else if (address == 0) {
+			int retval;
+			struct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &
+				endp->queue_next];
+			endp->active = 1;
+			ring->curr_endp = endp;
+			ring->in_use = 1;
+			mutex_unlock(&u132->scheduler_lock);
+			retval = edset_setup(u132, ring, endp, urb, address,
+				0x2, u132_hcd_initial_setup_sent);
+			if (retval != 0)
+				u132_hcd_giveback_urb(u132, endp, urb, retval);
+			return;
+		} else if (endp->usb_addr == 0) {
+			int retval;
+			struct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &
+				endp->queue_next];
+			endp->active = 1;
+			ring->curr_endp = endp;
+			ring->in_use = 1;
+			mutex_unlock(&u132->scheduler_lock);
+			retval = edset_setup(u132, ring, endp, urb, 0, 0x2,
+				u132_hcd_enumeration_address_sent);
+			if (retval != 0)
+				u132_hcd_giveback_urb(u132, endp, urb, retval);
+			return;
+		} else {
+			int retval;
+			u8 address = u132->addr[endp->usb_addr].address;
+			struct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &
+				endp->queue_next];
+			endp->active = 1;
+			ring->curr_endp = endp;
+			ring->in_use = 1;
+			mutex_unlock(&u132->scheduler_lock);
+			retval = edset_setup(u132, ring, endp, urb, address,
+				0x2, u132_hcd_configure_setup_sent);
+			if (retval != 0)
+				u132_hcd_giveback_urb(u132, endp, urb, retval);
+			return;
+		}
+	} else {
+		if (endp->input) {
+			u8 address = u132->addr[endp->usb_addr].address;
+			if (ring->in_use) {
+				mutex_unlock(&u132->scheduler_lock);
+				u132_endp_put_kref(u132, endp);
+				return;
+			} else {
+				int retval;
+				struct urb *urb = endp->urb_list[
+					ENDP_QUEUE_MASK & endp->queue_next];
+				endp->active = 1;
+				ring->curr_endp = endp;
+				ring->in_use = 1;
+				mutex_unlock(&u132->scheduler_lock);
+				retval = edset_input(u132, ring, endp, urb,
+					address, endp->toggle_bits,
+					u132_hcd_bulk_input_recv);
+				if (retval == 0) {
+				} else
+					u132_hcd_giveback_urb(u132, endp, urb,
+						retval);
+				return;
+			}
+		} else {	/* output pipe */
+			u8 address = u132->addr[endp->usb_addr].address;
+			if (ring->in_use) {
+				mutex_unlock(&u132->scheduler_lock);
+				u132_endp_put_kref(u132, endp);
+				return;
+			} else {
+				int retval;
+				struct urb *urb = endp->urb_list[
+					ENDP_QUEUE_MASK & endp->queue_next];
+				endp->active = 1;
+				ring->curr_endp = endp;
+				ring->in_use = 1;
+				mutex_unlock(&u132->scheduler_lock);
+				retval = edset_output(u132, ring, endp, urb,
+					address, endp->toggle_bits,
+					u132_hcd_bulk_output_sent);
+				if (retval == 0) {
+				} else
+					u132_hcd_giveback_urb(u132, endp, urb,
+						retval);
+				return;
+			}
+		}
+	}
 }
 #ifdef CONFIG_PM
 
 static void port_power(struct u132 *u132, int pn, int is_on)
 {
-        u132->port[pn].power = is_on;
+	u132->port[pn].power = is_on;
 }
 
 #endif
 
 static void u132_power(struct u132 *u132, int is_on)
 {
-        struct usb_hcd *hcd = u132_to_hcd(u132)
-                ;        /* hub is inactive unless the port is powered */
-        if (is_on) {
-                if (u132->power)
-                        return;
-                u132->power = 1;
-                hcd->self.controller->power.power_state = PMSG_ON;
-        } else {
-                u132->power = 0;
-                hcd->state = HC_STATE_HALT;
-                hcd->self.controller->power.power_state = PMSG_SUSPEND;
-        }
+	struct usb_hcd *hcd = u132_to_hcd(u132)
+		;	/* hub is inactive unless the port is powered */
+	if (is_on) {
+		if (u132->power)
+			return;
+		u132->power = 1;
+	} else {
+		u132->power = 0;
+		hcd->state = HC_STATE_HALT;
+	}
 }
 
 static int u132_periodic_reinit(struct u132 *u132)
 {
-        int retval;
-        u32 fi = u132->hc_fminterval & 0x03fff;
-        u32 fit;
-        u32 fminterval;
-        retval = u132_read_pcimem(u132, fminterval, &fminterval);
-        if (retval)
-                return retval;
-        fit = fminterval & FIT;
-        retval = u132_write_pcimem(u132, fminterval,
-                (fit ^ FIT) | u132->hc_fminterval);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, periodicstart,
-                ((9 *fi) / 10) & 0x3fff);
-        if (retval)
-                return retval;
-        return 0;
+	int retval;
+	u32 fi = u132->hc_fminterval & 0x03fff;
+	u32 fit;
+	u32 fminterval;
+	retval = u132_read_pcimem(u132, fminterval, &fminterval);
+	if (retval)
+		return retval;
+	fit = fminterval & FIT;
+	retval = u132_write_pcimem(u132, fminterval,
+		(fit ^ FIT) | u132->hc_fminterval);
+	if (retval)
+		return retval;
+	retval = u132_write_pcimem(u132, periodicstart,
+		((9 * fi) / 10) & 0x3fff);
+	if (retval)
+		return retval;
+	return 0;
 }
 
 static char *hcfs2string(int state)
 {
-        switch (state) {
-        case OHCI_USB_RESET:
-                return "reset";
-        case OHCI_USB_RESUME:
-                return "resume";
-        case OHCI_USB_OPER:
-                return "operational";
-        case OHCI_USB_SUSPEND:
-                return "suspend";
-        }
-        return "?";
+	switch (state) {
+	case OHCI_USB_RESET:
+		return "reset";
+	case OHCI_USB_RESUME:
+		return "resume";
+	case OHCI_USB_OPER:
+		return "operational";
+	case OHCI_USB_SUSPEND:
+		return "suspend";
+	}
+	return "?";
 }
 
 static int u132_init(struct u132 *u132)
 {
-        int retval;
-        u32 control;
-        u132_disable(u132);
-        u132->next_statechange = jiffies;
-        retval = u132_write_pcimem(u132, intrdisable, OHCI_INTR_MIE);
-        if (retval)
-                return retval;
-        retval = u132_read_pcimem(u132, control, &control);
-        if (retval)
-                return retval;
-        if (u132->num_ports == 0) {
-                u32 rh_a = -1;
-                retval = u132_read_pcimem(u132, roothub.a, &rh_a);
-                if (retval)
-                        return retval;
-                u132->num_ports = rh_a & RH_A_NDP;
-                retval = read_roothub_info(u132);
-                if (retval)
-                        return retval;
-        }
-        if (u132->num_ports > MAX_U132_PORTS) {
-                return -EINVAL;
-        }
-        return 0;
+	int retval;
+	u32 control;
+	u132_disable(u132);
+	u132->next_statechange = jiffies;
+	retval = u132_write_pcimem(u132, intrdisable, OHCI_INTR_MIE);
+	if (retval)
+		return retval;
+	retval = u132_read_pcimem(u132, control, &control);
+	if (retval)
+		return retval;
+	if (u132->num_ports == 0) {
+		u32 rh_a = -1;
+		retval = u132_read_pcimem(u132, roothub.a, &rh_a);
+		if (retval)
+			return retval;
+		u132->num_ports = rh_a & RH_A_NDP;
+		retval = read_roothub_info(u132);
+		if (retval)
+			return retval;
+	}
+	if (u132->num_ports > MAX_U132_PORTS)
+		return -EINVAL;
+
+	return 0;
 }
 
 
@@ -1616,986 +1603,1044 @@
 */
 static int u132_run(struct u132 *u132)
 {
-        int retval;
-        u32 control;
-        u32 status;
-        u32 fminterval;
-        u32 periodicstart;
-        u32 cmdstatus;
-        u32 roothub_a;
-        int mask = OHCI_INTR_INIT;
-        int first = u132->hc_fminterval == 0;
-        int sleep_time = 0;
-        int reset_timeout = 30;        /* ... allow extra time */
-        u132_disable(u132);
-        if (first) {
-                u32 temp;
-                retval = u132_read_pcimem(u132, fminterval, &temp);
-                if (retval)
-                        return retval;
-                u132->hc_fminterval = temp & 0x3fff;
-                if (u132->hc_fminterval != FI) {
-                }
-                u132->hc_fminterval |= FSMP(u132->hc_fminterval) << 16;
-        }
-        retval = u132_read_pcimem(u132, control, &u132->hc_control);
-        if (retval)
-                return retval;
-        dev_info(&u132->platform_dev->dev, "resetting from state '%s', control "
-                "= %08X\n", hcfs2string(u132->hc_control & OHCI_CTRL_HCFS),
-                u132->hc_control);
-        switch (u132->hc_control & OHCI_CTRL_HCFS) {
-        case OHCI_USB_OPER:
-                sleep_time = 0;
-                break;
-        case OHCI_USB_SUSPEND:
-        case OHCI_USB_RESUME:
-                u132->hc_control &= OHCI_CTRL_RWC;
-                u132->hc_control |= OHCI_USB_RESUME;
-                sleep_time = 10;
-                break;
-        default:
-                u132->hc_control &= OHCI_CTRL_RWC;
-                u132->hc_control |= OHCI_USB_RESET;
-                sleep_time = 50;
-                break;
-        }
-        retval = u132_write_pcimem(u132, control, u132->hc_control);
-        if (retval)
-                return retval;
-        retval = u132_read_pcimem(u132, control, &control);
-        if (retval)
-                return retval;
-        msleep(sleep_time);
-        retval = u132_read_pcimem(u132, roothub.a, &roothub_a);
-        if (retval)
-                return retval;
-        if (!(roothub_a & RH_A_NPS)) {
-                int temp;        /* power down each port */
-                for (temp = 0; temp < u132->num_ports; temp++) {
-                        retval = u132_write_pcimem(u132,
-                                roothub.portstatus[temp], RH_PS_LSDA);
-                        if (retval)
-                                return retval;
-                }
-        }
-        retval = u132_read_pcimem(u132, control, &control);
-        if (retval)
-                return retval;
-      retry:retval = u132_read_pcimem(u132, cmdstatus, &status);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, cmdstatus, OHCI_HCR);
-        if (retval)
-                return retval;
-      extra:{
-                retval = u132_read_pcimem(u132, cmdstatus, &status);
-                if (retval)
-                        return retval;
-                if (0 != (status & OHCI_HCR)) {
-                        if (--reset_timeout == 0) {
-                                dev_err(&u132->platform_dev->dev, "USB HC reset"
-                                        " timed out!\n");
-                                return -ENODEV;
-                        } else {
-                                msleep(5);
-                                goto extra;
-                        }
-                }
-        }
-        if (u132->flags & OHCI_QUIRK_INITRESET) {
-                retval = u132_write_pcimem(u132, control, u132->hc_control);
-                if (retval)
-                        return retval;
-                retval = u132_read_pcimem(u132, control, &control);
-                if (retval)
-                        return retval;
-        }
-        retval = u132_write_pcimem(u132, ed_controlhead, 0x00000000);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, ed_bulkhead, 0x11000000);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, hcca, 0x00000000);
-        if (retval)
-                return retval;
-        retval = u132_periodic_reinit(u132);
-        if (retval)
-                return retval;
-        retval = u132_read_pcimem(u132, fminterval, &fminterval);
-        if (retval)
-                return retval;
-        retval = u132_read_pcimem(u132, periodicstart, &periodicstart);
-        if (retval)
-                return retval;
-        if (0 == (fminterval & 0x3fff0000) || 0 == periodicstart) {
-                if (!(u132->flags & OHCI_QUIRK_INITRESET)) {
-                        u132->flags |= OHCI_QUIRK_INITRESET;
-                        goto retry;
-                } else
-                        dev_err(&u132->platform_dev->dev, "init err(%08x %04x)"
-                                "\n", fminterval, periodicstart);
-        }                        /* start controller operations */
-        u132->hc_control &= OHCI_CTRL_RWC;
-        u132->hc_control |= OHCI_CONTROL_INIT | OHCI_CTRL_BLE | OHCI_USB_OPER;
-        retval = u132_write_pcimem(u132, control, u132->hc_control);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, cmdstatus, OHCI_BLF);
-        if (retval)
-                return retval;
-        retval = u132_read_pcimem(u132, cmdstatus, &cmdstatus);
-        if (retval)
-                return retval;
-        retval = u132_read_pcimem(u132, control, &control);
-        if (retval)
-                return retval;
-        u132_to_hcd(u132)->state = HC_STATE_RUNNING;
-        retval = u132_write_pcimem(u132, roothub.status, RH_HS_DRWE);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, intrstatus, mask);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, intrdisable,
-                OHCI_INTR_MIE | OHCI_INTR_OC | OHCI_INTR_RHSC | OHCI_INTR_FNO |
-                OHCI_INTR_UE | OHCI_INTR_RD | OHCI_INTR_SF | OHCI_INTR_WDH |
-                OHCI_INTR_SO);
-        if (retval)
-                return retval;        /* handle root hub init quirks ... */
-        retval = u132_read_pcimem(u132, roothub.a, &roothub_a);
-        if (retval)
-                return retval;
-        roothub_a &= ~(RH_A_PSM | RH_A_OCPM);
-        if (u132->flags & OHCI_QUIRK_SUPERIO) {
-                roothub_a |= RH_A_NOCP;
-                roothub_a &= ~(RH_A_POTPGT | RH_A_NPS);
-                retval = u132_write_pcimem(u132, roothub.a, roothub_a);
-                if (retval)
-                        return retval;
-        } else if ((u132->flags & OHCI_QUIRK_AMD756) || distrust_firmware) {
-                roothub_a |= RH_A_NPS;
-                retval = u132_write_pcimem(u132, roothub.a, roothub_a);
-                if (retval)
-                        return retval;
-        }
-        retval = u132_write_pcimem(u132, roothub.status, RH_HS_LPSC);
-        if (retval)
-                return retval;
-        retval = u132_write_pcimem(u132, roothub.b,
-                (roothub_a & RH_A_NPS) ? 0 : RH_B_PPCM);
-        if (retval)
-                return retval;
-        retval = u132_read_pcimem(u132, control, &control);
-        if (retval)
-                return retval;
-        mdelay((roothub_a >> 23) & 0x1fe);
-        u132_to_hcd(u132)->state = HC_STATE_RUNNING;
-        return 0;
+	int retval;
+	u32 control;
+	u32 status;
+	u32 fminterval;
+	u32 periodicstart;
+	u32 cmdstatus;
+	u32 roothub_a;
+	int mask = OHCI_INTR_INIT;
+	int first = u132->hc_fminterval == 0;
+	int sleep_time = 0;
+	int reset_timeout = 30;	/* ... allow extra time */
+	u132_disable(u132);
+	if (first) {
+		u32 temp;
+		retval = u132_read_pcimem(u132, fminterval, &temp);
+		if (retval)
+			return retval;
+		u132->hc_fminterval = temp & 0x3fff;
+		u132->hc_fminterval |= FSMP(u132->hc_fminterval) << 16;
+	}
+	retval = u132_read_pcimem(u132, control, &u132->hc_control);
+	if (retval)
+		return retval;
+	dev_info(&u132->platform_dev->dev, "resetting from state '%s', control "
+		"= %08X\n", hcfs2string(u132->hc_control & OHCI_CTRL_HCFS),
+		u132->hc_control);
+	switch (u132->hc_control & OHCI_CTRL_HCFS) {
+	case OHCI_USB_OPER:
+		sleep_time = 0;
+		break;
+	case OHCI_USB_SUSPEND:
+	case OHCI_USB_RESUME:
+		u132->hc_control &= OHCI_CTRL_RWC;
+		u132->hc_control |= OHCI_USB_RESUME;
+		sleep_time = 10;
+		break;
+	default:
+		u132->hc_control &= OHCI_CTRL_RWC;
+		u132->hc_control |= OHCI_USB_RESET;
+		sleep_time = 50;
+		break;
+	}
+	retval = u132_write_pcimem(u132, control, u132->hc_control);
+	if (retval)
+		return retval;
+	retval = u132_read_pcimem(u132, control, &control);
+	if (retval)
+		return retval;
+	msleep(sleep_time);
+	retval = u132_read_pcimem(u132, roothub.a, &roothub_a);
+	if (retval)
+		return retval;
+	if (!(roothub_a & RH_A_NPS)) {
+		int temp;	/* power down each port */
+		for (temp = 0; temp < u132->num_ports; temp++) {
+			retval = u132_write_pcimem(u132,
+				roothub.portstatus[temp], RH_PS_LSDA);
+			if (retval)
+				return retval;
+		}
+	}
+	retval = u132_read_pcimem(u132, control, &control);
+	if (retval)
+		return retval;
+retry:
+	retval = u132_read_pcimem(u132, cmdstatus, &status);
+	if (retval)
+		return retval;
+	retval = u132_write_pcimem(u132, cmdstatus, OHCI_HCR);
+	if (retval)
+		return retval;
+extra:	{
+		retval = u132_read_pcimem(u132, cmdstatus, &status);
+		if (retval)
+			return retval;
+		if (0 != (status & OHCI_HCR)) {
+			if (--reset_timeout == 0) {
+				dev_err(&u132->platform_dev->dev, "USB HC reset"
+					" timed out!\n");
+				return -ENODEV;
+			} else {
+				msleep(5);
+				goto extra;
+			}
+		}
+	}
+	if (u132->flags & OHCI_QUIRK_INITRESET) {
+		retval = u132_write_pcimem(u132, control, u132->hc_control);
+		if (retval)
+			return retval;
+		retval = u132_read_pcimem(u132, control, &control);
+		if (retval)
+			return retval;
+	}
+	retval = u132_write_pcimem(u132, ed_controlhead, 0x00000000);
+	if (retval)
+		return retval;
+	retval = u132_write_pcimem(u132, ed_bulkhead, 0x11000000);
+	if (retval)
+		return retval;
+	retval = u132_write_pcimem(u132, hcca, 0x00000000);
+	if (retval)
+		return retval;
+	retval = u132_periodic_reinit(u132);
+	if (retval)
+		return retval;
+	retval = u132_read_pcimem(u132, fminterval, &fminterval);
+	if (retval)
+		return retval;
+	retval = u132_read_pcimem(u132, periodicstart, &periodicstart);
+	if (retval)
+		return retval;
+	if (0 == (fminterval & 0x3fff0000) || 0 == periodicstart) {
+		if (!(u132->flags & OHCI_QUIRK_INITRESET)) {
+			u132->flags |= OHCI_QUIRK_INITRESET;
+			goto retry;
+		} else
+			dev_err(&u132->platform_dev->dev, "init err(%08x %04x)"
+				"\n", fminterval, periodicstart);
+	}			/* start controller operations */
+	u132->hc_control &= OHCI_CTRL_RWC;
+	u132->hc_control |= OHCI_CONTROL_INIT | OHCI_CTRL_BLE | OHCI_USB_OPER;
+	retval = u132_write_pcimem(u132, control, u132->hc_control);
+	if (retval)
+		return retval;
+	retval = u132_write_pcimem(u132, cmdstatus, OHCI_BLF);
+	if (retval)
+		return retval;
+	retval = u132_read_pcimem(u132, cmdstatus, &cmdstatus);
+	if (retval)
+		return retval;
+	retval = u132_read_pcimem(u132, control, &control);
+	if (retval)
+		return retval;
+	u132_to_hcd(u132)->state = HC_STATE_RUNNING;
+	retval = u132_write_pcimem(u132, roothub.status, RH_HS_DRWE);
+	if (retval)
+		return retval;
+	retval = u132_write_pcimem(u132, intrstatus, mask);
+	if (retval)
+		return retval;
+	retval = u132_write_pcimem(u132, intrdisable,
+		OHCI_INTR_MIE | OHCI_INTR_OC | OHCI_INTR_RHSC | OHCI_INTR_FNO |
+		OHCI_INTR_UE | OHCI_INTR_RD | OHCI_INTR_SF | OHCI_INTR_WDH |
+		OHCI_INTR_SO);
+	if (retval)
+		return retval;	/* handle root hub init quirks ... */
+	retval = u132_read_pcimem(u132, roothub.a, &roothub_a);
+	if (retval)
+		return retval;
+	roothub_a &= ~(RH_A_PSM | RH_A_OCPM);
+	if (u132->flags & OHCI_QUIRK_SUPERIO) {
+		roothub_a |= RH_A_NOCP;
+		roothub_a &= ~(RH_A_POTPGT | RH_A_NPS);
+		retval = u132_write_pcimem(u132, roothub.a, roothub_a);
+		if (retval)
+			return retval;
+	} else if ((u132->flags & OHCI_QUIRK_AMD756) || distrust_firmware) {
+		roothub_a |= RH_A_NPS;
+		retval = u132_write_pcimem(u132, roothub.a, roothub_a);
+		if (retval)
+			return retval;
+	}
+	retval = u132_write_pcimem(u132, roothub.status, RH_HS_LPSC);
+	if (retval)
+		return retval;
+	retval = u132_write_pcimem(u132, roothub.b,
+		(roothub_a & RH_A_NPS) ? 0 : RH_B_PPCM);
+	if (retval)
+		return retval;
+	retval = u132_read_pcimem(u132, control, &control);
+	if (retval)
+		return retval;
+	mdelay((roothub_a >> 23) & 0x1fe);
+	u132_to_hcd(u132)->state = HC_STATE_RUNNING;
+	return 0;
 }
 
 static void u132_hcd_stop(struct usb_hcd *hcd)
 {
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "u132 device %p(hcd=%p) has b"
-                        "een removed %d\n", u132, hcd, u132->going);
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device hcd=%p is being remov"
-                        "ed\n", hcd);
-        } else {
-                down(&u132->sw_lock);
-                msleep(100);
-                u132_power(u132, 0);
-                up(&u132->sw_lock);
-        }
+	struct u132 *u132 = hcd_to_u132(hcd);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "u132 device %p(hcd=%p) has b"
+			"een removed %d\n", u132, hcd, u132->going);
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device hcd=%p is being remov"
+			"ed\n", hcd);
+	} else {
+		mutex_lock(&u132->sw_lock);
+		msleep(100);
+		u132_power(u132, 0);
+		mutex_unlock(&u132->sw_lock);
+	}
 }
 
 static int u132_hcd_start(struct usb_hcd *hcd)
 {
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else if (hcd->self.controller) {
-                int retval;
-                struct platform_device *pdev =
-                        to_platform_device(hcd->self.controller);
-                u16 vendor = ((struct u132_platform_data *)
-                        (pdev->dev.platform_data))->vendor;
-                u16 device = ((struct u132_platform_data *)
-                        (pdev->dev.platform_data))->device;
-                down(&u132->sw_lock);
-                msleep(10);
-                if (vendor == PCI_VENDOR_ID_AMD && device == 0x740c) {
-                        u132->flags = OHCI_QUIRK_AMD756;
-                } else if (vendor == PCI_VENDOR_ID_OPTI && device == 0xc861) {
-                        dev_err(&u132->platform_dev->dev, "WARNING: OPTi workar"
-                                "ounds unavailable\n");
-                } else if (vendor == PCI_VENDOR_ID_COMPAQ && device == 0xa0f8)
-                        u132->flags |= OHCI_QUIRK_ZFMICRO;
-                retval = u132_run(u132);
-                if (retval) {
-                        u132_disable(u132);
-                        u132->going = 1;
-                }
-                msleep(100);
-                up(&u132->sw_lock);
-                return retval;
-        } else {
-                dev_err(&u132->platform_dev->dev, "platform_device missing\n");
-                return -ENODEV;
-        }
+	struct u132 *u132 = hcd_to_u132(hcd);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		return -ENODEV;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed\n");
+		return -ESHUTDOWN;
+	} else if (hcd->self.controller) {
+		int retval;
+		struct platform_device *pdev =
+			to_platform_device(hcd->self.controller);
+		u16 vendor = ((struct u132_platform_data *)
+			(pdev->dev.platform_data))->vendor;
+		u16 device = ((struct u132_platform_data *)
+			(pdev->dev.platform_data))->device;
+		mutex_lock(&u132->sw_lock);
+		msleep(10);
+		if (vendor == PCI_VENDOR_ID_AMD && device == 0x740c) {
+			u132->flags = OHCI_QUIRK_AMD756;
+		} else if (vendor == PCI_VENDOR_ID_OPTI && device == 0xc861) {
+			dev_err(&u132->platform_dev->dev, "WARNING: OPTi workar"
+				"ounds unavailable\n");
+		} else if (vendor == PCI_VENDOR_ID_COMPAQ && device == 0xa0f8)
+			u132->flags |= OHCI_QUIRK_ZFMICRO;
+		retval = u132_run(u132);
+		if (retval) {
+			u132_disable(u132);
+			u132->going = 1;
+		}
+		msleep(100);
+		mutex_unlock(&u132->sw_lock);
+		return retval;
+	} else {
+		dev_err(&u132->platform_dev->dev, "platform_device missing\n");
+		return -ENODEV;
+	}
 }
 
 static int u132_hcd_reset(struct usb_hcd *hcd)
 {
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else {
-                int retval;
-                down(&u132->sw_lock);
-                retval = u132_init(u132);
-                if (retval) {
-                        u132_disable(u132);
-                        u132->going = 1;
-                }
-                up(&u132->sw_lock);
-                return retval;
-        }
+	struct u132 *u132 = hcd_to_u132(hcd);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		return -ENODEV;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed\n");
+		return -ESHUTDOWN;
+	} else {
+		int retval;
+		mutex_lock(&u132->sw_lock);
+		retval = u132_init(u132);
+		if (retval) {
+			u132_disable(u132);
+			u132->going = 1;
+		}
+		mutex_unlock(&u132->sw_lock);
+		return retval;
+	}
 }
 
 static int create_endpoint_and_queue_int(struct u132 *u132,
-        struct u132_udev *udev, struct usb_host_endpoint *hep, struct urb *urb,
-        struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp, u8 address,
-        gfp_t mem_flags)
-{
-        struct u132_ring *ring;
-        unsigned long irqs;
-        u8 endp_number = ++u132->num_endpoints;
-        struct u132_endp *endp = hep->hcpriv = u132->endp[endp_number - 1] =
-                kmalloc(sizeof(struct u132_endp), mem_flags);
-        if (!endp) {
-                return -ENOMEM;
-        }
-        INIT_DELAYED_WORK(&endp->scheduler, u132_hcd_endp_work_scheduler);
-        spin_lock_init(&endp->queue_lock.slock);
-        INIT_LIST_HEAD(&endp->urb_more);
-        ring = endp->ring = &u132->ring[0];
-        if (ring->curr_endp) {
-                list_add_tail(&endp->endp_ring, &ring->curr_endp->endp_ring);
-        } else {
-                INIT_LIST_HEAD(&endp->endp_ring);
-                ring->curr_endp = endp;
-        }
-        ring->length += 1;
-        endp->dequeueing = 0;
-        endp->edset_flush = 0;
-        endp->active = 0;
-        endp->delayed = 0;
-        endp->endp_number = endp_number;
-        endp->u132 = u132;
-        endp->hep = hep;
-        endp->pipetype = usb_pipetype(urb->pipe);
-        u132_endp_init_kref(u132, endp);
-        if (usb_pipein(urb->pipe)) {
-                endp->toggle_bits = 0x2;
-                usb_settoggle(udev->usb_device, usb_endp, 0, 0);
-                endp->input = 1;
-                endp->output = 0;
-                udev->endp_number_in[usb_endp] = endp_number;
-                u132_udev_get_kref(u132, udev);
-        } else {
-                endp->toggle_bits = 0x2;
-                usb_settoggle(udev->usb_device, usb_endp, 1, 0);
-                endp->input = 0;
-                endp->output = 1;
-                udev->endp_number_out[usb_endp] = endp_number;
-                u132_udev_get_kref(u132, udev);
-        }
-        urb->hcpriv = u132;
-        spin_lock_irqsave(&endp->queue_lock.slock, irqs);
-        endp->delayed = 1;
-        endp->jiffies = jiffies + msecs_to_jiffies(urb->interval);
-        endp->udev_number = address;
-        endp->usb_addr = usb_addr;
-        endp->usb_endp = usb_endp;
-        endp->queue_size = 1;
-        endp->queue_last = 0;
-        endp->queue_next = 0;
-        endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
-        spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-        u132_endp_queue_work(u132, endp, msecs_to_jiffies(urb->interval));
-        return 0;
-}
-
-static int queue_int_on_old_endpoint(struct u132 *u132, struct u132_udev *udev,
-        struct usb_host_endpoint *hep, struct urb *urb,
-        struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
-        u8 usb_endp, u8 address)
-{
-        urb->hcpriv = u132;
-        endp->delayed = 1;
-        endp->jiffies = jiffies + msecs_to_jiffies(urb->interval);
-        if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
-                endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
-        } else {
-                struct u132_urbq *urbq = kmalloc(sizeof(struct u132_urbq),
-                        GFP_ATOMIC);
-                if (urbq == NULL) {
-                        endp->queue_size -= 1;
-                        return -ENOMEM;
-                } else {
-                        list_add_tail(&urbq->urb_more, &endp->urb_more);
-                        urbq->urb = urb;
-                }
-        }
-        return 0;
+	struct u132_udev *udev, struct urb *urb,
+	struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp, u8 address,
+	gfp_t mem_flags)
+{
+	struct u132_ring *ring;
+	unsigned long irqs;
+	int rc;
+	u8 endp_number;
+	struct u132_endp *endp = kmalloc(sizeof(struct u132_endp), mem_flags);
+
+	if (!endp)
+		return -ENOMEM;
+
+	spin_lock_init(&endp->queue_lock.slock);
+	spin_lock_irqsave(&endp->queue_lock.slock, irqs);
+	rc = usb_hcd_link_urb_to_ep(u132_to_hcd(u132), urb);
+	if (rc) {
+		spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+		kfree(endp);
+		return rc;
+	}
+
+	endp_number = ++u132->num_endpoints;
+	urb->ep->hcpriv = u132->endp[endp_number - 1] = endp;
+	INIT_DELAYED_WORK(&endp->scheduler, u132_hcd_endp_work_scheduler);
+	INIT_LIST_HEAD(&endp->urb_more);
+	ring = endp->ring = &u132->ring[0];
+	if (ring->curr_endp) {
+		list_add_tail(&endp->endp_ring, &ring->curr_endp->endp_ring);
+	} else {
+		INIT_LIST_HEAD(&endp->endp_ring);
+		ring->curr_endp = endp;
+	}
+	ring->length += 1;
+	endp->dequeueing = 0;
+	endp->edset_flush = 0;
+	endp->active = 0;
+	endp->delayed = 0;
+	endp->endp_number = endp_number;
+	endp->u132 = u132;
+	endp->hep = urb->ep;
+	endp->pipetype = usb_pipetype(urb->pipe);
+	u132_endp_init_kref(u132, endp);
+	if (usb_pipein(urb->pipe)) {
+		endp->toggle_bits = 0x2;
+		usb_settoggle(udev->usb_device, usb_endp, 0, 0);
+		endp->input = 1;
+		endp->output = 0;
+		udev->endp_number_in[usb_endp] = endp_number;
+		u132_udev_get_kref(u132, udev);
+	} else {
+		endp->toggle_bits = 0x2;
+		usb_settoggle(udev->usb_device, usb_endp, 1, 0);
+		endp->input = 0;
+		endp->output = 1;
+		udev->endp_number_out[usb_endp] = endp_number;
+		u132_udev_get_kref(u132, udev);
+	}
+	urb->hcpriv = u132;
+	endp->delayed = 1;
+	endp->jiffies = jiffies + msecs_to_jiffies(urb->interval);
+	endp->udev_number = address;
+	endp->usb_addr = usb_addr;
+	endp->usb_endp = usb_endp;
+	endp->queue_size = 1;
+	endp->queue_last = 0;
+	endp->queue_next = 0;
+	endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
+	spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+	u132_endp_queue_work(u132, endp, msecs_to_jiffies(urb->interval));
+	return 0;
+}
+
+static int queue_int_on_old_endpoint(struct u132 *u132,
+	struct u132_udev *udev, struct urb *urb,
+	struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
+	u8 usb_endp, u8 address)
+{
+	urb->hcpriv = u132;
+	endp->delayed = 1;
+	endp->jiffies = jiffies + msecs_to_jiffies(urb->interval);
+	if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
+		endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
+	} else {
+		struct u132_urbq *urbq = kmalloc(sizeof(struct u132_urbq),
+			GFP_ATOMIC);
+		if (urbq == NULL) {
+			endp->queue_size -= 1;
+			return -ENOMEM;
+		} else {
+			list_add_tail(&urbq->urb_more, &endp->urb_more);
+			urbq->urb = urb;
+		}
+	}
+	return 0;
 }
 
 static int create_endpoint_and_queue_bulk(struct u132 *u132,
-        struct u132_udev *udev, struct usb_host_endpoint *hep, struct urb *urb,
-        struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp, u8 address,
-        gfp_t mem_flags)
-{
-        int ring_number;
-        struct u132_ring *ring;
-        unsigned long irqs;
-        u8 endp_number = ++u132->num_endpoints;
-        struct u132_endp *endp = hep->hcpriv = u132->endp[endp_number - 1] =
-                kmalloc(sizeof(struct u132_endp), mem_flags);
-        if (!endp) {
-                return -ENOMEM;
-        }
-        INIT_DELAYED_WORK(&endp->scheduler, u132_hcd_endp_work_scheduler);
-        spin_lock_init(&endp->queue_lock.slock);
-        INIT_LIST_HEAD(&endp->urb_more);
-        endp->dequeueing = 0;
-        endp->edset_flush = 0;
-        endp->active = 0;
-        endp->delayed = 0;
-        endp->endp_number = endp_number;
-        endp->u132 = u132;
-        endp->hep = hep;
-        endp->pipetype = usb_pipetype(urb->pipe);
-        u132_endp_init_kref(u132, endp);
-        if (usb_pipein(urb->pipe)) {
-                endp->toggle_bits = 0x2;
-                usb_settoggle(udev->usb_device, usb_endp, 0, 0);
-                ring_number = 3;
-                endp->input = 1;
-                endp->output = 0;
-                udev->endp_number_in[usb_endp] = endp_number;
-                u132_udev_get_kref(u132, udev);
-        } else {
-                endp->toggle_bits = 0x2;
-                usb_settoggle(udev->usb_device, usb_endp, 1, 0);
-                ring_number = 2;
-                endp->input = 0;
-                endp->output = 1;
-                udev->endp_number_out[usb_endp] = endp_number;
-                u132_udev_get_kref(u132, udev);
-        }
-        ring = endp->ring = &u132->ring[ring_number - 1];
-        if (ring->curr_endp) {
-                list_add_tail(&endp->endp_ring, &ring->curr_endp->endp_ring);
-        } else {
-                INIT_LIST_HEAD(&endp->endp_ring);
-                ring->curr_endp = endp;
-        }
-        ring->length += 1;
-        urb->hcpriv = u132;
-        spin_lock_irqsave(&endp->queue_lock.slock, irqs);
-        endp->udev_number = address;
-        endp->usb_addr = usb_addr;
-        endp->usb_endp = usb_endp;
-        endp->queue_size = 1;
-        endp->queue_last = 0;
-        endp->queue_next = 0;
-        endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
-        spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-        u132_endp_queue_work(u132, endp, 0);
-        return 0;
+	struct u132_udev *udev, struct urb *urb,
+	struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp, u8 address,
+	gfp_t mem_flags)
+{
+	int ring_number;
+	struct u132_ring *ring;
+	unsigned long irqs;
+	int rc;
+	u8 endp_number;
+	struct u132_endp *endp = kmalloc(sizeof(struct u132_endp), mem_flags);
+
+	if (!endp)
+		return -ENOMEM;
+
+	spin_lock_init(&endp->queue_lock.slock);
+	spin_lock_irqsave(&endp->queue_lock.slock, irqs);
+	rc = usb_hcd_link_urb_to_ep(u132_to_hcd(u132), urb);
+	if (rc) {
+		spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+		kfree(endp);
+		return rc;
+	}
+
+	endp_number = ++u132->num_endpoints;
+	urb->ep->hcpriv = u132->endp[endp_number - 1] = endp;
+	INIT_DELAYED_WORK(&endp->scheduler, u132_hcd_endp_work_scheduler);
+	INIT_LIST_HEAD(&endp->urb_more);
+	endp->dequeueing = 0;
+	endp->edset_flush = 0;
+	endp->active = 0;
+	endp->delayed = 0;
+	endp->endp_number = endp_number;
+	endp->u132 = u132;
+	endp->hep = urb->ep;
+	endp->pipetype = usb_pipetype(urb->pipe);
+	u132_endp_init_kref(u132, endp);
+	if (usb_pipein(urb->pipe)) {
+		endp->toggle_bits = 0x2;
+		usb_settoggle(udev->usb_device, usb_endp, 0, 0);
+		ring_number = 3;
+		endp->input = 1;
+		endp->output = 0;
+		udev->endp_number_in[usb_endp] = endp_number;
+		u132_udev_get_kref(u132, udev);
+	} else {
+		endp->toggle_bits = 0x2;
+		usb_settoggle(udev->usb_device, usb_endp, 1, 0);
+		ring_number = 2;
+		endp->input = 0;
+		endp->output = 1;
+		udev->endp_number_out[usb_endp] = endp_number;
+		u132_udev_get_kref(u132, udev);
+	}
+	ring = endp->ring = &u132->ring[ring_number - 1];
+	if (ring->curr_endp) {
+		list_add_tail(&endp->endp_ring, &ring->curr_endp->endp_ring);
+	} else {
+		INIT_LIST_HEAD(&endp->endp_ring);
+		ring->curr_endp = endp;
+	}
+	ring->length += 1;
+	urb->hcpriv = u132;
+	endp->udev_number = address;
+	endp->usb_addr = usb_addr;
+	endp->usb_endp = usb_endp;
+	endp->queue_size = 1;
+	endp->queue_last = 0;
+	endp->queue_next = 0;
+	endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
+	spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+	u132_endp_queue_work(u132, endp, 0);
+	return 0;
 }
 
 static int queue_bulk_on_old_endpoint(struct u132 *u132, struct u132_udev *udev,
-         struct usb_host_endpoint *hep, struct urb *urb,
-        struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
-        u8 usb_endp, u8 address)
-{
-        urb->hcpriv = u132;
-        if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
-                endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
-        } else {
-                struct u132_urbq *urbq = kmalloc(sizeof(struct u132_urbq),
-                        GFP_ATOMIC);
-                if (urbq == NULL) {
-                        endp->queue_size -= 1;
-                        return -ENOMEM;
-                } else {
-                        list_add_tail(&urbq->urb_more, &endp->urb_more);
-                        urbq->urb = urb;
-                }
-        }
-        return 0;
+	struct urb *urb,
+	struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
+	u8 usb_endp, u8 address)
+{
+	urb->hcpriv = u132;
+	if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
+		endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
+	} else {
+		struct u132_urbq *urbq = kmalloc(sizeof(struct u132_urbq),
+			GFP_ATOMIC);
+		if (urbq == NULL) {
+			endp->queue_size -= 1;
+			return -ENOMEM;
+		} else {
+			list_add_tail(&urbq->urb_more, &endp->urb_more);
+			urbq->urb = urb;
+		}
+	}
+	return 0;
 }
 
 static int create_endpoint_and_queue_control(struct u132 *u132,
-        struct usb_host_endpoint *hep, struct urb *urb,
-        struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp,
-        gfp_t mem_flags)
-{
-        struct u132_ring *ring;
-        u8 endp_number = ++u132->num_endpoints;
-        struct u132_endp *endp = hep->hcpriv = u132->endp[endp_number - 1] =
-                kmalloc(sizeof(struct u132_endp), mem_flags);
-        if (!endp) {
-                return -ENOMEM;
-        }
-        INIT_DELAYED_WORK(&endp->scheduler, u132_hcd_endp_work_scheduler);
-        spin_lock_init(&endp->queue_lock.slock);
-        INIT_LIST_HEAD(&endp->urb_more);
-        ring = endp->ring = &u132->ring[0];
-        if (ring->curr_endp) {
-                list_add_tail(&endp->endp_ring, &ring->curr_endp->endp_ring);
-        } else {
-                INIT_LIST_HEAD(&endp->endp_ring);
-                ring->curr_endp = endp;
-        }
-        ring->length += 1;
-        endp->dequeueing = 0;
-        endp->edset_flush = 0;
-        endp->active = 0;
-        endp->delayed = 0;
-        endp->endp_number = endp_number;
-        endp->u132 = u132;
-        endp->hep = hep;
-        u132_endp_init_kref(u132, endp);
-        u132_endp_get_kref(u132, endp);
-        if (usb_addr == 0) {
-                unsigned long irqs;
-                u8 address = u132->addr[usb_addr].address;
-                struct u132_udev *udev = &u132->udev[address];
-                endp->udev_number = address;
-                endp->usb_addr = usb_addr;
-                endp->usb_endp = usb_endp;
-                endp->input = 1;
-                endp->output = 1;
-                endp->pipetype = usb_pipetype(urb->pipe);
-                u132_udev_init_kref(u132, udev);
-                u132_udev_get_kref(u132, udev);
-                udev->endp_number_in[usb_endp] = endp_number;
-                udev->endp_number_out[usb_endp] = endp_number;
-                urb->hcpriv = u132;
-                spin_lock_irqsave(&endp->queue_lock.slock, irqs);
-                endp->queue_size = 1;
-                endp->queue_last = 0;
-                endp->queue_next = 0;
-                endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
-                spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                u132_endp_queue_work(u132, endp, 0);
-                return 0;
-        } else {                /*(usb_addr > 0) */
-                unsigned long irqs;
-                u8 address = u132->addr[usb_addr].address;
-                struct u132_udev *udev = &u132->udev[address];
-                endp->udev_number = address;
-                endp->usb_addr = usb_addr;
-                endp->usb_endp = usb_endp;
-                endp->input = 1;
-                endp->output = 1;
-                endp->pipetype = usb_pipetype(urb->pipe);
-                u132_udev_get_kref(u132, udev);
-                udev->enumeration = 2;
-                udev->endp_number_in[usb_endp] = endp_number;
-                udev->endp_number_out[usb_endp] = endp_number;
-                urb->hcpriv = u132;
-                spin_lock_irqsave(&endp->queue_lock.slock, irqs);
-                endp->queue_size = 1;
-                endp->queue_last = 0;
-                endp->queue_next = 0;
-                endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
-                spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                u132_endp_queue_work(u132, endp, 0);
-                return 0;
-        }
+	struct urb *urb,
+	struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp,
+	gfp_t mem_flags)
+{
+	struct u132_ring *ring;
+	unsigned long irqs;
+	int rc;
+	u8 endp_number;
+	struct u132_endp *endp = kmalloc(sizeof(struct u132_endp), mem_flags);
+
+	if (!endp)
+		return -ENOMEM;
+
+	spin_lock_init(&endp->queue_lock.slock);
+	spin_lock_irqsave(&endp->queue_lock.slock, irqs);
+	rc = usb_hcd_link_urb_to_ep(u132_to_hcd(u132), urb);
+	if (rc) {
+		spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+		kfree(endp);
+		return rc;
+	}
+
+	endp_number = ++u132->num_endpoints;
+	urb->ep->hcpriv = u132->endp[endp_number - 1] = endp;
+	INIT_DELAYED_WORK(&endp->scheduler, u132_hcd_endp_work_scheduler);
+	INIT_LIST_HEAD(&endp->urb_more);
+	ring = endp->ring = &u132->ring[0];
+	if (ring->curr_endp) {
+		list_add_tail(&endp->endp_ring, &ring->curr_endp->endp_ring);
+	} else {
+		INIT_LIST_HEAD(&endp->endp_ring);
+		ring->curr_endp = endp;
+	}
+	ring->length += 1;
+	endp->dequeueing = 0;
+	endp->edset_flush = 0;
+	endp->active = 0;
+	endp->delayed = 0;
+	endp->endp_number = endp_number;
+	endp->u132 = u132;
+	endp->hep = urb->ep;
+	u132_endp_init_kref(u132, endp);
+	u132_endp_get_kref(u132, endp);
+	if (usb_addr == 0) {
+		u8 address = u132->addr[usb_addr].address;
+		struct u132_udev *udev = &u132->udev[address];
+		endp->udev_number = address;
+		endp->usb_addr = usb_addr;
+		endp->usb_endp = usb_endp;
+		endp->input = 1;
+		endp->output = 1;
+		endp->pipetype = usb_pipetype(urb->pipe);
+		u132_udev_init_kref(u132, udev);
+		u132_udev_get_kref(u132, udev);
+		udev->endp_number_in[usb_endp] = endp_number;
+		udev->endp_number_out[usb_endp] = endp_number;
+		urb->hcpriv = u132;
+		endp->queue_size = 1;
+		endp->queue_last = 0;
+		endp->queue_next = 0;
+		endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
+		spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+		u132_endp_queue_work(u132, endp, 0);
+		return 0;
+	} else {		/*(usb_addr > 0) */
+		u8 address = u132->addr[usb_addr].address;
+		struct u132_udev *udev = &u132->udev[address];
+		endp->udev_number = address;
+		endp->usb_addr = usb_addr;
+		endp->usb_endp = usb_endp;
+		endp->input = 1;
+		endp->output = 1;
+		endp->pipetype = usb_pipetype(urb->pipe);
+		u132_udev_get_kref(u132, udev);
+		udev->enumeration = 2;
+		udev->endp_number_in[usb_endp] = endp_number;
+		udev->endp_number_out[usb_endp] = endp_number;
+		urb->hcpriv = u132;
+		endp->queue_size = 1;
+		endp->queue_last = 0;
+		endp->queue_next = 0;
+		endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;
+		spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+		u132_endp_queue_work(u132, endp, 0);
+		return 0;
+	}
 }
 
 static int queue_control_on_old_endpoint(struct u132 *u132,
-        struct usb_host_endpoint *hep, struct urb *urb,
-        struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
-        u8 usb_endp)
-{
-        if (usb_addr == 0) {
-                if (usb_pipein(urb->pipe)) {
-                        urb->hcpriv = u132;
-                        if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
-                                endp->urb_list[ENDP_QUEUE_MASK &
-                                        endp->queue_last++] = urb;
-                        } else {
-                                struct u132_urbq *urbq =
-                                        kmalloc(sizeof(struct u132_urbq),
-                                        GFP_ATOMIC);
-                                if (urbq == NULL) {
-                                        endp->queue_size -= 1;
-                                        return -ENOMEM;
-                                } else {
-                                        list_add_tail(&urbq->urb_more,
-                                                &endp->urb_more);
-                                        urbq->urb = urb;
-                                }
-                        }
-                        return 0;
-                } else {        /* usb_pipeout(urb->pipe) */
-                        struct u132_addr *addr = &u132->addr[usb_dev->devnum];
-                        int I = MAX_U132_UDEVS;
-                        int i = 0;
-                        while (--I > 0) {
-                                struct u132_udev *udev = &u132->udev[++i];
-                                if (udev->usb_device) {
-                                        continue;
-                                } else {
-                                        udev->enumeration = 1;
-                                        u132->addr[0].address = i;
-                                        endp->udev_number = i;
-                                        udev->udev_number = i;
-                                        udev->usb_addr = usb_dev->devnum;
-                                        u132_udev_init_kref(u132, udev);
-                                        udev->endp_number_in[usb_endp] =
-                                                endp->endp_number;
-                                        u132_udev_get_kref(u132, udev);
-                                        udev->endp_number_out[usb_endp] =
-                                                endp->endp_number;
-                                        udev->usb_device = usb_dev;
-                                        ((u8 *) (urb->setup_packet))[2] =
-                                                addr->address = i;
-                                        u132_udev_get_kref(u132, udev);
-                                        break;
-                                }
-                        }
-                        if (I == 0) {
-                                dev_err(&u132->platform_dev->dev, "run out of d"
-                                        "evice space\n");
-                                return -EINVAL;
-                        }
-                        urb->hcpriv = u132;
-                        if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
-                                endp->urb_list[ENDP_QUEUE_MASK &
-                                        endp->queue_last++] = urb;
-                        } else {
-                                struct u132_urbq *urbq =
-                                        kmalloc(sizeof(struct u132_urbq),
-                                        GFP_ATOMIC);
-                                if (urbq == NULL) {
-                                        endp->queue_size -= 1;
-                                        return -ENOMEM;
-                                } else {
-                                        list_add_tail(&urbq->urb_more,
-                                                &endp->urb_more);
-                                        urbq->urb = urb;
-                                }
-                        }
-                        return 0;
-                }
-        } else {                /*(usb_addr > 0) */
-                u8 address = u132->addr[usb_addr].address;
-                struct u132_udev *udev = &u132->udev[address];
-                urb->hcpriv = u132;
-                if (udev->enumeration == 2) {
-                } else
-                        udev->enumeration = 2;
-                if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
-                        endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] =
-                                urb;
-                } else {
-                        struct u132_urbq *urbq =
-                                kmalloc(sizeof(struct u132_urbq), GFP_ATOMIC);
-                        if (urbq == NULL) {
-                                endp->queue_size -= 1;
-                                return -ENOMEM;
-                        } else {
-                                list_add_tail(&urbq->urb_more, &endp->urb_more);
-                                urbq->urb = urb;
-                        }
-                }
-                return 0;
-        }
-}
-
-static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
-        struct urb *urb, gfp_t mem_flags)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (irqs_disabled()) {
-                if (__GFP_WAIT & mem_flags) {
-                        printk(KERN_ERR "invalid context for function that migh"
-                                "t sleep\n");
-                        return -EINVAL;
-                }
-        }
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb->status);
-                return -ESHUTDOWN;
-        } else {
-                u8 usb_addr = usb_pipedevice(urb->pipe);
-                u8 usb_endp = usb_pipeendpoint(urb->pipe);
-                struct usb_device *usb_dev = urb->dev;
-                if (usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {
-                        u8 address = u132->addr[usb_addr].address;
-                        struct u132_udev *udev = &u132->udev[address];
-                        struct u132_endp *endp = hep->hcpriv;
-                        urb->actual_length = 0;
-                        if (endp) {
-                                unsigned long irqs;
-                                int retval;
-                                spin_lock_irqsave(&endp->queue_lock.slock,
-                                        irqs);
-                                retval = queue_int_on_old_endpoint(u132, udev,
-                                        hep, urb, usb_dev, endp, usb_addr,
-                                        usb_endp, address);
-                                spin_unlock_irqrestore(&endp->queue_lock.slock,
-                                        irqs);
-                                if (retval) {
-                                        return retval;
-                                } else {
-                                        u132_endp_queue_work(u132, endp,
-                                                msecs_to_jiffies(urb->interval))
-                                                ;
-                                        return 0;
-                                }
-                        } else if (u132->num_endpoints == MAX_U132_ENDPS) {
-                                return -EINVAL;
-                        } else {        /*(endp == NULL) */
-                                return create_endpoint_and_queue_int(u132, udev,
-                                         hep, urb, usb_dev, usb_addr, usb_endp,
-                                        address, mem_flags);
-                        }
-                } else if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
-                        dev_err(&u132->platform_dev->dev, "the hardware does no"
-                                "t support PIPE_ISOCHRONOUS\n");
-                        return -EINVAL;
-                } else if (usb_pipetype(urb->pipe) == PIPE_BULK) {
-                        u8 address = u132->addr[usb_addr].address;
-                        struct u132_udev *udev = &u132->udev[address];
-                        struct u132_endp *endp = hep->hcpriv;
-                        urb->actual_length = 0;
-                        if (endp) {
-                                unsigned long irqs;
-                                int retval;
-                                spin_lock_irqsave(&endp->queue_lock.slock,
-                                        irqs);
-                                retval = queue_bulk_on_old_endpoint(u132, udev,
-                                        hep, urb, usb_dev, endp, usb_addr,
-                                        usb_endp, address);
-                                spin_unlock_irqrestore(&endp->queue_lock.slock,
-                                        irqs);
-                                if (retval) {
-                                        return retval;
-                                } else {
-                                        u132_endp_queue_work(u132, endp, 0);
-                                        return 0;
-                                }
-                        } else if (u132->num_endpoints == MAX_U132_ENDPS) {
-                                return -EINVAL;
-                        } else
-                                return create_endpoint_and_queue_bulk(u132,
-                                        udev, hep, urb, usb_dev, usb_addr,
-                                        usb_endp, address, mem_flags);
-                } else {
-                        struct u132_endp *endp = hep->hcpriv;
-                        u16 urb_size = 8;
-                        u8 *b = urb->setup_packet;
-                        int i = 0;
-                        char data[30 *3 + 4];
-                        char *d = data;
-                        int m = (sizeof(data) - 1) / 3;
-                        int l = 0;
-                        data[0] = 0;
-                        while (urb_size-- > 0) {
-                                if (i > m) {
-                                } else if (i++ < m) {
-                                        int w = sprintf(d, " %02X", *b++);
-                                        d += w;
-                                        l += w;
-                                } else
-                                        d += sprintf(d, " ..");
-                        }
-                        if (endp) {
-                                unsigned long irqs;
-                                int retval;
-                                spin_lock_irqsave(&endp->queue_lock.slock,
-                                        irqs);
-                                retval = queue_control_on_old_endpoint(u132,
-                                        hep, urb, usb_dev, endp, usb_addr,
-                                        usb_endp);
-                                spin_unlock_irqrestore(&endp->queue_lock.slock,
-                                        irqs);
-                                if (retval) {
-                                        return retval;
-                                } else {
-                                        u132_endp_queue_work(u132, endp, 0);
-                                        return 0;
-                                }
-                        } else if (u132->num_endpoints == MAX_U132_ENDPS) {
-                                return -EINVAL;
-                        } else
-                                return create_endpoint_and_queue_control(u132,
-                                        hep, urb, usb_dev, usb_addr, usb_endp,
-                                        mem_flags);
-                }
-        }
+	struct urb *urb,
+	struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
+	u8 usb_endp)
+{
+	if (usb_addr == 0) {
+		if (usb_pipein(urb->pipe)) {
+			urb->hcpriv = u132;
+			if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
+				endp->urb_list[ENDP_QUEUE_MASK &
+					endp->queue_last++] = urb;
+			} else {
+				struct u132_urbq *urbq =
+					kmalloc(sizeof(struct u132_urbq),
+					GFP_ATOMIC);
+				if (urbq == NULL) {
+					endp->queue_size -= 1;
+					return -ENOMEM;
+				} else {
+					list_add_tail(&urbq->urb_more,
+						&endp->urb_more);
+					urbq->urb = urb;
+				}
+			}
+			return 0;
+		} else {	/* usb_pipeout(urb->pipe) */
+			struct u132_addr *addr = &u132->addr[usb_dev->devnum];
+			int I = MAX_U132_UDEVS;
+			int i = 0;
+			while (--I > 0) {
+				struct u132_udev *udev = &u132->udev[++i];
+				if (udev->usb_device) {
+					continue;
+				} else {
+					udev->enumeration = 1;
+					u132->addr[0].address = i;
+					endp->udev_number = i;
+					udev->udev_number = i;
+					udev->usb_addr = usb_dev->devnum;
+					u132_udev_init_kref(u132, udev);
+					udev->endp_number_in[usb_endp] =
+						endp->endp_number;
+					u132_udev_get_kref(u132, udev);
+					udev->endp_number_out[usb_endp] =
+						endp->endp_number;
+					udev->usb_device = usb_dev;
+					((u8 *) (urb->setup_packet))[2] =
+						addr->address = i;
+					u132_udev_get_kref(u132, udev);
+					break;
+				}
+			}
+			if (I == 0) {
+				dev_err(&u132->platform_dev->dev, "run out of d"
+					"evice space\n");
+				return -EINVAL;
+			}
+			urb->hcpriv = u132;
+			if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
+				endp->urb_list[ENDP_QUEUE_MASK &
+					endp->queue_last++] = urb;
+			} else {
+				struct u132_urbq *urbq =
+					kmalloc(sizeof(struct u132_urbq),
+					GFP_ATOMIC);
+				if (urbq == NULL) {
+					endp->queue_size -= 1;
+					return -ENOMEM;
+				} else {
+					list_add_tail(&urbq->urb_more,
+						&endp->urb_more);
+					urbq->urb = urb;
+				}
+			}
+			return 0;
+		}
+	} else {		/*(usb_addr > 0) */
+		u8 address = u132->addr[usb_addr].address;
+		struct u132_udev *udev = &u132->udev[address];
+		urb->hcpriv = u132;
+		if (udev->enumeration != 2)
+			udev->enumeration = 2;
+		if (endp->queue_size++ < ENDP_QUEUE_SIZE) {
+			endp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] =
+				urb;
+		} else {
+			struct u132_urbq *urbq =
+				kmalloc(sizeof(struct u132_urbq), GFP_ATOMIC);
+			if (urbq == NULL) {
+				endp->queue_size -= 1;
+				return -ENOMEM;
+			} else {
+				list_add_tail(&urbq->urb_more, &endp->urb_more);
+				urbq->urb = urb;
+			}
+		}
+		return 0;
+	}
+}
+
+static int u132_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
+		gfp_t mem_flags)
+{
+	struct u132 *u132 = hcd_to_u132(hcd);
+	if (irqs_disabled()) {
+		if (__GFP_WAIT & mem_flags) {
+			printk(KERN_ERR "invalid context for function that migh"
+				"t sleep\n");
+			return -EINVAL;
+		}
+	}
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		return -ENODEV;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed "
+				"urb=%p\n", urb);
+		return -ESHUTDOWN;
+	} else {
+		u8 usb_addr = usb_pipedevice(urb->pipe);
+		u8 usb_endp = usb_pipeendpoint(urb->pipe);
+		struct usb_device *usb_dev = urb->dev;
+		if (usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {
+			u8 address = u132->addr[usb_addr].address;
+			struct u132_udev *udev = &u132->udev[address];
+			struct u132_endp *endp = urb->ep->hcpriv;
+			urb->actual_length = 0;
+			if (endp) {
+				unsigned long irqs;
+				int retval;
+				spin_lock_irqsave(&endp->queue_lock.slock,
+					irqs);
+				retval = usb_hcd_link_urb_to_ep(hcd, urb);
+				if (retval == 0) {
+					retval = queue_int_on_old_endpoint(
+							u132, udev, urb,
+							usb_dev, endp,
+							usb_addr, usb_endp,
+							address);
+					if (retval)
+						usb_hcd_unlink_urb_from_ep(
+	hcd, urb);
+				}
+				spin_unlock_irqrestore(&endp->queue_lock.slock,
+					irqs);
+				if (retval) {
+					return retval;
+				} else {
+					u132_endp_queue_work(u132, endp,
+						msecs_to_jiffies(urb->interval))
+						;
+					return 0;
+				}
+			} else if (u132->num_endpoints == MAX_U132_ENDPS) {
+				return -EINVAL;
+			} else {	/*(endp == NULL) */
+				return create_endpoint_and_queue_int(u132, udev,
+						urb, usb_dev, usb_addr,
+						usb_endp, address, mem_flags);
+			}
+		} else if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
+			dev_err(&u132->platform_dev->dev, "the hardware does no"
+				"t support PIPE_ISOCHRONOUS\n");
+			return -EINVAL;
+		} else if (usb_pipetype(urb->pipe) == PIPE_BULK) {
+			u8 address = u132->addr[usb_addr].address;
+			struct u132_udev *udev = &u132->udev[address];
+			struct u132_endp *endp = urb->ep->hcpriv;
+			urb->actual_length = 0;
+			if (endp) {
+				unsigned long irqs;
+				int retval;
+				spin_lock_irqsave(&endp->queue_lock.slock,
+					irqs);
+				retval = usb_hcd_link_urb_to_ep(hcd, urb);
+				if (retval == 0) {
+					retval = queue_bulk_on_old_endpoint(
+							u132, udev, urb,
+							usb_dev, endp,
+							usb_addr, usb_endp,
+							address);
+					if (retval)
+						usb_hcd_unlink_urb_from_ep(
+	hcd, urb);
+				}
+				spin_unlock_irqrestore(&endp->queue_lock.slock,
+					irqs);
+				if (retval) {
+					return retval;
+				} else {
+					u132_endp_queue_work(u132, endp, 0);
+					return 0;
+				}
+			} else if (u132->num_endpoints == MAX_U132_ENDPS) {
+				return -EINVAL;
+			} else
+				return create_endpoint_and_queue_bulk(u132,
+					udev, urb, usb_dev, usb_addr,
+					usb_endp, address, mem_flags);
+		} else {
+			struct u132_endp *endp = urb->ep->hcpriv;
+			u16 urb_size = 8;
+			u8 *b = urb->setup_packet;
+			int i = 0;
+			char data[30 * 3 + 4];
+			char *d = data;
+			int m = (sizeof(data) - 1) / 3;
+			int l = 0;
+			data[0] = 0;
+			while (urb_size-- > 0) {
+				if (i > m) {
+				} else if (i++ < m) {
+					int w = sprintf(d, " %02X", *b++);
+					d += w;
+					l += w;
+				} else
+					d += sprintf(d, " ..");
+			}
+			if (endp) {
+				unsigned long irqs;
+				int retval;
+				spin_lock_irqsave(&endp->queue_lock.slock,
+					irqs);
+				retval = usb_hcd_link_urb_to_ep(hcd, urb);
+				if (retval == 0) {
+					retval = queue_control_on_old_endpoint(
+							u132, urb, usb_dev,
+							endp, usb_addr,
+							usb_endp);
+					if (retval)
+						usb_hcd_unlink_urb_from_ep(
+								hcd, urb);
+				}
+				spin_unlock_irqrestore(&endp->queue_lock.slock,
+					irqs);
+				if (retval) {
+					return retval;
+				} else {
+					u132_endp_queue_work(u132, endp, 0);
+					return 0;
+				}
+			} else if (u132->num_endpoints == MAX_U132_ENDPS) {
+				return -EINVAL;
+			} else
+				return create_endpoint_and_queue_control(u132,
+					urb, usb_dev, usb_addr, usb_endp,
+					mem_flags);
+		}
+	}
 }
 
 static int dequeue_from_overflow_chain(struct u132 *u132,
-        struct u132_endp *endp, struct urb *urb)
+	struct u132_endp *endp, struct urb *urb)
 {
-        struct list_head *scan;
-        struct list_head *head = &endp->urb_more;
-        list_for_each(scan, head) {
-                struct u132_urbq *urbq = list_entry(scan, struct u132_urbq,
-                        urb_more);
-                if (urbq->urb == urb) {
-                        struct usb_hcd *hcd = u132_to_hcd(u132);
-                        list_del(scan);
-                        endp->queue_size -= 1;
-                        urb->error_count = 0;
-                        urb->hcpriv = NULL;
-                        usb_hcd_giveback_urb(hcd, urb);
-                        return 0;
-                } else
-                        continue;
-        }
-        dev_err(&u132->platform_dev->dev, "urb=%p not found in endp[%d]=%p ring"
-                "[%d] %c%c usb_endp=%d usb_addr=%d size=%d next=%04X last=%04X"
-                "\n", urb, endp->endp_number, endp, endp->ring->number,
-                endp->input ? 'I' : ' ', endp->output ? 'O' : ' ',
-                endp->usb_endp, endp->usb_addr, endp->queue_size,
-                endp->queue_next, endp->queue_last);
-        return -EINVAL;
+	struct list_head *scan;
+	struct list_head *head = &endp->urb_more;
+	list_for_each(scan, head) {
+		struct u132_urbq *urbq = list_entry(scan, struct u132_urbq,
+			urb_more);
+		if (urbq->urb == urb) {
+			struct usb_hcd *hcd = u132_to_hcd(u132);
+			list_del(scan);
+			endp->queue_size -= 1;
+			urb->error_count = 0;
+			usb_hcd_giveback_urb(hcd, urb, 0);
+			return 0;
+		} else
+			continue;
+	}
+	dev_err(&u132->platform_dev->dev, "urb=%p not found in endp[%d]=%p ring"
+		"[%d] %c%c usb_endp=%d usb_addr=%d size=%d next=%04X last=%04X"
+		"\n", urb, endp->endp_number, endp, endp->ring->number,
+		endp->input ? 'I' : ' ', endp->output ? 'O' : ' ',
+		endp->usb_endp, endp->usb_addr, endp->queue_size,
+		endp->queue_next, endp->queue_last);
+	return -EINVAL;
 }
 
 static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
-        struct urb *urb)
+		struct urb *urb, int status)
 {
-        unsigned long irqs;
-        spin_lock_irqsave(&endp->queue_lock.slock, irqs);
-        if (endp->queue_size == 0) {
-                dev_err(&u132->platform_dev->dev, "urb=%p not found in endp[%d]"
-                        "=%p ring[%d] %c%c usb_endp=%d usb_addr=%d\n", urb,
-                        endp->endp_number, endp, endp->ring->number,
-                        endp->input ? 'I' : ' ', endp->output ? 'O' : ' ',
-                        endp->usb_endp, endp->usb_addr);
-                spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                return -EINVAL;
-        }
-        if (urb == endp->urb_list[ENDP_QUEUE_MASK & endp->queue_next]) {
-                if (endp->active) {
-                        endp->dequeueing = 1;
-                        endp->edset_flush = 1;
-                        u132_endp_queue_work(u132, endp, 0);
-                        spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                        urb->hcpriv = NULL;
-                        return 0;
-                } else {
-                        spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                        u132_hcd_abandon_urb(u132, endp, urb, urb->status);
-                        return 0;
-                }
-        } else {
-                u16 queue_list = 0;
-                u16 queue_size = endp->queue_size;
-                u16 queue_scan = endp->queue_next;
-                struct urb **urb_slot = NULL;
-                while (++queue_list < ENDP_QUEUE_SIZE && --queue_size > 0) {
-                        if (urb == endp->urb_list[ENDP_QUEUE_MASK &
-                                ++queue_scan]) {
-                                urb_slot = &endp->urb_list[ENDP_QUEUE_MASK &
-                                        queue_scan];
-                                break;
-                        } else
-                                continue;
-                }
-                while (++queue_list < ENDP_QUEUE_SIZE && --queue_size > 0) {
-                        *urb_slot = endp->urb_list[ENDP_QUEUE_MASK &
-                                ++queue_scan];
-                        urb_slot = &endp->urb_list[ENDP_QUEUE_MASK &
-                                queue_scan];
-                }
-                if (urb_slot) {
-                        struct usb_hcd *hcd = u132_to_hcd(u132);
-                        endp->queue_size -= 1;
-                        if (list_empty(&endp->urb_more)) {
-                                spin_unlock_irqrestore(&endp->queue_lock.slock,
-                                        irqs);
-                        } else {
-                                struct list_head *next = endp->urb_more.next;
-                                struct u132_urbq *urbq = list_entry(next,
-                                        struct u132_urbq, urb_more);
-                                list_del(next);
-                                *urb_slot = urbq->urb;
-                                spin_unlock_irqrestore(&endp->queue_lock.slock,
-                                        irqs);
-                                kfree(urbq);
-                        } urb->error_count = 0;
-                        urb->hcpriv = NULL;
-                        usb_hcd_giveback_urb(hcd, urb);
-                        return 0;
-                } else if (list_empty(&endp->urb_more)) {
-                        dev_err(&u132->platform_dev->dev, "urb=%p not found in "
-                                "endp[%d]=%p ring[%d] %c%c usb_endp=%d usb_addr"
-                                "=%d size=%d next=%04X last=%04X\n", urb,
-                                endp->endp_number, endp, endp->ring->number,
-                                endp->input ? 'I' : ' ',
-                                endp->output ? 'O' : ' ', endp->usb_endp,
-                                endp->usb_addr, endp->queue_size,
-                                endp->queue_next, endp->queue_last);
-                        spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                        return -EINVAL;
-                } else {
-                        int retval = dequeue_from_overflow_chain(u132, endp,
-                                urb);
-                        spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
-                        return retval;
-                }
-        }
-}
-
-static int u132_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 2) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else {
-                u8 usb_addr = usb_pipedevice(urb->pipe);
-                u8 usb_endp = usb_pipeendpoint(urb->pipe);
-                u8 address = u132->addr[usb_addr].address;
-                struct u132_udev *udev = &u132->udev[address];
-                if (usb_pipein(urb->pipe)) {
-                        u8 endp_number = udev->endp_number_in[usb_endp];
-                        struct u132_endp *endp = u132->endp[endp_number - 1];
-                        return u132_endp_urb_dequeue(u132, endp, urb);
-                } else {
-                        u8 endp_number = udev->endp_number_out[usb_endp];
-                        struct u132_endp *endp = u132->endp[endp_number - 1];
-                        return u132_endp_urb_dequeue(u132, endp, urb);
-                }
-        }
+	unsigned long irqs;
+	int rc;
+
+	spin_lock_irqsave(&endp->queue_lock.slock, irqs);
+	rc = usb_hcd_check_unlink_urb(u132_to_hcd(u132), urb, status);
+	if (rc) {
+		spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+		return rc;
+	}
+	if (endp->queue_size == 0) {
+		dev_err(&u132->platform_dev->dev, "urb=%p not found in endp[%d]"
+			"=%p ring[%d] %c%c usb_endp=%d usb_addr=%d\n", urb,
+			endp->endp_number, endp, endp->ring->number,
+			endp->input ? 'I' : ' ', endp->output ? 'O' : ' ',
+			endp->usb_endp, endp->usb_addr);
+		spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+		return -EINVAL;
+	}
+	if (urb == endp->urb_list[ENDP_QUEUE_MASK & endp->queue_next]) {
+		if (endp->active) {
+			endp->dequeueing = 1;
+			endp->edset_flush = 1;
+			u132_endp_queue_work(u132, endp, 0);
+			spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+			return 0;
+		} else {
+			spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+			u132_hcd_abandon_urb(u132, endp, urb, status);
+			return 0;
+		}
+	} else {
+		u16 queue_list = 0;
+		u16 queue_size = endp->queue_size;
+		u16 queue_scan = endp->queue_next;
+		struct urb **urb_slot = NULL;
+		while (++queue_list < ENDP_QUEUE_SIZE && --queue_size > 0) {
+			if (urb == endp->urb_list[ENDP_QUEUE_MASK &
+				++queue_scan]) {
+				urb_slot = &endp->urb_list[ENDP_QUEUE_MASK &
+					queue_scan];
+				break;
+			} else
+				continue;
+		}
+		while (++queue_list < ENDP_QUEUE_SIZE && --queue_size > 0) {
+			*urb_slot = endp->urb_list[ENDP_QUEUE_MASK &
+				++queue_scan];
+			urb_slot = &endp->urb_list[ENDP_QUEUE_MASK &
+				queue_scan];
+		}
+		if (urb_slot) {
+			struct usb_hcd *hcd = u132_to_hcd(u132);
+
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
+			endp->queue_size -= 1;
+			if (list_empty(&endp->urb_more)) {
+				spin_unlock_irqrestore(&endp->queue_lock.slock,
+					irqs);
+			} else {
+				struct list_head *next = endp->urb_more.next;
+				struct u132_urbq *urbq = list_entry(next,
+					struct u132_urbq, urb_more);
+				list_del(next);
+				*urb_slot = urbq->urb;
+				spin_unlock_irqrestore(&endp->queue_lock.slock,
+					irqs);
+				kfree(urbq);
+			} urb->error_count = 0;
+			usb_hcd_giveback_urb(hcd, urb, status);
+			return 0;
+		} else if (list_empty(&endp->urb_more)) {
+			dev_err(&u132->platform_dev->dev, "urb=%p not found in "
+				"endp[%d]=%p ring[%d] %c%c usb_endp=%d usb_addr"
+				"=%d size=%d next=%04X last=%04X\n", urb,
+				endp->endp_number, endp, endp->ring->number,
+				endp->input ? 'I' : ' ',
+				endp->output ? 'O' : ' ', endp->usb_endp,
+				endp->usb_addr, endp->queue_size,
+				endp->queue_next, endp->queue_last);
+			spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+			return -EINVAL;
+		} else {
+			int retval;
+
+			usb_hcd_unlink_urb_from_ep(u132_to_hcd(u132), urb);
+			retval = dequeue_from_overflow_chain(u132, endp,
+				urb);
+			spin_unlock_irqrestore(&endp->queue_lock.slock, irqs);
+			return retval;
+		}
+	}
+}
+
+static int u132_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
+{
+	struct u132 *u132 = hcd_to_u132(hcd);
+	if (u132->going > 2) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		return -ENODEV;
+	} else {
+		u8 usb_addr = usb_pipedevice(urb->pipe);
+		u8 usb_endp = usb_pipeendpoint(urb->pipe);
+		u8 address = u132->addr[usb_addr].address;
+		struct u132_udev *udev = &u132->udev[address];
+		if (usb_pipein(urb->pipe)) {
+			u8 endp_number = udev->endp_number_in[usb_endp];
+			struct u132_endp *endp = u132->endp[endp_number - 1];
+			return u132_endp_urb_dequeue(u132, endp, urb, status);
+		} else {
+			u8 endp_number = udev->endp_number_out[usb_endp];
+			struct u132_endp *endp = u132->endp[endp_number - 1];
+			return u132_endp_urb_dequeue(u132, endp, urb, status);
+		}
+	}
 }
 
 static void u132_endpoint_disable(struct usb_hcd *hcd,
-        struct usb_host_endpoint *hep)
+	struct usb_host_endpoint *hep)
 {
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 2) {
-                dev_err(&u132->platform_dev->dev, "u132 device %p(hcd=%p hep=%p"
-                        ") has been removed %d\n", u132, hcd, hep,
-                        u132->going);
-        } else {
-                struct u132_endp *endp = hep->hcpriv;
-                if (endp)
-                        u132_endp_put_kref(u132, endp);
-        }
+	struct u132 *u132 = hcd_to_u132(hcd);
+	if (u132->going > 2) {
+		dev_err(&u132->platform_dev->dev, "u132 device %p(hcd=%p hep=%p"
+			") has been removed %d\n", u132, hcd, hep,
+			u132->going);
+	} else {
+		struct u132_endp *endp = hep->hcpriv;
+		if (endp)
+			u132_endp_put_kref(u132, endp);
+	}
 }
 
 static int u132_get_frame(struct usb_hcd *hcd)
 {
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else {
-                int frame = 0;
-                dev_err(&u132->platform_dev->dev, "TODO: u132_get_frame\n");
-                msleep(100);
-                return frame;
-        }
+	struct u132 *u132 = hcd_to_u132(hcd);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		return -ENODEV;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed\n");
+		return -ESHUTDOWN;
+	} else {
+		int frame = 0;
+		dev_err(&u132->platform_dev->dev, "TODO: u132_get_frame\n");
+		msleep(100);
+		return frame;
+	}
 }
 
 static int u132_roothub_descriptor(struct u132 *u132,
-        struct usb_hub_descriptor *desc)
+	struct usb_hub_descriptor *desc)
 {
-        int retval;
-        u16 temp;
-        u32 rh_a = -1;
-        u32 rh_b = -1;
-        retval = u132_read_pcimem(u132, roothub.a, &rh_a);
-        if (retval)
-                return retval;
-        desc->bDescriptorType = 0x29;
-        desc->bPwrOn2PwrGood = (rh_a & RH_A_POTPGT) >> 24;
-        desc->bHubContrCurrent = 0;
-        desc->bNbrPorts = u132->num_ports;
-        temp = 1 + (u132->num_ports / 8);
-        desc->bDescLength = 7 + 2 *temp;
-        temp = 0;
-        if (rh_a & RH_A_NPS)
-                temp |= 0x0002;
-        if (rh_a & RH_A_PSM)
-                temp |= 0x0001;
-        if (rh_a & RH_A_NOCP) {
-                temp |= 0x0010;
-        } else if (rh_a & RH_A_OCPM)
-                temp |= 0x0008;
-        desc->wHubCharacteristics = cpu_to_le16(temp);
-        retval = u132_read_pcimem(u132, roothub.b, &rh_b);
-        if (retval)
-                return retval;
-        memset(desc->bitmap, 0xff, sizeof(desc->bitmap));
-        desc->bitmap[0] = rh_b & RH_B_DR;
-        if (u132->num_ports > 7) {
-                desc->bitmap[1] = (rh_b & RH_B_DR) >> 8;
-                desc->bitmap[2] = 0xff;
-        } else
-                desc->bitmap[1] = 0xff;
-        return 0;
+	int retval;
+	u16 temp;
+	u32 rh_a = -1;
+	u32 rh_b = -1;
+	retval = u132_read_pcimem(u132, roothub.a, &rh_a);
+	if (retval)
+		return retval;
+	desc->bDescriptorType = 0x29;
+	desc->bPwrOn2PwrGood = (rh_a & RH_A_POTPGT) >> 24;
+	desc->bHubContrCurrent = 0;
+	desc->bNbrPorts = u132->num_ports;
+	temp = 1 + (u132->num_ports / 8);
+	desc->bDescLength = 7 + 2 * temp;
+	temp = 0;
+	if (rh_a & RH_A_NPS)
+		temp |= 0x0002;
+	if (rh_a & RH_A_PSM)
+		temp |= 0x0001;
+	if (rh_a & RH_A_NOCP)
+		temp |= 0x0010;
+	else if (rh_a & RH_A_OCPM)
+		temp |= 0x0008;
+	desc->wHubCharacteristics = cpu_to_le16(temp);
+	retval = u132_read_pcimem(u132, roothub.b, &rh_b);
+	if (retval)
+		return retval;
+	memset(desc->bitmap, 0xff, sizeof(desc->bitmap));
+	desc->bitmap[0] = rh_b & RH_B_DR;
+	if (u132->num_ports > 7) {
+		desc->bitmap[1] = (rh_b & RH_B_DR) >> 8;
+		desc->bitmap[2] = 0xff;
+	} else
+		desc->bitmap[1] = 0xff;
+	return 0;
 }
 
 static int u132_roothub_status(struct u132 *u132, __le32 *desc)
 {
-        u32 rh_status = -1;
-        int ret_status = u132_read_pcimem(u132, roothub.status, &rh_status);
-        *desc = cpu_to_le32(rh_status);
-        return ret_status;
+	u32 rh_status = -1;
+	int ret_status = u132_read_pcimem(u132, roothub.status, &rh_status);
+	*desc = cpu_to_le32(rh_status);
+	return ret_status;
 }
 
 static int u132_roothub_portstatus(struct u132 *u132, __le32 *desc, u16 wIndex)
 {
-        if (wIndex == 0 || wIndex > u132->num_ports) {
-                return -EINVAL;
-        } else {
-                int port = wIndex - 1;
-                u32 rh_portstatus = -1;
-                int ret_portstatus = u132_read_pcimem(u132,
-                        roothub.portstatus[port], &rh_portstatus);
-                *desc = cpu_to_le32(rh_portstatus);
-                if (*(u16 *) (desc + 2)) {
-                        dev_info(&u132->platform_dev->dev, "Port %d Status Chan"
-                                "ge = %08X\n", port, *desc);
-                }
-                return ret_portstatus;
-        }
+	if (wIndex == 0 || wIndex > u132->num_ports) {
+		return -EINVAL;
+	} else {
+		int port = wIndex - 1;
+		u32 rh_portstatus = -1;
+		int ret_portstatus = u132_read_pcimem(u132,
+			roothub.portstatus[port], &rh_portstatus);
+		*desc = cpu_to_le32(rh_portstatus);
+		if (*(u16 *) (desc + 2)) {
+			dev_info(&u132->platform_dev->dev, "Port %d Status Chan"
+				"ge = %08X\n", port, *desc);
+		}
+		return ret_portstatus;
+	}
 }
 
 
@@ -2606,381 +2651,340 @@
 #define tick_before(t1, t2) ((s16)(((s16)(t1))-((s16)(t2))) < 0)
 static int u132_roothub_portreset(struct u132 *u132, int port_index)
 {
-        int retval;
-        u32 fmnumber;
-        u16 now;
-        u16 reset_done;
-        retval = u132_read_pcimem(u132, fmnumber, &fmnumber);
-        if (retval)
-                return retval;
-        now = fmnumber;
-        reset_done = now + PORT_RESET_MSEC;
-        do {
-                u32 portstat;
-                do {
-                        retval = u132_read_pcimem(u132,
-                                roothub.portstatus[port_index], &portstat);
-                        if (retval)
-                                return retval;
-                        if (RH_PS_PRS & portstat) {
-                                continue;
-                        } else
-                                break;
-                } while (tick_before(now, reset_done));
-                if (RH_PS_PRS & portstat)
-                        return -ENODEV;
-                if (RH_PS_CCS & portstat) {
-                        if (RH_PS_PRSC & portstat) {
-                                retval = u132_write_pcimem(u132,
-                                        roothub.portstatus[port_index],
-                                        RH_PS_PRSC);
-                                if (retval)
-                                        return retval;
-                        }
-                } else
-                        break;        /* start the next reset,
-                                sleep till it's probably done */
-                retval = u132_write_pcimem(u132, roothub.portstatus[port_index],
-                         RH_PS_PRS);
-                if (retval)
-                        return retval;
-                msleep(PORT_RESET_HW_MSEC);
-                retval = u132_read_pcimem(u132, fmnumber, &fmnumber);
-                if (retval)
-                        return retval;
-                now = fmnumber;
-        } while (tick_before(now, reset_done));
-        return 0;
+	int retval;
+	u32 fmnumber;
+	u16 now;
+	u16 reset_done;
+	retval = u132_read_pcimem(u132, fmnumber, &fmnumber);
+	if (retval)
+		return retval;
+	now = fmnumber;
+	reset_done = now + PORT_RESET_MSEC;
+	do {
+		u32 portstat;
+		do {
+			retval = u132_read_pcimem(u132,
+				roothub.portstatus[port_index], &portstat);
+			if (retval)
+				return retval;
+			if (RH_PS_PRS & portstat)
+				continue;
+			else
+				break;
+		} while (tick_before(now, reset_done));
+		if (RH_PS_PRS & portstat)
+			return -ENODEV;
+		if (RH_PS_CCS & portstat) {
+			if (RH_PS_PRSC & portstat) {
+				retval = u132_write_pcimem(u132,
+					roothub.portstatus[port_index],
+					RH_PS_PRSC);
+				if (retval)
+					return retval;
+			}
+		} else
+			break;	/* start the next reset,
+				sleep till it's probably done */
+		retval = u132_write_pcimem(u132, roothub.portstatus[port_index],
+			 RH_PS_PRS);
+		if (retval)
+			return retval;
+		msleep(PORT_RESET_HW_MSEC);
+		retval = u132_read_pcimem(u132, fmnumber, &fmnumber);
+		if (retval)
+			return retval;
+		now = fmnumber;
+	} while (tick_before(now, reset_done));
+	return 0;
 }
 
 static int u132_roothub_setportfeature(struct u132 *u132, u16 wValue,
-        u16 wIndex)
+	u16 wIndex)
 {
-        if (wIndex == 0 || wIndex > u132->num_ports) {
-                return -EINVAL;
-        } else {
-                int retval;
-                int port_index = wIndex - 1;
-                struct u132_port *port = &u132->port[port_index];
-                port->Status &= ~(1 << wValue);
-                switch (wValue) {
-                case USB_PORT_FEAT_SUSPEND:
-                        retval = u132_write_pcimem(u132,
-                                roothub.portstatus[port_index], RH_PS_PSS);
-                        if (retval)
-                                return retval;
-                        return 0;
-                case USB_PORT_FEAT_POWER:
-                        retval = u132_write_pcimem(u132,
-                                roothub.portstatus[port_index], RH_PS_PPS);
-                        if (retval)
-                                return retval;
-                        return 0;
-                case USB_PORT_FEAT_RESET:
-                        retval = u132_roothub_portreset(u132, port_index);
-                        if (retval)
-                                return retval;
-                        return 0;
-                default:
-                        return -EPIPE;
-                }
-        }
+	if (wIndex == 0 || wIndex > u132->num_ports) {
+		return -EINVAL;
+	} else {
+		int retval;
+		int port_index = wIndex - 1;
+		struct u132_port *port = &u132->port[port_index];
+		port->Status &= ~(1 << wValue);
+		switch (wValue) {
+		case USB_PORT_FEAT_SUSPEND:
+			retval = u132_write_pcimem(u132,
+				roothub.portstatus[port_index], RH_PS_PSS);
+			if (retval)
+				return retval;
+			return 0;
+		case USB_PORT_FEAT_POWER:
+			retval = u132_write_pcimem(u132,
+				roothub.portstatus[port_index], RH_PS_PPS);
+			if (retval)
+				return retval;
+			return 0;
+		case USB_PORT_FEAT_RESET:
+			retval = u132_roothub_portreset(u132, port_index);
+			if (retval)
+				return retval;
+			return 0;
+		default:
+			return -EPIPE;
+		}
+	}
 }
 
 static int u132_roothub_clearportfeature(struct u132 *u132, u16 wValue,
-        u16 wIndex)
+	u16 wIndex)
 {
-        if (wIndex == 0 || wIndex > u132->num_ports) {
-                return -EINVAL;
-        } else {
-                int port_index = wIndex - 1;
-                u32 temp;
-                int retval;
-                struct u132_port *port = &u132->port[port_index];
-                port->Status &= ~(1 << wValue);
-                switch (wValue) {
-                case USB_PORT_FEAT_ENABLE:
-                        temp = RH_PS_CCS;
-                        break;
-                case USB_PORT_FEAT_C_ENABLE:
-                        temp = RH_PS_PESC;
-                        break;
-                case USB_PORT_FEAT_SUSPEND:
-                        temp = RH_PS_POCI;
-                        if ((u132->hc_control & OHCI_CTRL_HCFS)
-                                != OHCI_USB_OPER) {
-                                dev_err(&u132->platform_dev->dev, "TODO resume_"
-                                        "root_hub\n");
-                        }
-                        break;
-                case USB_PORT_FEAT_C_SUSPEND:
-                        temp = RH_PS_PSSC;
-                        break;
-                case USB_PORT_FEAT_POWER:
-                        temp = RH_PS_LSDA;
-                        break;
-                case USB_PORT_FEAT_C_CONNECTION:
-                        temp = RH_PS_CSC;
-                        break;
-                case USB_PORT_FEAT_C_OVER_CURRENT:
-                        temp = RH_PS_OCIC;
-                        break;
-                case USB_PORT_FEAT_C_RESET:
-                        temp = RH_PS_PRSC;
-                        break;
-                default:
-                        return -EPIPE;
-                }
-                retval = u132_write_pcimem(u132, roothub.portstatus[port_index],
-                         temp);
-                if (retval)
-                        return retval;
-                return 0;
-        }
+	if (wIndex == 0 || wIndex > u132->num_ports) {
+		return -EINVAL;
+	} else {
+		int port_index = wIndex - 1;
+		u32 temp;
+		int retval;
+		struct u132_port *port = &u132->port[port_index];
+		port->Status &= ~(1 << wValue);
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			temp = RH_PS_CCS;
+			break;
+		case USB_PORT_FEAT_C_ENABLE:
+			temp = RH_PS_PESC;
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			temp = RH_PS_POCI;
+			if ((u132->hc_control & OHCI_CTRL_HCFS)
+				!= OHCI_USB_OPER) {
+				dev_err(&u132->platform_dev->dev, "TODO resume_"
+					"root_hub\n");
+			}
+			break;
+		case USB_PORT_FEAT_C_SUSPEND:
+			temp = RH_PS_PSSC;
+			break;
+		case USB_PORT_FEAT_POWER:
+			temp = RH_PS_LSDA;
+			break;
+		case USB_PORT_FEAT_C_CONNECTION:
+			temp = RH_PS_CSC;
+			break;
+		case USB_PORT_FEAT_C_OVER_CURRENT:
+			temp = RH_PS_OCIC;
+			break;
+		case USB_PORT_FEAT_C_RESET:
+			temp = RH_PS_PRSC;
+			break;
+		default:
+			return -EPIPE;
+		}
+		retval = u132_write_pcimem(u132, roothub.portstatus[port_index],
+			 temp);
+		if (retval)
+			return retval;
+		return 0;
+	}
 }
 
 
 /* the virtual root hub timer IRQ checks for hub status*/
 static int u132_hub_status_data(struct usb_hcd *hcd, char *buf)
 {
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device hcd=%p has been remov"
-                        "ed %d\n", hcd, u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device hcd=%p is being remov"
-                        "ed\n", hcd);
-                return -ESHUTDOWN;
-        } else {
-                int i, changed = 0, length = 1;
-                if (u132->flags & OHCI_QUIRK_AMD756) {
-                        if ((u132->hc_roothub_a & RH_A_NDP) > MAX_ROOT_PORTS) {
-                                dev_err(&u132->platform_dev->dev, "bogus NDP, r"
-                                        "ereads as NDP=%d\n",
-                                        u132->hc_roothub_a & RH_A_NDP);
-                                goto done;
-                        }
-                }
-                if (u132->hc_roothub_status & (RH_HS_LPSC | RH_HS_OCIC)) {
-                        buf[0] = changed = 1;
-                } else
-                        buf[0] = 0;
-                if (u132->num_ports > 7) {
-                        buf[1] = 0;
-                        length++;
-                }
-                for (i = 0; i < u132->num_ports; i++) {
-                        if (u132->hc_roothub_portstatus[i] & (RH_PS_CSC |
-                                RH_PS_PESC | RH_PS_PSSC | RH_PS_OCIC |
-                                RH_PS_PRSC)) {
-                                changed = 1;
-                                if (i < 7) {
-                                        buf[0] |= 1 << (i + 1);
-                                } else
-                                        buf[1] |= 1 << (i - 7);
-                                continue;
-                        }
-                        if (!(u132->hc_roothub_portstatus[i] & RH_PS_CCS)) {
-                                continue;
-                        }
-                        if ((u132->hc_roothub_portstatus[i] & RH_PS_PSS)) {
-                                continue;
-                        }
-                }
-              done:return changed ? length : 0;
-        }
+	struct u132 *u132 = hcd_to_u132(hcd);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device hcd=%p has been remov"
+			"ed %d\n", hcd, u132->going);
+		return -ENODEV;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device hcd=%p is being remov"
+			"ed\n", hcd);
+		return -ESHUTDOWN;
+	} else {
+		int i, changed = 0, length = 1;
+		if (u132->flags & OHCI_QUIRK_AMD756) {
+			if ((u132->hc_roothub_a & RH_A_NDP) > MAX_ROOT_PORTS) {
+				dev_err(&u132->platform_dev->dev, "bogus NDP, r"
+					"ereads as NDP=%d\n",
+					u132->hc_roothub_a & RH_A_NDP);
+				goto done;
+			}
+		}
+		if (u132->hc_roothub_status & (RH_HS_LPSC | RH_HS_OCIC))
+			buf[0] = changed = 1;
+		else
+			buf[0] = 0;
+		if (u132->num_ports > 7) {
+			buf[1] = 0;
+			length++;
+		}
+		for (i = 0; i < u132->num_ports; i++) {
+			if (u132->hc_roothub_portstatus[i] & (RH_PS_CSC |
+				RH_PS_PESC | RH_PS_PSSC | RH_PS_OCIC |
+				RH_PS_PRSC)) {
+				changed = 1;
+				if (i < 7)
+					buf[0] |= 1 << (i + 1);
+				else
+					buf[1] |= 1 << (i - 7);
+				continue;
+			}
+			if (!(u132->hc_roothub_portstatus[i] & RH_PS_CCS))
+				continue;
+
+			if ((u132->hc_roothub_portstatus[i] & RH_PS_PSS))
+				continue;
+		}
+done:
+		return changed ? length : 0;
+	}
 }
 
 static int u132_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
-        u16 wIndex, char *buf, u16 wLength)
+	u16 wIndex, char *buf, u16 wLength)
 {
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else {
-                int retval = 0;
-                down(&u132->sw_lock);
-                switch (typeReq) {
-                case ClearHubFeature:
-                        switch (wValue) {
-                        case C_HUB_OVER_CURRENT:
-                        case C_HUB_LOCAL_POWER:
-                                break;
-                        default:
-                                goto stall;
-                        }
-                        break;
-                case SetHubFeature:
-                        switch (wValue) {
-                        case C_HUB_OVER_CURRENT:
-                        case C_HUB_LOCAL_POWER:
-                                break;
-                        default:
-                                goto stall;
-                        }
-                        break;
-                case ClearPortFeature:{
-                                retval = u132_roothub_clearportfeature(u132,
-                                        wValue, wIndex);
-                                if (retval)
-                                        goto error;
-                                break;
-                        }
-                case GetHubDescriptor:{
-                                retval = u132_roothub_descriptor(u132,
-                                        (struct usb_hub_descriptor *)buf);
-                                if (retval)
-                                        goto error;
-                                break;
-                        }
-                case GetHubStatus:{
-                                retval = u132_roothub_status(u132,
-                                        (__le32 *) buf);
-                                if (retval)
-                                        goto error;
-                                break;
-                        }
-                case GetPortStatus:{
-                                retval = u132_roothub_portstatus(u132,
-                                        (__le32 *) buf, wIndex);
-                                if (retval)
-                                        goto error;
-                                break;
-                        }
-                case SetPortFeature:{
-                                retval = u132_roothub_setportfeature(u132,
-                                        wValue, wIndex);
-                                if (retval)
-                                        goto error;
-                                break;
-                        }
-                default:
-                        goto stall;
-                      error:u132_disable(u132);
-                        u132->going = 1;
-                        break;
-                      stall:retval = -EPIPE;
-                        break;
-                }
-                up(&u132->sw_lock);
-                return retval;
-        }
+	struct u132 *u132 = hcd_to_u132(hcd);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		return -ENODEV;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed\n");
+		return -ESHUTDOWN;
+	} else {
+		int retval = 0;
+		mutex_lock(&u132->sw_lock);
+		switch (typeReq) {
+		case ClearHubFeature:
+			switch (wValue) {
+			case C_HUB_OVER_CURRENT:
+			case C_HUB_LOCAL_POWER:
+				break;
+			default:
+				goto stall;
+			}
+			break;
+		case SetHubFeature:
+			switch (wValue) {
+			case C_HUB_OVER_CURRENT:
+			case C_HUB_LOCAL_POWER:
+				break;
+			default:
+				goto stall;
+			}
+			break;
+		case ClearPortFeature:{
+				retval = u132_roothub_clearportfeature(u132,
+					wValue, wIndex);
+				if (retval)
+					goto error;
+				break;
+			}
+		case GetHubDescriptor:{
+				retval = u132_roothub_descriptor(u132,
+					(struct usb_hub_descriptor *)buf);
+				if (retval)
+					goto error;
+				break;
+			}
+		case GetHubStatus:{
+				retval = u132_roothub_status(u132,
+					(__le32 *) buf);
+				if (retval)
+					goto error;
+				break;
+			}
+		case GetPortStatus:{
+				retval = u132_roothub_portstatus(u132,
+					(__le32 *) buf, wIndex);
+				if (retval)
+					goto error;
+				break;
+			}
+		case SetPortFeature:{
+				retval = u132_roothub_setportfeature(u132,
+					wValue, wIndex);
+				if (retval)
+					goto error;
+				break;
+			}
+		default:
+			goto stall;
+		error:
+			u132_disable(u132);
+			u132->going = 1;
+			break;
+		stall:
+			retval = -EPIPE;
+			break;
+		}
+		mutex_unlock(&u132->sw_lock);
+		return retval;
+	}
 }
 
 static int u132_start_port_reset(struct usb_hcd *hcd, unsigned port_num)
 {
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else
-                return 0;
-}
-
-static void u132_hub_irq_enable(struct usb_hcd *hcd)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-        } else if (u132->going > 0)
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
+	struct u132 *u132 = hcd_to_u132(hcd);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		return -ENODEV;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed\n");
+		return -ESHUTDOWN;
+	} else
+		return 0;
 }
 
 
 #ifdef CONFIG_PM
-static int u132_hcd_suspend(struct usb_hcd *hcd, pm_message_t message)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else
-                return 0;
-}
-
-static int u132_hcd_resume(struct usb_hcd *hcd)
-{
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else
-                return 0;
-}
-
 static int u132_bus_suspend(struct usb_hcd *hcd)
 {
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else
-                return 0;
+	struct u132 *u132 = hcd_to_u132(hcd);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		return -ENODEV;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed\n");
+		return -ESHUTDOWN;
+	} else
+		return 0;
 }
 
 static int u132_bus_resume(struct usb_hcd *hcd)
 {
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else
-                return 0;
+	struct u132 *u132 = hcd_to_u132(hcd);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		return -ENODEV;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed\n");
+		return -ESHUTDOWN;
+	} else
+		return 0;
 }
 
 #else
-#define u132_hcd_suspend NULL
-#define u132_hcd_resume NULL
 #define u132_bus_suspend NULL
 #define u132_bus_resume NULL
 #endif
 static struct hc_driver u132_hc_driver = {
-        .description = hcd_name,
-        .hcd_priv_size = sizeof(struct u132),
-        .irq = NULL,
-        .flags = HCD_USB11 | HCD_MEMORY,
-        .reset = u132_hcd_reset,
-        .start = u132_hcd_start,
-        .suspend = u132_hcd_suspend,
-        .resume = u132_hcd_resume,
-        .stop = u132_hcd_stop,
-        .urb_enqueue = u132_urb_enqueue,
-        .urb_dequeue = u132_urb_dequeue,
-        .endpoint_disable = u132_endpoint_disable,
-        .get_frame_number = u132_get_frame,
-        .hub_status_data = u132_hub_status_data,
-        .hub_control = u132_hub_control,
-        .bus_suspend = u132_bus_suspend,
-        .bus_resume = u132_bus_resume,
-        .start_port_reset = u132_start_port_reset,
-        .hub_irq_enable = u132_hub_irq_enable,
+	.description = hcd_name,
+	.hcd_priv_size = sizeof(struct u132),
+	.irq = NULL,
+	.flags = HCD_USB11 | HCD_MEMORY,
+	.reset = u132_hcd_reset,
+	.start = u132_hcd_start,
+	.stop = u132_hcd_stop,
+	.urb_enqueue = u132_urb_enqueue,
+	.urb_dequeue = u132_urb_dequeue,
+	.endpoint_disable = u132_endpoint_disable,
+	.get_frame_number = u132_get_frame,
+	.hub_status_data = u132_hub_status_data,
+	.hub_control = u132_hub_control,
+	.bus_suspend = u132_bus_suspend,
+	.bus_resume = u132_bus_resume,
+	.start_port_reset = u132_start_port_reset,
 };
 
 /*
@@ -2991,148 +2995,152 @@
 */
 static int __devexit u132_remove(struct platform_device *pdev)
 {
-        struct usb_hcd *hcd = platform_get_drvdata(pdev);
-        if (hcd) {
-                struct u132 *u132 = hcd_to_u132(hcd);
-                if (u132->going++ > 1) {
-                        dev_err(&u132->platform_dev->dev, "already being remove"
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	if (hcd) {
+		struct u132 *u132 = hcd_to_u132(hcd);
+		if (u132->going++ > 1) {
+			dev_err(&u132->platform_dev->dev, "already being remove"
 				"d\n");
-                        return -ENODEV;
-                } else {
-                        int rings = MAX_U132_RINGS;
-                        int endps = MAX_U132_ENDPS;
-                        dev_err(&u132->platform_dev->dev, "removing device u132"
+			return -ENODEV;
+		} else {
+			int rings = MAX_U132_RINGS;
+			int endps = MAX_U132_ENDPS;
+			dev_err(&u132->platform_dev->dev, "removing device u132"
 				".%d\n", u132->sequence_num);
-                        msleep(100);
-                        down(&u132->sw_lock);
-                        u132_monitor_cancel_work(u132);
-                        while (rings-- > 0) {
-                                struct u132_ring *ring = &u132->ring[rings];
-                                u132_ring_cancel_work(u132, ring);
-                        } while (endps-- > 0) {
-                                struct u132_endp *endp = u132->endp[endps];
-                                if (endp)
-                                        u132_endp_cancel_work(u132, endp);
-                        }
-                        u132->going += 1;
-                        printk(KERN_INFO "removing device u132.%d\n",
-                                u132->sequence_num);
-                        up(&u132->sw_lock);
-                        usb_remove_hcd(hcd);
-                        u132_u132_put_kref(u132);
-                        return 0;
-                }
-        } else
-                return 0;
+			msleep(100);
+			mutex_lock(&u132->sw_lock);
+			u132_monitor_cancel_work(u132);
+			while (rings-- > 0) {
+				struct u132_ring *ring = &u132->ring[rings];
+				u132_ring_cancel_work(u132, ring);
+			} while (endps-- > 0) {
+				struct u132_endp *endp = u132->endp[endps];
+				if (endp)
+					u132_endp_cancel_work(u132, endp);
+			}
+			u132->going += 1;
+			printk(KERN_INFO "removing device u132.%d\n",
+				u132->sequence_num);
+			mutex_unlock(&u132->sw_lock);
+			usb_remove_hcd(hcd);
+			u132_u132_put_kref(u132);
+			return 0;
+		}
+	} else
+		return 0;
 }
 
 static void u132_initialise(struct u132 *u132, struct platform_device *pdev)
 {
-        int rings = MAX_U132_RINGS;
-        int ports = MAX_U132_PORTS;
-        int addrs = MAX_U132_ADDRS;
-        int udevs = MAX_U132_UDEVS;
-        int endps = MAX_U132_ENDPS;
-        u132->board = pdev->dev.platform_data;
-        u132->platform_dev = pdev;
-        u132->power = 0;
-        u132->reset = 0;
-        init_MUTEX(&u132->sw_lock);
-        init_MUTEX(&u132->scheduler_lock);
-        while (rings-- > 0) {
-                struct u132_ring *ring = &u132->ring[rings];
-                ring->u132 = u132;
-                ring->number = rings + 1;
-                ring->length = 0;
-                ring->curr_endp = NULL;
-                INIT_DELAYED_WORK(&ring->scheduler,
+	int rings = MAX_U132_RINGS;
+	int ports = MAX_U132_PORTS;
+	int addrs = MAX_U132_ADDRS;
+	int udevs = MAX_U132_UDEVS;
+	int endps = MAX_U132_ENDPS;
+	u132->board = pdev->dev.platform_data;
+	u132->platform_dev = pdev;
+	u132->power = 0;
+	u132->reset = 0;
+	mutex_init(&u132->sw_lock);
+	mutex_init(&u132->scheduler_lock);
+	while (rings-- > 0) {
+		struct u132_ring *ring = &u132->ring[rings];
+		ring->u132 = u132;
+		ring->number = rings + 1;
+		ring->length = 0;
+		ring->curr_endp = NULL;
+		INIT_DELAYED_WORK(&ring->scheduler,
 				  u132_hcd_ring_work_scheduler);
-        } down(&u132->sw_lock);
-        INIT_DELAYED_WORK(&u132->monitor, u132_hcd_monitor_work);
-        while (ports-- > 0) {
-                struct u132_port *port = &u132->port[ports];
-                port->u132 = u132;
-                port->reset = 0;
-                port->enable = 0;
-                port->power = 0;
-                port->Status = 0;
-        } while (addrs-- > 0) {
-                struct u132_addr *addr = &u132->addr[addrs];
-                addr->address = 0;
-        } while (udevs-- > 0) {
-                struct u132_udev *udev = &u132->udev[udevs];
-                int i = ARRAY_SIZE(udev->endp_number_in);
-                int o = ARRAY_SIZE(udev->endp_number_out);
-                udev->usb_device = NULL;
-                udev->udev_number = 0;
-                udev->usb_addr = 0;
-                udev->portnumber = 0;
-                while (i-- > 0) {
-                        udev->endp_number_in[i] = 0;
-                }
-                while (o-- > 0) {
-                        udev->endp_number_out[o] = 0;
-                }
-        }
-        while (endps-- > 0) {
-                u132->endp[endps] = NULL;
-        }
-        up(&u132->sw_lock);
-        return;
+	}
+	mutex_lock(&u132->sw_lock);
+	INIT_DELAYED_WORK(&u132->monitor, u132_hcd_monitor_work);
+	while (ports-- > 0) {
+		struct u132_port *port = &u132->port[ports];
+		port->u132 = u132;
+		port->reset = 0;
+		port->enable = 0;
+		port->power = 0;
+		port->Status = 0;
+	}
+	while (addrs-- > 0) {
+		struct u132_addr *addr = &u132->addr[addrs];
+		addr->address = 0;
+	}
+	while (udevs-- > 0) {
+		struct u132_udev *udev = &u132->udev[udevs];
+		int i = ARRAY_SIZE(udev->endp_number_in);
+		int o = ARRAY_SIZE(udev->endp_number_out);
+		udev->usb_device = NULL;
+		udev->udev_number = 0;
+		udev->usb_addr = 0;
+		udev->portnumber = 0;
+		while (i-- > 0)
+			udev->endp_number_in[i] = 0;
+
+		while (o-- > 0)
+			udev->endp_number_out[o] = 0;
+
+	}
+	while (endps-- > 0)
+		u132->endp[endps] = NULL;
+
+	mutex_unlock(&u132->sw_lock);
+	return;
 }
 
 static int __devinit u132_probe(struct platform_device *pdev)
 {
-        struct usb_hcd *hcd;
-        int retval;
-        u32 control;
-        u32 rh_a = -1;
-        u32 num_ports;
-        msleep(100);
-        if (u132_exiting > 0) {
-                return -ENODEV;
-        }
-        retval = ftdi_write_pcimem(pdev, intrdisable, OHCI_INTR_MIE);
-        if (retval)
-                return retval;
-        retval = ftdi_read_pcimem(pdev, control, &control);
-        if (retval)
-                return retval;
-        retval = ftdi_read_pcimem(pdev, roothub.a, &rh_a);
-        if (retval)
-                return retval;
-        num_ports = rh_a & RH_A_NDP;        /* refuse to confuse usbcore */
-        if (pdev->dev.dma_mask) {
-                return -EINVAL;
-        }
-        hcd = usb_create_hcd(&u132_hc_driver, &pdev->dev, pdev->dev.bus_id);
-        if (!hcd) {
-                printk(KERN_ERR "failed to create the usb hcd struct for U132\n"
-                        );
-                ftdi_elan_gone_away(pdev);
-                return -ENOMEM;
-        } else {
-                int retval = 0;
-                struct u132 *u132 = hcd_to_u132(hcd);
-                hcd->rsrc_start = 0;
-                mutex_lock(&u132_module_lock);
-                list_add_tail(&u132->u132_list, &u132_static_list);
-                u132->sequence_num = ++u132_instances;
-                mutex_unlock(&u132_module_lock);
-                u132_u132_init_kref(u132);
-                u132_initialise(u132, pdev);
-                hcd->product_desc = "ELAN U132 Host Controller";
-                retval = usb_add_hcd(hcd, 0, 0);
-                if (retval != 0) {
-                        dev_err(&u132->platform_dev->dev, "init error %d\n",
-                                retval);
-                        u132_u132_put_kref(u132);
-                        return retval;
-                } else {
-                        u132_monitor_queue_work(u132, 100);
-                        return 0;
-                }
-        }
+	struct usb_hcd *hcd;
+	int retval;
+	u32 control;
+	u32 rh_a = -1;
+	u32 num_ports;
+
+	msleep(100);
+	if (u132_exiting > 0)
+		return -ENODEV;
+
+	retval = ftdi_write_pcimem(pdev, intrdisable, OHCI_INTR_MIE);
+	if (retval)
+		return retval;
+	retval = ftdi_read_pcimem(pdev, control, &control);
+	if (retval)
+		return retval;
+	retval = ftdi_read_pcimem(pdev, roothub.a, &rh_a);
+	if (retval)
+		return retval;
+	num_ports = rh_a & RH_A_NDP;	/* refuse to confuse usbcore */
+	if (pdev->dev.dma_mask)
+		return -EINVAL;
+
+	hcd = usb_create_hcd(&u132_hc_driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		printk(KERN_ERR "failed to create the usb hcd struct for U132\n"
+			);
+		ftdi_elan_gone_away(pdev);
+		return -ENOMEM;
+	} else {
+		int retval = 0;
+		struct u132 *u132 = hcd_to_u132(hcd);
+		hcd->rsrc_start = 0;
+		mutex_lock(&u132_module_lock);
+		list_add_tail(&u132->u132_list, &u132_static_list);
+		u132->sequence_num = ++u132_instances;
+		mutex_unlock(&u132_module_lock);
+		u132_u132_init_kref(u132);
+		u132_initialise(u132, pdev);
+		hcd->product_desc = "ELAN U132 Host Controller";
+		retval = usb_add_hcd(hcd, 0, 0);
+		if (retval != 0) {
+			dev_err(&u132->platform_dev->dev, "init error %d\n",
+				retval);
+			u132_u132_put_kref(u132);
+			return retval;
+		} else {
+			u132_monitor_queue_work(u132, 100);
+			return 0;
+		}
+	}
 }
 
 
@@ -3143,56 +3151,58 @@
 */
 static int u132_suspend(struct platform_device *pdev, pm_message_t state)
 {
-        struct usb_hcd *hcd = platform_get_drvdata(pdev);
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else {
-                int retval = 0;
-                if (state.event == PM_EVENT_FREEZE) {
-                        retval = u132_bus_suspend(hcd);
-                } else if (state.event == PM_EVENT_SUSPEND) {
-                        int ports = MAX_U132_PORTS;
-                        while (ports-- > 0) {
-                                port_power(u132, ports, 0);
-                        }
-                }
-                if (retval == 0)
-                        pdev->dev.power.power_state = state;
-                return retval;
-        }
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct u132 *u132 = hcd_to_u132(hcd);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		return -ENODEV;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed\n");
+		return -ESHUTDOWN;
+	} else {
+		int retval = 0, ports;
+
+		switch (state.event) {
+		case PM_EVENT_FREEZE:
+			retval = u132_bus_suspend(hcd);
+			break;
+		case PM_EVENT_SUSPEND:
+		case PM_EVENT_HIBERNATE:
+			ports = MAX_U132_PORTS;
+			while (ports-- > 0) {
+				port_power(u132, ports, 0);
+			}
+			break;
+		}
+		return retval;
+	}
 }
 
 static int u132_resume(struct platform_device *pdev)
 {
-        struct usb_hcd *hcd = platform_get_drvdata(pdev);
-        struct u132 *u132 = hcd_to_u132(hcd);
-        if (u132->going > 1) {
-                dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
-                        , u132->going);
-                return -ENODEV;
-        } else if (u132->going > 0) {
-                dev_err(&u132->platform_dev->dev, "device is being removed\n");
-                return -ESHUTDOWN;
-        } else {
-                int retval = 0;
-                if (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {
-                        int ports = MAX_U132_PORTS;
-                        while (ports-- > 0) {
-                                port_power(u132, ports, 1);
-                        }
-                        retval = 0;
-                } else {
-                        pdev->dev.power.power_state = PMSG_ON;
-                        retval = u132_bus_resume(hcd);
-                }
-                return retval;
-        }
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct u132 *u132 = hcd_to_u132(hcd);
+	if (u132->going > 1) {
+		dev_err(&u132->platform_dev->dev, "device has been removed %d\n"
+			, u132->going);
+		return -ENODEV;
+	} else if (u132->going > 0) {
+		dev_err(&u132->platform_dev->dev, "device is being removed\n");
+		return -ESHUTDOWN;
+	} else {
+		int retval = 0;
+		if (!u132->port[0].power) {
+			int ports = MAX_U132_PORTS;
+			while (ports-- > 0) {
+				port_power(u132, ports, 1);
+			}
+			retval = 0;
+		} else {
+			retval = u132_bus_resume(hcd);
+		}
+		return retval;
+	}
 }
 
 #else
@@ -3205,49 +3215,51 @@
 * the platform_driver struct is static because it is per type of module
 */
 static struct platform_driver u132_platform_driver = {
-        .probe = u132_probe,
-        .remove = __devexit_p(u132_remove),
-        .suspend = u132_suspend,
-        .resume = u132_resume,
-        .driver = {
-                   .name = (char *)hcd_name,
-                   .owner = THIS_MODULE,
-                   },
+	.probe = u132_probe,
+	.remove = __devexit_p(u132_remove),
+	.suspend = u132_suspend,
+	.resume = u132_resume,
+	.driver = {
+		   .name = (char *)hcd_name,
+		   .owner = THIS_MODULE,
+		   },
 };
 static int __init u132_hcd_init(void)
 {
-        int retval;
-        INIT_LIST_HEAD(&u132_static_list);
-        u132_instances = 0;
-        u132_exiting = 0;
-        mutex_init(&u132_module_lock);
-        if (usb_disabled())
-                return -ENODEV;
-        printk(KERN_INFO "driver %s built at %s on %s\n", hcd_name, __TIME__,
-                __DATE__);
-        workqueue = create_singlethread_workqueue("u132");
-        retval = platform_driver_register(&u132_platform_driver);
-        return retval;
+	int retval;
+	INIT_LIST_HEAD(&u132_static_list);
+	u132_instances = 0;
+	u132_exiting = 0;
+	mutex_init(&u132_module_lock);
+	if (usb_disabled())
+		return -ENODEV;
+	printk(KERN_INFO "driver %s built at %s on %s\n", hcd_name, __TIME__,
+		__DATE__);
+	workqueue = create_singlethread_workqueue("u132");
+	retval = platform_driver_register(&u132_platform_driver);
+	return retval;
 }
 
 
 module_init(u132_hcd_init);
 static void __exit u132_hcd_exit(void)
 {
-        struct u132 *u132;
-        struct u132 *temp;
-        mutex_lock(&u132_module_lock);
-        u132_exiting += 1;
-        mutex_unlock(&u132_module_lock);
-        list_for_each_entry_safe(u132, temp, &u132_static_list, u132_list) {
-                platform_device_unregister(u132->platform_dev);
-        } platform_driver_unregister(&u132_platform_driver);
-        printk(KERN_INFO "u132-hcd driver deregistered\n");
-        wait_event(u132_hcd_wait, u132_instances == 0);
-        flush_workqueue(workqueue);
-        destroy_workqueue(workqueue);
+	struct u132 *u132;
+	struct u132 *temp;
+	mutex_lock(&u132_module_lock);
+	u132_exiting += 1;
+	mutex_unlock(&u132_module_lock);
+	list_for_each_entry_safe(u132, temp, &u132_static_list, u132_list) {
+		platform_device_unregister(u132->platform_dev);
+	}
+	platform_driver_unregister(&u132_platform_driver);
+	printk(KERN_INFO "u132-hcd driver deregistered\n");
+	wait_event(u132_hcd_wait, u132_instances == 0);
+	flush_workqueue(workqueue);
+	destroy_workqueue(workqueue);
 }
 
 
 module_exit(u132_hcd_exit);
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:u132_hcd");
diff -urN host/uhci-debug.c host.new/uhci-debug.c
--- host/uhci-debug.c	2009-02-24 19:00:15.631958661 +0100
+++ host.new/uhci-debug.c	2009-03-28 17:46:02.000000000 +0100
@@ -118,10 +118,12 @@
 	}
 
 	out += sprintf(out, "%s%s", ptype, (urbp->fsbr ? " FSBR" : ""));
-	out += sprintf(out, " Actlen=%d", urbp->urb->actual_length);
+	out += sprintf(out, " Actlen=%d%s", urbp->urb->actual_length,
+			(urbp->qh->type == USB_ENDPOINT_XFER_CONTROL ?
+				"-8" : ""));
 
-	if (urbp->urb->status != -EINPROGRESS)
-		out += sprintf(out, " Status=%d", urbp->urb->status);
+	if (urbp->urb->unlinked)
+		out += sprintf(out, " Unlinked=%d", urbp->urb->unlinked);
 	out += sprintf(out, "\n");
 
 	i = nactive = ninactive = 0;
diff -urN host/uhci-hcd.c host.new/uhci-hcd.c
--- host/uhci-hcd.c	2009-02-24 19:00:15.635958457 +0100
+++ host.new/uhci-hcd.c	2009-03-28 17:46:02.000000000 +0100
@@ -53,14 +53,13 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v3.0"
 #define DRIVER_AUTHOR "Linus 'Frodo Rabbit' Torvalds, Johannes Erdfelt, \
 Randy Dunlap, Georg Acher, Deti Fliegl, Thomas Sailer, Roman Weissgaerber, \
 Alan Stern"
 #define DRIVER_DESC "USB Universal Host Controller Interface driver"
 
 /* for flakey hardware, ignore overcurrent indicators */
-static int ignore_oc=1;
+static int ignore_oc;
 module_param(ignore_oc, bool, S_IRUGO);
 MODULE_PARM_DESC(ignore_oc, "ignore hardware overcurrent indications");
 
@@ -234,10 +233,10 @@
 	return 0;
 }
 
-static int remote_wakeup_is_broken(struct uhci_hcd *uhci)
+static int global_suspend_mode_is_broken(struct uhci_hcd *uhci)
 {
 	int port;
-	char *sys_info;
+	const char *sys_info;
 	static char bad_Asus_board[] = "A7V8X";
 
 	/* One of Asus's motherboards has a bug which causes it to
@@ -261,33 +260,60 @@
 __acquires(uhci->lock)
 {
 	int auto_stop;
-	int int_enable, egsm_enable;
+	int int_enable, egsm_enable, wakeup_enable;
+	struct usb_device *rhdev = uhci_to_hcd(uhci)->self.root_hub;
 
 	auto_stop = (new_state == UHCI_RH_AUTO_STOPPED);
-	dev_dbg(&uhci_to_hcd(uhci)->self.root_hub->dev,
-			"%s%s\n", __FUNCTION__,
+	dev_dbg(&rhdev->dev, "%s%s\n", __func__,
 			(auto_stop ? " (auto-stop)" : ""));
 
-	/* If we get a suspend request when we're already auto-stopped
-	 * then there's nothing to do.
+	/* Start off by assuming Resume-Detect interrupts and EGSM work
+	 * and that remote wakeups should be enabled.
+	 */
+	egsm_enable = USBCMD_EGSM;
+	uhci->RD_enable = 1;
+	int_enable = USBINTR_RESUME;
+	wakeup_enable = 1;
+
+	/* In auto-stop mode wakeups must always be detected, but
+	 * Resume-Detect interrupts may be prohibited.  (In the absence
+	 * of CONFIG_PM, they are always disallowed.)
 	 */
-	if (uhci->rh_state == UHCI_RH_AUTO_STOPPED) {
-		uhci->rh_state = new_state;
-		return;
+	if (auto_stop) {
+		if (!device_may_wakeup(&rhdev->dev))
+			int_enable = 0;
+
+	/* In bus-suspend mode wakeups may be disabled, but if they are
+	 * allowed then so are Resume-Detect interrupts.
+	 */
+	} else {
+#ifdef CONFIG_PM
+		if (!rhdev->do_remote_wakeup)
+			wakeup_enable = 0;
+#endif
 	}
 
-	/* Enable resume-detect interrupts if they work.
-	 * Then enter Global Suspend mode if _it_ works, still configured.
+	/* EGSM causes the root hub to echo a 'K' signal (resume) out any
+	 * port which requests a remote wakeup.  According to the USB spec,
+	 * every hub is supposed to do this.  But if we are ignoring
+	 * remote-wakeup requests anyway then there's no point to it.
+	 * We also shouldn't enable EGSM if it's broken.
 	 */
-	egsm_enable = USBCMD_EGSM;
-	uhci->working_RD = 1;
-	int_enable = USBINTR_RESUME;
-	if (remote_wakeup_is_broken(uhci))
+	if (!wakeup_enable || global_suspend_mode_is_broken(uhci))
 		egsm_enable = 0;
-	if (resume_detect_interrupts_are_broken(uhci) || !egsm_enable ||
-			!device_may_wakeup(
-				&uhci_to_hcd(uhci)->self.root_hub->dev))
-		uhci->working_RD = int_enable = 0;
+
+	/* If we're ignoring wakeup events then there's no reason to
+	 * enable Resume-Detect interrupts.  We also shouldn't enable
+	 * them if they are broken or disallowed.
+	 *
+	 * This logic may lead us to enabling RD but not EGSM.  The UHCI
+	 * spec foolishly says that RD works only when EGSM is on, but
+	 * there's no harm in enabling it anyway -- perhaps some chips
+	 * will implement it!
+	 */
+	if (!wakeup_enable || resume_detect_interrupts_are_broken(uhci) ||
+			!int_enable)
+		uhci->RD_enable = int_enable = 0;
 
 	outw(int_enable, uhci->io_addr + USBINTR);
 	outw(egsm_enable | USBCMD_CF, uhci->io_addr + USBCMD);
@@ -308,14 +334,17 @@
 			return;
 	}
 	if (!(inw(uhci->io_addr + USBSTS) & USBSTS_HCH))
-		dev_warn(&uhci_to_hcd(uhci)->self.root_hub->dev,
-			"Controller not stopped yet!\n");
+		dev_warn(uhci_dev(uhci), "Controller not stopped yet!\n");
 
 	uhci_get_current_frame_number(uhci);
 
 	uhci->rh_state = new_state;
 	uhci->is_stopped = UHCI_IS_STOPPED;
-	uhci_to_hcd(uhci)->poll_rh = !int_enable;
+
+	/* If interrupts don't work and remote wakeup is enabled then
+	 * the suspended root hub needs to be polled.
+	 */
+	uhci_to_hcd(uhci)->poll_rh = (!int_enable && wakeup_enable);
 
 	uhci_scan_schedule(uhci);
 	uhci_fsbr_off(uhci);
@@ -342,7 +371,7 @@
 __acquires(uhci->lock)
 {
 	dev_dbg(&uhci_to_hcd(uhci)->self.root_hub->dev,
-			"%s%s\n", __FUNCTION__,
+			"%s%s\n", __func__,
 			uhci->rh_state == UHCI_RH_AUTO_STOPPED ?
 				" (auto-start)" : "");
 
@@ -351,9 +380,12 @@
 	 * for 20 ms.
 	 */
 	if (uhci->rh_state == UHCI_RH_SUSPENDED) {
+		unsigned egsm;
+
+		/* Keep EGSM on if it was set before */
+		egsm = inw(uhci->io_addr + USBCMD) & USBCMD_EGSM;
 		uhci->rh_state = UHCI_RH_RESUMING;
-		outw(USBCMD_FGR | USBCMD_EGSM | USBCMD_CF,
-				uhci->io_addr + USBCMD);
+		outw(USBCMD_FGR | USBCMD_CF | egsm, uhci->io_addr + USBCMD);
 		spin_unlock_irq(&uhci->lock);
 		msleep(20);
 		spin_lock_irq(&uhci->lock);
@@ -378,7 +410,6 @@
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned short status;
-	unsigned long flags;
 
 	/*
 	 * Read the interrupt status, and write it back to clear the
@@ -398,7 +429,7 @@
 			dev_err(uhci_dev(uhci), "host controller process "
 					"error, something bad happened!\n");
 		if (status & USBSTS_HCH) {
-			spin_lock_irqsave(&uhci->lock, flags);
+			spin_lock(&uhci->lock);
 			if (uhci->rh_state >= UHCI_RH_RUNNING) {
 				dev_err(uhci_dev(uhci),
 					"host controller halted, "
@@ -415,16 +446,16 @@
 				 * pending unlinks */
 				mod_timer(&hcd->rh_timer, jiffies);
 			}
-			spin_unlock_irqrestore(&uhci->lock, flags);
+			spin_unlock(&uhci->lock);
 		}
 	}
 
 	if (status & USBSTS_RD)
 		usb_hcd_poll_rh_status(hcd);
 	else {
-		spin_lock_irqsave(&uhci->lock, flags);
+		spin_lock(&uhci->lock);
 		uhci_scan_schedule(uhci);
-		spin_unlock_irqrestore(&uhci->lock, flags);
+		spin_unlock(&uhci->lock);
 	}
 
 	return IRQ_HANDLED;
@@ -738,12 +769,12 @@
 	return rc;
 }
 
-static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
+static int uhci_pci_suspend(struct usb_hcd *hcd, pm_message_t message)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	int rc = 0;
 
-	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
+	dev_dbg(uhci_dev(uhci), "%s\n", __func__);
 
 	spin_lock_irq(&uhci->lock);
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags) || uhci->dead)
@@ -775,11 +806,11 @@
 	return rc;
 }
 
-static int uhci_resume(struct usb_hcd *hcd)
+static int uhci_pci_resume(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
-	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
+	dev_dbg(uhci_dev(uhci), "%s\n", __func__);
 
 	/* Since we aren't in D3 any more, it's safe to set this flag
 	 * even if the controller was dead.
@@ -809,8 +840,10 @@
 
 	spin_unlock_irq(&uhci->lock);
 
-	if (!uhci->working_RD) {
-		/* Suspended root hub needs to be polled */
+	/* If interrupts don't work and remote wakeup is enabled then
+	 * the suspended root hub needs to be polled.
+	 */
+	if (!uhci->RD_enable && hcd->self.root_hub->do_remote_wakeup) {
 		hcd->poll_rh = 1;
 		usb_hcd_poll_rh_status(hcd);
 	}
@@ -873,8 +906,8 @@
 	.reset =		uhci_init,
 	.start =		uhci_start,
 #ifdef CONFIG_PM
-	.suspend =		uhci_suspend,
-	.resume =		uhci_resume,
+	.pci_suspend =		uhci_pci_suspend,
+	.pci_resume =		uhci_pci_resume,
 	.bus_suspend =		uhci_rh_suspend,
 	.bus_resume =		uhci_rh_resume,
 #endif
@@ -917,12 +950,13 @@
 {
 	int retval = -ENOMEM;
 
-	printk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION "%s\n",
-			ignore_oc ? ", overcurrent ignored" : "");
-
 	if (usb_disabled())
 		return -ENODEV;
 
+	printk(KERN_INFO "uhci_hcd: " DRIVER_DESC "%s\n",
+			ignore_oc ? ", overcurrent ignored" : "");
+	set_bit(USB_UHCI_LOADED, &usb_hcds_loaded);
+
 	if (DEBUG_CONFIGURED) {
 		errbuf = kmalloc(ERRBUF_LEN, GFP_KERNEL);
 		if (!errbuf)
@@ -954,6 +988,7 @@
 
 errbuf_failed:
 
+	clear_bit(USB_UHCI_LOADED, &usb_hcds_loaded);
 	return retval;
 }
 
@@ -963,6 +998,7 @@
 	kmem_cache_destroy(uhci_up_cachep);
 	debugfs_remove(uhci_debugfs_root);
 	kfree(errbuf);
+	clear_bit(USB_UHCI_LOADED, &usb_hcds_loaded);
 }
 
 module_init(uhci_hcd_init);
diff -urN host/uhci-hcd.h host.new/uhci-hcd.h
--- host/uhci-hcd.h	2009-02-24 19:00:15.639958254 +0100
+++ host.new/uhci-hcd.h	2009-03-28 17:46:02.000000000 +0100
@@ -73,11 +73,11 @@
 #define   USBLEGSUP_RWC		0x8f00	/* the R/WC bits */
 #define   USBLEGSUP_RO		0x5040	/* R/O and reserved bits */
 
-#define UHCI_PTR_BITS		__constant_cpu_to_le32(0x000F)
-#define UHCI_PTR_TERM		__constant_cpu_to_le32(0x0001)
-#define UHCI_PTR_QH		__constant_cpu_to_le32(0x0002)
-#define UHCI_PTR_DEPTH		__constant_cpu_to_le32(0x0004)
-#define UHCI_PTR_BREADTH	__constant_cpu_to_le32(0x0000)
+#define UHCI_PTR_BITS		cpu_to_le32(0x000F)
+#define UHCI_PTR_TERM		cpu_to_le32(0x0001)
+#define UHCI_PTR_QH		cpu_to_le32(0x0002)
+#define UHCI_PTR_DEPTH		cpu_to_le32(0x0004)
+#define UHCI_PTR_BREADTH	cpu_to_le32(0x0000)
 
 #define UHCI_NUMFRAMES		1024	/* in the frame list [array] */
 #define UHCI_MAX_SOF_NUMBER	2047	/* in an SOF packet */
@@ -146,7 +146,6 @@
 	short phase;			/* Between 0 and period-1 */
 	short load;			/* Periodic time requirement, in us */
 	unsigned int iso_frame;		/* Frame # for iso_packet_desc */
-	int iso_status;			/* Status for Isochronous URBs */
 
 	int state;			/* QH_STATE_xxx; see above */
 	int type;			/* Queue type (control, bulk, etc) */
@@ -401,8 +400,9 @@
 	unsigned int scan_in_progress:1;	/* Schedule scan is running */
 	unsigned int need_rescan:1;		/* Redo the schedule scan */
 	unsigned int dead:1;			/* Controller has died */
-	unsigned int working_RD:1;		/* Suspended root hub doesn't
-						   need to be polled */
+	unsigned int RD_enable:1;		/* Suspended root hub with
+						   Resume-Detect interrupts
+						   enabled */
 	unsigned int is_initialized:1;		/* Data structure is usable */
 	unsigned int fsbr_is_on:1;		/* FSBR is turned on */
 	unsigned int fsbr_is_wanted:1;		/* Does any URB want FSBR? */
@@ -457,21 +457,6 @@
 };
 
 
-/*
- * Locking in uhci.c
- *
- * Almost everything relating to the hardware schedule and processing
- * of URBs is protected by uhci->lock.  urb->status is protected by
- * urb->lock; that's the one exception.
- *
- * To prevent deadlocks, never lock uhci->lock while holding urb->lock.
- * The safe order of locking is:
- *
- * #1 uhci->lock
- * #2 urb->lock
- */
-
-
 /* Some special IDs */
 
 #define PCI_VENDOR_ID_GENESYS		0x17a0
Files host/uhci-hcd.o and host.new/uhci-hcd.o differ
diff -urN host/uhci-hub.c host.new/uhci-hub.c
--- host/uhci-hub.c	2009-02-24 19:00:15.647957848 +0100
+++ host.new/uhci-hub.c	2009-03-28 17:46:02.000000000 +0100
@@ -12,7 +12,7 @@
  * (C) Copyright 2004 Alan Stern, stern@rowland.harvard.edu
  */
 
-static __u8 root_hub_hub_des[] =
+static const __u8 root_hub_hub_des[] =
 {
 	0x09,			/*  __u8  bLength; */
 	0x29,			/*  __u8  bDescriptorType; Hub-descriptor */
diff -urN host/uhci-q.c host.new/uhci-q.c
--- host/uhci-q.c	2009-02-24 19:00:15.659957238 +0100
+++ host.new/uhci-q.c	2009-03-28 17:46:02.000000000 +0100
@@ -123,14 +123,10 @@
 
 static void uhci_free_td(struct uhci_hcd *uhci, struct uhci_td *td)
 {
-	if (!list_empty(&td->list)) {
-		dev_warn(uhci_dev(uhci), "td %p still in list!\n", td);
-		WARN_ON(1);
-	}
-	if (!list_empty(&td->fl_list)) {
-		dev_warn(uhci_dev(uhci), "td %p still in fl_list!\n", td);
-		WARN_ON(1);
-	}
+	if (!list_empty(&td->list))
+		dev_WARN(uhci_dev(uhci), "td %p still in list!\n", td);
+	if (!list_empty(&td->fl_list))
+		dev_WARN(uhci_dev(uhci), "td %p still in fl_list!\n", td);
 
 	dma_pool_free(uhci->td_pool, td, td->dma_handle);
 }
@@ -295,10 +291,8 @@
 static void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
 	WARN_ON(qh->state != QH_STATE_IDLE && qh->udev);
-	if (!list_empty(&qh->queue)) {
-		dev_warn(uhci_dev(uhci), "qh %p list not empty!\n", qh);
-		WARN_ON(1);
-	}
+	if (!list_empty(&qh->queue))
+		dev_WARN(uhci_dev(uhci), "qh %p list not empty!\n", qh);
 
 	list_del(&qh->node);
 	if (qh->udev) {
@@ -408,7 +402,7 @@
 		/* Otherwise all the toggles in the URB have to be switched */
 		} else {
 			list_for_each_entry(td, &urbp->td_list, list) {
-				td->token ^= __constant_cpu_to_le32(
+				td->token ^= cpu_to_le32(
 							TD_TOKEN_TOGGLE);
 				toggle ^= 1;
 			}
@@ -746,18 +740,15 @@
 {
 	struct uhci_td *td, *tmp;
 
-	if (!list_empty(&urbp->node)) {
-		dev_warn(uhci_dev(uhci), "urb %p still on QH's list!\n",
+	if (!list_empty(&urbp->node))
+		dev_WARN(uhci_dev(uhci), "urb %p still on QH's list!\n",
 				urbp->urb);
-		WARN_ON(1);
-	}
 
 	list_for_each_entry_safe(td, tmp, &urbp->td_list, list) {
 		uhci_remove_td_from_urbp(td);
 		uhci_free_td(uhci, td);
 	}
 
-	urbp->urb->hcpriv = NULL;
 	kmem_cache_free(uhci_up_cachep, urbp);
 }
 
@@ -892,7 +883,7 @@
 
 	uhci_fill_td(td, 0, USB_PID_OUT | uhci_explen(0), 0);
 	wmb();
-	qh->dummy_td->status |= __constant_cpu_to_le32(TD_CTRL_ACTIVE);
+	qh->dummy_td->status |= cpu_to_le32(TD_CTRL_ACTIVE);
 	qh->dummy_td = td;
 
 	/* Low-speed transfers get a different queue, and won't hog the bus.
@@ -908,8 +899,6 @@
 	}
 	if (qh->state != QH_STATE_ACTIVE)
 		qh->skel = skel;
-
-	urb->actual_length = -8;	/* Account for the SETUP packet */
 	return 0;
 
 nomem:
@@ -1012,7 +1001,7 @@
 	 * fast side but not enough to justify delaying an interrupt
 	 * more than 2 or 3 URBs, so we will ignore the URB_NO_INTERRUPT
 	 * flag setting. */
-	td->status |= __constant_cpu_to_le32(TD_CTRL_IOC);
+	td->status |= cpu_to_le32(TD_CTRL_IOC);
 
 	/*
 	 * Build the new dummy TD and activate the old one
@@ -1024,7 +1013,7 @@
 
 	uhci_fill_td(td, 0, USB_PID_OUT | uhci_explen(0), 0);
 	wmb();
-	qh->dummy_td->status |= __constant_cpu_to_le32(TD_CTRL_ACTIVE);
+	qh->dummy_td->status |= cpu_to_le32(TD_CTRL_ACTIVE);
 	qh->dummy_td = td;
 
 	usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
@@ -1074,13 +1063,18 @@
 		}
 		if (exponent < 0)
 			return -EINVAL;
-		qh->period = 1 << exponent;
-		qh->skel = SKEL_INDEX(exponent);
 
-		/* For now, interrupt phase is fixed by the layout
-		 * of the QH lists. */
-		qh->phase = (qh->period / 2) & (MAX_PHASE - 1);
-		ret = uhci_check_bandwidth(uhci, qh);
+		/* If the slot is full, try a lower period */
+		do {
+			qh->period = 1 << exponent;
+			qh->skel = SKEL_INDEX(exponent);
+
+			/* For now, interrupt phase is fixed by the layout
+			 * of the QH lists.
+			 */
+			qh->phase = (qh->period / 2) & (MAX_PHASE - 1);
+			ret = uhci_check_bandwidth(uhci, qh);
+		} while (ret != 0 && --exponent >= 0);
 		if (ret)
 			return ret;
 	} else if (qh->period > urb->interval)
@@ -1172,7 +1166,7 @@
 				/* Some debugging code */
 				dev_dbg(&urb->dev->dev,
 						"%s: failed with status %x\n",
-						__FUNCTION__, status);
+						__func__, status);
 
 				if (debug > 1 && errbuf) {
 					/* Print the chain for debugging */
@@ -1272,7 +1266,8 @@
 	} else if (qh->period != urb->interval) {
 		return -EINVAL;		/* Can't change the period */
 
-	} else {	/* Pick up where the last URB leaves off */
+	} else {
+		/* Find the next unused frame */
 		if (list_empty(&qh->queue)) {
 			frame = qh->iso_frame;
 		} else {
@@ -1284,10 +1279,18 @@
 					lurb->number_of_packets *
 					lurb->interval;
 		}
-		if (urb->transfer_flags & URB_ISO_ASAP)
-			urb->start_frame = frame;
-		else if (urb->start_frame != frame)
-			return -EINVAL;
+		if (urb->transfer_flags & URB_ISO_ASAP) {
+			/* Skip some frames if necessary to insure
+			 * the start frame is in the future.
+			 */
+			uhci_get_current_frame_number(uhci);
+			if (uhci_frame_before_eq(frame, uhci->frame_number)) {
+				frame = uhci->frame_number + 1;
+				frame += ((qh->phase - frame) &
+					(qh->period - 1));
+			}
+		}	/* Otherwise pick up where the last URB leaves off */
+		urb->start_frame = frame;
 	}
 
 	/* Make sure we won't have to go too far into the future */
@@ -1312,7 +1315,7 @@
 	}
 
 	/* Set the interrupt-on-completion flag on the last packet. */
-	td->status |= __constant_cpu_to_le32(TD_CTRL_IOC);
+	td->status |= cpu_to_le32(TD_CTRL_IOC);
 
 	/* Add the TDs to the frame list */
 	frame = urb->start_frame;
@@ -1324,7 +1327,6 @@
 	if (list_empty(&qh->queue)) {
 		qh->iso_packet_desc = &urb->iso_frame_desc[0];
 		qh->iso_frame = urb->start_frame;
-		qh->iso_status = 0;
 	}
 
 	qh->skel = SKEL_ISO;
@@ -1361,22 +1363,18 @@
 			qh->iso_packet_desc->actual_length = actlength;
 			qh->iso_packet_desc->status = status;
 		}
-
-		if (status) {
+		if (status)
 			urb->error_count++;
-			qh->iso_status = status;
-		}
 
 		uhci_remove_td_from_urbp(td);
 		uhci_free_td(uhci, td);
 		qh->iso_frame += qh->period;
 		++qh->iso_packet_desc;
 	}
-	return qh->iso_status;
+	return 0;
 }
 
 static int uhci_urb_enqueue(struct usb_hcd *hcd,
-		struct usb_host_endpoint *hep,
 		struct urb *urb, gfp_t mem_flags)
 {
 	int ret;
@@ -1387,19 +1385,19 @@
 
 	spin_lock_irqsave(&uhci->lock, flags);
 
-	ret = urb->status;
-	if (ret != -EINPROGRESS)		/* URB already unlinked! */
-		goto done;
+	ret = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (ret)
+		goto done_not_linked;
 
 	ret = -ENOMEM;
 	urbp = uhci_alloc_urb_priv(uhci, urb);
 	if (!urbp)
 		goto done;
 
-	if (hep->hcpriv)
-		qh = (struct uhci_qh *) hep->hcpriv;
+	if (urb->ep->hcpriv)
+		qh = urb->ep->hcpriv;
 	else {
-		qh = uhci_alloc_qh(uhci, urb->dev, hep);
+		qh = uhci_alloc_qh(uhci, urb->dev, urb->ep);
 		if (!qh)
 			goto err_no_qh;
 	}
@@ -1440,27 +1438,29 @@
 err_submit_failed:
 	if (qh->state == QH_STATE_IDLE)
 		uhci_make_qh_idle(uhci, qh);	/* Reclaim unused QH */
-
 err_no_qh:
 	uhci_free_urb_priv(uhci, urbp);
-
 done:
+	if (ret)
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+done_not_linked:
 	spin_unlock_irqrestore(&uhci->lock, flags);
 	return ret;
 }
 
-static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned long flags;
-	struct urb_priv *urbp;
 	struct uhci_qh *qh;
+	int rc;
 
 	spin_lock_irqsave(&uhci->lock, flags);
-	urbp = urb->hcpriv;
-	if (!urbp)			/* URB was never linked! */
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
 		goto done;
-	qh = urbp->qh;
+
+	qh = ((struct urb_priv *) urb->hcpriv)->qh;
 
 	/* Remove Isochronous TDs from the frame list ASAP */
 	if (qh->type == USB_ENDPOINT_XFER_ISOC) {
@@ -1477,14 +1477,14 @@
 
 done:
 	spin_unlock_irqrestore(&uhci->lock, flags);
-	return 0;
+	return rc;
 }
 
 /*
  * Finish unlinking an URB and give it back
  */
 static void uhci_giveback_urb(struct uhci_hcd *uhci, struct uhci_qh *qh,
-		struct urb *urb)
+		struct urb *urb, int status)
 __releases(uhci->lock)
 __acquires(uhci->lock)
 {
@@ -1492,18 +1492,10 @@
 
 	if (qh->type == USB_ENDPOINT_XFER_CONTROL) {
 
-		/* urb->actual_length < 0 means the setup transaction didn't
-		 * complete successfully.  Either it failed or the URB was
-		 * unlinked first.  Regardless, don't confuse people with a
-		 * negative length. */
-		urb->actual_length = max(urb->actual_length, 0);
-
-		/* Report erroneous short transfers */
-		if (unlikely((urb->transfer_flags & URB_SHORT_NOT_OK) &&
-				urb->actual_length <
-					urb->transfer_buffer_length &&
-				urb->status == 0))
-			urb->status = -EREMOTEIO;
+		/* Subtract off the length of the SETUP packet from
+		 * urb->actual_length.
+		 */
+		urb->actual_length -= min_t(u32, 8, urb->actual_length);
 	}
 
 	/* When giving back the first URB in an Isochronous queue,
@@ -1516,7 +1508,6 @@
 
 		qh->iso_packet_desc = &nurb->iso_frame_desc[0];
 		qh->iso_frame = nurb->start_frame;
-		qh->iso_status = 0;
 	}
 
 	/* Take the URB off the QH's queue.  If the queue is now empty,
@@ -1529,9 +1520,10 @@
 	}
 
 	uhci_free_urb_priv(uhci, urbp);
+	usb_hcd_unlink_urb_from_ep(uhci_to_hcd(uhci), urb);
 
 	spin_unlock(&uhci->lock);
-	usb_hcd_giveback_urb(uhci_to_hcd(uhci), urb);
+	usb_hcd_giveback_urb(uhci_to_hcd(uhci), urb, status);
 	spin_lock(&uhci->lock);
 
 	/* If the queue is now empty, we can unlink the QH and give up its
@@ -1567,24 +1559,17 @@
 		if (status == -EINPROGRESS)
 			break;
 
-		spin_lock(&urb->lock);
-		if (urb->status == -EINPROGRESS)	/* Not dequeued */
-			urb->status = status;
-		else
-			status = ECONNRESET;		/* Not -ECONNRESET */
-		spin_unlock(&urb->lock);
-
 		/* Dequeued but completed URBs can't be given back unless
 		 * the QH is stopped or has finished unlinking. */
-		if (status == ECONNRESET) {
+		if (urb->unlinked) {
 			if (QH_FINISHED_UNLINKING(qh))
 				qh->is_stopped = 1;
 			else if (!qh->is_stopped)
 				return;
 		}
 
-		uhci_giveback_urb(uhci, qh, urb);
-		if (status < 0 && qh->type != USB_ENDPOINT_XFER_ISOC)
+		uhci_giveback_urb(uhci, qh, urb, status);
+		if (status < 0)
 			break;
 	}
 
@@ -1599,7 +1584,7 @@
 restart:
 	list_for_each_entry(urbp, &qh->queue, node) {
 		urb = urbp->urb;
-		if (urb->status != -EINPROGRESS) {
+		if (urb->unlinked) {
 
 			/* Fix up the TD links and save the toggles for
 			 * non-Isochronous queues.  For Isochronous queues,
@@ -1608,7 +1593,7 @@
 				qh->is_stopped = 0;
 				return;
 			}
-			uhci_giveback_urb(uhci, qh, urb);
+			uhci_giveback_urb(uhci, qh, urb, 0);
 			goto restart;
 		}
 	}
diff -urN host/whci/Kbuild host.new/whci/Kbuild
--- host/whci/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ host.new/whci/Kbuild	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,12 @@
+obj-$(CONFIG_USB_WHCI_HCD) += whci-hcd.o
+
+whci-hcd-y := \
+	asl.o	\
+	debug.o \
+	hcd.o 	\
+	hw.o	\
+	init.o	\
+	int.o	\
+	pzl.o	\
+	qset.o	\
+	wusb.o
diff -urN host/whci/asl.c host.new/whci/asl.c
--- host/whci/asl.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/whci/asl.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,362 @@
+/*
+ * Wireless Host Controller (WHC) asynchronous schedule management.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/dma-mapping.h>
+#include <linux/uwb/umc.h>
+#include <linux/usb.h>
+
+#include "../../wusbcore/wusbhc.h"
+
+#include "whcd.h"
+
+static void qset_get_next_prev(struct whc *whc, struct whc_qset *qset,
+			       struct whc_qset **next, struct whc_qset **prev)
+{
+	struct list_head *n, *p;
+
+	BUG_ON(list_empty(&whc->async_list));
+
+	n = qset->list_node.next;
+	if (n == &whc->async_list)
+		n = n->next;
+	p = qset->list_node.prev;
+	if (p == &whc->async_list)
+		p = p->prev;
+
+	*next = container_of(n, struct whc_qset, list_node);
+	*prev = container_of(p, struct whc_qset, list_node);
+
+}
+
+static void asl_qset_insert_begin(struct whc *whc, struct whc_qset *qset)
+{
+	list_move(&qset->list_node, &whc->async_list);
+	qset->in_sw_list = true;
+}
+
+static void asl_qset_insert(struct whc *whc, struct whc_qset *qset)
+{
+	struct whc_qset *next, *prev;
+
+	qset_clear(whc, qset);
+
+	/* Link into ASL. */
+	qset_get_next_prev(whc, qset, &next, &prev);
+	whc_qset_set_link_ptr(&qset->qh.link, next->qset_dma);
+	whc_qset_set_link_ptr(&prev->qh.link, qset->qset_dma);
+	qset->in_hw_list = true;
+}
+
+static void asl_qset_remove(struct whc *whc, struct whc_qset *qset)
+{
+	struct whc_qset *prev, *next;
+
+	qset_get_next_prev(whc, qset, &next, &prev);
+
+	list_move(&qset->list_node, &whc->async_removed_list);
+	qset->in_sw_list = false;
+
+	/*
+	 * No more qsets in the ASL?  The caller must stop the ASL as
+	 * it's no longer valid.
+	 */
+	if (list_empty(&whc->async_list))
+		return;
+
+	/* Remove from ASL. */
+	whc_qset_set_link_ptr(&prev->qh.link, next->qset_dma);
+	qset->in_hw_list = false;
+}
+
+/**
+ * process_qset - process any recently inactivated or halted qTDs in a
+ * qset.
+ *
+ * After inactive qTDs are removed, new qTDs can be added if the
+ * urb queue still contains URBs.
+ *
+ * Returns any additional WUSBCMD bits for the ASL sync command (i.e.,
+ * WUSBCMD_ASYNC_QSET_RM if a halted qset was removed).
+ */
+static uint32_t process_qset(struct whc *whc, struct whc_qset *qset)
+{
+	enum whc_update update = 0;
+	uint32_t status = 0;
+
+	while (qset->ntds) {
+		struct whc_qtd *td;
+		int t;
+
+		t = qset->td_start;
+		td = &qset->qtd[qset->td_start];
+		status = le32_to_cpu(td->status);
+
+		/*
+		 * Nothing to do with a still active qTD.
+		 */
+		if (status & QTD_STS_ACTIVE)
+			break;
+
+		if (status & QTD_STS_HALTED) {
+			/* Ug, an error. */
+			process_halted_qtd(whc, qset, td);
+			goto done;
+		}
+
+		/* Mmm, a completed qTD. */
+		process_inactive_qtd(whc, qset, td);
+	}
+
+	update |= qset_add_qtds(whc, qset);
+
+done:
+	/*
+	 * Remove this qset from the ASL if requested, but only if has
+	 * no qTDs.
+	 */
+	if (qset->remove && qset->ntds == 0) {
+		asl_qset_remove(whc, qset);
+		update |= WHC_UPDATE_REMOVED;
+	}
+	return update;
+}
+
+void asl_start(struct whc *whc)
+{
+	struct whc_qset *qset;
+
+	qset = list_first_entry(&whc->async_list, struct whc_qset, list_node);
+
+	le_writeq(qset->qset_dma | QH_LINK_NTDS(8), whc->base + WUSBASYNCLISTADDR);
+
+	whc_write_wusbcmd(whc, WUSBCMD_ASYNC_EN, WUSBCMD_ASYNC_EN);
+	whci_wait_for(&whc->umc->dev, whc->base + WUSBSTS,
+		      WUSBSTS_ASYNC_SCHED, WUSBSTS_ASYNC_SCHED,
+		      1000, "start ASL");
+}
+
+void asl_stop(struct whc *whc)
+{
+	whc_write_wusbcmd(whc, WUSBCMD_ASYNC_EN, 0);
+	whci_wait_for(&whc->umc->dev, whc->base + WUSBSTS,
+		      WUSBSTS_ASYNC_SCHED, 0,
+		      1000, "stop ASL");
+}
+
+/**
+ * asl_update - request an ASL update and wait for the hardware to be synced
+ * @whc: the WHCI HC
+ * @wusbcmd: WUSBCMD value to start the update.
+ *
+ * If the WUSB HC is inactive (i.e., the ASL is stopped) then the
+ * update must be skipped as the hardware may not respond to update
+ * requests.
+ */
+void asl_update(struct whc *whc, uint32_t wusbcmd)
+{
+	struct wusbhc *wusbhc = &whc->wusbhc;
+	long t;
+
+	mutex_lock(&wusbhc->mutex);
+	if (wusbhc->active) {
+		whc_write_wusbcmd(whc, wusbcmd, wusbcmd);
+		t = wait_event_timeout(
+			whc->async_list_wq,
+			(le_readl(whc->base + WUSBCMD) & WUSBCMD_ASYNC_UPDATED) == 0,
+			msecs_to_jiffies(1000));
+		if (t == 0)
+			whc_hw_error(whc, "ASL update timeout");
+	}
+	mutex_unlock(&wusbhc->mutex);
+}
+
+/**
+ * scan_async_work - scan the ASL for qsets to process.
+ *
+ * Process each qset in the ASL in turn and then signal the WHC that
+ * the ASL has been updated.
+ *
+ * Then start, stop or update the asynchronous schedule as required.
+ */
+void scan_async_work(struct work_struct *work)
+{
+	struct whc *whc = container_of(work, struct whc, async_work);
+	struct whc_qset *qset, *t;
+	enum whc_update update = 0;
+
+	spin_lock_irq(&whc->lock);
+
+	/*
+	 * Transerve the software list backwards so new qsets can be
+	 * safely inserted into the ASL without making it non-circular.
+	 */
+	list_for_each_entry_safe_reverse(qset, t, &whc->async_list, list_node) {
+		if (!qset->in_hw_list) {
+			asl_qset_insert(whc, qset);
+			update |= WHC_UPDATE_ADDED;
+		}
+
+		update |= process_qset(whc, qset);
+	}
+
+	spin_unlock_irq(&whc->lock);
+
+	if (update) {
+		uint32_t wusbcmd = WUSBCMD_ASYNC_UPDATED | WUSBCMD_ASYNC_SYNCED_DB;
+		if (update & WHC_UPDATE_REMOVED)
+			wusbcmd |= WUSBCMD_ASYNC_QSET_RM;
+		asl_update(whc, wusbcmd);
+	}
+
+	/*
+	 * Now that the ASL is updated, complete the removal of any
+	 * removed qsets.
+	 */
+	spin_lock_irq(&whc->lock);
+
+	list_for_each_entry_safe(qset, t, &whc->async_removed_list, list_node) {
+		qset_remove_complete(whc, qset);
+	}
+
+	spin_unlock_irq(&whc->lock);
+}
+
+/**
+ * asl_urb_enqueue - queue an URB onto the asynchronous list (ASL).
+ * @whc: the WHCI host controller
+ * @urb: the URB to enqueue
+ * @mem_flags: flags for any memory allocations
+ *
+ * The qset for the endpoint is obtained and the urb queued on to it.
+ *
+ * Work is scheduled to update the hardware's view of the ASL.
+ */
+int asl_urb_enqueue(struct whc *whc, struct urb *urb, gfp_t mem_flags)
+{
+	struct whc_qset *qset;
+	int err;
+	unsigned long flags;
+
+	spin_lock_irqsave(&whc->lock, flags);
+
+	qset = get_qset(whc, urb, GFP_ATOMIC);
+	if (qset == NULL)
+		err = -ENOMEM;
+	else
+		err = qset_add_urb(whc, qset, urb, GFP_ATOMIC);
+	if (!err) {
+		usb_hcd_link_urb_to_ep(&whc->wusbhc.usb_hcd, urb);
+		if (!qset->in_sw_list)
+			asl_qset_insert_begin(whc, qset);
+	}
+
+	spin_unlock_irqrestore(&whc->lock, flags);
+
+	if (!err)
+		queue_work(whc->workqueue, &whc->async_work);
+
+	return 0;
+}
+
+/**
+ * asl_urb_dequeue - remove an URB (qset) from the async list.
+ * @whc: the WHCI host controller
+ * @urb: the URB to dequeue
+ * @status: the current status of the URB
+ *
+ * URBs that do yet have qTDs can simply be removed from the software
+ * queue, otherwise the qset must be removed from the ASL so the qTDs
+ * can be removed.
+ */
+int asl_urb_dequeue(struct whc *whc, struct urb *urb, int status)
+{
+	struct whc_urb *wurb = urb->hcpriv;
+	struct whc_qset *qset = wurb->qset;
+	struct whc_std *std, *t;
+	int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&whc->lock, flags);
+
+	ret = usb_hcd_check_unlink_urb(&whc->wusbhc.usb_hcd, urb, status);
+	if (ret < 0)
+		goto out;
+
+	list_for_each_entry_safe(std, t, &qset->stds, list_node) {
+		if (std->urb == urb)
+			qset_free_std(whc, std);
+		else
+			std->qtd = NULL; /* so this std is re-added when the qset is */
+	}
+
+	asl_qset_remove(whc, qset);
+	wurb->status = status;
+	wurb->is_async = true;
+	queue_work(whc->workqueue, &wurb->dequeue_work);
+
+out:
+	spin_unlock_irqrestore(&whc->lock, flags);
+
+	return ret;
+}
+
+/**
+ * asl_qset_delete - delete a qset from the ASL
+ */
+void asl_qset_delete(struct whc *whc, struct whc_qset *qset)
+{
+	qset->remove = 1;
+	queue_work(whc->workqueue, &whc->async_work);
+	qset_delete(whc, qset);
+}
+
+/**
+ * asl_init - initialize the asynchronous schedule list
+ *
+ * A dummy qset with no qTDs is added to the ASL to simplify removing
+ * qsets (no need to stop the ASL when the last qset is removed).
+ */
+int asl_init(struct whc *whc)
+{
+	struct whc_qset *qset;
+
+	qset = qset_alloc(whc, GFP_KERNEL);
+	if (qset == NULL)
+		return -ENOMEM;
+
+	asl_qset_insert_begin(whc, qset);
+	asl_qset_insert(whc, qset);
+
+	return 0;
+}
+
+/**
+ * asl_clean_up - free ASL resources
+ *
+ * The ASL is stopped and empty except for the dummy qset.
+ */
+void asl_clean_up(struct whc *whc)
+{
+	struct whc_qset *qset;
+
+	if (!list_empty(&whc->async_list)) {
+		qset = list_first_entry(&whc->async_list, struct whc_qset, list_node);
+		list_del(&qset->list_node);
+		qset_free(whc, qset);
+	}
+}
diff -urN host/whci/debug.c host.new/whci/debug.c
--- host/whci/debug.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/whci/debug.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,189 @@
+/*
+ * Wireless Host Controller (WHC) debug.
+ *
+ * Copyright (C) 2008 Cambridge Silicon Radio Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include "../../wusbcore/wusbhc.h"
+
+#include "whcd.h"
+
+struct whc_dbg {
+	struct dentry *di_f;
+	struct dentry *asl_f;
+	struct dentry *pzl_f;
+};
+
+void qset_print(struct seq_file *s, struct whc_qset *qset)
+{
+	struct whc_std *std;
+	struct urb *urb = NULL;
+	int i;
+
+	seq_printf(s, "qset %08x\n", (u32)qset->qset_dma);
+	seq_printf(s, "  -> %08x\n", (u32)qset->qh.link);
+	seq_printf(s, "  info: %08x %08x %08x\n",
+		qset->qh.info1, qset->qh.info2,  qset->qh.info3);
+	seq_printf(s, "  sts: %04x errs: %d\n", qset->qh.status, qset->qh.err_count);
+	seq_printf(s, "  TD: sts: %08x opts: %08x\n",
+		qset->qh.overlay.qtd.status, qset->qh.overlay.qtd.options);
+
+	for (i = 0; i < WHCI_QSET_TD_MAX; i++) {
+		seq_printf(s, "  %c%c TD[%d]: sts: %08x opts: %08x ptr: %08x\n",
+			i == qset->td_start ? 'S' : ' ',
+			i == qset->td_end ? 'E' : ' ',
+			i, qset->qtd[i].status, qset->qtd[i].options,
+			(u32)qset->qtd[i].page_list_ptr);
+	}
+	seq_printf(s, "  ntds: %d\n", qset->ntds);
+	list_for_each_entry(std, &qset->stds, list_node) {
+		if (urb != std->urb) {
+			urb = std->urb;
+			seq_printf(s, "  urb %p transferred: %d bytes\n", urb,
+				urb->actual_length);
+		}
+		if (std->qtd)
+			seq_printf(s, "    sTD[%td]: %zu bytes @ %08x\n",
+				std->qtd - &qset->qtd[0],
+				std->len, std->num_pointers ?
+				(u32)(std->pl_virt[0].buf_ptr) : (u32)std->dma_addr);
+		else
+			seq_printf(s, "    sTD[-]: %zd bytes @ %08x\n",
+				std->len, std->num_pointers ?
+				(u32)(std->pl_virt[0].buf_ptr) : (u32)std->dma_addr);
+	}
+}
+
+static int di_print(struct seq_file *s, void *p)
+{
+	struct whc *whc = s->private;
+	char buf[72];
+	int d;
+
+	for (d = 0; d < whc->n_devices; d++) {
+		struct di_buf_entry *di = &whc->di_buf[d];
+
+		bitmap_scnprintf(buf, sizeof(buf),
+				 (unsigned long *)di->availability_info, UWB_NUM_MAS);
+
+		seq_printf(s, "DI[%d]\n", d);
+		seq_printf(s, "  availability: %s\n", buf);
+		seq_printf(s, "  %c%c key idx: %d dev addr: %d\n",
+			   (di->addr_sec_info & WHC_DI_SECURE) ? 'S' : ' ',
+			   (di->addr_sec_info & WHC_DI_DISABLE) ? 'D' : ' ',
+			   (di->addr_sec_info & WHC_DI_KEY_IDX_MASK) >> 8,
+			   (di->addr_sec_info & WHC_DI_DEV_ADDR_MASK));
+	}
+	return 0;
+}
+
+static int asl_print(struct seq_file *s, void *p)
+{
+	struct whc *whc = s->private;
+	struct whc_qset *qset;
+
+	list_for_each_entry(qset, &whc->async_list, list_node) {
+		qset_print(s, qset);
+	}
+
+	return 0;
+}
+
+static int pzl_print(struct seq_file *s, void *p)
+{
+	struct whc *whc = s->private;
+	struct whc_qset *qset;
+	int period;
+
+	for (period = 0; period < 5; period++) {
+		seq_printf(s, "Period %d\n", period);
+		list_for_each_entry(qset, &whc->periodic_list[period], list_node) {
+			qset_print(s, qset);
+		}
+	}
+	return 0;
+}
+
+static int di_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, di_print, inode->i_private);
+}
+
+static int asl_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, asl_print, inode->i_private);
+}
+
+static int pzl_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pzl_print, inode->i_private);
+}
+
+static struct file_operations di_fops = {
+	.open    = di_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release,
+	.owner   = THIS_MODULE,
+};
+
+static struct file_operations asl_fops = {
+	.open    = asl_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release,
+	.owner   = THIS_MODULE,
+};
+
+static struct file_operations pzl_fops = {
+	.open    = pzl_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release,
+	.owner   = THIS_MODULE,
+};
+
+void whc_dbg_init(struct whc *whc)
+{
+	if (whc->wusbhc.pal.debugfs_dir == NULL)
+		return;
+
+	whc->dbg = kzalloc(sizeof(struct whc_dbg), GFP_KERNEL);
+	if (whc->dbg == NULL)
+		return;
+
+	whc->dbg->di_f = debugfs_create_file("di", 0444,
+					      whc->wusbhc.pal.debugfs_dir, whc,
+					      &di_fops);
+	whc->dbg->asl_f = debugfs_create_file("asl", 0444,
+					      whc->wusbhc.pal.debugfs_dir, whc,
+					      &asl_fops);
+	whc->dbg->pzl_f = debugfs_create_file("pzl", 0444,
+					      whc->wusbhc.pal.debugfs_dir, whc,
+					      &pzl_fops);
+}
+
+void whc_dbg_clean_up(struct whc *whc)
+{
+	if (whc->dbg) {
+		debugfs_remove(whc->dbg->pzl_f);
+		debugfs_remove(whc->dbg->asl_f);
+		debugfs_remove(whc->dbg->di_f);
+		kfree(whc->dbg);
+	}
+}
diff -urN host/whci/hcd.c host.new/whci/hcd.c
--- host/whci/hcd.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/whci/hcd.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,339 @@
+/*
+ * Wireless Host Controller (WHC) driver.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/uwb/umc.h>
+
+#include "../../wusbcore/wusbhc.h"
+
+#include "whcd.h"
+
+/*
+ * One time initialization.
+ *
+ * Nothing to do here.
+ */
+static int whc_reset(struct usb_hcd *usb_hcd)
+{
+	return 0;
+}
+
+/*
+ * Start the wireless host controller.
+ *
+ * Start device notification.
+ *
+ * Put hc into run state, set DNTS parameters.
+ */
+static int whc_start(struct usb_hcd *usb_hcd)
+{
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+	u8 bcid;
+	int ret;
+
+	mutex_lock(&wusbhc->mutex);
+
+	le_writel(WUSBINTR_GEN_CMD_DONE
+		  | WUSBINTR_HOST_ERR
+		  | WUSBINTR_ASYNC_SCHED_SYNCED
+		  | WUSBINTR_DNTS_INT
+		  | WUSBINTR_ERR_INT
+		  | WUSBINTR_INT,
+		  whc->base + WUSBINTR);
+
+	/* set cluster ID */
+	bcid = wusb_cluster_id_get();
+	ret = whc_set_cluster_id(whc, bcid);
+	if (ret < 0)
+		goto out;
+	wusbhc->cluster_id = bcid;
+
+	/* start HC */
+	whc_write_wusbcmd(whc, WUSBCMD_RUN, WUSBCMD_RUN);
+
+	usb_hcd->uses_new_polling = 1;
+	usb_hcd->poll_rh = 1;
+	usb_hcd->state = HC_STATE_RUNNING;
+
+out:
+	mutex_unlock(&wusbhc->mutex);
+	return ret;
+}
+
+
+/*
+ * Stop the wireless host controller.
+ *
+ * Stop device notification.
+ *
+ * Wait for pending transfer to stop? Put hc into stop state?
+ */
+static void whc_stop(struct usb_hcd *usb_hcd)
+{
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+
+	mutex_lock(&wusbhc->mutex);
+
+	/* stop HC */
+	le_writel(0, whc->base + WUSBINTR);
+	whc_write_wusbcmd(whc, WUSBCMD_RUN, 0);
+	whci_wait_for(&whc->umc->dev, whc->base + WUSBSTS,
+		      WUSBSTS_HCHALTED, WUSBSTS_HCHALTED,
+		      100, "HC to halt");
+
+	wusb_cluster_id_put(wusbhc->cluster_id);
+
+	mutex_unlock(&wusbhc->mutex);
+}
+
+static int whc_get_frame_number(struct usb_hcd *usb_hcd)
+{
+	/* Frame numbers are not applicable to WUSB. */
+	return -ENOSYS;
+}
+
+
+/*
+ * Queue an URB to the ASL or PZL
+ */
+static int whc_urb_enqueue(struct usb_hcd *usb_hcd, struct urb *urb,
+			   gfp_t mem_flags)
+{
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+	int ret;
+
+	switch (usb_pipetype(urb->pipe)) {
+	case PIPE_INTERRUPT:
+		ret = pzl_urb_enqueue(whc, urb, mem_flags);
+		break;
+	case PIPE_ISOCHRONOUS:
+		dev_err(&whc->umc->dev, "isochronous transfers unsupported\n");
+		ret = -ENOTSUPP;
+		break;
+	case PIPE_CONTROL:
+	case PIPE_BULK:
+	default:
+		ret = asl_urb_enqueue(whc, urb, mem_flags);
+		break;
+	};
+
+	return ret;
+}
+
+/*
+ * Remove a queued URB from the ASL or PZL.
+ */
+static int whc_urb_dequeue(struct usb_hcd *usb_hcd, struct urb *urb, int status)
+{
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+	int ret;
+
+	switch (usb_pipetype(urb->pipe)) {
+	case PIPE_INTERRUPT:
+		ret = pzl_urb_dequeue(whc, urb, status);
+		break;
+	case PIPE_ISOCHRONOUS:
+		ret = -ENOTSUPP;
+		break;
+	case PIPE_CONTROL:
+	case PIPE_BULK:
+	default:
+		ret = asl_urb_dequeue(whc, urb, status);
+		break;
+	};
+
+	return ret;
+}
+
+/*
+ * Wait for all URBs to the endpoint to be completed, then delete the
+ * qset.
+ */
+static void whc_endpoint_disable(struct usb_hcd *usb_hcd,
+				 struct usb_host_endpoint *ep)
+{
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+	struct whc_qset *qset;
+
+	qset = ep->hcpriv;
+	if (qset) {
+		ep->hcpriv = NULL;
+		if (usb_endpoint_xfer_bulk(&ep->desc)
+		    || usb_endpoint_xfer_control(&ep->desc))
+			asl_qset_delete(whc, qset);
+		else
+			pzl_qset_delete(whc, qset);
+	}
+}
+
+static struct hc_driver whc_hc_driver = {
+	.description = "whci-hcd",
+	.product_desc = "Wireless host controller",
+	.hcd_priv_size = sizeof(struct whc) - sizeof(struct usb_hcd),
+	.irq = whc_int_handler,
+	.flags = HCD_USB2,
+
+	.reset = whc_reset,
+	.start = whc_start,
+	.stop = whc_stop,
+	.get_frame_number = whc_get_frame_number,
+	.urb_enqueue = whc_urb_enqueue,
+	.urb_dequeue = whc_urb_dequeue,
+	.endpoint_disable = whc_endpoint_disable,
+
+	.hub_status_data = wusbhc_rh_status_data,
+	.hub_control = wusbhc_rh_control,
+	.bus_suspend = wusbhc_rh_suspend,
+	.bus_resume = wusbhc_rh_resume,
+	.start_port_reset = wusbhc_rh_start_port_reset,
+};
+
+static int whc_probe(struct umc_dev *umc)
+{
+	int ret = -ENOMEM;
+	struct usb_hcd *usb_hcd;
+	struct wusbhc *wusbhc = NULL;
+	struct whc *whc = NULL;
+	struct device *dev = &umc->dev;
+
+	usb_hcd = usb_create_hcd(&whc_hc_driver, dev, "whci");
+	if (usb_hcd == NULL) {
+		dev_err(dev, "unable to create hcd\n");
+		goto error;
+	}
+
+	usb_hcd->wireless = 1;
+
+	wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	whc = wusbhc_to_whc(wusbhc);
+	whc->umc = umc;
+
+	ret = whc_init(whc);
+	if (ret)
+		goto error;
+
+	wusbhc->dev = dev;
+	wusbhc->uwb_rc = uwb_rc_get_by_grandpa(umc->dev.parent);
+	if (!wusbhc->uwb_rc) {
+		ret = -ENODEV;
+		dev_err(dev, "cannot get radio controller\n");
+		goto error;
+	}
+
+	if (whc->n_devices > USB_MAXCHILDREN) {
+		dev_warn(dev, "USB_MAXCHILDREN too low for WUSB adapter (%u ports)\n",
+			 whc->n_devices);
+		wusbhc->ports_max = USB_MAXCHILDREN;
+	} else
+		wusbhc->ports_max = whc->n_devices;
+	wusbhc->mmcies_max      = whc->n_mmc_ies;
+	wusbhc->start           = whc_wusbhc_start;
+	wusbhc->stop            = whc_wusbhc_stop;
+	wusbhc->mmcie_add       = whc_mmcie_add;
+	wusbhc->mmcie_rm        = whc_mmcie_rm;
+	wusbhc->dev_info_set    = whc_dev_info_set;
+	wusbhc->bwa_set         = whc_bwa_set;
+	wusbhc->set_num_dnts    = whc_set_num_dnts;
+	wusbhc->set_ptk         = whc_set_ptk;
+	wusbhc->set_gtk         = whc_set_gtk;
+
+	ret = wusbhc_create(wusbhc);
+	if (ret)
+		goto error_wusbhc_create;
+
+	ret = usb_add_hcd(usb_hcd, whc->umc->irq, IRQF_SHARED);
+	if (ret) {
+		dev_err(dev, "cannot add HCD: %d\n", ret);
+		goto error_usb_add_hcd;
+	}
+
+	ret = wusbhc_b_create(wusbhc);
+	if (ret) {
+		dev_err(dev, "WUSBHC phase B setup failed: %d\n", ret);
+		goto error_wusbhc_b_create;
+	}
+
+	whc_dbg_init(whc);
+
+	return 0;
+
+error_wusbhc_b_create:
+	usb_remove_hcd(usb_hcd);
+error_usb_add_hcd:
+	wusbhc_destroy(wusbhc);
+error_wusbhc_create:
+	uwb_rc_put(wusbhc->uwb_rc);
+error:
+	whc_clean_up(whc);
+	if (usb_hcd)
+		usb_put_hcd(usb_hcd);
+	return ret;
+}
+
+
+static void whc_remove(struct umc_dev *umc)
+{
+	struct usb_hcd *usb_hcd = dev_get_drvdata(&umc->dev);
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+
+	if (usb_hcd) {
+		whc_dbg_clean_up(whc);
+		wusbhc_b_destroy(wusbhc);
+		usb_remove_hcd(usb_hcd);
+		wusbhc_destroy(wusbhc);
+		uwb_rc_put(wusbhc->uwb_rc);
+		whc_clean_up(whc);
+		usb_put_hcd(usb_hcd);
+	}
+}
+
+static struct umc_driver whci_hc_driver = {
+	.name =		"whci-hcd",
+	.cap_id =       UMC_CAP_ID_WHCI_WUSB_HC,
+	.probe =	whc_probe,
+	.remove =	whc_remove,
+};
+
+static int __init whci_hc_driver_init(void)
+{
+	return umc_driver_register(&whci_hc_driver);
+}
+module_init(whci_hc_driver_init);
+
+static void __exit whci_hc_driver_exit(void)
+{
+	umc_driver_unregister(&whci_hc_driver);
+}
+module_exit(whci_hc_driver_exit);
+
+/* PCI device ID's that we handle (so it gets loaded) */
+static struct pci_device_id whci_hcd_id_table[] = {
+	{ PCI_DEVICE_CLASS(PCI_CLASS_WIRELESS_WHCI, ~0) },
+	{ /* empty last entry */ }
+};
+MODULE_DEVICE_TABLE(pci, whci_hcd_id_table);
+
+MODULE_DESCRIPTION("WHCI Wireless USB host controller driver");
+MODULE_AUTHOR("Cambridge Silicon Radio Ltd.");
+MODULE_LICENSE("GPL");
diff -urN host/whci/hw.c host.new/whci/hw.c
--- host/whci/hw.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/whci/hw.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,104 @@
+/*
+ * Wireless Host Controller (WHC) hardware access helpers.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/dma-mapping.h>
+#include <linux/uwb/umc.h>
+
+#include "../../wusbcore/wusbhc.h"
+
+#include "whcd.h"
+
+void whc_write_wusbcmd(struct whc *whc, u32 mask, u32 val)
+{
+	unsigned long flags;
+	u32 cmd;
+
+	spin_lock_irqsave(&whc->lock, flags);
+
+	cmd = le_readl(whc->base + WUSBCMD);
+	cmd = (cmd & ~mask) | val;
+	le_writel(cmd, whc->base + WUSBCMD);
+
+	spin_unlock_irqrestore(&whc->lock, flags);
+}
+
+/**
+ * whc_do_gencmd - start a generic command via the WUSBGENCMDSTS register
+ * @whc:    the WHCI HC
+ * @cmd:    command to start.
+ * @params: parameters for the command (the WUSBGENCMDPARAMS register value).
+ * @addr:   pointer to any data for the command (may be NULL).
+ * @len:    length of the data (if any).
+ */
+int whc_do_gencmd(struct whc *whc, u32 cmd, u32 params, void *addr, size_t len)
+{
+	unsigned long flags;
+	dma_addr_t dma_addr;
+	int t;
+	int ret = 0;
+
+	mutex_lock(&whc->mutex);
+
+	/* Wait for previous command to complete. */
+	t = wait_event_timeout(whc->cmd_wq,
+			       (le_readl(whc->base + WUSBGENCMDSTS) & WUSBGENCMDSTS_ACTIVE) == 0,
+			       WHC_GENCMD_TIMEOUT_MS);
+	if (t == 0) {
+		dev_err(&whc->umc->dev, "generic command timeout (%04x/%04x)\n",
+			le_readl(whc->base + WUSBGENCMDSTS),
+			le_readl(whc->base + WUSBGENCMDPARAMS));
+		ret = -ETIMEDOUT;
+		goto out;
+	}
+
+	if (addr) {
+		memcpy(whc->gen_cmd_buf, addr, len);
+		dma_addr = whc->gen_cmd_buf_dma;
+	} else
+		dma_addr = 0;
+
+	/* Poke registers to start cmd. */
+	spin_lock_irqsave(&whc->lock, flags);
+
+	le_writel(params, whc->base + WUSBGENCMDPARAMS);
+	le_writeq(dma_addr, whc->base + WUSBGENADDR);
+
+	le_writel(WUSBGENCMDSTS_ACTIVE | WUSBGENCMDSTS_IOC | cmd,
+		  whc->base + WUSBGENCMDSTS);
+
+	spin_unlock_irqrestore(&whc->lock, flags);
+out:
+	mutex_unlock(&whc->mutex);
+
+	return ret;
+}
+
+/**
+ * whc_hw_error - recover from a hardware error
+ * @whc:    the WHCI HC that broke.
+ * @reason: a description of the failure.
+ *
+ * Recover from broken hardware with a full reset.
+ */
+void whc_hw_error(struct whc *whc, const char *reason)
+{
+	struct wusbhc *wusbhc = &whc->wusbhc;
+
+	dev_err(&whc->umc->dev, "hardware error: %s\n", reason);
+	wusbhc_reset_all(wusbhc);
+}
diff -urN host/whci/init.c host.new/whci/init.c
--- host/whci/init.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/whci/init.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,188 @@
+/*
+ * Wireless Host Controller (WHC) initialization.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/dma-mapping.h>
+#include <linux/uwb/umc.h>
+
+#include "../../wusbcore/wusbhc.h"
+
+#include "whcd.h"
+
+/*
+ * Reset the host controller.
+ */
+static void whc_hw_reset(struct whc *whc)
+{
+	le_writel(WUSBCMD_WHCRESET, whc->base + WUSBCMD);
+	whci_wait_for(&whc->umc->dev, whc->base + WUSBCMD, WUSBCMD_WHCRESET, 0,
+		      100, "reset");
+}
+
+static void whc_hw_init_di_buf(struct whc *whc)
+{
+	int d;
+
+	/* Disable all entries in the Device Information buffer. */
+	for (d = 0; d < whc->n_devices; d++)
+		whc->di_buf[d].addr_sec_info = WHC_DI_DISABLE;
+
+	le_writeq(whc->di_buf_dma, whc->base + WUSBDEVICEINFOADDR);
+}
+
+static void whc_hw_init_dn_buf(struct whc *whc)
+{
+	/* Clear the Device Notification buffer to ensure the V (valid)
+	 * bits are clear.  */
+	memset(whc->dn_buf, 0, 4096);
+
+	le_writeq(whc->dn_buf_dma, whc->base + WUSBDNTSBUFADDR);
+}
+
+int whc_init(struct whc *whc)
+{
+	u32 whcsparams;
+	int ret, i;
+	resource_size_t start, len;
+
+	spin_lock_init(&whc->lock);
+	mutex_init(&whc->mutex);
+	init_waitqueue_head(&whc->cmd_wq);
+	init_waitqueue_head(&whc->async_list_wq);
+	init_waitqueue_head(&whc->periodic_list_wq);
+	whc->workqueue = create_singlethread_workqueue(dev_name(&whc->umc->dev));
+	if (whc->workqueue == NULL) {
+		ret = -ENOMEM;
+		goto error;
+	}
+	INIT_WORK(&whc->dn_work, whc_dn_work);
+
+	INIT_WORK(&whc->async_work, scan_async_work);
+	INIT_LIST_HEAD(&whc->async_list);
+	INIT_LIST_HEAD(&whc->async_removed_list);
+
+	INIT_WORK(&whc->periodic_work, scan_periodic_work);
+	for (i = 0; i < 5; i++)
+		INIT_LIST_HEAD(&whc->periodic_list[i]);
+	INIT_LIST_HEAD(&whc->periodic_removed_list);
+
+	/* Map HC registers. */
+	start = whc->umc->resource.start;
+	len   = whc->umc->resource.end - start + 1;
+	if (!request_mem_region(start, len, "whci-hc")) {
+		dev_err(&whc->umc->dev, "can't request HC region\n");
+		ret = -EBUSY;
+		goto error;
+	}
+	whc->base_phys = start;
+	whc->base = ioremap(start, len);
+	if (!whc->base) {
+		dev_err(&whc->umc->dev, "ioremap\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	whc_hw_reset(whc);
+
+	/* Read maximum number of devices, keys and MMC IEs. */
+	whcsparams = le_readl(whc->base + WHCSPARAMS);
+	whc->n_devices = WHCSPARAMS_TO_N_DEVICES(whcsparams);
+	whc->n_keys    = WHCSPARAMS_TO_N_KEYS(whcsparams);
+	whc->n_mmc_ies = WHCSPARAMS_TO_N_MMC_IES(whcsparams);
+
+	dev_dbg(&whc->umc->dev, "N_DEVICES = %d, N_KEYS = %d, N_MMC_IES = %d\n",
+		whc->n_devices, whc->n_keys, whc->n_mmc_ies);
+
+	whc->qset_pool = dma_pool_create("qset", &whc->umc->dev,
+					 sizeof(struct whc_qset), 64, 0);
+	if (whc->qset_pool == NULL) {
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	ret = asl_init(whc);
+	if (ret < 0)
+		goto error;
+	ret = pzl_init(whc);
+	if (ret < 0)
+		goto error;
+
+	/* Allocate and initialize a buffer for generic commands, the
+	   Device Information buffer, and the Device Notification
+	   buffer. */
+
+	whc->gen_cmd_buf = dma_alloc_coherent(&whc->umc->dev, WHC_GEN_CMD_DATA_LEN,
+					      &whc->gen_cmd_buf_dma, GFP_KERNEL);
+	if (whc->gen_cmd_buf == NULL) {
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	whc->dn_buf = dma_alloc_coherent(&whc->umc->dev,
+					 sizeof(struct dn_buf_entry) * WHC_N_DN_ENTRIES,
+					 &whc->dn_buf_dma, GFP_KERNEL);
+	if (!whc->dn_buf) {
+		ret = -ENOMEM;
+		goto error;
+	}
+	whc_hw_init_dn_buf(whc);
+
+	whc->di_buf = dma_alloc_coherent(&whc->umc->dev,
+					 sizeof(struct di_buf_entry) * whc->n_devices,
+					 &whc->di_buf_dma, GFP_KERNEL);
+	if (!whc->di_buf) {
+		ret = -ENOMEM;
+		goto error;
+	}
+	whc_hw_init_di_buf(whc);
+
+	return 0;
+
+error:
+	whc_clean_up(whc);
+	return ret;
+}
+
+void whc_clean_up(struct whc *whc)
+{
+	resource_size_t len;
+
+	if (whc->di_buf)
+		dma_free_coherent(&whc->umc->dev, sizeof(struct di_buf_entry) * whc->n_devices,
+				  whc->di_buf, whc->di_buf_dma);
+	if (whc->dn_buf)
+		dma_free_coherent(&whc->umc->dev, sizeof(struct dn_buf_entry) * WHC_N_DN_ENTRIES,
+				  whc->dn_buf, whc->dn_buf_dma);
+	if (whc->gen_cmd_buf)
+		dma_free_coherent(&whc->umc->dev, WHC_GEN_CMD_DATA_LEN,
+				  whc->gen_cmd_buf, whc->gen_cmd_buf_dma);
+
+	pzl_clean_up(whc);
+	asl_clean_up(whc);
+
+	if (whc->qset_pool)
+		dma_pool_destroy(whc->qset_pool);
+
+	len   = whc->umc->resource.end - whc->umc->resource.start + 1;
+	if (whc->base)
+		iounmap(whc->base);
+	if (whc->base_phys)
+		release_mem_region(whc->base_phys, len);
+
+	if (whc->workqueue)
+		destroy_workqueue(whc->workqueue);
+}
diff -urN host/whci/int.c host.new/whci/int.c
--- host/whci/int.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/whci/int.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,94 @@
+/*
+ * Wireless Host Controller (WHC) interrupt handling.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/uwb/umc.h>
+
+#include "../../wusbcore/wusbhc.h"
+
+#include "whcd.h"
+
+static void transfer_done(struct whc *whc)
+{
+	queue_work(whc->workqueue, &whc->async_work);
+	queue_work(whc->workqueue, &whc->periodic_work);
+}
+
+irqreturn_t whc_int_handler(struct usb_hcd *hcd)
+{
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(hcd);
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+	u32 sts;
+
+	sts = le_readl(whc->base + WUSBSTS);
+	if (!(sts & WUSBSTS_INT_MASK))
+		return IRQ_NONE;
+	le_writel(sts & WUSBSTS_INT_MASK, whc->base + WUSBSTS);
+
+	if (sts & WUSBSTS_GEN_CMD_DONE)
+		wake_up(&whc->cmd_wq);
+
+	if (sts & WUSBSTS_HOST_ERR)
+		dev_err(&whc->umc->dev, "FIXME: host system error\n");
+
+	if (sts & WUSBSTS_ASYNC_SCHED_SYNCED)
+		wake_up(&whc->async_list_wq);
+
+	if (sts & WUSBSTS_PERIODIC_SCHED_SYNCED)
+		wake_up(&whc->periodic_list_wq);
+
+	if (sts & WUSBSTS_DNTS_INT)
+		queue_work(whc->workqueue, &whc->dn_work);
+
+	/*
+	 * A transfer completed (see [WHCI] section 4.7.1.2 for when
+	 * this occurs).
+	 */
+	if (sts & (WUSBSTS_INT | WUSBSTS_ERR_INT))
+		transfer_done(whc);
+
+	return IRQ_HANDLED;
+}
+
+static int process_dn_buf(struct whc *whc)
+{
+	struct wusbhc *wusbhc = &whc->wusbhc;
+	struct dn_buf_entry *dn;
+	int processed = 0;
+
+	for (dn = whc->dn_buf; dn < whc->dn_buf + WHC_N_DN_ENTRIES; dn++) {
+		if (dn->status & WHC_DN_STATUS_VALID) {
+			wusbhc_handle_dn(wusbhc, dn->src_addr,
+					 (struct wusb_dn_hdr *)dn->dn_data,
+					 dn->msg_size);
+			dn->status &= ~WHC_DN_STATUS_VALID;
+			processed++;
+		}
+	}
+	return processed;
+}
+
+void whc_dn_work(struct work_struct *work)
+{
+	struct whc *whc = container_of(work, struct whc, dn_work);
+	int processed;
+
+	do {
+		processed = process_dn_buf(whc);
+	} while (processed);
+}
diff -urN host/whci/pzl.c host.new/whci/pzl.c
--- host/whci/pzl.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/whci/pzl.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,390 @@
+/*
+ * Wireless Host Controller (WHC) periodic schedule management.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/dma-mapping.h>
+#include <linux/uwb/umc.h>
+#include <linux/usb.h>
+
+#include "../../wusbcore/wusbhc.h"
+
+#include "whcd.h"
+
+static void update_pzl_pointers(struct whc *whc, int period, u64 addr)
+{
+	switch (period) {
+	case 0:
+		whc_qset_set_link_ptr(&whc->pz_list[0], addr);
+		whc_qset_set_link_ptr(&whc->pz_list[2], addr);
+		whc_qset_set_link_ptr(&whc->pz_list[4], addr);
+		whc_qset_set_link_ptr(&whc->pz_list[6], addr);
+		whc_qset_set_link_ptr(&whc->pz_list[8], addr);
+		whc_qset_set_link_ptr(&whc->pz_list[10], addr);
+		whc_qset_set_link_ptr(&whc->pz_list[12], addr);
+		whc_qset_set_link_ptr(&whc->pz_list[14], addr);
+		break;
+	case 1:
+		whc_qset_set_link_ptr(&whc->pz_list[1], addr);
+		whc_qset_set_link_ptr(&whc->pz_list[5], addr);
+		whc_qset_set_link_ptr(&whc->pz_list[9], addr);
+		whc_qset_set_link_ptr(&whc->pz_list[13], addr);
+		break;
+	case 2:
+		whc_qset_set_link_ptr(&whc->pz_list[3], addr);
+		whc_qset_set_link_ptr(&whc->pz_list[11], addr);
+		break;
+	case 3:
+		whc_qset_set_link_ptr(&whc->pz_list[7], addr);
+		break;
+	case 4:
+		whc_qset_set_link_ptr(&whc->pz_list[15], addr);
+		break;
+	}
+}
+
+/*
+ * Return the 'period' to use for this qset.  The minimum interval for
+ * the endpoint is used so whatever urbs are submitted the device is
+ * polled often enough.
+ */
+static int qset_get_period(struct whc *whc, struct whc_qset *qset)
+{
+	uint8_t bInterval = qset->ep->desc.bInterval;
+
+	if (bInterval < 6)
+		bInterval = 6;
+	if (bInterval > 10)
+		bInterval = 10;
+	return bInterval - 6;
+}
+
+static void qset_insert_in_sw_list(struct whc *whc, struct whc_qset *qset)
+{
+	int period;
+
+	period = qset_get_period(whc, qset);
+
+	qset_clear(whc, qset);
+	list_move(&qset->list_node, &whc->periodic_list[period]);
+	qset->in_sw_list = true;
+}
+
+static void pzl_qset_remove(struct whc *whc, struct whc_qset *qset)
+{
+	list_move(&qset->list_node, &whc->periodic_removed_list);
+	qset->in_hw_list = false;
+	qset->in_sw_list = false;
+}
+
+/**
+ * pzl_process_qset - process any recently inactivated or halted qTDs
+ * in a qset.
+ *
+ * After inactive qTDs are removed, new qTDs can be added if the
+ * urb queue still contains URBs.
+ *
+ * Returns the schedule updates required.
+ */
+static enum whc_update pzl_process_qset(struct whc *whc, struct whc_qset *qset)
+{
+	enum whc_update update = 0;
+	uint32_t status = 0;
+
+	while (qset->ntds) {
+		struct whc_qtd *td;
+		int t;
+
+		t = qset->td_start;
+		td = &qset->qtd[qset->td_start];
+		status = le32_to_cpu(td->status);
+
+		/*
+		 * Nothing to do with a still active qTD.
+		 */
+		if (status & QTD_STS_ACTIVE)
+			break;
+
+		if (status & QTD_STS_HALTED) {
+			/* Ug, an error. */
+			process_halted_qtd(whc, qset, td);
+			goto done;
+		}
+
+		/* Mmm, a completed qTD. */
+		process_inactive_qtd(whc, qset, td);
+	}
+
+	update |= qset_add_qtds(whc, qset);
+
+done:
+	/*
+	 * If there are no qTDs in this qset, remove it from the PZL.
+	 */
+	if (qset->remove && qset->ntds == 0) {
+		pzl_qset_remove(whc, qset);
+		update |= WHC_UPDATE_REMOVED;
+	}
+
+	return update;
+}
+
+/**
+ * pzl_start - start the periodic schedule
+ * @whc: the WHCI host controller
+ *
+ * The PZL must be valid (e.g., all entries in the list should have
+ * the T bit set).
+ */
+void pzl_start(struct whc *whc)
+{
+	le_writeq(whc->pz_list_dma, whc->base + WUSBPERIODICLISTBASE);
+
+	whc_write_wusbcmd(whc, WUSBCMD_PERIODIC_EN, WUSBCMD_PERIODIC_EN);
+	whci_wait_for(&whc->umc->dev, whc->base + WUSBSTS,
+		      WUSBSTS_PERIODIC_SCHED, WUSBSTS_PERIODIC_SCHED,
+		      1000, "start PZL");
+}
+
+/**
+ * pzl_stop - stop the periodic schedule
+ * @whc: the WHCI host controller
+ */
+void pzl_stop(struct whc *whc)
+{
+	whc_write_wusbcmd(whc, WUSBCMD_PERIODIC_EN, 0);
+	whci_wait_for(&whc->umc->dev, whc->base + WUSBSTS,
+		      WUSBSTS_PERIODIC_SCHED, 0,
+		      1000, "stop PZL");
+}
+
+/**
+ * pzl_update - request a PZL update and wait for the hardware to be synced
+ * @whc: the WHCI HC
+ * @wusbcmd: WUSBCMD value to start the update.
+ *
+ * If the WUSB HC is inactive (i.e., the PZL is stopped) then the
+ * update must be skipped as the hardware may not respond to update
+ * requests.
+ */
+void pzl_update(struct whc *whc, uint32_t wusbcmd)
+{
+	struct wusbhc *wusbhc = &whc->wusbhc;
+	long t;
+
+	mutex_lock(&wusbhc->mutex);
+	if (wusbhc->active) {
+		whc_write_wusbcmd(whc, wusbcmd, wusbcmd);
+		t = wait_event_timeout(
+			whc->periodic_list_wq,
+			(le_readl(whc->base + WUSBCMD) & WUSBCMD_PERIODIC_UPDATED) == 0,
+			msecs_to_jiffies(1000));
+		if (t == 0)
+			whc_hw_error(whc, "PZL update timeout");
+	}
+	mutex_unlock(&wusbhc->mutex);
+}
+
+static void update_pzl_hw_view(struct whc *whc)
+{
+	struct whc_qset *qset, *t;
+	int period;
+	u64 tmp_qh = 0;
+
+	for (period = 0; period < 5; period++) {
+		list_for_each_entry_safe(qset, t, &whc->periodic_list[period], list_node) {
+			whc_qset_set_link_ptr(&qset->qh.link, tmp_qh);
+			tmp_qh = qset->qset_dma;
+			qset->in_hw_list = true;
+		}
+		update_pzl_pointers(whc, period, tmp_qh);
+	}
+}
+
+/**
+ * scan_periodic_work - scan the PZL for qsets to process.
+ *
+ * Process each qset in the PZL in turn and then signal the WHC that
+ * the PZL has been updated.
+ *
+ * Then start, stop or update the periodic schedule as required.
+ */
+void scan_periodic_work(struct work_struct *work)
+{
+	struct whc *whc = container_of(work, struct whc, periodic_work);
+	struct whc_qset *qset, *t;
+	enum whc_update update = 0;
+	int period;
+
+	spin_lock_irq(&whc->lock);
+
+	for (period = 4; period >= 0; period--) {
+		list_for_each_entry_safe(qset, t, &whc->periodic_list[period], list_node) {
+			if (!qset->in_hw_list)
+				update |= WHC_UPDATE_ADDED;
+			update |= pzl_process_qset(whc, qset);
+		}
+	}
+
+	if (update & (WHC_UPDATE_ADDED | WHC_UPDATE_REMOVED))
+		update_pzl_hw_view(whc);
+
+	spin_unlock_irq(&whc->lock);
+
+	if (update) {
+		uint32_t wusbcmd = WUSBCMD_PERIODIC_UPDATED | WUSBCMD_PERIODIC_SYNCED_DB;
+		if (update & WHC_UPDATE_REMOVED)
+			wusbcmd |= WUSBCMD_PERIODIC_QSET_RM;
+		pzl_update(whc, wusbcmd);
+	}
+
+	/*
+	 * Now that the PZL is updated, complete the removal of any
+	 * removed qsets.
+	 */
+	spin_lock_irq(&whc->lock);
+
+	list_for_each_entry_safe(qset, t, &whc->periodic_removed_list, list_node) {
+		qset_remove_complete(whc, qset);
+	}
+
+	spin_unlock_irq(&whc->lock);
+}
+
+/**
+ * pzl_urb_enqueue - queue an URB onto the periodic list (PZL)
+ * @whc: the WHCI host controller
+ * @urb: the URB to enqueue
+ * @mem_flags: flags for any memory allocations
+ *
+ * The qset for the endpoint is obtained and the urb queued on to it.
+ *
+ * Work is scheduled to update the hardware's view of the PZL.
+ */
+int pzl_urb_enqueue(struct whc *whc, struct urb *urb, gfp_t mem_flags)
+{
+	struct whc_qset *qset;
+	int err;
+	unsigned long flags;
+
+	spin_lock_irqsave(&whc->lock, flags);
+
+	qset = get_qset(whc, urb, GFP_ATOMIC);
+	if (qset == NULL)
+		err = -ENOMEM;
+	else
+		err = qset_add_urb(whc, qset, urb, GFP_ATOMIC);
+	if (!err) {
+		usb_hcd_link_urb_to_ep(&whc->wusbhc.usb_hcd, urb);
+		if (!qset->in_sw_list)
+			qset_insert_in_sw_list(whc, qset);
+	}
+
+	spin_unlock_irqrestore(&whc->lock, flags);
+
+	if (!err)
+		queue_work(whc->workqueue, &whc->periodic_work);
+
+	return 0;
+}
+
+/**
+ * pzl_urb_dequeue - remove an URB (qset) from the periodic list
+ * @whc: the WHCI host controller
+ * @urb: the URB to dequeue
+ * @status: the current status of the URB
+ *
+ * URBs that do yet have qTDs can simply be removed from the software
+ * queue, otherwise the qset must be removed so the qTDs can be safely
+ * removed.
+ */
+int pzl_urb_dequeue(struct whc *whc, struct urb *urb, int status)
+{
+	struct whc_urb *wurb = urb->hcpriv;
+	struct whc_qset *qset = wurb->qset;
+	struct whc_std *std, *t;
+	int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&whc->lock, flags);
+
+	ret = usb_hcd_check_unlink_urb(&whc->wusbhc.usb_hcd, urb, status);
+	if (ret < 0)
+		goto out;
+
+	list_for_each_entry_safe(std, t, &qset->stds, list_node) {
+		if (std->urb == urb)
+			qset_free_std(whc, std);
+		else
+			std->qtd = NULL; /* so this std is re-added when the qset is */
+	}
+
+	pzl_qset_remove(whc, qset);
+	wurb->status = status;
+	wurb->is_async = false;
+	queue_work(whc->workqueue, &wurb->dequeue_work);
+
+out:
+	spin_unlock_irqrestore(&whc->lock, flags);
+
+	return ret;
+}
+
+/**
+ * pzl_qset_delete - delete a qset from the PZL
+ */
+void pzl_qset_delete(struct whc *whc, struct whc_qset *qset)
+{
+	qset->remove = 1;
+	queue_work(whc->workqueue, &whc->periodic_work);
+	qset_delete(whc, qset);
+}
+
+
+/**
+ * pzl_init - initialize the periodic zone list
+ * @whc: the WHCI host controller
+ */
+int pzl_init(struct whc *whc)
+{
+	int i;
+
+	whc->pz_list = dma_alloc_coherent(&whc->umc->dev, sizeof(u64) * 16,
+					  &whc->pz_list_dma, GFP_KERNEL);
+	if (whc->pz_list == NULL)
+		return -ENOMEM;
+
+	/* Set T bit on all elements in PZL. */
+	for (i = 0; i < 16; i++)
+		whc->pz_list[i] = cpu_to_le64(QH_LINK_NTDS(8) | QH_LINK_T);
+
+	le_writeq(whc->pz_list_dma, whc->base + WUSBPERIODICLISTBASE);
+
+	return 0;
+}
+
+/**
+ * pzl_clean_up - free PZL resources
+ * @whc: the WHCI host controller
+ *
+ * The PZL is stopped and empty.
+ */
+void pzl_clean_up(struct whc *whc)
+{
+	if (whc->pz_list)
+		dma_free_coherent(&whc->umc->dev,  sizeof(u64) * 16, whc->pz_list,
+				  whc->pz_list_dma);
+}
diff -urN host/whci/qset.c host.new/whci/qset.c
--- host/whci/qset.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/whci/qset.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,527 @@
+/*
+ * Wireless Host Controller (WHC) qset management.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/dma-mapping.h>
+#include <linux/uwb/umc.h>
+#include <linux/usb.h>
+
+#include "../../wusbcore/wusbhc.h"
+
+#include "whcd.h"
+
+struct whc_qset *qset_alloc(struct whc *whc, gfp_t mem_flags)
+{
+	struct whc_qset *qset;
+	dma_addr_t dma;
+
+	qset = dma_pool_alloc(whc->qset_pool, mem_flags, &dma);
+	if (qset == NULL)
+		return NULL;
+	memset(qset, 0, sizeof(struct whc_qset));
+
+	qset->qset_dma = dma;
+	qset->whc = whc;
+
+	INIT_LIST_HEAD(&qset->list_node);
+	INIT_LIST_HEAD(&qset->stds);
+
+	return qset;
+}
+
+/**
+ * qset_fill_qh - fill the static endpoint state in a qset's QHead
+ * @qset: the qset whose QH needs initializing with static endpoint
+ *        state
+ * @urb:  an urb for a transfer to this endpoint
+ */
+static void qset_fill_qh(struct whc_qset *qset, struct urb *urb)
+{
+	struct usb_device *usb_dev = urb->dev;
+	struct usb_wireless_ep_comp_descriptor *epcd;
+	bool is_out;
+
+	is_out = usb_pipeout(urb->pipe);
+
+	epcd = (struct usb_wireless_ep_comp_descriptor *)qset->ep->extra;
+
+	if (epcd) {
+		qset->max_seq = epcd->bMaxSequence;
+		qset->max_burst = epcd->bMaxBurst;
+	} else {
+		qset->max_seq = 2;
+		qset->max_burst = 1;
+	}
+
+	qset->qh.info1 = cpu_to_le32(
+		QH_INFO1_EP(usb_pipeendpoint(urb->pipe))
+		| (is_out ? QH_INFO1_DIR_OUT : QH_INFO1_DIR_IN)
+		| usb_pipe_to_qh_type(urb->pipe)
+		| QH_INFO1_DEV_INFO_IDX(wusb_port_no_to_idx(usb_dev->portnum))
+		| QH_INFO1_MAX_PKT_LEN(usb_maxpacket(urb->dev, urb->pipe, is_out))
+		);
+	qset->qh.info2 = cpu_to_le32(
+		QH_INFO2_BURST(qset->max_burst)
+		| QH_INFO2_DBP(0)
+		| QH_INFO2_MAX_COUNT(3)
+		| QH_INFO2_MAX_RETRY(3)
+		| QH_INFO2_MAX_SEQ(qset->max_seq - 1)
+		);
+	/* FIXME: where can we obtain these Tx parameters from?  Why
+	 * doesn't the chip know what Tx power to use? It knows the Rx
+	 * strength and can presumably guess the Tx power required
+	 * from that? */
+	qset->qh.info3 = cpu_to_le32(
+		QH_INFO3_TX_RATE_53_3
+		| QH_INFO3_TX_PWR(0) /* 0 == max power */
+		);
+}
+
+/**
+ * qset_clear - clear fields in a qset so it may be reinserted into a
+ * schedule
+ */
+void qset_clear(struct whc *whc, struct whc_qset *qset)
+{
+	qset->td_start = qset->td_end = qset->ntds = 0;
+	qset->remove = 0;
+
+	qset->qh.link = cpu_to_le32(QH_LINK_NTDS(8) | QH_LINK_T);
+	qset->qh.status = cpu_to_le16(QH_STATUS_ICUR(qset->td_start));
+	qset->qh.err_count = 0;
+	qset->qh.cur_window = cpu_to_le32((1 << qset->max_burst) - 1);
+	qset->qh.scratch[0] = 0;
+	qset->qh.scratch[1] = 0;
+	qset->qh.scratch[2] = 0;
+
+	memset(&qset->qh.overlay, 0, sizeof(qset->qh.overlay));
+
+	init_completion(&qset->remove_complete);
+}
+
+/**
+ * get_qset - get the qset for an async endpoint
+ *
+ * A new qset is created if one does not already exist.
+ */
+struct whc_qset *get_qset(struct whc *whc, struct urb *urb,
+				 gfp_t mem_flags)
+{
+	struct whc_qset *qset;
+
+	qset = urb->ep->hcpriv;
+	if (qset == NULL) {
+		qset = qset_alloc(whc, mem_flags);
+		if (qset == NULL)
+			return NULL;
+
+		qset->ep = urb->ep;
+		urb->ep->hcpriv = qset;
+		qset_fill_qh(qset, urb);
+	}
+	return qset;
+}
+
+void qset_remove_complete(struct whc *whc, struct whc_qset *qset)
+{
+	list_del_init(&qset->list_node);
+	complete(&qset->remove_complete);
+}
+
+/**
+ * qset_add_qtds - add qTDs for an URB to a qset
+ *
+ * Returns true if the list (ASL/PZL) must be updated because (for a
+ * WHCI 0.95 controller) an activated qTD was pointed to be iCur.
+ */
+enum whc_update qset_add_qtds(struct whc *whc, struct whc_qset *qset)
+{
+	struct whc_std *std;
+	enum whc_update update = 0;
+
+	list_for_each_entry(std, &qset->stds, list_node) {
+		struct whc_qtd *qtd;
+		uint32_t status;
+
+		if (qset->ntds >= WHCI_QSET_TD_MAX
+		    || (qset->pause_after_urb && std->urb != qset->pause_after_urb))
+			break;
+
+		if (std->qtd)
+			continue; /* already has a qTD */
+
+		qtd = std->qtd = &qset->qtd[qset->td_end];
+
+		/* Fill in setup bytes for control transfers. */
+		if (usb_pipecontrol(std->urb->pipe))
+			memcpy(qtd->setup, std->urb->setup_packet, 8);
+
+		status = QTD_STS_ACTIVE | QTD_STS_LEN(std->len);
+
+		if (whc_std_last(std) && usb_pipeout(std->urb->pipe))
+			status |= QTD_STS_LAST_PKT;
+
+		/*
+		 * For an IN transfer the iAlt field should be set so
+		 * the h/w will automatically advance to the next
+		 * transfer. However, if there are 8 or more TDs
+		 * remaining in this transfer then iAlt cannot be set
+		 * as it could point to somewhere in this transfer.
+		 */
+		if (std->ntds_remaining < WHCI_QSET_TD_MAX) {
+			int ialt;
+			ialt = (qset->td_end + std->ntds_remaining) % WHCI_QSET_TD_MAX;
+			status |= QTD_STS_IALT(ialt);
+		} else if (usb_pipein(std->urb->pipe))
+			qset->pause_after_urb = std->urb;
+
+		if (std->num_pointers)
+			qtd->options = cpu_to_le32(QTD_OPT_IOC);
+		else
+			qtd->options = cpu_to_le32(QTD_OPT_IOC | QTD_OPT_SMALL);
+		qtd->page_list_ptr = cpu_to_le64(std->dma_addr);
+
+		qtd->status = cpu_to_le32(status);
+
+		if (QH_STATUS_TO_ICUR(qset->qh.status) == qset->td_end)
+			update = WHC_UPDATE_UPDATED;
+
+		if (++qset->td_end >= WHCI_QSET_TD_MAX)
+			qset->td_end = 0;
+		qset->ntds++;
+	}
+
+	return update;
+}
+
+/**
+ * qset_remove_qtd - remove the first qTD from a qset.
+ *
+ * The qTD might be still active (if it's part of a IN URB that
+ * resulted in a short read) so ensure it's deactivated.
+ */
+static void qset_remove_qtd(struct whc *whc, struct whc_qset *qset)
+{
+	qset->qtd[qset->td_start].status = 0;
+
+	if (++qset->td_start >= WHCI_QSET_TD_MAX)
+		qset->td_start = 0;
+	qset->ntds--;
+}
+
+/**
+ * qset_free_std - remove an sTD and free it.
+ * @whc: the WHCI host controller
+ * @std: the sTD to remove and free.
+ */
+void qset_free_std(struct whc *whc, struct whc_std *std)
+{
+	list_del(&std->list_node);
+	if (std->num_pointers) {
+		dma_unmap_single(whc->wusbhc.dev, std->dma_addr,
+				 std->num_pointers * sizeof(struct whc_page_list_entry),
+				 DMA_TO_DEVICE);
+		kfree(std->pl_virt);
+	}
+
+	kfree(std);
+}
+
+/**
+ * qset_remove_qtds - remove an URB's qTDs (and sTDs).
+ */
+static void qset_remove_qtds(struct whc *whc, struct whc_qset *qset,
+			     struct urb *urb)
+{
+	struct whc_std *std, *t;
+
+	list_for_each_entry_safe(std, t, &qset->stds, list_node) {
+		if (std->urb != urb)
+			break;
+		if (std->qtd != NULL)
+			qset_remove_qtd(whc, qset);
+		qset_free_std(whc, std);
+	}
+}
+
+/**
+ * qset_free_stds - free any remaining sTDs for an URB.
+ */
+static void qset_free_stds(struct whc_qset *qset, struct urb *urb)
+{
+	struct whc_std *std, *t;
+
+	list_for_each_entry_safe(std, t, &qset->stds, list_node) {
+		if (std->urb == urb)
+			qset_free_std(qset->whc, std);
+	}
+}
+
+static int qset_fill_page_list(struct whc *whc, struct whc_std *std, gfp_t mem_flags)
+{
+	dma_addr_t dma_addr = std->dma_addr;
+	dma_addr_t sp, ep;
+	size_t std_len = std->len;
+	size_t pl_len;
+	int p;
+
+	sp = ALIGN(dma_addr, WHCI_PAGE_SIZE);
+	ep = dma_addr + std_len;
+	std->num_pointers = DIV_ROUND_UP(ep - sp, WHCI_PAGE_SIZE);
+
+	pl_len = std->num_pointers * sizeof(struct whc_page_list_entry);
+	std->pl_virt = kmalloc(pl_len, mem_flags);
+	if (std->pl_virt == NULL)
+		return -ENOMEM;
+	std->dma_addr = dma_map_single(whc->wusbhc.dev, std->pl_virt, pl_len, DMA_TO_DEVICE);
+
+	for (p = 0; p < std->num_pointers; p++) {
+		std->pl_virt[p].buf_ptr = cpu_to_le64(dma_addr);
+		dma_addr = ALIGN(dma_addr + WHCI_PAGE_SIZE, WHCI_PAGE_SIZE);
+	}
+
+	return 0;
+}
+
+/**
+ * urb_dequeue_work - executes asl/pzl update and gives back the urb to the system.
+ */
+static void urb_dequeue_work(struct work_struct *work)
+{
+	struct whc_urb *wurb = container_of(work, struct whc_urb, dequeue_work);
+	struct whc_qset *qset = wurb->qset;
+	struct whc *whc = qset->whc;
+	unsigned long flags;
+
+	if (wurb->is_async == true)
+		asl_update(whc, WUSBCMD_ASYNC_UPDATED
+			   | WUSBCMD_ASYNC_SYNCED_DB
+			   | WUSBCMD_ASYNC_QSET_RM);
+	else
+		pzl_update(whc, WUSBCMD_PERIODIC_UPDATED
+			   | WUSBCMD_PERIODIC_SYNCED_DB
+			   | WUSBCMD_PERIODIC_QSET_RM);
+
+	spin_lock_irqsave(&whc->lock, flags);
+	qset_remove_urb(whc, qset, wurb->urb, wurb->status);
+	spin_unlock_irqrestore(&whc->lock, flags);
+}
+
+/**
+ * qset_add_urb - add an urb to the qset's queue.
+ *
+ * The URB is chopped into sTDs, one for each qTD that will required.
+ * At least one qTD (and sTD) is required even if the transfer has no
+ * data (e.g., for some control transfers).
+ */
+int qset_add_urb(struct whc *whc, struct whc_qset *qset, struct urb *urb,
+	gfp_t mem_flags)
+{
+	struct whc_urb *wurb;
+	int remaining = urb->transfer_buffer_length;
+	u64 transfer_dma = urb->transfer_dma;
+	int ntds_remaining;
+
+	ntds_remaining = DIV_ROUND_UP(remaining, QTD_MAX_XFER_SIZE);
+	if (ntds_remaining == 0)
+		ntds_remaining = 1;
+
+	wurb = kzalloc(sizeof(struct whc_urb), mem_flags);
+	if (wurb == NULL)
+		goto err_no_mem;
+	urb->hcpriv = wurb;
+	wurb->qset = qset;
+	wurb->urb = urb;
+	INIT_WORK(&wurb->dequeue_work, urb_dequeue_work);
+
+	while (ntds_remaining) {
+		struct whc_std *std;
+		size_t std_len;
+
+		std = kmalloc(sizeof(struct whc_std), mem_flags);
+		if (std == NULL)
+			goto err_no_mem;
+
+		std_len = remaining;
+		if (std_len > QTD_MAX_XFER_SIZE)
+			std_len = QTD_MAX_XFER_SIZE;
+
+		std->urb = urb;
+		std->dma_addr = transfer_dma;
+		std->len = std_len;
+		std->ntds_remaining = ntds_remaining;
+		std->qtd = NULL;
+
+		INIT_LIST_HEAD(&std->list_node);
+		list_add_tail(&std->list_node, &qset->stds);
+
+		if (std_len > WHCI_PAGE_SIZE) {
+			if (qset_fill_page_list(whc, std, mem_flags) < 0)
+				goto err_no_mem;
+		} else
+			std->num_pointers = 0;
+
+		ntds_remaining--;
+		remaining -= std_len;
+		transfer_dma += std_len;
+	}
+
+	return 0;
+
+err_no_mem:
+	qset_free_stds(qset, urb);
+	return -ENOMEM;
+}
+
+/**
+ * qset_remove_urb - remove an URB from the urb queue.
+ *
+ * The URB is returned to the USB subsystem.
+ */
+void qset_remove_urb(struct whc *whc, struct whc_qset *qset,
+			    struct urb *urb, int status)
+{
+	struct wusbhc *wusbhc = &whc->wusbhc;
+	struct whc_urb *wurb = urb->hcpriv;
+
+	usb_hcd_unlink_urb_from_ep(&wusbhc->usb_hcd, urb);
+	/* Drop the lock as urb->complete() may enqueue another urb. */
+	spin_unlock(&whc->lock);
+	wusbhc_giveback_urb(wusbhc, urb, status);
+	spin_lock(&whc->lock);
+
+	kfree(wurb);
+}
+
+/**
+ * get_urb_status_from_qtd - get the completed urb status from qTD status
+ * @urb:    completed urb
+ * @status: qTD status
+ */
+static int get_urb_status_from_qtd(struct urb *urb, u32 status)
+{
+	if (status & QTD_STS_HALTED) {
+		if (status & QTD_STS_DBE)
+			return usb_pipein(urb->pipe) ? -ENOSR : -ECOMM;
+		else if (status & QTD_STS_BABBLE)
+			return -EOVERFLOW;
+		else if (status & QTD_STS_RCE)
+			return -ETIME;
+		return -EPIPE;
+	}
+	if (usb_pipein(urb->pipe)
+	    && (urb->transfer_flags & URB_SHORT_NOT_OK)
+	    && urb->actual_length < urb->transfer_buffer_length)
+		return -EREMOTEIO;
+	return 0;
+}
+
+/**
+ * process_inactive_qtd - process an inactive (but not halted) qTD.
+ *
+ * Update the urb with the transfer bytes from the qTD, if the urb is
+ * completely transfered or (in the case of an IN only) the LPF is
+ * set, then the transfer is complete and the urb should be returned
+ * to the system.
+ */
+void process_inactive_qtd(struct whc *whc, struct whc_qset *qset,
+				 struct whc_qtd *qtd)
+{
+	struct whc_std *std = list_first_entry(&qset->stds, struct whc_std, list_node);
+	struct urb *urb = std->urb;
+	uint32_t status;
+	bool complete;
+
+	status = le32_to_cpu(qtd->status);
+
+	urb->actual_length += std->len - QTD_STS_TO_LEN(status);
+
+	if (usb_pipein(urb->pipe) && (status & QTD_STS_LAST_PKT))
+		complete = true;
+	else
+		complete = whc_std_last(std);
+
+	qset_remove_qtd(whc, qset);
+	qset_free_std(whc, std);
+
+	/*
+	 * Transfers for this URB are complete?  Then return it to the
+	 * USB subsystem.
+	 */
+	if (complete) {
+		qset_remove_qtds(whc, qset, urb);
+		qset_remove_urb(whc, qset, urb, get_urb_status_from_qtd(urb, status));
+
+		/*
+		 * If iAlt isn't valid then the hardware didn't
+		 * advance iCur. Adjust the start and end pointers to
+		 * match iCur.
+		 */
+		if (!(status & QTD_STS_IALT_VALID))
+			qset->td_start = qset->td_end
+				= QH_STATUS_TO_ICUR(le16_to_cpu(qset->qh.status));
+		qset->pause_after_urb = NULL;
+	}
+}
+
+/**
+ * process_halted_qtd - process a qset with a halted qtd
+ *
+ * Remove all the qTDs for the failed URB and return the failed URB to
+ * the USB subsystem.  Then remove all other qTDs so the qset can be
+ * removed.
+ *
+ * FIXME: this is the point where rate adaptation can be done.  If a
+ * transfer failed because it exceeded the maximum number of retries
+ * then it could be reactivated with a slower rate without having to
+ * remove the qset.
+ */
+void process_halted_qtd(struct whc *whc, struct whc_qset *qset,
+			       struct whc_qtd *qtd)
+{
+	struct whc_std *std = list_first_entry(&qset->stds, struct whc_std, list_node);
+	struct urb *urb = std->urb;
+	int urb_status;
+
+	urb_status = get_urb_status_from_qtd(urb, le32_to_cpu(qtd->status));
+
+	qset_remove_qtds(whc, qset, urb);
+	qset_remove_urb(whc, qset, urb, urb_status);
+
+	list_for_each_entry(std, &qset->stds, list_node) {
+		if (qset->ntds == 0)
+			break;
+		qset_remove_qtd(whc, qset);
+		std->qtd = NULL;
+	}
+
+	qset->remove = 1;
+}
+
+void qset_free(struct whc *whc, struct whc_qset *qset)
+{
+	dma_pool_free(whc->qset_pool, qset, qset->qset_dma);
+}
+
+/**
+ * qset_delete - wait for a qset to be unused, then free it.
+ */
+void qset_delete(struct whc *whc, struct whc_qset *qset)
+{
+	wait_for_completion(&qset->remove_complete);
+	qset_free(whc, qset);
+}
diff -urN host/whci/whcd.h host.new/whci/whcd.h
--- host/whci/whcd.h	1970-01-01 01:00:00.000000000 +0100
+++ host.new/whci/whcd.h	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,205 @@
+/*
+ * Wireless Host Controller (WHC) private header.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ */
+#ifndef __WHCD_H
+#define __WHCD_H
+
+#include <linux/uwb/whci.h>
+#include <linux/uwb/umc.h>
+#include <linux/workqueue.h>
+
+#include "whci-hc.h"
+
+/* Generic command timeout. */
+#define WHC_GENCMD_TIMEOUT_MS 100
+
+struct whc_dbg;
+
+struct whc {
+	struct wusbhc wusbhc;
+	struct umc_dev *umc;
+
+	resource_size_t base_phys;
+	void __iomem *base;
+	int irq;
+
+	u8 n_devices;
+	u8 n_keys;
+	u8 n_mmc_ies;
+
+	u64 *pz_list;
+	struct dn_buf_entry *dn_buf;
+	struct di_buf_entry *di_buf;
+	dma_addr_t pz_list_dma;
+	dma_addr_t dn_buf_dma;
+	dma_addr_t di_buf_dma;
+
+	spinlock_t   lock;
+	struct mutex mutex;
+
+	void *            gen_cmd_buf;
+	dma_addr_t        gen_cmd_buf_dma;
+	wait_queue_head_t cmd_wq;
+
+	struct workqueue_struct *workqueue;
+	struct work_struct       dn_work;
+
+	struct dma_pool *qset_pool;
+
+	struct list_head async_list;
+	struct list_head async_removed_list;
+	wait_queue_head_t async_list_wq;
+	struct work_struct async_work;
+
+	struct list_head periodic_list[5];
+	struct list_head periodic_removed_list;
+	wait_queue_head_t periodic_list_wq;
+	struct work_struct periodic_work;
+
+	struct whc_dbg *dbg;
+};
+
+#define wusbhc_to_whc(w) (container_of((w), struct whc, wusbhc))
+
+/**
+ * struct whc_std - a software TD.
+ * @urb: the URB this sTD is for.
+ * @offset: start of the URB's data for this TD.
+ * @len: the length of data in the associated TD.
+ * @ntds_remaining: number of TDs (starting from this one) in this transfer.
+ *
+ * Queued URBs may require more TDs than are available in a qset so we
+ * use a list of these "software TDs" (sTDs) to hold per-TD data.
+ */
+struct whc_std {
+	struct urb *urb;
+	size_t len;
+	int    ntds_remaining;
+	struct whc_qtd *qtd;
+
+	struct list_head list_node;
+	int num_pointers;
+	dma_addr_t dma_addr;
+	struct whc_page_list_entry *pl_virt;
+};
+
+/**
+ * struct whc_urb - per URB host controller structure.
+ * @urb: the URB this struct is for.
+ * @qset: the qset associated to the URB.
+ * @dequeue_work: the work to remove the URB when dequeued.
+ * @is_async: the URB belongs to async sheduler or not.
+ * @status: the status to be returned when calling wusbhc_giveback_urb.
+ */
+struct whc_urb {
+	struct urb *urb;
+	struct whc_qset *qset;
+	struct work_struct dequeue_work;
+	bool is_async;
+	int status;
+};
+
+/**
+ * whc_std_last - is this sTD the URB's last?
+ * @std: the sTD to check.
+ */
+static inline bool whc_std_last(struct whc_std *std)
+{
+	return std->ntds_remaining <= 1;
+}
+
+enum whc_update {
+	WHC_UPDATE_ADDED   = 0x01,
+	WHC_UPDATE_REMOVED = 0x02,
+	WHC_UPDATE_UPDATED = 0x04,
+};
+
+/* init.c */
+int whc_init(struct whc *whc);
+void whc_clean_up(struct whc *whc);
+
+/* hw.c */
+void whc_write_wusbcmd(struct whc *whc, u32 mask, u32 val);
+int whc_do_gencmd(struct whc *whc, u32 cmd, u32 params, void *addr, size_t len);
+void whc_hw_error(struct whc *whc, const char *reason);
+
+/* wusb.c */
+int whc_wusbhc_start(struct wusbhc *wusbhc);
+void whc_wusbhc_stop(struct wusbhc *wusbhc, int delay);
+int whc_mmcie_add(struct wusbhc *wusbhc, u8 interval, u8 repeat_cnt,
+		  u8 handle, struct wuie_hdr *wuie);
+int whc_mmcie_rm(struct wusbhc *wusbhc, u8 handle);
+int whc_bwa_set(struct wusbhc *wusbhc, s8 stream_index, const struct uwb_mas_bm *mas_bm);
+int whc_dev_info_set(struct wusbhc *wusbhc, struct wusb_dev *wusb_dev);
+int whc_set_num_dnts(struct wusbhc *wusbhc, u8 interval, u8 slots);
+int whc_set_ptk(struct wusbhc *wusbhc, u8 port_idx, u32 tkid,
+		const void *ptk, size_t key_size);
+int whc_set_gtk(struct wusbhc *wusbhc, u32 tkid,
+		const void *gtk, size_t key_size);
+int whc_set_cluster_id(struct whc *whc, u8 bcid);
+
+/* int.c */
+irqreturn_t whc_int_handler(struct usb_hcd *hcd);
+void whc_dn_work(struct work_struct *work);
+
+/* asl.c */
+void asl_start(struct whc *whc);
+void asl_stop(struct whc *whc);
+int  asl_init(struct whc *whc);
+void asl_clean_up(struct whc *whc);
+int  asl_urb_enqueue(struct whc *whc, struct urb *urb, gfp_t mem_flags);
+int  asl_urb_dequeue(struct whc *whc, struct urb *urb, int status);
+void asl_qset_delete(struct whc *whc, struct whc_qset *qset);
+void scan_async_work(struct work_struct *work);
+
+/* pzl.c */
+int  pzl_init(struct whc *whc);
+void pzl_clean_up(struct whc *whc);
+void pzl_start(struct whc *whc);
+void pzl_stop(struct whc *whc);
+int  pzl_urb_enqueue(struct whc *whc, struct urb *urb, gfp_t mem_flags);
+int  pzl_urb_dequeue(struct whc *whc, struct urb *urb, int status);
+void pzl_qset_delete(struct whc *whc, struct whc_qset *qset);
+void scan_periodic_work(struct work_struct *work);
+
+/* qset.c */
+struct whc_qset *qset_alloc(struct whc *whc, gfp_t mem_flags);
+void qset_free(struct whc *whc, struct whc_qset *qset);
+struct whc_qset *get_qset(struct whc *whc, struct urb *urb, gfp_t mem_flags);
+void qset_delete(struct whc *whc, struct whc_qset *qset);
+void qset_clear(struct whc *whc, struct whc_qset *qset);
+int qset_add_urb(struct whc *whc, struct whc_qset *qset, struct urb *urb,
+		 gfp_t mem_flags);
+void qset_free_std(struct whc *whc, struct whc_std *std);
+void qset_remove_urb(struct whc *whc, struct whc_qset *qset,
+			    struct urb *urb, int status);
+void process_halted_qtd(struct whc *whc, struct whc_qset *qset,
+			       struct whc_qtd *qtd);
+void process_inactive_qtd(struct whc *whc, struct whc_qset *qset,
+				 struct whc_qtd *qtd);
+enum whc_update qset_add_qtds(struct whc *whc, struct whc_qset *qset);
+void qset_remove_complete(struct whc *whc, struct whc_qset *qset);
+void pzl_update(struct whc *whc, uint32_t wusbcmd);
+void asl_update(struct whc *whc, uint32_t wusbcmd);
+
+/* debug.c */
+void whc_dbg_init(struct whc *whc);
+void whc_dbg_clean_up(struct whc *whc);
+
+#endif /* #ifndef __WHCD_H */
diff -urN host/whci/whci-hc.h host.new/whci/whci-hc.h
--- host/whci/whci-hc.h	1970-01-01 01:00:00.000000000 +0100
+++ host.new/whci/whci-hc.h	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,418 @@
+/*
+ * Wireless Host Controller (WHC) data structures.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ */
+#ifndef _WHCI_WHCI_HC_H
+#define _WHCI_WHCI_HC_H
+
+#include <linux/list.h>
+
+/**
+ * WHCI_PAGE_SIZE - page size use by WHCI
+ *
+ * WHCI assumes that host system uses pages of 4096 octets.
+ */
+#define WHCI_PAGE_SIZE 4096
+
+
+/**
+ * QTD_MAX_TXFER_SIZE - max number of bytes to transfer with a single
+ * qtd.
+ *
+ * This is 2^20 - 1.
+ */
+#define QTD_MAX_XFER_SIZE 1048575
+
+
+/**
+ * struct whc_qtd - Queue Element Transfer Descriptors (qTD)
+ *
+ * This describes the data for a bulk, control or interrupt transfer.
+ *
+ * [WHCI] section 3.2.4
+ */
+struct whc_qtd {
+	__le32 status; /*< remaining transfer len and transfer status */
+	__le32 options;
+	__le64 page_list_ptr; /*< physical pointer to data buffer page list*/
+	__u8   setup[8];      /*< setup data for control transfers */
+} __attribute__((packed));
+
+#define QTD_STS_ACTIVE     (1 << 31)  /* enable execution of transaction */
+#define QTD_STS_HALTED     (1 << 30)  /* transfer halted */
+#define QTD_STS_DBE        (1 << 29)  /* data buffer error */
+#define QTD_STS_BABBLE     (1 << 28)  /* babble detected */
+#define QTD_STS_RCE        (1 << 27)  /* retry count exceeded */
+#define QTD_STS_LAST_PKT   (1 << 26)  /* set Last Packet Flag in WUSB header */
+#define QTD_STS_INACTIVE   (1 << 25)  /* queue set is marked inactive */
+#define QTD_STS_IALT_VALID (1 << 23)                          /* iAlt field is valid */
+#define QTD_STS_IALT(i)    (QTD_STS_IALT_VALID | ((i) << 20)) /* iAlt field */
+#define QTD_STS_LEN(l)     ((l) << 0) /* transfer length */
+#define QTD_STS_TO_LEN(s)  ((s) & 0x000fffff)
+
+#define QTD_OPT_IOC      (1 << 1) /* page_list_ptr points to buffer directly */
+#define QTD_OPT_SMALL    (1 << 0) /* interrupt on complete */
+
+/**
+ * struct whc_itd - Isochronous Queue Element Transfer Descriptors (iTD)
+ *
+ * This describes the data and other parameters for an isochronous
+ * transfer.
+ *
+ * [WHCI] section 3.2.5
+ */
+struct whc_itd {
+	__le16 presentation_time;    /*< presentation time for OUT transfers */
+	__u8   num_segments;         /*< number of data segments in segment list */
+	__u8   status;               /*< command execution status */
+	__le32 options;              /*< misc transfer options */
+	__le64 page_list_ptr;        /*< physical pointer to data buffer page list */
+	__le64 seg_list_ptr;         /*< physical pointer to segment list */
+} __attribute__((packed));
+
+#define ITD_STS_ACTIVE   (1 << 7) /* enable execution of transaction */
+#define ITD_STS_DBE      (1 << 5) /* data buffer error */
+#define ITD_STS_BABBLE   (1 << 4) /* babble detected */
+#define ITD_STS_INACTIVE (1 << 1) /* queue set is marked inactive */
+
+#define ITD_OPT_IOC      (1 << 1) /* interrupt on complete */
+#define ITD_OPT_SMALL    (1 << 0) /* page_list_ptr points to buffer directly */
+
+/**
+ * Page list entry.
+ *
+ * A TD's page list must contain sufficient page list entries for the
+ * total data length in the TD.
+ *
+ * [WHCI] section 3.2.4.3
+ */
+struct whc_page_list_entry {
+	__le64 buf_ptr; /*< physical pointer to buffer */
+} __attribute__((packed));
+
+/**
+ * struct whc_seg_list_entry - Segment list entry.
+ *
+ * Describes a portion of the data buffer described in the containing
+ * qTD's page list.
+ *
+ * seg_ptr = qtd->page_list_ptr[qtd->seg_list_ptr[seg].idx].buf_ptr
+ *           + qtd->seg_list_ptr[seg].offset;
+ *
+ * Segments can't cross page boundries.
+ *
+ * [WHCI] section 3.2.5.5
+ */
+struct whc_seg_list_entry {
+	__le16 len;    /*< segment length */
+	__u8   idx;    /*< index into page list */
+	__u8   status; /*< segment status */
+	__le16 offset; /*< 12 bit offset into page */
+} __attribute__((packed));
+
+/**
+ * struct whc_qhead - endpoint and status information for a qset.
+ *
+ * [WHCI] section 3.2.6
+ */
+struct whc_qhead {
+	__le64 link; /*< next qset in list */
+	__le32 info1;
+	__le32 info2;
+	__le32 info3;
+	__le16 status;
+	__le16 err_count;  /*< transaction error count */
+	__le32 cur_window;
+	__le32 scratch[3]; /*< h/w scratch area */
+	union {
+		struct whc_qtd qtd;
+		struct whc_itd itd;
+	} overlay;
+} __attribute__((packed));
+
+#define QH_LINK_PTR_MASK (~0x03Full)
+#define QH_LINK_PTR(ptr) ((ptr) & QH_LINK_PTR_MASK)
+#define QH_LINK_IQS      (1 << 4) /* isochronous queue set */
+#define QH_LINK_NTDS(n)  (((n) - 1) << 1) /* number of TDs in queue set */
+#define QH_LINK_T        (1 << 0) /* last queue set in periodic schedule list */
+
+#define QH_INFO1_EP(e)           ((e) << 0)  /* endpoint number */
+#define QH_INFO1_DIR_IN          (1 << 4)    /* IN transfer */
+#define QH_INFO1_DIR_OUT         (0 << 4)    /* OUT transfer */
+#define QH_INFO1_TR_TYPE_CTRL    (0x0 << 5)  /* control transfer */
+#define QH_INFO1_TR_TYPE_ISOC    (0x1 << 5)  /* isochronous transfer */
+#define QH_INFO1_TR_TYPE_BULK    (0x2 << 5)  /* bulk transfer */
+#define QH_INFO1_TR_TYPE_INT     (0x3 << 5)  /* interrupt */
+#define QH_INFO1_TR_TYPE_LP_INT  (0x7 << 5)  /* low power interrupt */
+#define QH_INFO1_DEV_INFO_IDX(i) ((i) << 8)  /* index into device info buffer */
+#define QH_INFO1_SET_INACTIVE    (1 << 15)   /* set inactive after transfer */
+#define QH_INFO1_MAX_PKT_LEN(l)  ((l) << 16) /* maximum packet length */
+
+#define QH_INFO2_BURST(b)        ((b) << 0)  /* maximum burst length */
+#define QH_INFO2_DBP(p)          ((p) << 5)  /* data burst policy (see [WUSB] table 5-7) */
+#define QH_INFO2_MAX_COUNT(c)    ((c) << 8)  /* max isoc/int pkts per zone */
+#define QH_INFO2_RQS             (1 << 15)   /* reactivate queue set */
+#define QH_INFO2_MAX_RETRY(r)    ((r) << 16) /* maximum transaction retries */
+#define QH_INFO2_MAX_SEQ(s)      ((s) << 20) /* maximum sequence number */
+#define QH_INFO3_MAX_DELAY(d)    ((d) << 0)  /* maximum stream delay in 125 us units (isoc only) */
+#define QH_INFO3_INTERVAL(i)     ((i) << 16) /* segment interval in 125 us units (isoc only) */
+
+#define QH_INFO3_TX_RATE_53_3    (0 << 24)
+#define QH_INFO3_TX_RATE_80      (1 << 24)
+#define QH_INFO3_TX_RATE_106_7   (2 << 24)
+#define QH_INFO3_TX_RATE_160     (3 << 24)
+#define QH_INFO3_TX_RATE_200     (4 << 24)
+#define QH_INFO3_TX_RATE_320     (5 << 24)
+#define QH_INFO3_TX_RATE_400     (6 << 24)
+#define QH_INFO3_TX_RATE_480     (7 << 24)
+#define QH_INFO3_TX_PWR(p)       ((p) << 29) /* transmit power (see [WUSB] section 5.2.1.2) */
+
+#define QH_STATUS_FLOW_CTRL      (1 << 15)
+#define QH_STATUS_ICUR(i)        ((i) << 5)
+#define QH_STATUS_TO_ICUR(s)     (((s) >> 5) & 0x7)
+
+/**
+ * usb_pipe_to_qh_type - USB core pipe type to QH transfer type
+ *
+ * Returns the QH type field for a USB core pipe type.
+ */
+static inline unsigned usb_pipe_to_qh_type(unsigned pipe)
+{
+	static const unsigned type[] = {
+		[PIPE_ISOCHRONOUS] = QH_INFO1_TR_TYPE_ISOC,
+		[PIPE_INTERRUPT]   = QH_INFO1_TR_TYPE_INT,
+		[PIPE_CONTROL]     = QH_INFO1_TR_TYPE_CTRL,
+		[PIPE_BULK]        = QH_INFO1_TR_TYPE_BULK,
+	};
+	return type[usb_pipetype(pipe)];
+}
+
+/**
+ * Maxiumum number of TDs in a qset.
+ */
+#define WHCI_QSET_TD_MAX 8
+
+/**
+ * struct whc_qset - WUSB data transfers to a specific endpoint
+ * @qh: the QHead of this qset
+ * @qtd: up to 8 qTDs (for qsets for control, bulk and interrupt
+ * transfers)
+ * @itd: up to 8 iTDs (for qsets for isochronous transfers)
+ * @qset_dma: DMA address for this qset
+ * @whc: WHCI HC this qset is for
+ * @ep: endpoint
+ * @stds: list of sTDs queued to this qset
+ * @ntds: number of qTDs queued (not necessarily the same as nTDs
+ * field in the QH)
+ * @td_start: index of the first qTD in the list
+ * @td_end: index of next free qTD in the list (provided
+ *          ntds < WHCI_QSET_TD_MAX)
+ *
+ * Queue Sets (qsets) are added to the asynchronous schedule list
+ * (ASL) or the periodic zone list (PZL).
+ *
+ * qsets may contain up to 8 TDs (either qTDs or iTDs as appropriate).
+ * Each TD may refer to at most 1 MiB of data. If a single transfer
+ * has > 8MiB of data, TDs can be reused as they are completed since
+ * the TD list is used as a circular buffer.  Similarly, several
+ * (smaller) transfers may be queued in a qset.
+ *
+ * WHCI controllers may cache portions of the qsets in the ASL and
+ * PZL, requiring the WHCD to inform the WHC that the lists have been
+ * updated (fields changed or qsets inserted or removed).  For safe
+ * insertion and removal of qsets from the lists the schedule must be
+ * stopped to avoid races in updating the QH link pointers.
+ *
+ * Since the HC is free to execute qsets in any order, all transfers
+ * to an endpoint should use the same qset to ensure transfers are
+ * executed in the order they're submitted.
+ *
+ * [WHCI] section 3.2.3
+ */
+struct whc_qset {
+	struct whc_qhead qh;
+	union {
+		struct whc_qtd qtd[WHCI_QSET_TD_MAX];
+		struct whc_itd itd[WHCI_QSET_TD_MAX];
+	};
+
+	/* private data for WHCD */
+	dma_addr_t qset_dma;
+	struct whc *whc;
+	struct usb_host_endpoint *ep;
+	struct list_head stds;
+	int ntds;
+	int td_start;
+	int td_end;
+	struct list_head list_node;
+	unsigned in_sw_list:1;
+	unsigned in_hw_list:1;
+	unsigned remove:1;
+	struct urb *pause_after_urb;
+	struct completion remove_complete;
+	int max_burst;
+	int max_seq;
+};
+
+static inline void whc_qset_set_link_ptr(u64 *ptr, u64 target)
+{
+	if (target)
+		*ptr = (*ptr & ~(QH_LINK_PTR_MASK | QH_LINK_T)) | QH_LINK_PTR(target);
+	else
+		*ptr = QH_LINK_T;
+}
+
+/**
+ * struct di_buf_entry - Device Information (DI) buffer entry.
+ *
+ * There's one of these per connected device.
+ */
+struct di_buf_entry {
+	__le32 availability_info[8]; /*< MAS availability information, one MAS per bit */
+	__le32 addr_sec_info;        /*< addressing and security info */
+	__le32 reserved[7];
+} __attribute__((packed));
+
+#define WHC_DI_SECURE           (1 << 31)
+#define WHC_DI_DISABLE          (1 << 30)
+#define WHC_DI_KEY_IDX(k)       ((k) << 8)
+#define WHC_DI_KEY_IDX_MASK     0x0000ff00
+#define WHC_DI_DEV_ADDR(a)      ((a) << 0)
+#define WHC_DI_DEV_ADDR_MASK    0x000000ff
+
+/**
+ * struct dn_buf_entry - Device Notification (DN) buffer entry.
+ *
+ * [WHCI] section 3.2.8
+ */
+struct dn_buf_entry {
+	__u8   msg_size;    /*< number of octets of valid DN data */
+	__u8   reserved1;
+	__u8   src_addr;    /*< source address */
+	__u8   status;      /*< buffer entry status */
+	__le32 tkid;        /*< TKID for source device, valid if secure bit is set */
+	__u8   dn_data[56]; /*< up to 56 octets of DN data */
+} __attribute__((packed));
+
+#define WHC_DN_STATUS_VALID  (1 << 7) /* buffer entry is valid */
+#define WHC_DN_STATUS_SECURE (1 << 6) /* notification received using secure frame */
+
+#define WHC_N_DN_ENTRIES (4096 / sizeof(struct dn_buf_entry))
+
+/* The Add MMC IE WUSB Generic Command may take up to 256 bytes of
+   data. [WHCI] section 2.4.7. */
+#define WHC_GEN_CMD_DATA_LEN 256
+
+/*
+ * HC registers.
+ *
+ * [WHCI] section 2.4
+ */
+
+#define WHCIVERSION          0x00
+
+#define WHCSPARAMS           0x04
+#  define WHCSPARAMS_TO_N_MMC_IES(p) (((p) >> 16) & 0xff)
+#  define WHCSPARAMS_TO_N_KEYS(p)    (((p) >> 8) & 0xff)
+#  define WHCSPARAMS_TO_N_DEVICES(p) (((p) >> 0) & 0x7f)
+
+#define WUSBCMD              0x08
+#  define WUSBCMD_BCID(b)            ((b) << 16)
+#  define WUSBCMD_BCID_MASK          (0xff << 16)
+#  define WUSBCMD_ASYNC_QSET_RM      (1 << 12)
+#  define WUSBCMD_PERIODIC_QSET_RM   (1 << 11)
+#  define WUSBCMD_WUSBSI(s)          ((s) << 8)
+#  define WUSBCMD_WUSBSI_MASK        (0x7 << 8)
+#  define WUSBCMD_ASYNC_SYNCED_DB    (1 << 7)
+#  define WUSBCMD_PERIODIC_SYNCED_DB (1 << 6)
+#  define WUSBCMD_ASYNC_UPDATED      (1 << 5)
+#  define WUSBCMD_PERIODIC_UPDATED   (1 << 4)
+#  define WUSBCMD_ASYNC_EN           (1 << 3)
+#  define WUSBCMD_PERIODIC_EN        (1 << 2)
+#  define WUSBCMD_WHCRESET           (1 << 1)
+#  define WUSBCMD_RUN                (1 << 0)
+
+#define WUSBSTS              0x0c
+#  define WUSBSTS_ASYNC_SCHED             (1 << 15)
+#  define WUSBSTS_PERIODIC_SCHED          (1 << 14)
+#  define WUSBSTS_DNTS_SCHED              (1 << 13)
+#  define WUSBSTS_HCHALTED                (1 << 12)
+#  define WUSBSTS_GEN_CMD_DONE            (1 << 9)
+#  define WUSBSTS_CHAN_TIME_ROLLOVER      (1 << 8)
+#  define WUSBSTS_DNTS_OVERFLOW           (1 << 7)
+#  define WUSBSTS_BPST_ADJUSTMENT_CHANGED (1 << 6)
+#  define WUSBSTS_HOST_ERR                (1 << 5)
+#  define WUSBSTS_ASYNC_SCHED_SYNCED      (1 << 4)
+#  define WUSBSTS_PERIODIC_SCHED_SYNCED   (1 << 3)
+#  define WUSBSTS_DNTS_INT                (1 << 2)
+#  define WUSBSTS_ERR_INT                 (1 << 1)
+#  define WUSBSTS_INT                     (1 << 0)
+#  define WUSBSTS_INT_MASK                0x3ff
+
+#define WUSBINTR             0x10
+#  define WUSBINTR_GEN_CMD_DONE             (1 << 9)
+#  define WUSBINTR_CHAN_TIME_ROLLOVER       (1 << 8)
+#  define WUSBINTR_DNTS_OVERFLOW            (1 << 7)
+#  define WUSBINTR_BPST_ADJUSTMENT_CHANGED  (1 << 6)
+#  define WUSBINTR_HOST_ERR                 (1 << 5)
+#  define WUSBINTR_ASYNC_SCHED_SYNCED       (1 << 4)
+#  define WUSBINTR_PERIODIC_SCHED_SYNCED    (1 << 3)
+#  define WUSBINTR_DNTS_INT                 (1 << 2)
+#  define WUSBINTR_ERR_INT                  (1 << 1)
+#  define WUSBINTR_INT                      (1 << 0)
+#  define WUSBINTR_ALL 0x3ff
+
+#define WUSBGENCMDSTS        0x14
+#  define WUSBGENCMDSTS_ACTIVE (1 << 31)
+#  define WUSBGENCMDSTS_ERROR  (1 << 24)
+#  define WUSBGENCMDSTS_IOC    (1 << 23)
+#  define WUSBGENCMDSTS_MMCIE_ADD 0x01
+#  define WUSBGENCMDSTS_MMCIE_RM  0x02
+#  define WUSBGENCMDSTS_SET_MAS   0x03
+#  define WUSBGENCMDSTS_CHAN_STOP 0x04
+#  define WUSBGENCMDSTS_RWP_EN    0x05
+
+#define WUSBGENCMDPARAMS     0x18
+#define WUSBGENADDR          0x20
+#define WUSBASYNCLISTADDR    0x28
+#define WUSBDNTSBUFADDR      0x30
+#define WUSBDEVICEINFOADDR   0x38
+
+#define WUSBSETSECKEYCMD     0x40
+#  define WUSBSETSECKEYCMD_SET    (1 << 31)
+#  define WUSBSETSECKEYCMD_ERASE  (1 << 30)
+#  define WUSBSETSECKEYCMD_GTK    (1 << 8)
+#  define WUSBSETSECKEYCMD_IDX(i) ((i) << 0)
+
+#define WUSBTKID             0x44
+#define WUSBSECKEY           0x48
+#define WUSBPERIODICLISTBASE 0x58
+#define WUSBMASINDEX         0x60
+
+#define WUSBDNTSCTRL         0x64
+#  define WUSBDNTSCTRL_ACTIVE      (1 << 31)
+#  define WUSBDNTSCTRL_INTERVAL(i) ((i) << 8)
+#  define WUSBDNTSCTRL_SLOTS(s)    ((s) << 0)
+
+#define WUSBTIME             0x68
+#  define WUSBTIME_CHANNEL_TIME_MASK 0x00ffffff
+
+#define WUSBBPST             0x6c
+#define WUSBDIBUPDATED       0x70
+
+#endif /* #ifndef _WHCI_WHCI_HC_H */
diff -urN host/whci/wusb.c host.new/whci/wusb.c
--- host/whci/wusb.c	1970-01-01 01:00:00.000000000 +0100
+++ host.new/whci/wusb.c	2009-03-28 17:46:02.000000000 +0100
@@ -0,0 +1,222 @@
+/*
+ * Wireless Host Controller (WHC) WUSB operations.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/uwb/umc.h>
+
+#include "../../wusbcore/wusbhc.h"
+
+#include "whcd.h"
+
+static int whc_update_di(struct whc *whc, int idx)
+{
+	int offset = idx / 32;
+	u32 bit = 1 << (idx % 32);
+
+	le_writel(bit, whc->base + WUSBDIBUPDATED + offset);
+
+	return whci_wait_for(&whc->umc->dev,
+			     whc->base + WUSBDIBUPDATED + offset, bit, 0,
+			     100, "DI update");
+}
+
+/*
+ * WHCI starts MMCs based on there being a valid GTK so these need
+ * only start/stop the asynchronous and periodic schedules and send a
+ * channel stop command.
+ */
+
+int whc_wusbhc_start(struct wusbhc *wusbhc)
+{
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+
+	asl_start(whc);
+	pzl_start(whc);
+
+	return 0;
+}
+
+void whc_wusbhc_stop(struct wusbhc *wusbhc, int delay)
+{
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+	u32 stop_time, now_time;
+	int ret;
+
+	pzl_stop(whc);
+	asl_stop(whc);
+
+	now_time = le_readl(whc->base + WUSBTIME) & WUSBTIME_CHANNEL_TIME_MASK;
+	stop_time = (now_time + ((delay * 8) << 7)) & 0x00ffffff;
+	ret = whc_do_gencmd(whc, WUSBGENCMDSTS_CHAN_STOP, stop_time, NULL, 0);
+	if (ret == 0)
+		msleep(delay);
+}
+
+int whc_mmcie_add(struct wusbhc *wusbhc, u8 interval, u8 repeat_cnt,
+		  u8 handle, struct wuie_hdr *wuie)
+{
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+	u32 params;
+
+	params = (interval << 24)
+		| (repeat_cnt << 16)
+		| (wuie->bLength << 8)
+		| handle;
+
+	return whc_do_gencmd(whc, WUSBGENCMDSTS_MMCIE_ADD, params, wuie, wuie->bLength);
+}
+
+int whc_mmcie_rm(struct wusbhc *wusbhc, u8 handle)
+{
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+	u32 params;
+
+	params = handle;
+
+	return whc_do_gencmd(whc, WUSBGENCMDSTS_MMCIE_RM, params, NULL, 0);
+}
+
+int whc_bwa_set(struct wusbhc *wusbhc, s8 stream_index, const struct uwb_mas_bm *mas_bm)
+{
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+
+	if (stream_index >= 0)
+		whc_write_wusbcmd(whc, WUSBCMD_WUSBSI_MASK, WUSBCMD_WUSBSI(stream_index));
+
+	return whc_do_gencmd(whc, WUSBGENCMDSTS_SET_MAS, 0, (void *)mas_bm, sizeof(*mas_bm));
+}
+
+int whc_dev_info_set(struct wusbhc *wusbhc, struct wusb_dev *wusb_dev)
+{
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+	int idx = wusb_dev->port_idx;
+	struct di_buf_entry *di = &whc->di_buf[idx];
+	int ret;
+
+	mutex_lock(&whc->mutex);
+
+	uwb_mas_bm_copy_le(di->availability_info, &wusb_dev->availability);
+	di->addr_sec_info &= ~(WHC_DI_DISABLE | WHC_DI_DEV_ADDR_MASK);
+	di->addr_sec_info |= WHC_DI_DEV_ADDR(wusb_dev->addr);
+
+	ret = whc_update_di(whc, idx);
+
+	mutex_unlock(&whc->mutex);
+
+	return ret;
+}
+
+/*
+ * Set the number of Device Notification Time Slots (DNTS) and enable
+ * device notifications.
+ */
+int whc_set_num_dnts(struct wusbhc *wusbhc, u8 interval, u8 slots)
+{
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+	u32 dntsctrl;
+
+	dntsctrl = WUSBDNTSCTRL_ACTIVE
+		| WUSBDNTSCTRL_INTERVAL(interval)
+		| WUSBDNTSCTRL_SLOTS(slots);
+
+	le_writel(dntsctrl, whc->base + WUSBDNTSCTRL);
+
+	return 0;
+}
+
+static int whc_set_key(struct whc *whc, u8 key_index, uint32_t tkid,
+		       const void *key, size_t key_size, bool is_gtk)
+{
+	uint32_t setkeycmd;
+	uint32_t seckey[4];
+	int i;
+	int ret;
+
+	memcpy(seckey, key, key_size);
+	setkeycmd = WUSBSETSECKEYCMD_SET | WUSBSETSECKEYCMD_IDX(key_index);
+	if (is_gtk)
+		setkeycmd |= WUSBSETSECKEYCMD_GTK;
+
+	le_writel(tkid, whc->base + WUSBTKID);
+	for (i = 0; i < 4; i++)
+		le_writel(seckey[i], whc->base + WUSBSECKEY + 4*i);
+	le_writel(setkeycmd, whc->base + WUSBSETSECKEYCMD);
+
+	ret = whci_wait_for(&whc->umc->dev, whc->base + WUSBSETSECKEYCMD,
+			    WUSBSETSECKEYCMD_SET, 0, 100, "set key");
+
+	return ret;
+}
+
+/**
+ * whc_set_ptk - set the PTK to use for a device.
+ *
+ * The index into the key table for this PTK is the same as the
+ * device's port index.
+ */
+int whc_set_ptk(struct wusbhc *wusbhc, u8 port_idx, u32 tkid,
+		const void *ptk, size_t key_size)
+{
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+	struct di_buf_entry *di = &whc->di_buf[port_idx];
+	int ret;
+
+	mutex_lock(&whc->mutex);
+
+	if (ptk) {
+		ret = whc_set_key(whc, port_idx, tkid, ptk, key_size, false);
+		if (ret)
+			goto out;
+
+		di->addr_sec_info &= ~WHC_DI_KEY_IDX_MASK;
+		di->addr_sec_info |= WHC_DI_SECURE | WHC_DI_KEY_IDX(port_idx);
+	} else
+		di->addr_sec_info &= ~WHC_DI_SECURE;
+
+	ret = whc_update_di(whc, port_idx);
+out:
+	mutex_unlock(&whc->mutex);
+	return ret;
+}
+
+/**
+ * whc_set_gtk - set the GTK for subsequent broadcast packets
+ *
+ * The GTK is stored in the last entry in the key table (the previous
+ * N_DEVICES entries are for the per-device PTKs).
+ */
+int whc_set_gtk(struct wusbhc *wusbhc, u32 tkid,
+		const void *gtk, size_t key_size)
+{
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+	int ret;
+
+	mutex_lock(&whc->mutex);
+
+	ret = whc_set_key(whc, whc->n_devices, tkid, gtk, key_size, true);
+
+	mutex_unlock(&whc->mutex);
+
+	return ret;
+}
+
+int whc_set_cluster_id(struct whc *whc, u8 bcid)
+{
+	whc_write_wusbcmd(whc, WUSBCMD_BCID_MASK, WUSBCMD_BCID(bcid));
+	return 0;
+}
