Common subdirectories: host.old/.svn and host/.svn
Files host.old/built-in.o and host/built-in.o differ
diff host.old/ehci-fotg2xx.c host/ehci-fotg2xx.c
10,18d9
<  *
<  *  This program is distributed in the hope that it will be useful,
<  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
<  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  *  GNU General Public License for more details.
<  *
<  *  You should have received a copy of the GNU General Public License
<  *  along with this program; if not, write to the Free Software
<  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
23,24d13
< #define IO_ADDRESS(x)      (((x&0xfff00000)>>4)|(x & 0x000fffff)|0xF0000000)
< 
31,38c20,26
< #define OTGC_INT_BSRPDN                           BIT(0)
< #define OTGC_INT_ASRPDET                          BIT(4)
< #define OTGC_INT_AVBUSERR                         BIT(5)
< #define OTGC_INT_RLCHG                            BIT(8)
< #define OTGC_INT_IDCHG                            BIT(9)
< #define OTGC_INT_OVC                              BIT(10)
< #define OTGC_INT_BPLGRMV                          BIT(11)
< #define OTGC_INT_APLGRMV                          BIT(12)
---
> #define GLOBAL_ISR			0xC0
> #define GLOBAL_ICR			0xC4
> 
> #define HCD_MISC			0x40
> 
> #define OTGC_SCR			0x80
> #define OTGC_INT_EN			0x88
40,41c28,52
< #define OTGC_INT_A_TYPE                           (OTGC_INT_ASRPDET|OTGC_INT_AVBUSERR|OTGC_INT_OVC|OTGC_INT_RLCHG|OTGC_INT_IDCHG|OTGC_INT_APLGRMV)
< #define OTGC_INT_B_TYPE                           (OTGC_INT_AVBUSERR|OTGC_INT_OVC|OTGC_INT_RLCHG|OTGC_INT_IDCHG)
---
> #define GLOBAL_INT_POLARITY		(1 << 3)
> #define GLOBAL_INT_MASK_HC		(1 << 2)
> #define GLOBAL_INT_MASK_OTG		(1 << 1)
> #define GLOBAL_INT_MASK_DEV		(1 << 0)
> 
> #define OTGC_SCR_ID			(1 << 21)
> #define OTGC_SCR_CROLE			(1 << 20)
> #define OTGC_SCR_VBUS_VLD		(1 << 19)
> #define OTGC_SCR_A_SRP_RESP_TYPE	(1 << 8)
> #define OTGC_SCR_A_SRP_DET_EN		(1 << 7)
> #define OTGC_SCR_A_SET_B_HNP_EN		(1 << 6)
> #define OTGC_SCR_A_BUS_DROP		(1 << 5)
> #define OTGC_SCR_A_BUS_REQ		(1 << 4)
> 
> #define OTGC_INT_APLGRMV		(1 << 12)
> #define OTGC_INT_BPLGRMV		(1 << 11)
> #define OTGC_INT_OVC			(1 << 10)
> #define OTGC_INT_IDCHG			(1 << 9)
> #define OTGC_INT_RLCHG			(1 << 8)
> #define OTGC_INT_AVBUSERR		(1 << 5)
> #define OTGC_INT_ASRPDET		(1 << 4)
> #define OTGC_INT_BSRPDN			(1 << 0)
> 
> #define OTGC_INT_A_TYPE		(OTGC_INT_ASRPDET|OTGC_INT_AVBUSERR|OTGC_INT_OVC|OTGC_INT_RLCHG|OTGC_INT_IDCHG|OTGC_INT_APLGRMV)
> #define OTGC_INT_B_TYPE		(OTGC_INT_AVBUSERR|OTGC_INT_OVC|OTGC_INT_RLCHG|OTGC_INT_IDCHG)
47c58,59
< 	/***************** OTG HW INIT *****************/
---
> 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
> 	unsigned int reg;
49,50c61,63
< 	printk("USB OTG2xx role detected: %s, ",
< 		((readl(hcd->regs + 0x80) >> 20) & 1)?"Peripheral":"Host");
---
> 	reg = __raw_readl(hcd->regs + OTGC_SCR);
> 	ehci_info(ehci, "role detected: %s, ",
> 		  (reg & OTGC_SCR_CROLE) ? "Peripheral" : "Host");
52,54c65,66
< 	/* register 0x80, bit21 - 0: A-Device, 1: B-Device */
< 	if (readl(hcd->regs + 0x80) & (1 << 21))
< 		printk("B-Device (may be unsupported!)\n");
---
> 	if (reg & OTGC_SCR_ID)
> 		ehci_info(ehci, "B-Device (may be unsupported!)\n");
56c68
< 		printk("A-Device\n");
---
> 		ehci_info(ehci, "A-Device\n");
58,59c70,72
< 	/* clear A_SRP_RESP_TYPE */
< 	otg_clear(0x80, BIT(8));
---
> 	/* Enable the SRP detect */
> 	reg &= ~OTGC_SCR_A_SRP_RESP_TYPE;
> 	__raw_writel(reg, hcd->regs + OTGC_SCR);
60a74
> 	reg = __raw_readl(hcd->regs + OTGC_INT_EN);
62,63c76
< 	otg_clear(0x88, OTGC_INT_B_TYPE);
< 
---
> 	reg &= ~OTGC_INT_B_TYPE;
65c78,79
< 	otg_set(0x88, OTGC_INT_A_TYPE);
---
> 	reg |= OTGC_INT_A_TYPE;
> 	__raw_writel(reg, hcd->regs + OTGC_INT_EN);
67,70c81,88
< 	otg_clear(0xc4, BIT(1)); /* unMASK OTG INT */
< 
< 	/* WILIBOX: setup MISC register, fixes timing problems */
< 	otg_set(0x40, 0xD);
---
> 	reg = __raw_readl(hcd->regs + GLOBAL_ICR);
> 	reg &= ~GLOBAL_INT_MASK_OTG;
> 	__raw_writel(reg, hcd->regs + GLOBAL_ICR);
> 
> 	/* setup MISC register, fixes timing problems */
> 	reg = __raw_readl(hcd->regs + HCD_MISC);
> 	reg |= 0xD;
> 	__raw_writel(reg, hcd->regs + HCD_MISC);
75,96d92
< static void fotg2xx_otgp_close(struct usb_hcd *hcd)
< {
< 	u32 wTemp;
< 
< 	/* usb glob int dis */
< 	otg_clear(0x100, BIT(2));
< 
< 	/* mask perip. set */
< 	otg_set(0xc4, BIT(0));
< 
< 	/* clear int status (?) */
< 	wTemp = readl(hcd->regs + 0x140);
< 	wTemp = readl(hcd->regs + 0x144);
< 	wTemp = readl(hcd->regs + 0x148);
< 	wTemp = readl(hcd->regs + 0x14C);
< 
< 	otg_set(0x140, 0);
< 	otg_set(0x144, 0);
< 	otg_set(0x148, 0);
< 	otg_set(0x14C, 0);
< }
< 
99c95
< 	u32 wTemp;
---
> 	unsigned int reg;
101,112c97,105
< 	/* <1>.Enable Interrupt Mask
< 	mdwOTGC_GINT_MASK_HOST_Set(); */
< 	otg_set(0xc4, BIT(2));
< 
< 	/* <2>.Clear the Interrupt status
< 	wTemp=mdwHost20_USBINTR_Rd();
< 	wTemp=wTemp&0x0000003F;
< 	mdwHost20_USBSTS_Set(wTemp); */
< 
< 	wTemp = readl(hcd->regs + 0x18);
< 	wTemp = wTemp & 0x0000003F;
< 	writel(wTemp, hcd->regs + 0x14);
---
> 	/* <1>.Enable Interrupt Mask */
> 	reg = __raw_readl(hcd->regs + GLOBAL_ICR);
> 	reg |= GLOBAL_INT_MASK_HC;
> 	__raw_writel(reg, hcd->regs + GLOBAL_ICR);
> 
> 	/* <2>.Clear the Interrupt status */
> 	reg = __raw_readl(hcd->regs + 0x18);
> 	reg &= 0x0000003F;
> 	__raw_writel(reg, hcd->regs + 0x14);
117,120c110,118
< 	/* clear A_SRP_DET */
< 	otg_clear(0x80, BIT(7));
< 	/* clear HOST INT MASK */
< 	otg_clear(0xc4, BIT(2));
---
> 	unsigned int reg;
> 
> 	reg = __raw_readl(hcd->regs + OTGC_SCR);
> 	reg &= ~OTGC_SCR_A_SRP_DET_EN;
> 	__raw_writel(reg, hcd->regs + OTGC_SCR);
> 
> 	reg = __raw_readl(hcd->regs + GLOBAL_ICR);
> 	reg &= ~GLOBAL_INT_MASK_HC;
> 	__raw_writel(reg, hcd->regs + GLOBAL_ICR);
141c139
< 
---
> #if 0
143c141
< 		writel(readl(IO_ADDRESS(0x40000000) + 0x30) | ((BIT(21)|BIT(22))),
---
> 		writel(readl(IO_ADDRESS(0x40000000) + 0x30) | ((BIT(22)|BIT(23))),
144a143,153
> #endif
> 	switch (hcd->rsrc_start) {
> 		case 0x68000000:
> 		writel(readl(IO_ADDRESS(0x40000000) + 0x30) | (BIT(22)),
> 		       IO_ADDRESS(0x40000000) + 0x30);
> 			break;
> 		case 0x69000000:
> 		writel(readl(IO_ADDRESS(0x40000000) + 0x30) | (BIT(23)),
> 		       IO_ADDRESS(0x40000000) + 0x30);
> 			break;
> 	}
157d165
< 	fotg2xx_otgp_close(hcd);
167c175
< 	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
---
> 	ehci->regs = hcd->regs + HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
172c180,181
< 	ehci->hcs_params = readl(&ehci->caps->hcs_params);
---
> 	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
> //	hcd->has_tt = 1;
175d183
< 
180d187
< 
207c214
<              fotg2xx_otgc_init(hcd);
---
>        //      fotg2xx_otgc_init(hcd);
209,210c216,217
<        else{//Changfe to A Type
<              fotg2xx_otgc_init(hcd);
---
>        else{//Change to A Type
>       //       fotg2xx_otgc_init(hcd);
217,218d223
<                {
< 
220d224
<                }
224,225c228
<         {
<          printk("%s[%d]: VBus error!\n",__FILE__,__LINE__);
---
>          printk("VBus error!\n");
227d229
<         }
229,233c231
<        {
<          printk("%s[%d]: Overcurrent detected!\n",__FILE__,__LINE__);
< 
<        }
< 
---
>          printk("Overcurrent detected!\n");
244c242
<                              printk("%s[%d] SRP detected, but not implemented!\n",__FILE__,__LINE__);
---
>                              printk("SRP detected, but not implemented!\n");
283d280
< 
288a286
> 	struct ehci_hcd *ehci = hcd_to_ehci (hcd);
290a289
> 	spin_lock_irq(&ehci->lock);
297c296
< 		writel(readl(hcd->regs + 0x84) | val, hcd->regs + 0x84);
---
> 		//writel(readl(hcd->regs + 0x84) | val, hcd->regs + 0x84);
299c298
< 		fotg2xx_int_isr(hcd, val);
---
> //		fotg2xx_int_isr(hcd, val);
303c302
< 
---
> 		spin_unlock_irq(&ehci->lock);
309a309
> 			spin_unlock_irq(&ehci->lock);
313,314c313,314
< 		printk("%s: received irq for peripheral - don't know what to do!\n", __FILE__);
< 
---
> 		printk("received irq for peripheral - don't know what to do!\n");
> 	spin_unlock_irq(&ehci->lock);
340c340
< 	//.shutdown		= ehci_shutdown,
---
> 	.shutdown		= ehci_shutdown,
350a351,352
> //	.relinquish_port	= ehci_relinquish_port,
> //	.port_handed_over	= ehci_port_handed_over,
353,363d354
< 
< 
< /**
<  * usb_hcd_fotg2xx_probe - initialize FOTG2XX-based HCDs
<  * @drvier: Driver to be used for this HCD
<  * @pdev: USB Host Controller being probed
<  * Context: !in_interrupt()
<  *
<  * Allocates basic resources for this USB host controller.
<  *
<  */
370a362
> 	long mask;
397a390
> 
406d398
< 	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
407a400
> 	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
413a407,423
> 	/* Setup for mini-A host and VBUS depending on Device */
> 	switch (hcd->rsrc_start) {
> 		case 0x68000000:
> 			/* USB0 */
> 			mask =  BIT(29) | BIT(22);
> 			break;
> 		case 0x69000000:
> 			/* USB1 */
> 			mask =  BIT(30) | BIT(23);
> 			break;
> 		default:
> 			dev_err(&pdev->dev, "fotg2xx id mismatch: found %d.%d.%d\n",
> 					readl(hcd->regs + 0x00), readl(hcd->regs + 0x04),
> 					readl(hcd->regs + 0x08));
> 			retval = -ENODEV;
> 			goto err4;
> 	}
415,421c425,426
< 	/* set global reg to mini-A host */
< 	writel(readl(IO_ADDRESS(0x40000000) + 0x30) & ~(BIT(30)|BIT(29)),
< 	       IO_ADDRESS(0x40000000) + 0x30);
< 
< 	/* USB0&USB1 - VBUS off */
< 	writel(readl(IO_ADDRESS(0x40000000) + 0x30) & ~(BIT(21)|BIT(22)),
< 	       IO_ADDRESS(0x40000000) + 0x30);
---
> 	writel(readl(IO_ADDRESS(0x40000000) + 0x30) & ~mask,
> 			IO_ADDRESS(0x40000000) + 0x30);
428c433
< 		dev_dbg(&pdev->dev, "fotg2xx id mismatch: found %d.%d.%d\n",
---
> 		dev_err(&pdev->dev, "fotg2xx id mismatch: found %d.%d.%d\n",
438,442c443
< 	/* set ChipEnable  */
< 	otg_set(0x100, BIT(5));
< 
< 	/* set HalfSpeedEnable */
< 	otg_set(0x100, BIT(1));
---
> 	/* register additional interrupt - here we check otg status */
445d445
< 	//otg_clear(0xc4, BIT(3)); /* hi active */
447d446
< 
450c449
< 	otg_set(0xc4, BIT(0)); /* peripheral */
---
> //	otg_set(0xc4, BIT(0)); /* peripheral */
452,453c451
< 	/* register additional interrupt - here we check otg status */
< 	if ((request_irq(irq, &fotg2xx_ehci_irq, IRQF_SHARED|IRQF_DISABLED,
---
> 	if ((request_irq(irq, &fotg2xx_ehci_irq, IRQF_SHARED,
462a461
> 
465c464
<       err4:
---
> err4:
467c466
<       err3:
---
> err3:
469c468
<       err2:
---
> err2:
471c470
<       err1:
---
> err1:
479,486d477
< /**
<  * usb_hcd_fotg2xx_remove - shutdown processing for FOTG2XX-based HCDs
<  * @dev: USB Host Controller being removed
<  * Context: !in_interrupt()
<  *
<  * Reverses the effect of usb_hcd_fotg2xx_probe().
<  *
<  */
501c492
< MODULE_ALIAS("fotg2xx-ehci");
---
> MODULE_ALIAS("platform:ehci-fotg2xx");
507c498
< 		.name = "ehci-hcd-FOTG2XX",
---
> 		.name = "ehci-fotg2xx",
diff host.old/ehci-hcd.c host/ehci-hcd.c
595d594
< #endif
597a597
> #endif
696,698d695
< #ifdef CONFIG_SL2312_USB
< 			mod_timer(&hcd->rh_timer, ehci->reset_done[i] + 1);
< #endif
700c697,698
< 			usb_hcd_resume_root_hub(hcd);
---
> 			mod_timer(&hcd->rh_timer, ehci->reset_done[i]);
> //			usb_hcd_resume_root_hub(hcd);
769,775d766
< #ifdef CONFIG_SL2312_USB
< 		{
< 			printk("urb_transaction: %p\n",
< 			       qh_urb_transaction(ehci, urb, &qtd_list, mem_flags));
< 			return -ENOMEM;
< 		}
< #else
777d767
< #endif
Files host.old/ehci-hcd.o and host/ehci-hcd.o differ
diff host.old/ehci-hub.c host/ehci-hub.c
460d459
< #ifndef CONFIG_SL2312_USB
464d462
< #endif
615d612
< #ifndef CONFIG_SL2312_USB
622d618
< #endif
627d622
< #ifndef CONFIG_SL2312_USB
632d626
< #endif
663d656
< #ifndef CONFIG_SL2312_USB
680d672
< #endif
704d695
< #ifndef CONFIG_SL2312_USB
706,708d696
< #else
< 					temp & ~(PORT_RESUME),
< #endif
730,737d717
< #ifdef CONFIG_SL2312_USB
< 			ehci_writel(ehci, temp & ~(PORT_RESET),
< 					status_reg);
< 			do {
< 				temp = ehci_readl(ehci, status_reg);
< 				udelay(10);
< 			} while (temp & PORT_RESET);
< #else
750d729
< #endif
757c736
< 			ehci_writel(ehci, ehci_readl(ehci, &ehci->regs->command)|(0x1),&ehci->regs->command);
---
> 			ehci_writel(ehci, ehci_readl(ehci, &ehci->regs->command)|(CMD_RUN),&ehci->regs->command);
759,776c738
< 			hcd->state = HC_STATE_RUNNING;
< 
< 			switch ((ehci_readl(ehci, hcd->regs + 0x80) >> 22) & 3) {
< 				case 0:
< 						printk("Full speed\n");
< 						break;
< 
< 				case 1:
< 						printk("Low speed\n");
< 						break;
< 
< 				case 2:
< 						printk("High speed\n");
< 						break;
< 				default:
< 						printk("Speed detection error\n");
< 						break;
< 			}
---
> //			hcd->state = HC_STATE_RUNNING;
797d758
< #ifndef CONFIG_SL2312_USB
803,811c764
< #else
< 		if (temp & PORT_CONNECT) {
< 			status |= 1 << USB_PORT_FEAT_CONNECTION;
< 		if (((ehci_readl(ehci, hcd->regs + 0x80) >> 22) & 3) == 2)
< 				status |= 1 << USB_PORT_FEAT_HIGHSPEED;
< 		else if (((ehci_readl(ehci, hcd->regs + 0x80) >> 22) & 3) == 1)
< 				status |= 1 << USB_PORT_FEAT_LOWSPEED;
< 		}
< #endif
---
> 
816d768
< #ifndef CONFIG_SL2312_USB
819d770
< #endif
822d772
< #ifndef CONFIG_SL2312_USB
825d774
< #endif
850d798
< #ifndef CONFIG_SL2312_USB
853d800
< #endif
868d814
< #ifndef CONFIG_SL2312_USB
872d817
< #endif
875d819
< #ifndef CONFIG_SL2312_USB
890d833
< #endif
894d836
< #ifndef CONFIG_SL2312_USB
896d837
< #endif
diff host.old/ehci.h host/ehci.h
722c722,723
< 		switch ((portsc>>26)&3) {
---
> 		portsc = readl(ehci_to_hcd(ehci)->regs + 0x80);
> 		switch ((portsc>>22)&3) {
