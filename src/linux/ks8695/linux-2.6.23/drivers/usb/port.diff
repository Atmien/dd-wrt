Files host/built-in.o and host.port/built-in.o differ
diff -urN host/ehci-fotg2xx.c host.port/ehci-fotg2xx.c
--- host/ehci-fotg2xx.c	2009-04-08 18:13:51.000000000 +0200
+++ host.port/ehci-fotg2xx.c	2009-04-09 20:23:39.431135292 +0200
@@ -7,117 +7,115 @@
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #include <linux/platform_device.h>
 
-#define IO_ADDRESS(x)      (((x&0xfff00000)>>4)|(x & 0x000fffff)|0xF0000000)
-
 #define otg_set(port, bits) writel(readl(hcd->regs + port) | bits, hcd->regs + port)
 
 #define otg_clear(port, bits) writel(readl(hcd->regs + port) & ~bits, hcd->regs + port)
 
 #define BIT(x) (1 << x)
 
-#define OTGC_INT_BSRPDN                           BIT(0)
-#define OTGC_INT_ASRPDET                          BIT(4)
-#define OTGC_INT_AVBUSERR                         BIT(5)
-#define OTGC_INT_RLCHG                            BIT(8)
-#define OTGC_INT_IDCHG                            BIT(9)
-#define OTGC_INT_OVC                              BIT(10)
-#define OTGC_INT_BPLGRMV                          BIT(11)
-#define OTGC_INT_APLGRMV                          BIT(12)
+#define GLOBAL_ISR			0xC0
+#define GLOBAL_ICR			0xC4
+
+#define HCD_MISC			0x40
+
+#define OTGC_SCR			0x80
+#define OTGC_INT_EN			0x88
 
-#define OTGC_INT_A_TYPE                           (OTGC_INT_ASRPDET|OTGC_INT_AVBUSERR|OTGC_INT_OVC|OTGC_INT_RLCHG|OTGC_INT_IDCHG|OTGC_INT_APLGRMV)
-#define OTGC_INT_B_TYPE                           (OTGC_INT_AVBUSERR|OTGC_INT_OVC|OTGC_INT_RLCHG|OTGC_INT_IDCHG)
+#define GLOBAL_INT_POLARITY		(1 << 3)
+#define GLOBAL_INT_MASK_HC		(1 << 2)
+#define GLOBAL_INT_MASK_OTG		(1 << 1)
+#define GLOBAL_INT_MASK_DEV		(1 << 0)
+
+#define OTGC_SCR_ID			(1 << 21)
+#define OTGC_SCR_CROLE			(1 << 20)
+#define OTGC_SCR_VBUS_VLD		(1 << 19)
+#define OTGC_SCR_A_SRP_RESP_TYPE	(1 << 8)
+#define OTGC_SCR_A_SRP_DET_EN		(1 << 7)
+#define OTGC_SCR_A_SET_B_HNP_EN		(1 << 6)
+#define OTGC_SCR_A_BUS_DROP		(1 << 5)
+#define OTGC_SCR_A_BUS_REQ		(1 << 4)
+
+#define OTGC_INT_APLGRMV		(1 << 12)
+#define OTGC_INT_BPLGRMV		(1 << 11)
+#define OTGC_INT_OVC			(1 << 10)
+#define OTGC_INT_IDCHG			(1 << 9)
+#define OTGC_INT_RLCHG			(1 << 8)
+#define OTGC_INT_AVBUSERR		(1 << 5)
+#define OTGC_INT_ASRPDET		(1 << 4)
+#define OTGC_INT_BSRPDN			(1 << 0)
+
+#define OTGC_INT_A_TYPE		(OTGC_INT_ASRPDET|OTGC_INT_AVBUSERR|OTGC_INT_OVC|OTGC_INT_RLCHG|OTGC_INT_IDCHG|OTGC_INT_APLGRMV)
+#define OTGC_INT_B_TYPE		(OTGC_INT_AVBUSERR|OTGC_INT_OVC|OTGC_INT_RLCHG|OTGC_INT_IDCHG)
 
 static void fotg2xx_otgc_role_change(struct usb_hcd *hcd);
 
 static void fotg2xx_otgc_init(struct usb_hcd *hcd)
 {
-	/***************** OTG HW INIT *****************/
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	unsigned int reg;
 
-	printk("USB OTG2xx role detected: %s, ",
-		((readl(hcd->regs + 0x80) >> 20) & 1)?"Peripheral":"Host");
+	reg = __raw_readl(hcd->regs + OTGC_SCR);
+	ehci_info(ehci, "role detected: %s, ",
+		  (reg & OTGC_SCR_CROLE) ? "Peripheral" : "Host");
 
-	/* register 0x80, bit21 - 0: A-Device, 1: B-Device */
-	if (readl(hcd->regs + 0x80) & (1 << 21))
-		printk("B-Device (may be unsupported!)\n");
+	if (reg & OTGC_SCR_ID)
+		ehci_info(ehci, "B-Device (may be unsupported!)\n");
 	else
-		printk("A-Device\n");
+		ehci_info(ehci, "A-Device\n");
 
-	/* clear A_SRP_RESP_TYPE */
-	otg_clear(0x80, BIT(8));
+	/* Enable the SRP detect */
+	reg &= ~OTGC_SCR_A_SRP_RESP_TYPE;
+	__raw_writel(reg, hcd->regs + OTGC_SCR);
 
+	reg = __raw_readl(hcd->regs + OTGC_INT_EN);
 	/* clear INT B: bits AVBUSERR | OVC | RLCHG | IDCHG */
-	otg_clear(0x88, OTGC_INT_B_TYPE);
-
+	reg &= ~OTGC_INT_B_TYPE;
 	/* set INT A: bits ASRPDET | AVBUSERR | OVC | RLCHG | IDCHG | APLGRMV */
-	otg_set(0x88, OTGC_INT_A_TYPE);
+	reg |= OTGC_INT_A_TYPE;
+	__raw_writel(reg, hcd->regs + OTGC_INT_EN);
 
-	otg_clear(0xc4, BIT(1)); /* unMASK OTG INT */
-
-	/* WILIBOX: setup MISC register, fixes timing problems */
-	otg_set(0x40, 0xD);
+	reg = __raw_readl(hcd->regs + GLOBAL_ICR);
+	reg &= ~GLOBAL_INT_MASK_OTG;
+	__raw_writel(reg, hcd->regs + GLOBAL_ICR);
+
+	/* setup MISC register, fixes timing problems */
+	reg = __raw_readl(hcd->regs + HCD_MISC);
+	reg |= 0xD;
+	__raw_writel(reg, hcd->regs + HCD_MISC);
 
 	fotg2xx_otgc_role_change(hcd);
 }
 
-static void fotg2xx_otgp_close(struct usb_hcd *hcd)
-{
-	u32 wTemp;
-
-	/* usb glob int dis */
-	otg_clear(0x100, BIT(2));
-
-	/* mask perip. set */
-	otg_set(0xc4, BIT(0));
-
-	/* clear int status (?) */
-	wTemp = readl(hcd->regs + 0x140);
-	wTemp = readl(hcd->regs + 0x144);
-	wTemp = readl(hcd->regs + 0x148);
-	wTemp = readl(hcd->regs + 0x14C);
-
-	otg_set(0x140, 0);
-	otg_set(0x144, 0);
-	otg_set(0x148, 0);
-	otg_set(0x14C, 0);
-}
-
 static void fotg2xx_otgh_close(struct usb_hcd *hcd)
 {
-	u32 wTemp;
+	unsigned int reg;
 
-	/* <1>.Enable Interrupt Mask
-	mdwOTGC_GINT_MASK_HOST_Set(); */
-	otg_set(0xc4, BIT(2));
-
-	/* <2>.Clear the Interrupt status
-	wTemp=mdwHost20_USBINTR_Rd();
-	wTemp=wTemp&0x0000003F;
-	mdwHost20_USBSTS_Set(wTemp); */
-
-	wTemp = readl(hcd->regs + 0x18);
-	wTemp = wTemp & 0x0000003F;
-	writel(wTemp, hcd->regs + 0x14);
+	/* <1>.Enable Interrupt Mask */
+	reg = __raw_readl(hcd->regs + GLOBAL_ICR);
+	reg |= GLOBAL_INT_MASK_HC;
+	__raw_writel(reg, hcd->regs + GLOBAL_ICR);
+
+	/* <2>.Clear the Interrupt status */
+	reg = __raw_readl(hcd->regs + 0x18);
+	reg &= 0x0000003F;
+	__raw_writel(reg, hcd->regs + 0x14);
 }
 
 static void fotg2xx_otgh_open(struct usb_hcd *hcd)
 {
-	/* clear A_SRP_DET */
-	otg_clear(0x80, BIT(7));
-	/* clear HOST INT MASK */
-	otg_clear(0xc4, BIT(2));
+	unsigned int reg;
+
+	reg = __raw_readl(hcd->regs + OTGC_SCR);
+	reg &= ~OTGC_SCR_A_SRP_DET_EN;
+	__raw_writel(reg, hcd->regs + OTGC_SCR);
+
+	reg = __raw_readl(hcd->regs + GLOBAL_ICR);
+	reg &= ~GLOBAL_INT_MASK_HC;
+	__raw_writel(reg, hcd->regs + GLOBAL_ICR);
 }
 
 /* change to host role */
@@ -138,10 +136,21 @@
 
 		/* set A_BUS_REQ */
 		otg_set(0x80, BIT(4));
-
+#if 0
 		/* set global bus reg to VBUS on */
-		writel(readl(IO_ADDRESS(0x40000000) + 0x30) | ((BIT(21)|BIT(22))),
+		writel(readl(IO_ADDRESS(0x40000000) + 0x30) | ((BIT(22)|BIT(23))),
 		       IO_ADDRESS(0x40000000) + 0x30);
+#endif
+	switch (hcd->rsrc_start) {
+		case 0x68000000:
+		writel(readl(IO_ADDRESS(0x40000000) + 0x30) | (BIT(22)),
+		       IO_ADDRESS(0x40000000) + 0x30);
+			break;
+		case 0x69000000:
+		writel(readl(IO_ADDRESS(0x40000000) + 0x30) | (BIT(23)),
+		       IO_ADDRESS(0x40000000) + 0x30);
+			break;
+	}
 
 		if (readl(hcd->regs + 0x80) & (1<<19)) {
 			printk("Waiting for VBus");
@@ -154,7 +163,6 @@
 			printk("VBUS enabled.\n");
 		mdelay(1);
 	}
-	fotg2xx_otgp_close(hcd);
 	fotg2xx_otgh_open(hcd);
 }
 
@@ -164,20 +172,19 @@
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 
 	ehci->caps = hcd->regs;
-	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
+	ehci->regs = hcd->regs + HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
 
 	dbg_hcs_params(ehci, "reset");
 	dbg_hcc_params(ehci, "reset");
 
-	ehci->hcs_params = readl(&ehci->caps->hcs_params);
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+//	hcd->has_tt = 1;
 
 	result = ehci_halt(ehci);
-
 	if (result)
 		return result;
 
 	result = ehci_init(hcd);
-
 	if (result)
 		return result;
 
@@ -204,33 +211,24 @@
       {
        if ((readl(hcd->regs + 0x80) & BIT(21)) != 0)
           {//Change to B Type
-             fotg2xx_otgc_init(hcd);
+       //      fotg2xx_otgc_init(hcd);
           }
-       else{//Changfe to A Type
-             fotg2xx_otgc_init(hcd);
+       else{//Change to A Type
+      //       fotg2xx_otgc_init(hcd);
            }
 
       }else{//else of " if (wINTStatus&OTGC_INT_IDCHG) "
 
   //<2>.Check for RL_Change
            if (wINTStatus&OTGC_INT_RLCHG)
-               {
-
                      fotg2xx_otgc_role_change(hcd);
-               }
 
  //<3>.Error Detect
      if (wINTStatus&OTGC_INT_AVBUSERR)
-        {
-         printk("%s[%d]: VBus error!\n",__FILE__,__LINE__);
+         printk("VBus error!\n");
 
-        }
      if (wINTStatus&OTGC_INT_OVC)
-       {
-         printk("%s[%d]: Overcurrent detected!\n",__FILE__,__LINE__);
-
-       }
-
+         printk("Overcurrent detected!\n");
 
            //<3>.Check for Type-A/Type-B Interrupt
            if ((readl(hcd->regs + 0x80) & BIT(21)) == 0)
@@ -241,7 +239,7 @@
                    if (wINTStatus&OTGC_INT_ASRPDET)
                       {
                        //<1>.SRP detected => then set global variable
-                             printk("%s[%d] SRP detected, but not implemented!\n",__FILE__,__LINE__);
+                             printk("SRP detected, but not implemented!\n");
 
 #if 0
                        //<2>.Turn on the V Bus
@@ -280,38 +278,40 @@
 
               }
          }   //end of " if (wINTStatus&OTGC_INT_IDCHG) "
-
 }
 
 static irqreturn_t fotg2xx_ehci_irq (int irq, void * devid)
 {
 	struct usb_hcd *hcd = devid;
+	struct ehci_hcd *ehci = hcd_to_ehci (hcd);
 	u32 val;
 
+	spin_lock_irq(&ehci->lock);
 	/* OTG Interrupt Status Register */
 	val = readl(hcd->regs + 0x84);
 
 	/* OTG stuff */
 	if (val) {
 		/* supposed to do "INT STS Clr" - XXX */
-		writel(readl(hcd->regs + 0x84) | val, hcd->regs + 0x84);
+		//writel(readl(hcd->regs + 0x84) | val, hcd->regs + 0x84);
 
-		fotg2xx_int_isr(hcd, val);
+//		fotg2xx_int_isr(hcd, val);
 
 		/* supposed to do "INT STS Clr" - XXX */
 		writel(readl(hcd->regs + 0x84) | val, hcd->regs + 0x84);
-
+		spin_unlock_irq(&ehci->lock);
 		return IRQ_HANDLED;
 	}
 
 	if ((readl(hcd->regs + 0x80) & BIT(20)) == 0) { /* Role is HOST */
 		if (readl(hcd->regs + 0xC0) & BIT(2)) { /* INT STS HOST */
 			/* leave this for ehci irq handler */
+			spin_unlock_irq(&ehci->lock);
 			return IRQ_NONE;
 		}
 	} else
-		printk("%s: received irq for peripheral - don't know what to do!\n", __FILE__);
-
+		printk("received irq for peripheral - don't know what to do!\n");
+	spin_unlock_irq(&ehci->lock);
 	/* do not call the ehci irq handler */
 	return IRQ_HANDLED;
 }
@@ -337,7 +337,7 @@
 	.reset			= fotg2xx_ehci_hc_reset,
 	.start			= fotg2xx_ehci_run,
 	.stop			= ehci_stop,
-	//.shutdown		= ehci_shutdown,
+	.shutdown		= ehci_shutdown,
 	.urb_enqueue		= ehci_urb_enqueue,
 	.urb_dequeue		= ehci_urb_dequeue,
 	.endpoint_disable	= ehci_endpoint_disable,
@@ -348,19 +348,10 @@
 	.bus_suspend		= ehci_bus_suspend,
 	.bus_resume		= ehci_bus_resume,
 #endif
+//	.relinquish_port	= ehci_relinquish_port,
+//	.port_handed_over	= ehci_port_handed_over,
 };
 
-
-
-/**
- * usb_hcd_fotg2xx_probe - initialize FOTG2XX-based HCDs
- * @drvier: Driver to be used for this HCD
- * @pdev: USB Host Controller being probed
- * Context: !in_interrupt()
- *
- * Allocates basic resources for this USB host controller.
- *
- */
 static int fotg2xx_ehci_probe(struct platform_device *pdev)
 {
 	const struct hc_driver *driver = &fotg2xx_ehci_hc_driver;
@@ -368,6 +359,7 @@
 	struct resource *res;
 	int irq;
 	int retval;
+	long mask;
 
 	pr_debug("initializing FOTG2XX-SOC USB Controller\n");
 
@@ -395,6 +387,7 @@
 		retval = -ENODEV;
 		goto err2;
 	}
+
 	hcd->rsrc_start = res->start;
 	hcd->rsrc_len = res->end - res->start + 1;
 	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
@@ -403,29 +396,41 @@
 		retval = -EBUSY;
 		goto err2;
 	}
-	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
 
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
 	if (hcd->regs == NULL) {
 		dev_dbg(&pdev->dev, "error mapping memory\n");
 		retval = -EFAULT;
 		goto err3;
 	}
 
+	/* Setup for mini-A host and VBUS depending on Device */
+	switch (hcd->rsrc_start) {
+		case 0x68000000:
+			/* USB0 */
+			mask =  BIT(29) | BIT(22);
+			break;
+		case 0x69000000:
+			/* USB1 */
+			mask =  BIT(30) | BIT(23);
+			break;
+		default:
+			dev_err(&pdev->dev, "fotg2xx id mismatch: found %d.%d.%d\n",
+					readl(hcd->regs + 0x00), readl(hcd->regs + 0x04),
+					readl(hcd->regs + 0x08));
+			retval = -ENODEV;
+			goto err4;
+	}
 
-	/* set global reg to mini-A host */
-	writel(readl(IO_ADDRESS(0x40000000) + 0x30) & ~(BIT(30)|BIT(29)),
-	       IO_ADDRESS(0x40000000) + 0x30);
-
-	/* USB0&USB1 - VBUS off */
-	writel(readl(IO_ADDRESS(0x40000000) + 0x30) & ~(BIT(21)|BIT(22)),
-	       IO_ADDRESS(0x40000000) + 0x30);
+	writel(readl(IO_ADDRESS(0x40000000) + 0x30) & ~mask,
+			IO_ADDRESS(0x40000000) + 0x30);
 
 	if ( (readl(hcd->regs) == 0x01000010) &&
 		(readl(hcd->regs + 4) == 0x00000001) &&
 		(readl(hcd->regs + 8) == 0x00000006) )
 		printk("Found Faraday OTG 2XX controller (base = 0x%08lX)\n", (unsigned long) hcd->rsrc_start);
 	else {
-		dev_dbg(&pdev->dev, "fotg2xx id mismatch: found %d.%d.%d\n",
+		dev_err(&pdev->dev, "fotg2xx id mismatch: found %d.%d.%d\n",
 		       readl(hcd->regs + 0x00),
 		       readl(hcd->regs + 0x04),
 		       readl(hcd->regs + 0x08));
@@ -435,22 +440,15 @@
 
 	platform_set_drvdata(pdev, hcd);
 
-	/* set ChipEnable  */
-	otg_set(0x100, BIT(5));
-
-	/* set HalfSpeedEnable */
-	otg_set(0x100, BIT(1));
+	/* register additional interrupt - here we check otg status */
 
 	/* mask interrupts - peripheral, otg, host, hi-active (bits 0,1,2,3) */
-	//otg_clear(0xc4, BIT(3)); /* hi active */
 	otg_set(0xc4, BIT(3)); /* hi active */
-
 	otg_set(0xc4, BIT(2)); /* host */
 	otg_set(0xc4, BIT(1)); /* otg */
-	otg_set(0xc4, BIT(0)); /* peripheral */
+//	otg_set(0xc4, BIT(0)); /* peripheral */
 
-	/* register additional interrupt - here we check otg status */
-	if ((request_irq(irq, &fotg2xx_ehci_irq, IRQF_SHARED|IRQF_DISABLED,
+	if ((request_irq(irq, &fotg2xx_ehci_irq, IRQF_SHARED,
 		 hcd->irq_descr, hcd)) != 0) {
 		dev_dbg(&pdev->dev, "error requesting irq %d\n", irq);
 		retval = -EFAULT;
@@ -460,15 +458,16 @@
 	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
 	if (retval != 0)
 		goto err4;
+
 	return retval;
 
-      err4:
+err4:
 	iounmap(hcd->regs);
-      err3:
+err3:
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-      err2:
+err2:
 	usb_put_hcd(hcd);
-      err1:
+err1:
 	dev_err(&pdev->dev, "init %s fail, %d\n", pdev->dev.bus_id, retval);
 	return retval;
 }
@@ -476,14 +475,6 @@
 /* may be called without controller electrically present */
 /* may be called with controller, bus, and devices active */
 
-/**
- * usb_hcd_fotg2xx_remove - shutdown processing for FOTG2XX-based HCDs
- * @dev: USB Host Controller being removed
- * Context: !in_interrupt()
- *
- * Reverses the effect of usb_hcd_fotg2xx_probe().
- *
- */
 int fotg2xx_ehci_remove(struct platform_device *pdev)
 {
 	struct usb_hcd *hcd =
@@ -498,12 +489,12 @@
 	return 0;
 }
 
-MODULE_ALIAS("fotg2xx-ehci");
+MODULE_ALIAS("platform:ehci-fotg2xx");
 
 static struct platform_driver fotg2xx_ehci_driver = {
 	.probe = fotg2xx_ehci_probe,
 	.remove = fotg2xx_ehci_remove,
 	.driver = {
-		.name = "ehci-hcd-FOTG2XX",
+		.name = "ehci-fotg2xx",
 	},
 };
diff -urN host/ehci-hcd.c host.port/ehci-hcd.c
--- host/ehci-hcd.c	2009-02-24 19:00:15.000000000 +0100
+++ host.port/ehci-hcd.c	2009-04-09 20:14:41.585682781 +0200
@@ -592,9 +592,9 @@
 	hcd->state = HC_STATE_RUNNING;
 #ifndef CONFIG_SL2312_USB
 	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
-#endif
 	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
 	msleep(5);
+#endif
 	up_write(&ehci_cf_port_reset_rwsem);
 
 	temp = HC_VERSION(ehci_readl(ehci, &ehci->caps->hc_capbase));
@@ -693,11 +693,9 @@
 			 * stop that signaling.
 			 */
 			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
-#ifdef CONFIG_SL2312_USB
-			mod_timer(&hcd->rh_timer, ehci->reset_done[i] + 1);
-#endif
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
-			usb_hcd_resume_root_hub(hcd);
+			mod_timer(&hcd->rh_timer, ehci->reset_done[i]);
+//			usb_hcd_resume_root_hub(hcd);
 		}
 	}
 
@@ -766,15 +764,7 @@
 	// case PIPE_BULK:
 	default:
 		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
-#ifdef CONFIG_SL2312_USB
-		{
-			printk("urb_transaction: %p\n",
-			       qh_urb_transaction(ehci, urb, &qtd_list, mem_flags));
-			return -ENOMEM;
-		}
-#else
 			return -ENOMEM;
-#endif
 		return submit_async (ehci, ep, urb, &qtd_list, mem_flags);
 
 	case PIPE_INTERRUPT:
Files host/ehci-hcd.o and host.port/ehci-hcd.o differ
diff -urN host/ehci-hub.c host.port/ehci-hub.c
--- host/ehci-hub.c	2009-04-09 18:48:07.000000000 +0200
+++ host.port/ehci-hub.c	2009-04-09 20:18:46.369626148 +0200
@@ -457,11 +457,9 @@
 	 * always set, seem to clear PORT_OCC and PORT_CSC when writing to
 	 * PORT_POWER; that's surprising, but maybe within-spec.
 	 */
-#ifndef CONFIG_SL2312_USB
 	if (!ignore_oc)
 		mask = PORT_CSC | PORT_PEC | PORT_OCC;
 	else
-#endif
 		mask = PORT_CSC | PORT_PEC;
 	// PORT_RESUME from hardware ~= PORT_STAT_C_SUSPEND
 
@@ -612,24 +610,20 @@
 		case USB_PORT_FEAT_C_SUSPEND:
 			/* we auto-clear this feature */
 			break;
-#ifndef CONFIG_SL2312_USB
 		case USB_PORT_FEAT_POWER:
 			if (HCS_PPC (ehci->hcs_params))
 				ehci_writel(ehci,
 					  temp & ~(PORT_RWC_BITS | PORT_POWER),
 					  status_reg);
 			break;
-#endif
 		case USB_PORT_FEAT_C_CONNECTION:
 			ehci_writel(ehci, (temp & ~PORT_RWC_BITS) | PORT_CSC,
 					status_reg);
 			break;
-#ifndef CONFIG_SL2312_USB
 		case USB_PORT_FEAT_C_OVER_CURRENT:
 			ehci_writel(ehci, (temp & ~PORT_RWC_BITS) | PORT_OCC,
 					status_reg);
 			break;
-#endif
 		case USB_PORT_FEAT_C_RESET:
 			/* GetPortStatus clears reset */
 			break;
@@ -660,7 +654,6 @@
 		if (temp & PORT_PEC)
 			status |= 1 << USB_PORT_FEAT_C_ENABLE;
 
-#ifndef CONFIG_SL2312_USB
 		if ((temp & PORT_OCC) && !ignore_oc){
 			status |= 1 << USB_PORT_FEAT_C_OVER_CURRENT;
 
@@ -677,7 +670,6 @@
 					status_reg);
 			}
 		}
-#endif
 
 		/* whoever resumes must GetPortStatus to complete it!! */
 		if (temp & PORT_RESUME) {
@@ -701,11 +693,7 @@
 				/* stop resume signaling */
 				temp = ehci_readl(ehci, status_reg);
 				ehci_writel(ehci,
-#ifndef CONFIG_SL2312_USB
 					temp & ~(PORT_RWC_BITS | PORT_RESUME),
-#else
-					temp & ~(PORT_RESUME),
-#endif
 					status_reg);
 				retval = handshake(ehci, status_reg,
 					   PORT_RESUME, 0, 2000 /* 2msec */);
@@ -727,14 +715,6 @@
 			ehci->reset_done [wIndex] = 0;
 
 			/* force reset to complete */
-#ifdef CONFIG_SL2312_USB
-			ehci_writel(ehci, temp & ~(PORT_RESET),
-					status_reg);
-			do {
-				temp = ehci_readl(ehci, status_reg);
-				udelay(10);
-			} while (temp & PORT_RESET);
-#else
 			ehci_writel(ehci, temp & ~(PORT_RWC_BITS | PORT_RESET),
 					status_reg);
 			/* REVISIT:  some hardware needs 550+ usec to clear
@@ -747,33 +727,15 @@
 					wIndex + 1, retval);
 				goto error;
 			}
-#endif
 
 			/* see what we found out */
 			temp = check_reset_complete (ehci, wIndex, status_reg,
 					ehci_readl(ehci, status_reg));
 #ifdef CONFIG_SL2312_USB
 			/* restart schedule */
-			ehci_writel(ehci, ehci_readl(ehci, &ehci->regs->command)|(0x1),&ehci->regs->command);
+			ehci_writel(ehci, ehci_readl(ehci, &ehci->regs->command)|(CMD_RUN),&ehci->regs->command);
 
-			hcd->state = HC_STATE_RUNNING;
-
-			switch ((ehci_readl(ehci, hcd->regs + 0x80) >> 22) & 3) {
-				case 0:
-						printk("Full speed\n");
-						break;
-
-				case 1:
-						printk("Low speed\n");
-						break;
-
-				case 2:
-						printk("High speed\n");
-						break;
-				default:
-						printk("Speed detection error\n");
-						break;
-			}
+//			hcd->state = HC_STATE_RUNNING;
 
 #endif
 		}
@@ -794,35 +756,22 @@
 		 * for PORT_POWER anyway).
 		 */
 
-#ifndef CONFIG_SL2312_USB
 		if (temp & PORT_CONNECT) {
 			status |= 1 << USB_PORT_FEAT_CONNECTION;
 			// status may be from integrated TT
 			status |= ehci_port_speed(ehci, temp);
 		}
-#else
-		if (temp & PORT_CONNECT) {
-			status |= 1 << USB_PORT_FEAT_CONNECTION;
-		if (((ehci_readl(ehci, hcd->regs + 0x80) >> 22) & 3) == 2)
-				status |= 1 << USB_PORT_FEAT_HIGHSPEED;
-		else if (((ehci_readl(ehci, hcd->regs + 0x80) >> 22) & 3) == 1)
-				status |= 1 << USB_PORT_FEAT_LOWSPEED;
-		}
-#endif
+
 		if (temp & PORT_PE)
 			status |= 1 << USB_PORT_FEAT_ENABLE;
 		if (temp & (PORT_SUSPEND|PORT_RESUME))
 			status |= 1 << USB_PORT_FEAT_SUSPEND;
-#ifndef CONFIG_SL2312_USB
 		if (temp & PORT_OC)
 			status |= 1 << USB_PORT_FEAT_OVER_CURRENT;
-#endif
 		if (temp & PORT_RESET)
 			status |= 1 << USB_PORT_FEAT_RESET;
-#ifndef CONFIG_SL2312_USB
 		if (temp & PORT_POWER)
 			status |= 1 << USB_PORT_FEAT_POWER;
-#endif
 
 #ifndef	EHCI_VERBOSE_DEBUG
 	if (status & ~0xffff)	/* only if wPortChange is interesting */
@@ -847,10 +796,8 @@
 			goto error;
 		wIndex--;
 		temp = ehci_readl(ehci, status_reg);
-#ifndef CONFIG_SL2312_USB
 		if (temp & PORT_OWNER)
 			break;
-#endif
 
 		temp &= ~PORT_RWC_BITS;
 		switch (wValue) {
@@ -865,14 +812,11 @@
 			ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
 			break;
 		case USB_PORT_FEAT_POWER:
-#ifndef CONFIG_SL2312_USB
 			if (HCS_PPC (ehci->hcs_params))
 				ehci_writel(ehci, temp | PORT_POWER,
 						status_reg);
-#endif
 			break;
 		case USB_PORT_FEAT_RESET:
-#ifndef CONFIG_SL2312_USB
 			if (temp & PORT_RESUME)
 				goto error;
 			/* line status bits may report this as low speed,
@@ -887,13 +831,10 @@
 					wIndex + 1);
 				temp |= PORT_OWNER;
 			} else
-#endif
 			{
 				ehci_vdbg (ehci, "port %d reset\n", wIndex + 1);
 				temp |= PORT_RESET;
-#ifndef CONFIG_SL2312_USB
 				temp &= ~PORT_PE;
-#endif
 
 				/*
 				 * caller must wait, then call GetPortStatus
diff -urN host/ehci.h host.port/ehci.h
--- host/ehci.h	2009-02-24 19:00:15.000000000 +0100
+++ host.port/ehci.h	2009-04-09 20:06:11.981152556 +0200
@@ -719,7 +719,8 @@
 ehci_port_speed(struct ehci_hcd *ehci, unsigned int portsc)
 {
 	if (ehci_is_TDI(ehci)) {
-		switch ((portsc>>26)&3) {
+		portsc = readl(ehci_to_hcd(ehci)->regs + 0x80);
+		switch ((portsc>>22)&3) {
 		case 0:
 			return 0;
 		case 1:
