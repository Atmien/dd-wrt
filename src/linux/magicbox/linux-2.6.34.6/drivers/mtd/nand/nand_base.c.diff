diff -puNrb linux-2.6.27.39/drivers/mtd/nand/nand_base.c linux/drivers/mtd/nand/nand_base.c
--- linux-2.6.27.39/drivers/mtd/nand/nand_base.c	2009-11-20 09:54:00.000000000 +0200
+++ linux/drivers/mtd/nand/nand_base.c	2009-11-20 09:55:49.000000000 +0200
@@ -42,6 +42,7 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
 #include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/nand_ecc_mlc.h>
 #include <linux/mtd/compatmac.h>
 #include <linux/interrupt.h>
 #include <linux/bitops.h>
@@ -65,10 +66,12 @@ static struct nand_ecclayout nand_oob_8 
 
 static struct nand_ecclayout nand_oob_16 = {
 	.eccbytes = 6,
-	.eccpos = {0, 1, 2, 3, 6, 7},
+	.eccpos = {8, 9, 10, 13, 14, 15},
 	.oobfree = {
-		{.offset = 8,
-		 . length = 8}}
+		{.offset = 0,
+		 .length = 8},
+		{.offset = 11,
+		 .length = 2}}
 };
 
 static struct nand_ecclayout nand_oob_64 = {
@@ -82,6 +85,22 @@ static struct nand_ecclayout nand_oob_64
 		 .length = 38}}
 };
 
+/*
+ * fake MLC layout
+ * used by yaffs to see correct oobfree amount (oobfree as in MLC layout)
+ * used for reading if data is written using slc ecc (eccpos as in SLC layout)
+ */
+static struct nand_ecclayout nand_oob_64_mlc = {
+	.eccbytes = 24,
+	.eccpos = {
+		   40, 41, 42, 43, 44, 45, 46, 47,
+		   48, 49, 50, 51, 52, 53, 54, 55,
+		   56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 22}}
+};
+
 static int nand_get_device(struct nand_chip *chip, struct mtd_info *mtd,
 			   int new_state);
 
@@ -94,6 +113,37 @@ static int nand_do_write_oob(struct mtd_
  */
 DEFINE_LED_TRIGGER(nand_led_trigger);
 
+static int mlc_ecc_allowed = 0;
+
+static int __init on_setup_mlc(char *str)
+{
+	mlc_ecc_allowed = (str[0] != '0');
+	return 1;
+}
+__setup("mlc=", on_setup_mlc);
+
+static int is_nand_mlc(struct nand_chip *chip) {
+	return chip->cellinfo & NAND_CI_CELLTYPE_MSK;
+}
+
+static void set_ecc_mlc(struct nand_chip *chip) {
+	chip->oob_poi[ECC_ID_OFFSET] = 0;
+}
+
+static int is_ecc_mlc(struct nand_chip *chip) {
+	int bits = 0;
+	unsigned char ecc_id;
+	if (chip->page_shift <= 9) return 0;	/* small page nand */
+
+	ecc_id = chip->oob_poi[ECC_ID_OFFSET];
+	if (ecc_id == 0) return 1;
+	if (ecc_id == 0xff) return 0;
+
+	for ( ; ecc_id; ecc_id >>= 1)
+		bits += ecc_id & 0x01;
+	return bits < 4;
+}
+
 /**
  * nand_release_device - [GENERIC] release chip
  * @mtd:	MTD device structure
@@ -229,6 +279,25 @@ static int nand_verify_buf(struct mtd_in
 	return 0;
 }
 
+static int nand_verify_buf_mlc(struct mtd_info *mtd, struct nand_chip *chip,
+			       const uint8_t *buf, int len)
+{
+	/* ignore one-bit error */
+	unsigned char rbuf[len];
+	int i;
+	unsigned errors = 0;
+
+	chip->read_buf(mtd, rbuf, len);
+	for (i = 0; i < len; ++i) {
+		unsigned char err = rbuf[i] ^ buf[i];
+		for (; err != 0; err /= 2) {
+			errors += (err & 1);
+			if (errors > 1) return -EFAULT;
+		}
+	}
+	return 0;
+}
+
 /**
  * nand_write_buf16 - [DEFAULT] write buffer to chip
  * @mtd:	MTD device structure
@@ -335,6 +404,21 @@ static int nand_block_bad(struct mtd_inf
 	return res;
 }
 
+static int nand_block_bad_mlc(struct mtd_info *mtd, loff_t ofs, int getchip)
+{
+	int res = nand_block_bad(mtd, ofs, getchip);
+	if (res == 0) {
+		/*
+		 * MLC nand initially (from factory)
+		 * contains bad block info at last page within block
+		 */
+		ofs = ((ofs & ~(mtd->erasesize - 1)) +
+		       mtd->erasesize - mtd->writesize);
+		res = nand_block_bad(mtd, ofs, getchip);
+	}
+	return res;
+}
+
 /**
  * nand_default_block_markbad - [DEFAULT] mark a block bad
  * @mtd:	MTD device structure
@@ -368,6 +452,17 @@ static int nand_default_block_markbad(st
 		chip->ops.oobbuf = buf;
 		chip->ops.ooboffs = chip->badblockpos & ~0x01;
 
+		if (is_nand_mlc(chip)) {
+			/*
+			 * MLC nand supports only one write to page after erase
+			 * make sure our write succeeds
+			 * by erasing whole block before write
+			 */
+			int page = (int)(ofs >> chip->page_shift);
+			chip->erase_cmd(mtd, page & chip->pagemask);
+			ret = chip->waitfunc(mtd, chip);
+		}
+
 		ret = nand_do_write_oob(mtd, ofs, &chip->ops);
 		nand_release_device(mtd);
 	}
@@ -434,6 +529,60 @@ void nand_wait_ready(struct mtd_info *mt
 }
 EXPORT_SYMBOL_GPL(nand_wait_ready);
 
+static int get_backup_page(struct mtd_info *mtd, int page, int allow_bad) {
+#ifdef MIPSEL
+	struct nand_chip *chip = mtd->priv;
+	int page_offset = chip->backup_offset >> chip->page_shift;
+
+	if (page < page_offset) {
+		int page_backup = page + page_offset;
+		loff_t ofs_backup = ((loff_t) page_backup) << chip->page_shift;
+		if (allow_bad || !nand_block_checkbad(mtd, ofs_backup, 0, 1)) {
+			return page_backup;
+		}
+	}
+#endif
+	return -1;
+}
+
+static void nand_backup_merge(struct mtd_info *mtd, uint8_t *orig, int len) {
+	for ( ; len > 0; --len, ++orig) {
+		uint8_t byte = nand_read_byte(mtd);
+		*orig &= byte;
+	}
+}
+
+static int check_backup_oob(struct mtd_info *mtd, struct nand_chip *chip,
+			    int bpage) {
+	int differ = 0;
+	uint8_t ff = 0xff;
+	uint8_t *optr;
+	uint8_t *oend;
+
+	/* check that OOB areas are equal or backup is empty */
+	*(uint32_t*)(&chip->oob_poi[BACKUP_4xFF_OFFSET]) = 0xffffffff;
+	nand_wait_ready(mtd);
+	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, bpage);
+
+	optr = chip->oob_poi;
+	oend = optr + mtd->oobsize;
+	for ( ; optr < oend; ++optr) {
+		uint8_t byte = nand_read_byte(mtd);
+		ff &= byte;
+		if (byte != *optr) {
+			*optr &= byte;
+			differ = 1;
+		}
+	}
+	return differ && ff != 0xff;
+}
+
+static int read_page_raw_dummy(struct mtd_info *mtd, struct nand_chip *chip,
+			       uint8_t *buf)
+{
+	return 0;
+}
+
 /**
  * nand_command - [DEFAULT] Send command to NAND device
  * @mtd:	MTD device structure
@@ -776,6 +925,18 @@ static int nand_read_page_swecc(struct m
 
 	chip->ecc.read_page_raw(mtd, chip, buf);
 
+	if (is_ecc_mlc(chip)) {
+		for (i = 0; i < 4; ++i, p += 0x200) {
+			unsigned char *ecc = chip->oob_poi + 24 + 10 * i;
+			int stat = nand_correct_data_mlc(p, ecc);
+			if (stat < 0)
+				mtd->ecc_stats.failed++;
+			else
+				mtd->ecc_stats.corrected += stat;
+		}
+		return 0;
+	}
+
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
 		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
 
@@ -1065,6 +1226,7 @@ static int nand_do_read_ops(struct mtd_i
 
 		/* Is the current page in the buffer ? */
 		if (realpage != chip->pagebuf || oob) {
+			int bpage = get_backup_page(mtd, page, 0);
 			bufpoi = aligned ? buf : chip->buffers->databuf;
 
 			if (likely(sndcmd)) {
@@ -1075,10 +1237,38 @@ static int nand_do_read_ops(struct mtd_i
 			/* Now read the page into the buffer */
 			if (unlikely(ops->mode == MTD_OOB_RAW))
 				ret = chip->ecc.read_page_raw(mtd, chip, bufpoi);
+#ifdef FIXME
+			/* disable subpage reads - not supported with mlc ecc */
 			else if (!aligned && NAND_SUBPAGE_READ(chip) && !oob)
 				ret = chip->ecc.read_subpage(mtd, chip, col, bytes, bufpoi);
+#endif
 			else
 				ret = chip->ecc.read_page(mtd, chip, bufpoi);
+
+			if (bpage >= 0) {
+				int use_backup = (mtd->ecc_stats.failed
+						  - stats.failed
+						  + mtd->ecc_stats.corrected
+						  - stats.corrected);
+				if (!use_backup) {
+					use_backup = check_backup_oob(mtd, chip,
+								      bpage);
+				}
+				sndcmd = 1;
+				if (use_backup) {
+					void *rptr;
+					chip->cmdfunc(mtd, NAND_CMD_READ0,
+						      0x00, bpage);
+					nand_backup_merge(mtd, bufpoi,
+							  mtd->writesize);
+
+					rptr = chip->ecc.read_page_raw;
+					chip->ecc.read_page_raw = read_page_raw_dummy;
+					ret = chip->ecc.read_page(mtd, chip, bufpoi);
+					chip->ecc.read_page_raw = rptr;
+				}
+			}
+
 			if (ret < 0)
 				break;
 
@@ -1095,7 +1285,8 @@ static int nand_do_read_ops(struct mtd_i
 				/* Raw mode does data:oob:data:oob */
 				if (ops->mode != MTD_OOB_RAW) {
 					int toread = min(oobreadlen,
-						chip->ecc.layout->oobavail);
+							 ops->mode == MTD_OOB_PLACE ?
+							 mtd->oobsize : chip->ecc.layout->oobavail);
 					if (toread) {
 						oob = nand_transfer_oob(chip,
 							oob, ops, toread);
@@ -1209,11 +1400,20 @@ static int nand_read(struct mtd_info *mt
 static int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
 			     int page, int sndcmd)
 {
+	int bpage = get_backup_page(mtd, page, 0);
+
 	if (sndcmd) {
 		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
 		sndcmd = 0;
 	}
 	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	if (bpage >= 0) {
+		nand_wait_ready(mtd);
+		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, bpage);
+		nand_backup_merge(mtd, chip->oob_poi, mtd->oobsize);
+		sndcmd = 1;
+	}
 	return sndcmd;
 }
 
@@ -1506,6 +1706,16 @@ static void nand_write_page_swecc(struct
 	const uint8_t *p = buf;
 	uint32_t *eccpos = chip->ecc.layout->eccpos;
 
+	if (chip->ecc.layout == &nand_oob_64_mlc) {
+		set_ecc_mlc(chip);
+		nand_calculate_ecc_mlc(p + 0x000, chip->oob_poi + 24);
+		nand_calculate_ecc_mlc(p + 0x200, chip->oob_poi + 34);
+		nand_calculate_ecc_mlc(p + 0x400, chip->oob_poi + 44);
+		nand_calculate_ecc_mlc(p + 0x600, chip->oob_poi + 54);
+		chip->ecc.write_page_raw(mtd, chip, buf);
+		return;
+	}
+
 	/* Software ecc calculation */
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
 		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
@@ -1601,7 +1811,17 @@ static int nand_write_page(struct mtd_in
 			   const uint8_t *buf, int page, int cached, int raw)
 {
 	int status;
+	int bpage = get_backup_page(mtd, page, 1);
+
+	if (bpage >= 0) {
+		loff_t bofs = ((loff_t) bpage) << chip->page_shift;
+		if (nand_block_checkbad(mtd, bofs, 0, 1))
+			return -EIO;
 
+		*(uint32_t*)(&chip->oob_poi[BACKUP_4xFF_OFFSET]) = 0;
+		*(uint32_t*)(&chip->oob_poi[ALWAYS_4x00_OFFSET]) = 0;
+	}
+write_again:
 	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
 
 	if (unlikely(raw))
@@ -1638,9 +1858,27 @@ static int nand_write_page(struct mtd_in
 	/* Send command to read back the data */
 	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
 
-	if (chip->verify_buf(mtd, buf, mtd->writesize))
+	if (chip->verify_buf(mtd, buf, mtd->writesize)) {
+		if (chip->ecc.layout != &nand_oob_64_mlc) {
+			return -EIO;
+		}
+		chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+		if (nand_verify_buf_mlc(mtd, chip, buf, mtd->writesize)) {
 		return -EIO;
+		}
+		++mtd->ecc_stats.corrected;
+	}
 #endif
+	if (bpage >= 0) {
+		page = bpage;
+		bpage = -2;
+		*(uint32_t*)(&chip->oob_poi[BACKUP_4xFF_OFFSET]) = 0xffffffff;
+		if (chip->ecc.mode == NAND_ECC_SOFT) {
+			// ECC is already calculated, do not recalculate it
+			raw = 1;
+		}
+		goto write_again;
+	}
 	return 0;
 }
 
@@ -1746,8 +1984,7 @@ static int nand_do_write_ops(struct mtd_
 	    (chip->pagebuf << chip->page_shift) < (to + ops->len))
 		chip->pagebuf = -1;
 
-	/* If we're not given explicit OOB data, let it be 0xFF */
-	if (likely(!oob))
+	/* make sure unused OOB bytes are written as 0xFF */
 		memset(chip->oob_poi, 0xff, mtd->oobsize);
 
 	while(1) {
@@ -2015,6 +2252,7 @@ int nand_erase_nand(struct mtd_info *mtd
 		    int allowbbt)
 {
 	int page, len, status, pages_per_block, ret, chipnr;
+	int erase_bad = 0;
 	struct nand_chip *chip = mtd->priv;
 	int rewrite_bbt[NAND_MAX_CHIPS]={0};
 	unsigned int bbt_masked_page = 0xffffffff;
@@ -2028,6 +2266,11 @@ int nand_erase_nand(struct mtd_info *mtd
 		return -EINVAL;
 	}
 
+	if (instr->len == 0xDeadBeef) {
+		instr->len = (1 << chip->phys_erase_shift);
+		erase_bad = 1;
+	}
+
 	/* Length must align on block boundary */
 	if (instr->len & ((1 << chip->phys_erase_shift) - 1)) {
 		DEBUG(MTD_DEBUG_LEVEL0, "nand_erase: "
@@ -2080,6 +2323,18 @@ int nand_erase_nand(struct mtd_info *mtd
 	instr->state = MTD_ERASING;
 
 	while (len) {
+		int opage = page;
+		int bpage = get_backup_page(mtd, page, 1);
+	erase_again:
+		/*
+		 * try to erase bad block
+		 */
+		if (erase_bad && chip->bbt) {
+			loff_t ofs = ((loff_t) page) << chip->page_shift;
+			int block = ofs >> chip->bbt_erase_shift;
+			chip->bbt[block / 4] &= ~(0x03 << ((block & 0x03) * 2));
+		}
+
 		/*
 		 * heck if we have a bad block, we do not erase bad blocks !
 		 */
@@ -2128,6 +2383,15 @@ int nand_erase_nand(struct mtd_info *mtd
 		    (page & BBT_PAGE_MASK) == bbt_masked_page)
 			    rewrite_bbt[chipnr] = (page << chip->page_shift);
 
+		/* erase backup page as well */
+		if (bpage >= 0) {
+			if (page != bpage) {
+				page = bpage;
+				goto erase_again;
+			}
+			page = opage;
+		}
+		
 		/* Increment page address and decrement length */
 		len -= (1 << chip->phys_erase_shift);
 		page += pages_per_block;
@@ -2331,6 +2595,7 @@ static struct nand_flash_dev *nand_get_f
 	 * not match, ignore the device completely.
 	 */
 
+	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
 	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 
 	/* Read manufacturer and device IDs */
@@ -2455,6 +2720,32 @@ static struct nand_flash_dev *nand_get_f
 	return type;
 }
 
+int nand_lock_and_callback(struct mtd_info *mtd,
+			   int (*callback)(struct mtd_info *, void *),
+			   void *priv)
+{
+	int ret;
+	struct nand_chip *chip = mtd->priv;
+	if (chip == NULL) {
+		/* this is partition - get a master */
+		mtd = *(struct mtd_info **)(mtd + 1);
+		chip = mtd->priv;
+	}
+
+	/* Grab the lock and see if the device is available */
+	nand_get_device(chip, mtd , FL_READING);
+
+	chip->select_chip(mtd, 0);
+
+	ret = (*callback)(mtd, priv);
+
+	chip->select_chip(mtd, -1);
+
+	/* Deselect and wake up anyone waiting on the device */
+	nand_release_device(mtd);
+	return ret;
+}
+
 /**
  * nand_scan_ident - [NAND Interface] Scan for the NAND device
  * @mtd:	     MTD device structure
@@ -2552,6 +2843,15 @@ int nand_scan_tail(struct mtd_info *mtd)
 	if (!chip->write_page)
 		chip->write_page = nand_write_page;
 
+	if (is_nand_mlc(chip)) {
+		if (chip->block_bad == nand_block_bad)
+			chip->block_bad = nand_block_bad_mlc;
+		if (mlc_ecc_allowed)
+			chip->ecc.layout = &nand_oob_64_mlc;
+		else
+			printk("WARNING: mlc nand with slc ecc\n");
+	}
+
 	/*
 	 * check ECC mode, default to software if 3byte/512byte hardware ECC is
 	 * selected and we have 256 byte pagesize fallback to software ECC
@@ -2608,6 +2908,7 @@ int nand_scan_tail(struct mtd_info *mtd)
 		chip->ecc.read_subpage = nand_read_subpage;
 		chip->ecc.write_page = nand_write_page_swecc;
 		chip->ecc.read_oob = nand_read_oob_std;
+		if (!chip->ecc.write_oob)
 		chip->ecc.write_oob = nand_write_oob_std;
 		chip->ecc.size = 256;
 		chip->ecc.bytes = 3;
