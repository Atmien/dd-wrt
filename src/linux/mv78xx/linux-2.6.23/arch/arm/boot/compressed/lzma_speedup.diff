Index: LzmaDecode.c
===================================================================
--- LzmaDecode.c	(revision 9920)
+++ LzmaDecode.c	(working copy)
@@ -1,8 +1,8 @@
 /*
-  LzmaDecodeSize.c
-  LZMA Decoder (optimized for Size version)
+  LzmaDecode.c
+  LZMA Decoder
   
-  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  LZMA SDK 4.05 Copyright (c) 1999-2004 Igor Pavlov (2004-08-25)
   http://www.7-zip.org/
 
   LZMA SDK is licensed under two licenses:
@@ -21,6 +21,10 @@
 
 #include "LzmaDecode.h"
 
+#ifndef Byte
+#define Byte unsigned char
+#endif
+
 #define kNumTopBits 24
 #define kTopValue ((UInt32)1 << kNumTopBits)
 
@@ -30,12 +34,11 @@
 
 typedef struct _CRangeDecoder
 {
-  const Byte *Buffer;
-  const Byte *BufferLim;
+  Byte *Buffer;
+  Byte *BufferLim;
   UInt32 Range;
   UInt32 Code;
   #ifdef _LZMA_IN_CB
-  ILzmaInCallback *InCallback;
   int Result;
   #endif
   int ExtraBytes;
@@ -46,8 +49,8 @@
   if (rd->Buffer == rd->BufferLim)
   {
     #ifdef _LZMA_IN_CB
-    SizeT size;
-    rd->Result = rd->InCallback->Read(rd->InCallback, &rd->Buffer, &size);
+    UInt32 size;
+    rd->Result = read_byte(&rd->Buffer, &size);
     rd->BufferLim = rd->Buffer + size;
     if (size == 0)
     #endif
@@ -62,11 +65,7 @@
 /* #define ReadByte (*rd->Buffer++) */
 #define ReadByte (RangeDecoderReadByte(rd))
 
-void RangeDecoderInit(CRangeDecoder *rd
-  #ifndef _LZMA_IN_CB
-    , const Byte *stream, SizeT bufferSize
-  #endif
-    )
+void RangeDecoderInit(CRangeDecoder *rd)
 {
   int i;
   #ifdef _LZMA_IN_CB
@@ -91,7 +90,7 @@
   RC_INIT_VAR
   UInt32 result = 0;
   int i;
-  for (i = numTotalBits; i != 0; i--)
+  for (i = numTotalBits; i > 0; i--)
   {
     /* UInt32 t; */
     range >>= 1;
@@ -159,7 +158,7 @@
   #ifdef _LZMA_LOC_OPT
   RC_INIT_VAR
   #endif
-  for(i = numLevels; i != 0; i--)
+  for(i = numLevels; i > 0; i--)
   {
     #ifdef _LZMA_LOC_OPT
     CProb *prob = probs + mi;
@@ -234,11 +233,11 @@
     matchByte <<= 1;
     #ifdef _LZMA_LOC_OPT
     {
-      CProb *prob = probs + 0x100 + (matchBit << 8) + symbol;
+      CProb *prob = probs + ((1 + matchBit) << 8) + symbol;
       RC_GET_BIT2(prob, symbol, bit = 0, bit = 1)
     }
     #else
-    bit = RangeDecoderBitDecode(probs + 0x100 + (matchBit << 8) + symbol, rd);
+    bit = RangeDecoderBitDecode(probs + ((1 + matchBit) << 8) + symbol, rd);
     symbol = (symbol << 1) | bit;
     #endif
     if (matchBit != bit)
@@ -292,7 +291,6 @@
 }
 
 #define kNumStates 12
-#define kNumLitStates 7
 
 #define kStartPosModelIndex 4
 #define kEndPosModelIndex 14
@@ -323,125 +321,85 @@
 StopCompilingDueBUG
 #endif
 
-int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+#ifdef _LZMA_OUT_READ
+
+typedef struct _LzmaVarState
 {
-  unsigned char prop0;
-  if (size < LZMA_PROPERTIES_SIZE)
-    return LZMA_RESULT_DATA_ERROR;
-  prop0 = propsData[0];
-  if (prop0 >= (9 * 5 * 5))
-    return LZMA_RESULT_DATA_ERROR;
-  {
-    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
-    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
-    propsRes->lc = prop0;
-    /*
-    unsigned char remainder = (unsigned char)(prop0 / 9);
-    propsRes->lc = prop0 % 9;
-    propsRes->pb = remainder / 5;
-    propsRes->lp = remainder % 5;
-    */
-  }
+  CRangeDecoder RangeDecoder;
+  Byte *Dictionary;
+  UInt32 DictionarySize;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 Reps[4];
+  int lc;
+  int lp;
+  int pb;
+  int State;
+  int PreviousIsMatch;
+  int RemainLen;
+} LzmaVarState;
 
-  #ifdef _LZMA_OUT_READ
-  {
-    int i;
-    propsRes->DictionarySize = 0;
-    for (i = 0; i < 4; i++)
-      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
-    if (propsRes->DictionarySize == 0)
-      propsRes->DictionarySize = 1;
-  }
-  #endif
+int LzmaDecoderInit(
+    unsigned char *buffer, UInt32 bufferSize,
+    int lc, int lp, int pb,
+    unsigned char *dictionary, UInt32 dictionarySize,
+    )
+{
+  LzmaVarState *vs = (LzmaVarState *)buffer;
+  CProb *p = (CProb *)(buffer + sizeof(LzmaVarState));
+  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + lp));
+  UInt32 i;
+  if (bufferSize < numProbs * sizeof(CProb) + sizeof(LzmaVarState))
+    return LZMA_RESULT_NOT_ENOUGH_MEM;
+  vs->Dictionary = dictionary;
+  vs->DictionarySize = dictionarySize;
+  vs->DictionaryPos = 0;
+  vs->GlobalPos = 0;
+  vs->Reps[0] = vs->Reps[1] = vs->Reps[2] = vs->Reps[3] = 1;
+  vs->lc = lc;
+  vs->lp = lp;
+  vs->pb = pb;
+  vs->State = 0;
+  vs->PreviousIsMatch = 0;
+  vs->RemainLen = 0;
+  dictionary[dictionarySize - 1] = 0;
+  for (i = 0; i < numProbs; i++)
+    p[i] = kBitModelTotal >> 1; 
+  RangeDecoderInit(&vs->RangeDecoder, 
+  );
   return LZMA_RESULT_OK;
 }
 
-#define kLzmaStreamWasFinishedId (-1)
-
-int LzmaDecode(CLzmaDecoderState *vs,
-    #ifdef _LZMA_IN_CB
-    ILzmaInCallback *InCallback,
-    #else
-    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
-    #endif
-    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+int LzmaDecode(unsigned char *buffer, 
+    unsigned char *outStream, UInt32 outSize,
+    UInt32 *outSizeProcessed)
 {
-  CProb *p = vs->Probs;
-  SizeT nowPos = 0;
-  Byte previousByte = 0;
-  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
-  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
-  int lc = vs->Properties.lc;
-  CRangeDecoder rd;
-
-  #ifdef _LZMA_OUT_READ
-  
+  LzmaVarState *vs = (LzmaVarState *)buffer;
+  CProb *p = (CProb *)(buffer + sizeof(LzmaVarState));
+  CRangeDecoder rd = vs->RangeDecoder;
   int state = vs->State;
+  int previousIsMatch = vs->PreviousIsMatch;
+  Byte previousByte;
   UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  UInt32 nowPos = 0;
+  UInt32 posStateMask = (1 << (vs->pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->lp)) - 1;
+  int lc = vs->lc;
   int len = vs->RemainLen;
   UInt32 globalPos = vs->GlobalPos;
-  UInt32 distanceLimit = vs->DistanceLimit;
 
   Byte *dictionary = vs->Dictionary;
-  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionarySize = vs->DictionarySize;
   UInt32 dictionaryPos = vs->DictionaryPos;
 
-  Byte tempDictionary[4];
-
-  rd.Range = vs->Range;
-  rd.Code = vs->Code;
-  #ifdef _LZMA_IN_CB
-  rd.InCallback = InCallback;
-  rd.Buffer = vs->Buffer;
-  rd.BufferLim = vs->BufferLim;
-  #else
-  rd.Buffer = inStream;
-  rd.BufferLim = inStream + inSize;
-  #endif
-
-  #ifndef _LZMA_IN_CB
-  *inSizeProcessed = 0;
-  #endif
-  *outSizeProcessed = 0;
-  if (len == kLzmaStreamWasFinishedId)
-    return LZMA_RESULT_OK;
-
-  if (dictionarySize == 0)
+  if (len == -1)
   {
-    dictionary = tempDictionary;
-    dictionarySize = 1;
-    tempDictionary[0] = vs->TempDictionary[0];
+    *outSizeProcessed = 0;
+    return LZMA_RESULT_OK;
   }
 
-  if (len == kLzmaNeedInitId)
+  while(len > 0 && nowPos < outSize)
   {
-    {
-      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
-      UInt32 i;
-      for (i = 0; i < numProbs; i++)
-        p[i] = kBitModelTotal >> 1; 
-      rep0 = rep1 = rep2 = rep3 = 1;
-      state = 0;
-      globalPos = 0;
-      distanceLimit = 0;
-      dictionaryPos = 0;
-      dictionary[dictionarySize - 1] = 0;
-      RangeDecoderInit(&rd
-          #ifndef _LZMA_IN_CB
-          , inStream, inSize
-          #endif
-          );
-      #ifdef _LZMA_IN_CB
-      if (rd.Result != LZMA_RESULT_OK)
-        return rd.Result;
-      #endif
-      if (rd.ExtraBytes != 0)
-        return LZMA_RESULT_DATA_ERROR;
-    }
-    len = 0;
-  }
-  while(len != 0 && nowPos < outSize)
-  {
     UInt32 pos = dictionaryPos - rep0;
     if (pos >= dictionarySize)
       pos += dictionarySize;
@@ -454,49 +412,34 @@
     previousByte = dictionary[dictionarySize - 1];
   else
     previousByte = dictionary[dictionaryPos - 1];
+#else
 
-  #ifdef _LZMA_IN_CB
-  rd.Result = LZMA_RESULT_OK;
-  #endif
-  rd.ExtraBytes = 0;
-
-  #else /* if !_LZMA_OUT_READ */
-
+int LzmaDecode(
+    Byte *buffer, UInt32 bufferSize,
+    int lc, int lp, int pb,
+    unsigned char *outStream, UInt32 outSize,
+    UInt32 *outSizeProcessed)
+{
+  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + lp));
+  CProb *p = (CProb *)buffer;
+  CRangeDecoder rd;
+  UInt32 i;
   int state = 0;
+  int previousIsMatch = 0;
+  Byte previousByte = 0;
   UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  UInt32 nowPos = 0;
+  UInt32 posStateMask = (1 << pb) - 1;
+  UInt32 literalPosMask = (1 << lp) - 1;
   int len = 0;
+  if (bufferSize < numProbs * sizeof(CProb))
+    return LZMA_RESULT_NOT_ENOUGH_MEM;
+  for (i = 0; i < numProbs; i++)
+    p[i] = kBitModelTotal >> 1; 
+  RangeDecoderInit(&rd);
+#endif
 
-  #ifndef _LZMA_IN_CB
-  *inSizeProcessed = 0;
-  #endif
   *outSizeProcessed = 0;
-
-  {
-    UInt32 i;
-    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
-    for (i = 0; i < numProbs; i++)
-      p[i] = kBitModelTotal >> 1;
-  }
-  
-  #ifdef _LZMA_IN_CB
-  rd.InCallback = InCallback;
-  #endif
-  RangeDecoderInit(&rd
-      #ifndef _LZMA_IN_CB
-      , inStream, inSize
-      #endif
-      );
-
-  #ifdef _LZMA_IN_CB
-  if (rd.Result != LZMA_RESULT_OK)
-    return rd.Result;
-  #endif
-  if (rd.ExtraBytes != 0)
-    return LZMA_RESULT_DATA_ERROR;
-
-  #endif /* _LZMA_OUT_READ */
-
-
   while(nowPos < outSize)
   {
     int posState = (int)(
@@ -523,7 +466,10 @@
         )
         & literalPosMask) << lc) + (previousByte >> (8 - lc))));
 
-      if (state >= kNumLitStates)
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+      if (previousIsMatch)
       {
         Byte matchByte;
         #ifdef _LZMA_OUT_READ
@@ -535,24 +481,20 @@
         matchByte = outStream[nowPos - rep0];
         #endif
         previousByte = LzmaLiteralDecodeMatch(probs, &rd, matchByte);
+        previousIsMatch = 0;
       }
       else
         previousByte = LzmaLiteralDecode(probs, &rd);
       outStream[nowPos++] = previousByte;
       #ifdef _LZMA_OUT_READ
-      if (distanceLimit < dictionarySize)
-        distanceLimit++;
-
       dictionary[dictionaryPos] = previousByte;
       if (++dictionaryPos == dictionarySize)
         dictionaryPos = 0;
       #endif
-      if (state < 4) state = 0;
-      else if (state < 10) state -= 3;
-      else state -= 6;
     }
     else             
     {
+      previousIsMatch = 1;
       if (RangeDecoderBitDecode(p + IsRep + state, &rd) == 1)
       {
         if (RangeDecoderBitDecode(p + IsRepG0 + state, &rd) == 0)
@@ -562,14 +504,14 @@
             #ifdef _LZMA_OUT_READ
             UInt32 pos;
             #endif
-      
-            #ifdef _LZMA_OUT_READ
-            if (distanceLimit == 0)
-            #else
-            if (nowPos == 0)
-            #endif
+            if (
+               (nowPos 
+                #ifdef _LZMA_OUT_READ
+                + globalPos
+                #endif
+               )
+               == 0)
               return LZMA_RESULT_DATA_ERROR;
-
             state = state < 7 ? 9 : 11;
             #ifdef _LZMA_OUT_READ
             pos = dictionaryPos - rep0;
@@ -583,11 +525,6 @@
             previousByte = outStream[nowPos - rep0];
             #endif
             outStream[nowPos++] = previousByte;
-
-            #ifdef _LZMA_OUT_READ
-            if (distanceLimit < dictionarySize)
-              distanceLimit++;
-            #endif
             continue;
           }
         }
@@ -642,29 +579,23 @@
         }
         else
           rep0 = posSlot;
-        if (++rep0 == (UInt32)(0))
-        {
-          /* it's for stream version */
-          len = kLzmaStreamWasFinishedId;
-          break;
-        }
+        rep0++;
       }
-
-      len += kMatchMinLen;
-      #ifdef _LZMA_OUT_READ
-      if (rep0 > distanceLimit) 
-      #else
-      if (rep0 > nowPos)
-      #endif
+      if (rep0 == (UInt32)(0))
+      {
+        /* it's for stream version */
+        len = -1;
+        break;
+      }
+      if (rep0 > nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+      {
         return LZMA_RESULT_DATA_ERROR;
-
-      #ifdef _LZMA_OUT_READ
-      if (dictionarySize - distanceLimit > (UInt32)len)
-        distanceLimit += len;
-      else
-        distanceLimit = dictionarySize;
-      #endif
-
+      }
+      len += kMatchMinLen;
       do
       {
         #ifdef _LZMA_OUT_READ
@@ -678,35 +609,26 @@
         #else
         previousByte = outStream[nowPos - rep0];
         #endif
-        len--;
         outStream[nowPos++] = previousByte;
+        len--;
       }
-      while(len != 0 && nowPos < outSize);
+      while(len > 0 && nowPos < outSize);
     }
   }
 
-
   #ifdef _LZMA_OUT_READ
-  vs->Range = rd.Range;
-  vs->Code = rd.Code;
+  vs->RangeDecoder = rd;
   vs->DictionaryPos = dictionaryPos;
-  vs->GlobalPos = globalPos + (UInt32)nowPos;
-  vs->DistanceLimit = distanceLimit;
+  vs->GlobalPos = globalPos + nowPos;
   vs->Reps[0] = rep0;
   vs->Reps[1] = rep1;
   vs->Reps[2] = rep2;
   vs->Reps[3] = rep3;
   vs->State = state;
+  vs->PreviousIsMatch = previousIsMatch;
   vs->RemainLen = len;
-  vs->TempDictionary[0] = tempDictionary[0];
   #endif
 
-  #ifdef _LZMA_IN_CB
-  vs->Buffer = rd.Buffer;
-  vs->BufferLim = rd.BufferLim;
-  #else
-  *inSizeProcessed = (SizeT)(rd.Buffer - inStream);
-  #endif
   *outSizeProcessed = nowPos;
   return LZMA_RESULT_OK;
 }
Index: LzmaDecode.h
===================================================================
--- LzmaDecode.h	(revision 9920)
+++ LzmaDecode.h	(working copy)
@@ -2,7 +2,7 @@
   LzmaDecode.h
   LZMA Decoder interface
 
-  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  LZMA SDK 4.05 Copyright (c) 1999-2004 Igor Pavlov (2004-08-25)
   http://www.7-zip.org/
 
   LZMA SDK is licensed under two licenses:
@@ -22,8 +22,6 @@
 #ifndef __LZMADECODE_H
 #define __LZMADECODE_H
 
-#include "LzmaTypes.h"
-
 /* #define _LZMA_IN_CB */
 /* Use callback for input data */
 
@@ -37,77 +35,50 @@
 /* #define _LZMA_LOC_OPT */
 /* Enable local speed optimizations inside code */
 
+#ifndef UInt32
+#ifdef _LZMA_UINT32_IS_ULONG
+#define UInt32 unsigned long
+#else
+#define UInt32 unsigned int
+#endif
+#endif
+
 #ifdef _LZMA_PROB32
 #define CProb UInt32
 #else
-#define CProb UInt16
+#define CProb unsigned short
 #endif
 
 #define LZMA_RESULT_OK 0
 #define LZMA_RESULT_DATA_ERROR 1
+#define LZMA_RESULT_NOT_ENOUGH_MEM 2
 
-#ifdef _LZMA_IN_CB
-typedef struct _ILzmaInCallback
-{
-  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
-} ILzmaInCallback;
-#endif
 
 #define LZMA_BASE_SIZE 1846
 #define LZMA_LIT_SIZE 768
 
-#define LZMA_PROPERTIES_SIZE 5
+/* 
+bufferSize = (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << (lc + lp)))* sizeof(CProb)
+bufferSize += 100 in case of _LZMA_OUT_READ
+by default CProb is unsigned short, 
+but if specify _LZMA_PROB_32, CProb will be UInt32(unsigned int)
+*/
 
-typedef struct _CLzmaProperties
-{
-  int lc;
-  int lp;
-  int pb;
-  #ifdef _LZMA_OUT_READ
-  UInt32 DictionarySize;
-  #endif
-}CLzmaProperties;
-
-int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
-
-#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))
-
-#define kLzmaNeedInitId (-2)
-
-typedef struct _CLzmaDecoderState
-{
-  CLzmaProperties Properties;
-  CProb *Probs;
-
-  #ifdef _LZMA_IN_CB
-  const unsigned char *Buffer;
-  const unsigned char *BufferLim;
-  #endif
-
-  #ifdef _LZMA_OUT_READ
-  unsigned char *Dictionary;
-  UInt32 Range;
-  UInt32 Code;
-  UInt32 DictionaryPos;
-  UInt32 GlobalPos;
-  UInt32 DistanceLimit;
-  UInt32 Reps[4];
-  int State;
-  int RemainLen;
-  unsigned char TempDictionary[4];
-  #endif
-} CLzmaDecoderState;
-
 #ifdef _LZMA_OUT_READ
-#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
+int LzmaDecoderInit(
+    unsigned char *buffer, UInt32 bufferSize,
+    int lc, int lp, int pb,
+    unsigned char *dictionary, UInt32 dictionarySize,
+);
 #endif
 
-int LzmaDecode(CLzmaDecoderState *vs,
-    #ifdef _LZMA_IN_CB
-    ILzmaInCallback *inCallback,
-    #else
-    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
-    #endif
-    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
+int LzmaDecode(
+    unsigned char *buffer, 
+  #ifndef _LZMA_OUT_READ
+    UInt32 bufferSize,
+    int lc, int lp, int pb,
+  #endif
+    unsigned char *outStream, UInt32 outSize,
+    UInt32 *outSizeProcessed);
 
 #endif
Index: misc_lzma.c
===================================================================
--- misc_lzma.c	(revision 9920)
+++ misc_lzma.c	(working copy)
@@ -125,12 +125,12 @@
 static ulg free_mem_ptr_end;
 
 #define _LZMA_IN_CB
+
 #include "LzmaDecode.h"
+static __inline__ int read_byte(unsigned char **buffer, UInt32 *bufferSize);
 #include "LzmaDecode.c"
 
-static int read_byte(void *object, const unsigned char **buffer, SizeT *bufferSize);
 
-
 /*
  * Do the lzma decompression
  */
@@ -138,16 +138,14 @@
 {
 
 	unsigned int i;
-        CLzmaDecoderState state;
 	unsigned int uncompressedSize = 0;
-        
-        ILzmaInCallback callback;
-        callback.Read = read_byte;
+        unsigned char *workspace;
+        unsigned int lc,lp,pb;
 
 	// lzma args
 	i = get_byte();
-	state.Properties.lc = i % 9, i = i / 9;
-        state.Properties.lp = i % 5, state.Properties.pb = i / 5;
+	lc = i % 9, i = i / 9;
+	lp = i % 5, pb = i / 5;
         
         // skip dictionary size
         for (i = 0; i < 4; i++) 
@@ -157,15 +155,14 @@
 		(get_byte() << 8) +
 		(get_byte() << 16) +
 		(get_byte() << 24);
-            
+        workspace = output_data + uncompressedSize;
         // skip high order bytes
         for (i = 0; i < 4; i++) 
         	get_byte();
-        // point it beyond uncompresedSize
-        state.Probs = (CProb*) (output_data + uncompressedSize);
 	// decompress kernel
-	if (LzmaDecode( &state, &callback,
-	   (unsigned char*)output_data, uncompressedSize, &i) == LZMA_RESULT_OK)
+//	if (LzmaDecode(workspace, ~0, lc, lp, pb,
+//		(unsigned char*)LOADADDR, osize, &i) == LZMA_RESULT_OK)
+	if (LzmaDecode(workspace, ~0, lc,lp,pb,(unsigned char*)output_data, uncompressedSize, &i) == LZMA_RESULT_OK)
 	{
 		if ( i != uncompressedSize )
 		   error( "kernel corrupted!\n");
@@ -178,10 +175,10 @@
 }
 
 
-static unsigned int icnt = 0;
-static int read_byte(void *object, const unsigned char **buffer, SizeT *bufferSize)
+static __inline__ int read_byte(unsigned char **buffer, UInt32 *bufferSize)
 {
 	static unsigned char val;
+	static unsigned int icnt = 0;
 	*bufferSize = 1;
 	val = get_byte();
 	*buffer = &val;
Index: Makefile
===================================================================
--- Makefile	(revision 9920)
+++ Makefile	(working copy)
@@ -73,7 +73,7 @@
 
 targets       := vmlinux vmlinux.lds piggy.lzma piggy.o font.o font.c \
 		 head.o misc_lzma.o print.o $(OBJS)
-EXTRA_CFLAGS  := -fpic -fno-builtin -Os
+EXTRA_CFLAGS  := -fpic -fno-builtin -O2
 EXTRA_AFLAGS  :=
 
 # Supply ZRELADDR, INITRD_PHYS and PARAMS_PHYS to the decompressor via
