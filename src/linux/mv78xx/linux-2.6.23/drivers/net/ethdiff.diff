--- ixp400_eth.c	2007-12-10 22:14:00.713668052 +0100
+++ ixp400_eth.c.new	2007-12-10 22:14:02.389740000 +0100
@@ -9,7 +9,7 @@
  * -- Intel Copyright Notice --
  * 
  * @par
- * Copyright (c) 2004-2005  Intel Corporation. All Rights Reserved. 
+ * Copyright (c) 2004-2007  Intel Corporation. All Rights Reserved. 
  * 
  * @par 
  * This software program is licensed subject to the GNU
@@ -72,10 +72,9 @@
 /*
  * System-defined header files
  */
-#include <linux/autoconf.h>
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
-#include <linux/platform_device.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
 #include <linux/netdevice.h>
@@ -91,13 +90,11 @@
 #include <net/ip.h>
 #include <linux/sysctl.h>
 #include <linux/unistd.h>
-#include <linux/version.h>
-
-#if KERNEL_VERSION(2,6,0) <= LINUX_VERSION_CODE
+#include <linux/platform_device.h>
 #include <linux/workqueue.h>
-#define IS_KERNEL26 1
-#else
-#define IS_KERNEL26 0
+
+#ifdef CONFIG_XFRM
+#include <net/xfrm.h>
 #endif
 
 /*
@@ -133,13 +130,13 @@
 MODULE_LICENSE ("GPL");
 MODULE_AUTHOR ("Intel Corporation");
 #define MODULE_NAME "ixp400_eth"
-#define MOD_VERSION "1.6"
+#define MOD_VERSION "1.7"
 
 /* 
  * Non-user configurable private variable 
  */
 
-#if defined(CONFIG_CPU_IXP46X) || defined (CONFIG_CPU_IXP43X)
+#if defined (CONFIG_CPU_IXP46X) || defined (CONFIG_CPU_IXP43X)
 /* NPE-A enabled flag for parity error detection configuration */
 static IxParityENAccConfigOption parity_npeA_enabled = IX_PARITYENACC_DISABLE;
 /* NPE-B enabled flag for parity error detection configuration */
@@ -153,7 +150,7 @@
 /* 
  * Module parameters 
  */
-static int npe_learning = 0;	/* default : NPE learning & filtering enable */
+static int npe_learning = 1;	/* default : NPE learning & filtering enable */
 static int log_level = 0;	/* default : no log */
 static int no_ixp400_sw_init = 0;	/* default : init core components of the IXP400 Software */
 static int no_phy_scan = 0;	/* default : do phy discovery */
@@ -169,9 +166,9 @@
 static int dev_max_count = 1;	/* only NPEC is used */
 #elif defined (CONFIG_IXP400_ETH_NPEB_ONLY)
 static int dev_max_count = 1;	/* only NPEB is used */
-#elif defined (CONFIG_ARCH_IXDP425) || defined(CONFIG_ARCH_IXDPG425)\
-      || defined (CONFIG_ARCH_ADI_COYOTE) || defined (CONFIG_ARCH_AVILA) || defined (CONFIG_MACH_KIXRP435)
-static int dev_max_count = 2;	/* only NPEB and NPEC */
+#elif defined (CONFIG_ARCH_IXDP425) || defined(CONFIG_MACH_IXDPG425)\
+      || defined (CONFIG_ARCH_ADI_COYOTE) || defined (CONFIG_MACH_KIXRP435)
+static int dev_max_count = 2;	/* only NPEB and NPEC or NPEA and NPEC on IXP43X */
 #elif defined (CONFIG_ARCH_IXDP465) || defined(CONFIG_MACH_IXDP465)
 static int dev_max_count = 3;	/* all NPEs are used */
 #endif
@@ -187,32 +184,32 @@
  */
 static int netdev_max_backlog = 290;
 
-module_param (netdev_max_backlog, int, 0);
+MODULE_PARM (netdev_max_backlog, "i");
 MODULE_PARM_DESC (netdev_max_backlog,
 		  "Should be set to the value of /proc/sys/net/core/netdev_max_backlog (perf affecting)");
 #endif /* CONFIG_IXP400_NAPI */
-module_param (datapath_poll, int, 0);
+MODULE_PARM (datapath_poll, "i");
 MODULE_PARM_DESC (datapath_poll,
 		  "If non-zero, use polling method for datapath instead of interrupts");
-module_param (npe_learning, int, 0);
+MODULE_PARM (npe_learning, "i");
 MODULE_PARM_DESC (npe_learning,
 		  "If non-zero, NPE MAC Address Learning & Filtering feature will be enabled");
-module_param (log_level, int, 0);
+MODULE_PARM (log_level, "i");
 MODULE_PARM_DESC (log_level,
 		  "Set log level: 0 - None, 1 - Verbose, 2 - Debug");
-module_param (no_ixp400_sw_init, int, 0);
+MODULE_PARM (no_ixp400_sw_init, "i");
 MODULE_PARM_DESC (no_ixp400_sw_init,
 		  "If non-zero, do not initialise Intel IXP400 Software Release core components");
-module_param (no_phy_scan, int, 0);
+MODULE_PARM (no_phy_scan, "i");
 MODULE_PARM_DESC (no_phy_scan, "If non-zero, use hard-coded phy addresses");
-module_param (phy_reset, int, 0);
+MODULE_PARM (phy_reset, "i");
 MODULE_PARM_DESC (phy_reset, "If non-zero, reset the phys");
-module_param (dev_max_count, int, 0);
+MODULE_PARM (dev_max_count, "i");
 MODULE_PARM_DESC (dev_max_count, "Number of devices to initialize");
-module_param (npe_error_handler, int, 0);
+MODULE_PARM (npe_error_handler, "i");
 MODULE_PARM_DESC (npe_error_handler,
 		  "If non-zero, NPE error handling feature will be enabled");
-module_param (hss_coexist, int, 0);
+MODULE_PARM (hss_coexist, "i");
 MODULE_PARM_DESC (hss_coexist,
 		  "If non-zero, HSS-Ethernet coexist feature will be enabled");
 /* devices will be called ixp0 and ixp1 */
@@ -404,11 +401,6 @@
 #endif
 
 /* extern Linux kernel data */
-#if !(IS_KERNEL26 || defined(CONFIG_IXP400_NAPI))
-/* used to get the current queue level */
-extern struct softnet_data softnet_data[];
-#endif
-
 extern unsigned long loops_per_jiffy;	/* used to calculate CPU clock speed */
 
 /* 
@@ -430,7 +422,7 @@
  * Prototype for parity error detection and handler
  */
 
-#if defined(CONFIG_CPU_IXP46X) || defined (CONFIG_CPU_IXP43X)
+#if defined (CONFIG_CPU_IXP46X) || defined (CONFIG_CPU_IXP43X)
 static int __init parity_npe_error_handler_init (void);
 static void parity_npe_error_handler_uninit (void);
 static void parity_npe_recovery_done_cb (IxErrHdlAccErrorEventType
@@ -506,17 +498,11 @@
   volatile BOOL maintenanceCheckStopped;
 
   /* workqueue used for tx timeout */
-#if IS_KERNEL26
   struct workqueue_struct *timeout_workq;
   struct work_struct timeout_work;
-#else
-  struct tq_struct taskqueue_timeout;
-#endif
-
 
   /* used to control the message output */
   UINT32 devFlags;
-  struct net_device *ndev;
 } priv_data_t;
 
 /* Collection of boolean PHY configuration parameters */
@@ -536,7 +522,6 @@
 } npe_info_t;
 
 
-#if IS_KERNEL26
 static int __devinit dev_eth_probe (struct device *dev);
 static int __devexit dev_eth_remove (struct device *dev);
 static void dev_eth_release (struct device *dev);
@@ -572,7 +557,7 @@
    .dev = {
 	   .release = dev_eth_release,
 	   },
-#if IX_ETH_ACC_NUMBER_OF_PORTS > 2 && !defined (CONFIG_MACH_KIXRP435)
+#if IX_ETH_ACC_NUMBER_OF_PORTS > 2 && !defined (CONFIG_CPU_IXP43X)
    },
   {
    .name = MODULE_NAME,
@@ -591,10 +576,6 @@
 dev_eth_release (struct device *dev)
 {
 }
-#else
-static struct net_device ixp400_eth_devices[IX_ETH_ACC_NUMBER_OF_PORTS];
-
-#endif /* IS_KERNEL26 */
 
 
 /*
@@ -645,15 +626,7 @@
  * the IXDP425 and Coyote (IXP4XX RG) Development platforms.
  * However, they may differ on other platforms.
  */
-static int phyAddresses[IXP425_ETH_ACC_MII_MAX_ADDR] = {
-/*#if defined(CONFIG_ARCH_AVILA)
-    5, 
-    4, 
-    0, 
-    1,
-    2,
-    3
-#el*/
+static int phyAddresses[IXP400_ETH_ACC_MII_MAX_ADDR] = {
 #if defined(CONFIG_ARCH_IXDP425)
   /* 1 PHY per NPE port */
   0,				/* Port 1 (IX_ETH_PORT_1 / NPE B) */
@@ -662,7 +635,7 @@
   /* 1 PHY per NPE port */
   0,				/* Port 1 (IX_ETH_PORT_1 / NPE B) */
   1,				/* Port 2 (IX_ETH_PORT_2 / NPE C) */
-  2				/* Port 3 (IX_ETH_PORT_2 / NPE A) */
+  2				/* Port 3 (IX_ETH_PORT_3 / NPE A) */
 #elif defined(CONFIG_ARCH_ADI_COYOTE)
   4,				/* Port 1 (IX_ETH_PORT_1) - Connected to PHYs 1-4      */
   5,				/* Port 2 (IX_ETH_PORT_2) - Only connected to PHY 5    */
@@ -675,7 +648,7 @@
     /* /_______________/|     /___/|                      */
     /* | 1 | 2 | 3 | 4 |      | 5 |                       */
     /* ----------------------------------------           */
-#elif defined(CONFIG_ARCH_IXDPG425)
+#elif defined(CONFIG_MACH_IXDPG425)
   5,				/* Port 1 (ixp0) - Connected to switch via PHY 5 */
   4,				/* Port 2 (ixp1) - Only connected to PHY 4       */
   0,				/* 4 port switch - PHY 0..3                      */
@@ -734,16 +707,6 @@
  * See also function phy_init() in this file
  */
 static phy_cfg_t default_phy_cfg[] = {
-/*#if defined(CONFIG_ARCH_AVILA)
-    {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON,TRUE},
-    {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON,TRUE}, 
-    {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON,TRUE},
-    {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON,TRUE},
-    {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON,TRUE},
-    {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON,TRUE}
-
-
-#el*/
 #if defined(CONFIG_ARCH_IXDP425)
   {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, TRUE},	/* Port 0: monitor the phy */
   {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, TRUE}	/* Port 1: monitor the link */
@@ -760,9 +723,9 @@
   {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, FALSE},
   {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, FALSE}
 
-#elif defined(CONFIG_ARCH_IXDPG425)
-  {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, FALSE},	/* Port 1: NO link */
-  {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, TRUE},	/* Port 2: monitor the link */
+#elif defined(CONFIG_MACH_IXDPG425)
+  {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, FALSE},	/* Port 0: NO link */
+  {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, TRUE},	/* Port 1: monitor the link */
   {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, FALSE},
   {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, FALSE},
   {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, FALSE},
@@ -773,7 +736,6 @@
   {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, FALSE},
   {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, FALSE},
   {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, FALSE}
-
 #else
   {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, TRUE},	/* Port 0: monitor the link */
   {PHY_SPEED_100, PHY_DUPLEX_FULL, PHY_AUTONEG_ON, TRUE}	/* Port 1: monitor the link */
@@ -878,11 +840,8 @@
 static UINT32 skbAllocFailErrorCount = 0;
 static UINT32 replenishErrorCount = 0;
 
-
-#if IS_KERNEL26
 /* Workqueue for maintenance task */
 static struct workqueue_struct *maintenance_workq = NULL;
-#endif
 
 
 /*
@@ -1141,10 +1100,12 @@
    */
 
   if ((skb->truesize >= priv->alloc_size) &&
-      (skb->users.counter == 1) &&
-      (skb->cloned == 0) &&
+      (atomic_read (&skb->users) == 1) &&
+      (!skb_cloned (skb)) &&
+      (skb->fclone == SKB_FCLONE_UNAVAILABLE) &&
       (skb->destructor == NULL) &&
-      (skb_shinfo (skb)->dataref.counter == 1) &&
+      (atomic_read (&skb_shinfo (skb)->dataref) == 1) &&
+      (skb->nohdr == 0) &&
       (skb_shinfo (skb)->nr_frags == 0) &&
       (skb_shinfo (skb)->frag_list == NULL) &&
       (skQueueHead - skQueueTail < SKB_QSIZE))
@@ -1166,6 +1127,11 @@
 
       dst_release (skb->dst);
 
+#ifdef CONFIG_XFRM
+      secpath_put (skb->sp);
+      skb->sp = NULL;
+#endif
+
 #ifdef CONFIG_NETFILTER
       /* Some packets may get incorrectly process by netfilter firewall 
        * software if CONFIG_NETFILTER is enabled and filtering is in use. 
@@ -1173,33 +1139,35 @@
        * before re-using it on the Rx-path
        */
       skb->nfmark = 0;
-      skb->nfcache = 0;
       nf_conntrack_put (skb->nfct);
       skb->nfct = NULL;
 #ifdef CONFIG_NETFILTER_DEBUG
       skb->nf_debug = 0;
 #endif
-#endif /* CONFIG_NETFILTER */
-#ifdef CONFIG_NETFILTER
-#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
+#ifdef CONFIG_BRIDGE_NETFILTER
 /* We need to free the memory attached to the nf_bridge pointer to avoid a memory leak */
       nf_bridge_put (skb->nf_bridge);
       skb->nf_bridge = NULL;
-#endif
+#endif /* CONFIG_BRIDGE_NETFILTER */
+#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
+      nf_conntrack_put_reasm (skb->nfct_reasm);
+      skb->nfct_reasm = NULL;
+#endif /* CONFIG_NF_CONNTRACK || CONFIG_NF_CONNTRACK_MODULE */
 #endif /* CONFIG_NETFILTER */
       skb->sk = NULL;
       skb->dst = NULL;
       skb->pkt_type = PACKET_HOST;	/* Default type */
       skb->ip_summed = 0;
       skb->priority = 0;
-      skb->security = 0;
+      skb->ipvs_property = 0;
+      skb->nfctinfo = 0;
+      skb->local_df = 0;
 #ifdef CONFIG_NET_SCHED
       skb->tc_index = 0;
-#endif
-#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
-      skb->imq_flags = 0;
-      skb->nf_info = NULL;
-#endif
+#ifdef CONFIG_NET_CLS_ACT
+      skb->tc_verd = 0;
+#endif /* CONFIG_NET_CLS_ACT */
+#endif /* CONFIG_NET_SCHED */
 
       /* reset the data pointer (skb_reserve is not used for efficiency) */
       skb->data = skb->head + SKB_RESERVED_HEADER_SIZE + HDR_SIZE;
@@ -1417,12 +1385,7 @@
 {
   struct sk_buff *skb;
   int key;
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
-
 
   dev_rx_buff_prealloc (priv);
 
@@ -1463,11 +1426,7 @@
   int killed = FALSE;
   if (signal_pending (current))
     {
-#if IS_KERNEL26
       spin_lock_irq (&current->sighand->siglock);
-#else
-      spin_lock_irq (&current->sigmask_lock);
-#endif
 
       if (sigismember (&(current->pending.signal), SIGKILL)
 	  || sigismember (&(current->pending.signal), SIGTERM))
@@ -1477,11 +1436,7 @@
 	}
       flush_signals (current);
 
-#if IS_KERNEL26
       spin_unlock_irq (&current->sighand->siglock);
-#else
-      spin_unlock_irq (&current->sigmask_lock);
-#endif
     }
   return killed;
 }
@@ -1497,11 +1452,7 @@
 dev_media_check_thread (void *arg)
 {
   struct net_device *dev = (struct net_device *) arg;
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
   int linkUp;
   int speed100;
   int fullDuplex = -1;		/* unknown duplex mode */
@@ -1518,24 +1469,13 @@
    */
   down (priv->maintenanceCheckThreadComplete);
 
-#if IS_KERNEL26
   daemonize ("ixp400 MediaCheck");
   spin_lock_irq (&current->sighand->siglock);
-#else
-  daemonize ();
-  reparent_to_init ();
-  spin_lock_irq (&current->sigmask_lock);
-#endif
 
   sigemptyset (&current->blocked);
 
-#if IS_KERNEL26
   recalc_sigpending ();
   spin_unlock_irq (&current->sighand->siglock);
-#else
-  recalc_sigpending (current);
-  spin_unlock_irq (&current->sigmask_lock);
-#endif
 
   snprintf (current->comm, sizeof (current->comm), "ixp400 %s", dev->name);
 
@@ -1607,8 +1547,6 @@
 	      if (!netif_carrier_ok (dev))
 		{
 		  /* inform the kernel of a change in link state */
-		  P_ERROR ("\nixp400_eth: %s PHY:%d link down->up ",
-			   dev->name, phyNum);
 		  netif_carrier_on (dev);
 		}
 
@@ -1637,8 +1575,6 @@
 	      if (netif_carrier_ok (dev))
 		{
 		  /* inform the kernel of a change in link state */
-		  P_ERROR ("\nixp400_eth: %s PHY:%d link up->down ",
-			   dev->name, phyNum);
 		  netif_carrier_off (dev);
 		}
 	    }
@@ -1651,8 +1587,6 @@
 	   */
 	  if (!netif_carrier_ok (dev))
 	    {
-	      P_ERROR ("\nixp400_eth: %s PHY:%d link not monitored up ",
-		       dev->name, phyNum);
 	      netif_carrier_on (dev);
 	    }
 	}
@@ -1688,16 +1622,12 @@
 #if !defined (CONFIG_IXP400_ETH_NPEB_ONLY) &&\
     !defined (CONFIG_IXP400_ETH_NPEC_ONLY)
 
-  /* Only ixp465 has NPE-A */
 #if defined (CONFIG_CPU_IXP46X) || defined (CONFIG_CPU_IXP43X)
-//    if (machine_is_ixdp465())
-  {
-    if (unlikely (IX_SUCCESS != ixNpeMhMessagesReceive (IX_NPEMH_NPEID_NPEA)))
-      {
-	P_ERROR ("NPE-A npeMh read failure!\n");
-      }
-  }
-#endif
+  if (unlikely (IX_SUCCESS != ixNpeMhMessagesReceive (IX_NPEMH_NPEID_NPEA)))
+    {
+      P_ERROR ("NPE-A npeMh read failure!\n");
+    }
+#endif /* defined CONFIG_CPU_IXP46X || defined CONFIG_CPU_IXP43X */
 #endif
 
   /* Polling for NPE-B */
@@ -1746,11 +1676,7 @@
 {
   unsigned long flags;
 
-#if IS_KERNEL26
   local_irq_save (flags);
-#else
-  save_flags_cli (flags);
-#endif
 
   __asm__ (" mcr p14,0,%0,c1,c1,0\n"	/* write current counter */
 : :	   "r" (timer_countup_ticks));
@@ -1760,38 +1686,22 @@
 	   " mcr p14,0,r1,c4,c1,0\n"	/* enable interrupts */
 : : :	   "r1");
 
-#if IS_KERNEL26
   local_irq_restore (flags);
-#else
-  restore_flags (flags);
-#endif
 }
 
-#if IS_KERNEL26
 static irqreturn_t
-dev_pmu_timer_npemhpoll_os_isr (int irg, void *dev_id)
-#else
-static void
 dev_pmu_timer_npemhpoll_os_isr (int irg, void *dev_id, struct pt_regs *regs)
-#endif
 {
   dev_pmu_timer_restart ();	/* set up the timer for the next interrupt */
 
   npemh_poll (NULL);
 
-#if IS_KERNEL26
   return IRQ_HANDLED;
-#endif
 }
 
-#if IS_KERNEL26
 static irqreturn_t
-dev_pmu_timer_datapathpoll_os_isr (int irg, void *dev_id)
-#else
-static void
 dev_pmu_timer_datapathpoll_os_isr (int irg, void *dev_id,
 				   struct pt_regs *regs)
-#endif
 {
   dev_pmu_timer_restart ();	/* set up the timer for the next interrupt */
 
@@ -1804,9 +1714,7 @@
   ixEthRxPriorityPoll (0, 128);
   ixEthTxFrameDoneQMCallback (0, 0);
 
-#if IS_KERNEL26
   return IRQ_HANDLED;
-#endif
 }
 
 /* initialize the PMU timer */
@@ -1865,20 +1773,12 @@
 {
   unsigned long flags;
 
-#if IS_KERNEL26
   local_irq_save (flags);
-#else
-  save_flags_cli (flags);
-#endif
 
   __asm__ (" mrc p14,0,r1,c4,c1,0; "	/* get int enable register */
 	   " and r1,r1,#0x1e; " " mcr p14,0,r1,c4,c1,0\n"	/* disable interrupts */
 : : :	   "r1");
-#if IS_KERNEL26
   local_irq_restore (flags);
-#else
-  restore_flags (flags);
-#endif
 }
 
 static int
@@ -1894,7 +1794,7 @@
        */
       if (request_irq (IX_OSAL_IXP400_XSCALE_PMU_IRQ_LVL,
 		       dev_pmu_timer_npemhpoll_os_isr,
-		       IRQF_SHARED,
+		       SA_SHIRQ,
 		       "ixp400_eth PMU timer", (void *) IRQ_ANY_PARAMETER))
 	{
 	  P_ERROR ("Failed to reassign irq to PMU timer interrupt!\n");
@@ -1910,7 +1810,7 @@
        */
       if (request_irq (IX_OSAL_IXP400_XSCALE_PMU_IRQ_LVL,
 		       dev_pmu_timer_datapathpoll_os_isr,
-		       IRQF_SHARED,
+		       SA_SHIRQ,
 		       "ixp400_eth PMU timer", (void *) IRQ_ANY_PARAMETER))
 	{
 	  P_ERROR ("Failed to reassign irq to PMU timer interrupt!\n");
@@ -1943,16 +1843,10 @@
 /* Internal ISR : run a few thousand times per second and calls 
  * the queue manager dispatcher entry point.
  */
-#if IS_KERNEL26
 static irqreturn_t
-dev_qmgr_os_isr (int irg, void *dev_id)
-#else
-static void
 dev_qmgr_os_isr (int irg, void *dev_id, struct pt_regs *regs)
-#endif
 {
 #ifdef CONFIG_IXP400_NAPI
-
   /* Note: there are 2 possible race conditions where the normal
    * EthAcc QMgr receive callback will be invoked by dispatcherFunc()
    * to drain the rx queues rather than polling them via dev_rx_poll:
@@ -1976,9 +1870,7 @@
   /* call the queue manager entry point */
   dispatcherFunc (IX_QMGR_QUELOW_GROUP);
 
-#if IS_KERNEL26
   return IRQ_HANDLED;
-#endif
 }
 
 /* Internal ISR : run a few thousand times per second and calls 
@@ -2026,67 +1918,34 @@
  * IX_ETH_DB_MAINTENANCE_TIME jiffies
  */
 
-static void maintenance_timer_task (struct work_struct *data);
+static void maintenance_timer_task (void *data);
 
 /* task spawned by timer interrupt for EthDB maintenance */
-#if IS_KERNEL26
-static DECLARE_DELAYED_WORK (ethdb_maintenance_work, maintenance_timer_task);
-#else
-static struct tq_struct taskqueue_maintenance = {
-routine:maintenance_timer_task
-};
-
-static void maintenance_timer_cb (unsigned long data);
-
-static struct timer_list maintenance_timer = {
-function:&maintenance_timer_cb
-};
-#endif
+static DECLARE_WORK (ethdb_maintenance_work, maintenance_timer_task, NULL);
 
 static void
 maintenance_timer_set (void)
 {
-#if IS_KERNEL26
   queue_delayed_work (maintenance_workq, &ethdb_maintenance_work,
 		      DB_MAINTENANCE_TIME);
-#else
-  maintenance_timer.expires = jiffies + DB_MAINTENANCE_TIME;
-  add_timer (&maintenance_timer);
-#endif
 }
 
 static void
 maintenance_timer_clear (void)
 {
-#if IS_KERNEL26
   cancel_delayed_work (&ethdb_maintenance_work);
   flush_workqueue (maintenance_workq);
-#else
-  del_timer_sync (&maintenance_timer);
-#endif
 }
 
 static void
-maintenance_timer_task (struct work_struct *data)
+maintenance_timer_task (void *data)
 {
   down (maintenance_mutex);
   ixEthDBDatabaseMaintenance ();
   up (maintenance_mutex);
-#if IS_KERNEL26
   maintenance_timer_set ();
-#endif
 }
 
-#if !(IS_KERNEL26)
-static void
-maintenance_timer_cb (unsigned long data)
-{
-  schedule_work (&taskqueue_maintenance);
-
-  maintenance_timer_set ();
-}
-#endif
-
 /*
  *  DATAPLANE
  */
@@ -2100,11 +1959,7 @@
 tx_done_disable_cb (UINT32 callbackTag, IX_OSAL_MBUF * mbuf)
 {
   struct net_device *dev = (struct net_device *) callbackTag;
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
 
   TRACE;
 
@@ -2126,11 +1981,7 @@
 tx_done_cb (UINT32 callbackTag, IX_OSAL_MBUF * mbuf)
 {
   struct net_device *dev = (struct net_device *) callbackTag;
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
 
   TRACE;
   priv->stats.tx_packets++;	/* total packets transmitted */
@@ -2157,11 +2008,7 @@
 tx_done_queue_stopped_cb (UINT32 callbackTag, IX_OSAL_MBUF * mbuf)
 {
   struct net_device *dev = (struct net_device *) callbackTag;
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
 
   TRACE;
 
@@ -2185,8 +2032,7 @@
 		    struct sk_buff *skb, struct net_device *dev)
 {
   unsigned header_len = dev->hard_header_len;
-  skb_reset_mac_header (skb);
-//    skb->mac.raw=skb->data;
+  skb->mac.raw = skb->data;
   /* skip the mac header : there is no need for length comparison since
    * the skb during a receive is always greater than the header size and 
    * runt frames are not enabled.
@@ -2195,11 +2041,7 @@
   skb->len -= header_len;
 
   /* fill the pkt arrival time (set at the irq callback entry) */
-#if IS_KERNEL26
-  skb->tstamp = timeval_to_ktime (irq_stamp);
-#else
-  skb->stamp = irq_stamp;
-#endif
+  skb_set_timestamp (skb, &irq_stamp);
 
   /* fill the input device field */
   skb->dev = dev;
@@ -2223,12 +2065,7 @@
        * and its constants are taken from the eth_type_trans()
        * function.
        */
-#if IS_KERNEL26
       struct ethhdr *eth = eth_hdr (skb);
-#else
-      struct ethhdr *eth = skb->mac.ethernet;
-#endif
-
       unsigned short hproto = ntohs (eth->h_proto);
 
       if (hproto >= 1536)
@@ -2270,11 +2107,7 @@
 	   * mode is set This costs
 	   * a lookup inside the packet payload.
 	   */
-#if IS_KERNEL26
 	  struct ethhdr *eth = eth_hdr (skb);
-#else
-	  struct ethhdr *eth = skb->mac.ethernet;
-#endif
 	  unsigned char *hdest = eth->h_dest;
 
 	  if (memcmp (hdest, dev->dev_addr, ETH_ALEN) != 0)
@@ -2332,18 +2165,15 @@
 #ifndef CONFIG_IXP400_NAPI
   unsigned int qlevel;
 #endif
-//    u8 *vlanh;
+
   TRACE;
   dev = (struct net_device *) callbackTag;
   priv = dev->priv;
 
 #ifndef CONFIG_IXP400_NAPI
 
-#if IS_KERNEL26
   qlevel = __get_cpu_var (softnet_data).input_pkt_queue.qlen;
-#else
-  qlevel = softnet_data[0].input_pkt_queue.qlen;
-#endif
+
   /* check if the system accepts more traffic and
    * against chained mbufs 
    */
@@ -2390,9 +2220,7 @@
       /* set the length of the received skb from the mbuf length  */
       skb->tail = skb->data + len;
       skb->len = len;
-//      vlanh=(u8 *)skb->data;
-//      if (*(vlanh+12)==0x81) 
-//          *(vlanh+13)=0;
+
 #ifdef DEBUG_DUMP
       skb_dump ("rx", skb);
 #endif
@@ -2442,11 +2270,7 @@
 ixp400_dev_set_multicast_list (struct net_device *dev)
 {
   int res;
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
   IxEthAccMacAddr addr1 = { };
 
 /* 4 possible scenarios here
@@ -2578,11 +2402,7 @@
 {
   int res;
   IxEthAccMacAddr npeMacAddr;
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
 
   P_DEBUG ("port_enable(%s)\n", dev->name);
 
@@ -2672,11 +2492,7 @@
 static void
 port_disable (struct net_device *dev)
 {
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
   int res;
   IX_STATUS status;
 #ifdef CONFIG_IXP400_NAPI
@@ -2729,19 +2545,11 @@
   ixQMgrNotificationEnable (IX_QMGR_QUEUE_31, IX_QMGR_Q_SOURCE_ID_NOT_E);
 
   /* disable interrupts briefly while calling the TxDone callback */
-#if IS_KERNEL26
   local_irq_save (flags);
-#else
-  save_flags_cli (flags);
-#endif /* IS_KERNEL26 */
   /* now service the queue to satisfy the "empty" condition */
   ixEthTxFrameDoneQMCallback (0, 0);
 
-#if IS_KERNEL26
   local_irq_restore (flags);
-#else
-  restore_flags (flags);
-#endif /* IS_KERNEL26 */
 
 #endif /* CONFIG_IXP400_NAPI */
 
@@ -2768,16 +2576,12 @@
 /* this function is called by the kernel to transmit packet 
  * It is expected to run in the context of the ksoftirq thread.
 */
-int
+static int
 dev_hard_start_xmit (struct sk_buff *skb, struct net_device *dev)
 {
   int res;
   IX_OSAL_MBUF *mbuf;
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
 
   TRACE;
 
@@ -2864,11 +2668,7 @@
 
   if (res == 0)
     {
-#if IS_KERNEL26
       try_module_get (THIS_MODULE);
-#else
-      MOD_INC_USE_COUNT;
-#endif
     }
 
   return res;
@@ -2892,11 +2692,7 @@
        */
       for (dev_idx = 0; dev_idx < dev_max_count; dev_idx++)
 	{
-#if IS_KERNEL26
 	  tmp_dev = dev_get_drvdata (&ixp400_eth_devices[dev_idx].dev);
-#else
-	  tmp_dev = &ixp400_eth_devices[dev_idx];
-#endif
 
 	  if (netif_running (tmp_dev))
 	    {
@@ -2917,20 +2713,16 @@
 
   up (maintenance_mutex);
 
-#if IS_KERNEL26
   module_put (THIS_MODULE);
-#else
-  MOD_DEC_USE_COUNT;
-#endif
 
   return 0;
 }
 
 static void
-dev_tx_timeout_task (struct work_struct *work)
+dev_tx_timeout_task (void *dev_id)
 {
-  priv_data_t *priv = container_of (work, priv_data_t, timeout_work);
-  struct net_device *dev = priv->ndev;
+  struct net_device *dev = (struct net_device *) dev_id;
+  priv_data_t *priv = netdev_priv (dev);
 
   P_WARN ("%s: Tx Timeout for port %d\n", dev->name, priv->port_id);
 
@@ -2965,29 +2757,17 @@
 static void
 dev_tx_timeout (struct net_device *dev)
 {
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
 
   TRACE;
-#if IS_KERNEL26
   queue_work (priv->timeout_workq, &priv->timeout_work);
-#else
-  schedule_work (&priv->taskqueue_timeout);
-#endif
 }
 
 /* update the maximum msdu value for this device */
 static void
 dev_change_msdu (struct net_device *dev, int new_msdu_size)
 {
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
   unsigned int new_size = new_msdu_size;
 
   priv->msdu_size = new_size;
@@ -3025,11 +2805,8 @@
 static int
 dev_change_mtu (struct net_device *dev, int new_mtu_size)
 {
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
+
   /* the msdu size includes the ethernet header plus the 
    * mtu (IP payload), but does not include the FCS which is 
    * stripped out by the access layer.
@@ -3068,11 +2845,7 @@
 static int
 do_dev_ioctl (struct net_device *dev, struct ifreq *req, int cmd)
 {
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
   struct mii_ioctl_data *data = (struct mii_ioctl_data *) &req->ifr_data;
   int phy = phyAddresses[portIdPhyIndexMap[priv->port_id]];
   int res = 0;
@@ -3141,11 +2914,7 @@
   IxEthEthObjStats ethStats __attribute__ ((aligned (32))) =
   {
   };
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
 
   TRACE;
 
@@ -3251,7 +3020,7 @@
 
   if (request_irq (IX_OSAL_IXP400_QM1_IRQ_LVL,
 		   dev_qmgr_os_isr,
-		   IRQF_SHARED, "ixp400_eth QM1", (void *) IRQ_ANY_PARAMETER))
+		   SA_SHIRQ, "ixp400_eth QM1", (void *) IRQ_ANY_PARAMETER))
     {
       P_ERROR ("Failed to request_irq to Queue Manager interrupt!\n");
       return -1;
@@ -3374,7 +3143,7 @@
 phy_init (void)
 {
   int res;
-  BOOL physcan[IXP425_ETH_ACC_MII_MAX_ADDR];
+  BOOL physcan[IXP400_ETH_ACC_MII_MAX_ADDR];
   int i, phy_found, num_phys_to_set, dev_count;
 
   /* initialise the MII register access mutex */
@@ -3417,7 +3186,7 @@
        * phyAddresses array and use no_phy_scan=1 parameter on 
        * the command line.
        */
-      for (i = 0, phy_found = 0; i < IXP425_ETH_ACC_MII_MAX_ADDR; i++)
+      for (i = 0, phy_found = 0; i < IXP400_ETH_ACC_MII_MAX_ADDR; i++)
 	{
 	  if (physcan[i])
 	    {
@@ -3432,7 +3201,7 @@
 		  phyAddresses[phy_found] = i;
 		}
 
-	      if (++phy_found == IXP425_ETH_ACC_MII_MAX_ADDR)
+	      if (++phy_found == IXP400_ETH_ACC_MII_MAX_ADDR)
 		break;
 	    }
 	}
@@ -3499,11 +3268,7 @@
   int res;
   IxEthAccMacAddr npeMacAddr;
   struct sockaddr *saddr = (struct sockaddr *) addr;
-#if IS_KERNEL26
   priv_data_t *priv = netdev_priv (dev);
-#else
-  priv_data_t *priv = dev->priv;
-#endif
 
   /* Get MAC addr from parameter */
   memcpy (&npeMacAddr.macAddress,
@@ -3560,7 +3325,6 @@
   return NULL;
 }
 
-#if IS_KERNEL26
 static struct Qdisc_ops dev_qdisc_ops = {
   .id = "ixp400_eth",
   .priv_size = 0,
@@ -3569,21 +3333,11 @@
   .requeue = dev_qdisc_no_enqueue,
   .owner = THIS_MODULE,
 };
-#else
-static struct Qdisc_ops dev_qdisc_ops = {
-  NULL, NULL, "ixp400_eth", 0,
-  dev_qdisc_no_enqueue,
-  dev_qdisc_no_dequeue,
-  dev_qdisc_no_enqueue,
-  NULL,
-  NULL, NULL, NULL, NULL, NULL
-};
-#endif
 
 #endif
 
 static int
-dev_rxtxcallback_register (IxEthAccPortId portId, UINT32 dev)
+dev_port_init (IxEthAccPortId portId, UINT32 dev)
 {
   int res;
 
@@ -3695,13 +3449,6 @@
        */
       if (likely (func))
 	{
-	  /*
-	   * NPE error handler and recovery needs to run without interference
-	   * from NPE poll and queue manager
-	   */
-	  disable_irq (IX_OSAL_IXP400_XSCALE_PMU_IRQ_LVL);
-	  disable_irq (IX_OSAL_IXP400_QM1_IRQ_LVL);
-
 	  (*func) ();
 	}
     }
@@ -3764,13 +3511,6 @@
     default:
       P_ERROR ("Unknown NPE recovery error\n");
     }
-
-  /*
-   * Enable PMU and queue manager interrupt that being disabled in parity
-   * error callback handler
-   */
-  enable_irq (IX_OSAL_IXP400_XSCALE_PMU_IRQ_LVL);
-  enable_irq (IX_OSAL_IXP400_QM1_IRQ_LVL);
 }
 
 /*
@@ -4064,16 +3804,10 @@
 /* Initialize device structs.
  * Resource allocation is deffered until do_dev_open
  */
-#if IS_KERNEL26
 static int __devinit
 dev_eth_probe (struct device *dev)
-#else
-static int __devinit
-dev_eth_probe (struct net_device *ndev)
-#endif
 {
   priv_data_t *priv = NULL;
-#if IS_KERNEL26
   struct net_device *ndev = NULL;
   IxEthAccPortId portId = to_platform_device (dev)->id;
   TRACE;
@@ -4086,28 +3820,7 @@
   priv = netdev_priv (ndev);
 
   TRACE;
-#else
-  static int found_devices = 0;
-  IxEthAccPortId portId = default_portId[found_devices];
-
-  TRACE;
-
-  /* there is a limited number of devices */
-  if (found_devices >= dev_max_count)	/* module parameter */
-    return -ENODEV;
-
-  SET_MODULE_OWNER (ndev);
-
-  /* allocate and initialize priv struct */
-  priv = ndev->priv = kmalloc (sizeof (priv_data_t), GFP_KERNEL);
-  if (ndev->priv == NULL)
-    return -ENOMEM;
-
-  memset (ndev->priv, 0, sizeof (priv_data_t));
-
-  TRACE;
 
-#endif
   /* Initialize the ethAcc port */
   if (ixEthAccPortInit (portId))
     {
@@ -4315,17 +4028,11 @@
 
   dev_change_msdu (ndev, ndev->mtu + ndev->hard_header_len + VLAN_HDR);
 
-#if IS_KERNEL26
   /* create timeout queue to handle transmission timeout */
   priv->timeout_workq = create_singlethread_workqueue (MODULE_NAME);
   BUG_ON (!priv->timeout_workq);
-  priv->ndev = ndev;
-  INIT_WORK (&priv->timeout_work, dev_tx_timeout_task);
-#else
-  /* create timeout queue to handle transmission timeout */
-  priv->taskqueue_timeout.routine = dev_tx_timeout_task;
-  priv->taskqueue_timeout.data = (void *) ndev;
-#endif
+
+  INIT_WORK (&priv->timeout_work, dev_tx_timeout_task, (void *) ndev);
 
   /* set the internal maximum queueing capabilities */
   ndev->tx_queue_len = TX_MBUF_POOL_SIZE;
@@ -4340,17 +4047,13 @@
 
   TRACE;
 
-#if IS_KERNEL26
   if (register_netdev (ndev))
     goto error;
-#else
-  found_devices++;
-#endif /* IS_KERNEL26 */
 
   TRACE;
 
-  /* register EthAcc callbacks for this port */
-  if (dev_rxtxcallback_register (portId, (UINT32) ndev))
+  /* configuring the port  */
+  if (dev_port_init (portId, (UINT32) ndev))
     {
       goto error;
     }
@@ -4382,7 +4085,6 @@
     qdisc_destroy (ndev->qdisc);
 #endif
 
-#if IS_KERNEL26
   /* Step 1: Destoying workqueue */
   if (priv && priv->timeout_workq)
     {
@@ -4402,13 +4104,6 @@
 
       free_netdev (ndev);
     }
-#else
-  if (ndev)
-    kfree (ndev);
-
-  if (priv)
-    kfree (priv);
-#endif /* IS_KERNEL26 */
 
   TRACE;
 
@@ -4419,31 +4114,17 @@
   return 0;
 }
 
-#if IS_KERNEL26
 static int __devexit
 dev_eth_remove (struct device *dev)
-#else
-static int __devexit
-dev_eth_remove (int dev_count)
-#endif
 {
-#if IS_KERNEL26
   struct net_device *ndev = dev_get_drvdata (dev);
   priv_data_t *priv = netdev_priv (ndev);
-#else
-  struct net_device *ndev = &ixp400_eth_devices[dev_count];
-  priv_data_t *priv = ndev->priv;
-#endif
 
   TRACE;
 
   if (priv != NULL)
     {
-#if IS_KERNEL26
       IxEthAccPortId portId = to_platform_device (dev)->id;
-#else
-      IxEthAccPortId portId = priv->port_id;
-#endif
 
       if (IX_SUCCESS !=
 	  ixNpeDlNpeStopAndReset (default_npeImageId[portId].npeId))
@@ -4453,14 +4134,12 @@
 
       TRACE;
 
-#if IS_KERNEL26
       if (priv->timeout_workq)
 	{
 	  flush_workqueue (priv->timeout_workq);
 	  destroy_workqueue (priv->timeout_workq);
 	  priv->timeout_workq = NULL;
 	}
-#endif
 
 #ifdef CONFIG_IXP400_ETH_QDISC_ENABLED
       if (ndev->qdisc)
@@ -4470,13 +4149,8 @@
 #endif
       unregister_netdev (ndev);
 
-#if IS_KERNEL26
       free_netdev (ndev);
       dev_set_drvdata (dev, NULL);
-#else
-      kfree (ndev->priv);
-      ndev->priv = NULL;
-#endif
     }
 
   return 0;
@@ -4508,15 +4182,11 @@
 }
 
 
-#if IS_KERNEL26 || defined MODULE
 static int __init
 ixp400_eth_init (void)
 {
   int res, dev_count;
 
-#if !IS_KERNEL26
-  struct net_device *dev;
-#endif
 
   TRACE;
 
@@ -4551,7 +4221,12 @@
 
   TRACE;
 
-  /* Handle ixdp465 platform specific stuff here */
+  /*
+   * IXP43X and IXP46X supports the feature below:
+   * 1. Ethernet on NPE-A
+   * 2. Ethernet-HSS coexist capability
+   * 3. NPE software error handler
+   */
 #if defined (CONFIG_CPU_IXP46X) || defined (CONFIG_CPU_IXP43X)
   {
     UINT32 expbusCtrlReg;
@@ -4601,6 +4276,7 @@
       }
   }
 #endif
+
   TRACE;
 
   /* Enable/disable the EthDB MAC Learning & Filtering feature.
@@ -4685,17 +4361,14 @@
 
   TRACE;
 
-#if IS_KERNEL26
   if ((res = driver_register (&ixp400_eth_driver)))
     return res;
-#endif
 
   TRACE;
 
   /* Initialise the driver structure */
   for (dev_count = 0; dev_count < dev_max_count;	/* module parameter */
        dev_count++)
-#if IS_KERNEL26
     {
       if ((res = platform_device_register (&ixp400_eth_devices[dev_count])))
 	{
@@ -4706,33 +4379,12 @@
 
       TRACE;
     }
-#else
-    {
-      dev = &ixp400_eth_devices[dev_count];
-
-      dev->init = dev_eth_probe;
-
-      TRACE;
-
-      if ((res = register_netdev (dev)))
-	{
-	  TRACE;
-
-	  P_ERROR ("Failed to register netdev. res = %d\n", res);
-	  return res;
-	}
-
-      TRACE;
-    }
-#endif
 
   TRACE;
 
-#if IS_KERNEL26
   /* Create the workqueue for the maintenance task */
   maintenance_workq = create_singlethread_workqueue ("ethDB wq");
   BUG_ON (!maintenance_workq);
-#endif
 
   TRACE;
 
@@ -4847,9 +4499,7 @@
 
   return 0;
 }
-#endif /* IS_KERNEL26 || defined MODULE */
 
-#if IS_KERNEL26 || defined (MODULE)
 void __exit
 ixp400_eth_exit (void)
 {
@@ -4894,19 +4544,12 @@
 
   for (dev_count = 0; dev_count < dev_max_count;	/* module parameter */
        dev_count++)
-#if IS_KERNEL26
     {
       platform_device_unregister (&ixp400_eth_devices[dev_count]);
     }
-#else
-    {
-      dev_eth_remove (dev_count);
-    }
-#endif
 
   TRACE;
 
-#if IS_KERNEL26
   driver_unregister (&ixp400_eth_driver);
 
   TRACE;
@@ -4916,7 +4559,6 @@
       destroy_workqueue (maintenance_workq);
       maintenance_workq = NULL;
     }
-#endif
 
   TRACE;
 
@@ -4940,7 +4582,5 @@
   P_VERBOSE ("IXP400 NPE Ethernet driver software uninstalled\n");
 }
 
-#endif /* IS_KERNEL26 || defined MODULE */
-
 module_init (ixp400_eth_init);
 module_exit (ixp400_eth_exit);
