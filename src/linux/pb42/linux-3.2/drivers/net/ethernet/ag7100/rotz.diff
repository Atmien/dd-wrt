Index: ag7100.c
===================================================================
--- ag7100.c	(revision 16055)
+++ ag7100.c	(working copy)
@@ -1123,9 +1123,6 @@
 
     netif_stop_queue(mac->mac_dev);
 
-    spin_lock_irqsave(&mac->mac_lock, flags);
-    ag7100_intr_enable_tx(mac);
-    spin_unlock_irqrestore(&mac->mac_lock, flags);
 }
 
 /* ******************************
@@ -1189,6 +1186,12 @@
     int                len;
     int                nds_this_pkt;
 
+
+    ds = &r->ring_desc[r->ring_head];
+    if(ag7100_tx_owned_by_dma(ds))
+	goto dropit;
+    
+
 #ifdef VSC73XX_DEBUG
     {
         static int vsc73xx_dbg;
@@ -1242,8 +1245,8 @@
 #endif    
 #endif
 
-    if (ag7100_tx_reap_thresh(mac)) 
-        ag7100_tx_reap(mac);
+//    if (ag7100_tx_reap_thresh(mac)) 
+//        ag7100_tx_reap(mac);
 
     ag7100_trc_new(r->ring_head,"hard-stop hd");
     ag7100_trc_new(r->ring_tail,"hard-stop tl");
@@ -1347,36 +1350,13 @@
 
     assert(isr == (isr & imr));
 
-    if (likely(isr & (AG7100_INTR_RX | AG7100_INTR_RX_OVF)))
+    if (likely(isr & (AG7100_INTR_RX | AG7100_INTR_RX_OVF | AG7100_INTR_TX)))
     {
         handled = 1;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
-	if (likely(napi_schedule_prep(&mac->mac_napi)))
-#else
-	if (likely(netif_rx_schedule_prep(dev)))
-#endif
-        {
-            ag7100_intr_disable_recv(mac);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
-            __napi_schedule(&mac->mac_napi);
-#else
-            __netif_rx_schedule(dev);
-#endif
-        }
-        else
-        {
-            printk(MODULE_NAME ": driver bug! interrupt while in poll\n");
-            assert(0);
-            ag7100_intr_disable_recv(mac);
-        }
-        /*ag7100_recv_packets(dev, mac, 200, &budget);*/
+        ag7100_intr_disable_recv(mac);
+        ag7100_intr_disable_tx(mac);
+        napi_schedule(&mac->mac_napi);
     }
-    if (likely(isr & AG7100_INTR_TX))
-    {
-        handled = 1;
-        ag7100_intr_ack_tx(mac);
-        ag7100_tx_reap(mac);
-    }
     if (unlikely(isr & AG7100_INTR_RX_BUS_ERROR))
     {
         assert(0);
@@ -1441,45 +1421,42 @@
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 	ag7100_mac_t *mac = container_of(napi, ag7100_mac_t, mac_napi);
 	struct net_device *dev = mac->mac_dev;
-	int work_done,      max_work  = budget, status = 0;
+	int work_done,      max_work  = budget;
 #else
 	ag7100_mac_t       *mac       = (ag7100_mac_t *)netdev_priv(dev);
-	int work_done,      max_work  = min(*budget, dev->quota), status = 0;
+	int work_done,      max_work  = min(*budget, dev->quota);
 #endif
     ag7100_rx_status_t  ret;
     u32                 flags;
-    spin_lock_irqsave(&mac->mac_lock, flags);
+    u32                 status;
+    ag7100_tx_reap(mac);
 
     ret = ag7100_recv_packets(dev, mac, max_work, &work_done);
 
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 	if (work_done < budget)
 		{
+		if (likely(ret == AG7100_RX_STATUS_NOT_DONE))
+		{
+    		return work_done;
+		}
+		status = ag7100_reg_rd(mac, AG7100_DMA_TX_STATUS);
+		if ((status & AG7100_TX_STATUS_PKT_SENT))
+		{
+		return work_done;
+		}
     		napi_complete(napi);
+		spin_lock_irqsave(&mac->mac_lock, flags);
     		ag7100_intr_enable_recv(mac);
+    		ag7100_intr_enable_tx(mac);
+		spin_unlock_irqrestore(&mac->mac_lock, flags);
     		}
-#else
-    dev->quota  -= work_done;
-    *budget     -= work_done;
-    if (likely(ret == AG7100_RX_STATUS_DONE))
-    {
-    netif_rx_complete(dev);
-    }
-#endif
+
     if(ret == AG7100_RX_DMA_HANG)
     {
-        status = 0;
         ag7100_dma_reset(mac);
+        return 0;
     }
-
-    if (likely(ret == AG7100_RX_STATUS_NOT_DONE))
-    {
-        /*
-        * We have work left
-        */
-        status = 1;
-    }
     else if (ret == AG7100_RX_STATUS_OOM)
     {
         printk(MODULE_NAME ": oom..?\n");
@@ -1488,7 +1465,6 @@
         */
         mod_timer(&mac->mac_oom_timer, jiffies+1);
     }
-    spin_unlock_irqrestore(&mac->mac_lock, flags);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 	return work_done;
@@ -1560,14 +1536,14 @@
 
         if (ag7100_rx_owned_by_dma(ds))
         {
-#if 1
+#if 0
             if(quota == iquota)
             {
                 *work_done = quota = 0;
                 return AG7100_RX_DMA_HANG;
             }
-            break;
 #endif
+            break;
         }
         ag7100_intr_ack_rx(mac);
 
@@ -1839,7 +1815,6 @@
     ag7100_trc_new(tail,"tl");
 
     ar7100_flush_ge(mac->mac_unit);
-    spin_lock_irqsave(&mac->mac_lock, flags);
     while(tail != head)
     {
         ds   = &r->ring_desc[tail];
@@ -1868,20 +1843,13 @@
 
         reaped ++;
     }
-    spin_unlock_irqrestore(&mac->mac_lock, flags);
+    if (reaped)
+	ag7100_intr_ack_tx(mac);
 
     r->ring_tail = tail;
 
-    if (netif_queue_stopped(mac->mac_dev) &&
-        (ag7100_ndesc_unused(mac, r) >= AG7100_TX_QSTART_THRESH) &&
-        netif_carrier_ok(mac->mac_dev))
+    if ((ag7100_ndesc_unused(mac, r) >= AG7100_TX_QSTART_THRESH))
     {
-        if (ag7100_reg_rd(mac, AG7100_DMA_INTR_MASK) & AG7100_INTR_TX)
-        {
-            spin_lock_irqsave(&mac->mac_lock, flags);
-            ag7100_intr_disable_tx(mac);
-            spin_unlock_irqrestore(&mac->mac_lock, flags);
-        }
         netif_wake_queue(mac->mac_dev);
     }
 
Index: athrs16_phy.c
===================================================================
--- athrs16_phy.c	(revision 16055)
+++ athrs16_phy.c	(working copy)
@@ -156,24 +156,7 @@
 static uint32_t athrs16_reg_read(uint32_t reg_addr);
 static void athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val);
 
-void phy_mode_setup() 
-{
-    printk("phy_mode_setup\n");
 
-    /*work around for phy4 rgmii mode*/
-    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);     
-    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);    
-
-    /*rx delay*/ 
-    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);     
-    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);  
-
-    /*tx delay*/ 
-    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);     
-    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);    
-
-}
-
 #define AR8X16_PROBE_RETRIES	10
 
 enum {
@@ -223,7 +206,22 @@
 			(int)(id & AR8216_CTRL_REVISION));
 	return ret;
 }
+void phy_mode_setup() 
+{
+    printk("phy_mode_setup\n");
+    /*work around for phy4 rgmii mode*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);    
 
+    /*rx delay*/ 
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);  
+
+    /*tx delay*/ 
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);    
+}
+
 void athrs16_reg_init()
 {
     /* if using header for register configuration, we have to     */
@@ -586,7 +584,7 @@
     int           gainedLinks = 0;
     uint32_t      phyBase;
     uint32_t      phyAddr;
-    #if 0
+#if 1
     for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
         if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
             continue;
